webpackJsonp([0], {
  "/ocq": function(t, e, n) {
    "use strict";
    /*!
     * vue-router v3.4.3
     * (c) 2020 Evan You
     * @license MIT
     */
    function r(t, e) {
      0
    }

    function i(t, e) {
      for (var n in e) t[n] = e[n];
      return t
    }
    var o = {
      name: "RouterView",
      functional: !0,
      props: {
        name: {
          type: String,
          default: "default"
        }
      },
      render: function(t, e) {
        var n = e.props,
          r = e.children,
          o = e.parent,
          a = e.data;
        a.routerView = !0;
        for (var l = o.$createElement, c = n.name, h = o.$route, u = o._routerViewCache || (o._routerViewCache = {}),
            d = 0, p = !1; o && o._routerRoot !== o;) {
          var f = o.$vnode ? o.$vnode.data : {};
          f.routerView && d++, f.keepAlive && o._directInactive && o._inactive && (p = !0), o = o.$parent
        }
        if (a.routerViewDepth = d, p) {
          var g = u[c],
            m = g && g.component;
          return m ? (g.configProps && s(m, a, g.route, g.configProps), l(m, a, r)) : l()
        }
        var v = h.matched[d],
          y = v && v.components[c];
        if (!v || !y) return u[c] = null, l();
        u[c] = {
          component: y
        }, a.registerRouteInstance = function(t, e) {
          var n = v.instances[c];
          (e && n !== t || !e && n === t) && (v.instances[c] = e)
        }, (a.hook || (a.hook = {})).prepatch = function(t, e) {
          v.instances[c] = e.componentInstance
        }, a.hook.init = function(t) {
          t.data.keepAlive && t.componentInstance && t.componentInstance !== v.instances[c] && (v.instances[
            c] = t.componentInstance)
        };
        var b = v.props && v.props[c];
        return b && (i(u[c], {
          route: h,
          configProps: b
        }), s(y, a, h, b)), l(y, a, r)
      }
    };

    function s(t, e, n, r) {
      var o = e.props = function(t, e) {
        switch (typeof e) {
          case "undefined":
            return;
          case "object":
            return e;
          case "function":
            return e(t);
          case "boolean":
            return e ? t.params : void 0;
          default:
            0
        }
      }(n, r);
      if (o) {
        o = e.props = i({}, o);
        var s = e.attrs = e.attrs || {};
        for (var a in o) t.props && a in t.props || (s[a] = o[a], delete o[a])
      }
    }
    var a = /[!'()*]/g,
      l = function(t) {
        return "%" + t.charCodeAt(0).toString(16)
      },
      c = /%2C/g,
      h = function(t) {
        return encodeURIComponent(t).replace(a, l).replace(c, ",")
      },
      u = decodeURIComponent;
    var d = function(t) {
      return null == t || "object" == typeof t ? t : String(t)
    };

    function p(t) {
      var e = {};
      return (t = t.trim().replace(/^(\?|#|&)/, "")) ? (t.split("&").forEach(function(t) {
        var n = t.replace(/\+/g, " ").split("="),
          r = u(n.shift()),
          i = n.length > 0 ? u(n.join("=")) : null;
        void 0 === e[r] ? e[r] = i : Array.isArray(e[r]) ? e[r].push(i) : e[r] = [e[r], i]
      }), e) : e
    }

    function f(t) {
      var e = t ? Object.keys(t).map(function(e) {
        var n = t[e];
        if (void 0 === n) return "";
        if (null === n) return h(e);
        if (Array.isArray(n)) {
          var r = [];
          return n.forEach(function(t) {
            void 0 !== t && (null === t ? r.push(h(e)) : r.push(h(e) + "=" + h(t)))
          }), r.join("&")
        }
        return h(e) + "=" + h(n)
      }).filter(function(t) {
        return t.length > 0
      }).join("&") : null;
      return e ? "?" + e : ""
    }
    var g = /\/?$/;

    function m(t, e, n, r) {
      var i = r && r.options.stringifyQuery,
        o = e.query || {};
      try {
        o = v(o)
      } catch (t) {}
      var s = {
        name: e.name || t && t.name,
        meta: t && t.meta || {},
        path: e.path || "/",
        hash: e.hash || "",
        query: o,
        params: e.params || {},
        fullPath: b(e, i),
        matched: t ? function(t) {
          var e = [];
          for (; t;) e.unshift(t), t = t.parent;
          return e
        }(t) : []
      };
      return n && (s.redirectedFrom = b(n, i)), Object.freeze(s)
    }

    function v(t) {
      if (Array.isArray(t)) return t.map(v);
      if (t && "object" == typeof t) {
        var e = {};
        for (var n in t) e[n] = v(t[n]);
        return e
      }
      return t
    }
    var y = m(null, {
      path: "/"
    });

    function b(t, e) {
      var n = t.path,
        r = t.query;
      void 0 === r && (r = {});
      var i = t.hash;
      return void 0 === i && (i = ""), (n || "/") + (e || f)(r) + i
    }

    function C(t, e) {
      return e === y ? t === e : !!e && (t.path && e.path ? t.path.replace(g, "") === e.path.replace(g, "") && t.hash ===
        e.hash && x(t.query, e.query) : !(!t.name || !e.name) && (t.name === e.name && t.hash === e.hash && x(t
          .query, e.query) && x(t.params, e.params)))
    }

    function x(t, e) {
      if (void 0 === t && (t = {}), void 0 === e && (e = {}), !t || !e) return t === e;
      var n = Object.keys(t),
        r = Object.keys(e);
      return n.length === r.length && n.every(function(n) {
        var r = t[n],
          i = e[n];
        return null == r || null == i ? r === i : "object" == typeof r && "object" == typeof i ? x(r, i) :
          String(r) === String(i)
      })
    }

    function w(t, e, n) {
      var r = t.charAt(0);
      if ("/" === r) return t;
      if ("?" === r || "#" === r) return e + t;
      var i = e.split("/");
      n && i[i.length - 1] || i.pop();
      for (var o = t.replace(/^\//, "").split("/"), s = 0; s < o.length; s++) {
        var a = o[s];
        ".." === a ? i.pop() : "." !== a && i.push(a)
      }
      return "" !== i[0] && i.unshift(""), i.join("/")
    }

    function A(t) {
      return t.replace(/\/\//g, "/")
    }
    var E = Array.isArray || function(t) {
        return "[object Array]" == Object.prototype.toString.call(t)
      },
      S = I,
      M = T,
      k = function(t, e) {
        return j(T(t, e), e)
      },
      O = j,
      P = B,
      D = new RegExp(["(\\\\.)",
        "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"
      ].join("|"), "g");

    function T(t, e) {
      for (var n, r = [], i = 0, o = 0, s = "", a = e && e.delimiter || "/"; null != (n = D.exec(t));) {
        var l = n[0],
          c = n[1],
          h = n.index;
        if (s += t.slice(o, h), o = h + l.length, c) s += c[1];
        else {
          var u = t[o],
            d = n[2],
            p = n[3],
            f = n[4],
            g = n[5],
            m = n[6],
            v = n[7];
          s && (r.push(s), s = "");
          var y = null != d && null != u && u !== d,
            b = "+" === m || "*" === m,
            C = "?" === m || "*" === m,
            x = n[2] || a,
            w = f || g;
          r.push({
            name: p || i++,
            prefix: d || "",
            delimiter: x,
            optional: C,
            repeat: b,
            partial: y,
            asterisk: !!v,
            pattern: w ? N(w) : v ? ".*" : "[^" + L(x) + "]+?"
          })
        }
      }
      return o < t.length && (s += t.substr(o)), s && r.push(s), r
    }

    function _(t) {
      return encodeURI(t).replace(/[\/?#]/g, function(t) {
        return "%" + t.charCodeAt(0).toString(16).toUpperCase()
      })
    }

    function j(t, e) {
      for (var n = new Array(t.length), r = 0; r < t.length; r++) "object" == typeof t[r] && (n[r] = new RegExp(
        "^(?:" + t[r].pattern + ")$", $(e)));
      return function(e, r) {
        for (var i = "", o = e || {}, s = (r || {}).pretty ? _ : encodeURIComponent, a = 0; a < t.length; a++) {
          var l = t[a];
          if ("string" != typeof l) {
            var c, h = o[l.name];
            if (null == h) {
              if (l.optional) {
                l.partial && (i += l.prefix);
                continue
              }
              throw new TypeError('Expected "' + l.name + '" to be defined')
            }
            if (E(h)) {
              if (!l.repeat) throw new TypeError('Expected "' + l.name + '" to not repeat, but received `' +
                JSON.stringify(h) + "`");
              if (0 === h.length) {
                if (l.optional) continue;
                throw new TypeError('Expected "' + l.name + '" to not be empty')
              }
              for (var u = 0; u < h.length; u++) {
                if (c = s(h[u]), !n[a].test(c)) throw new TypeError('Expected all "' + l.name + '" to match "' +
                  l.pattern + '", but received `' + JSON.stringify(c) + "`");
                i += (0 === u ? l.prefix : l.delimiter) + c
              }
            } else {
              if (c = l.asterisk ? encodeURI(h).replace(/[?#]/g, function(t) {
                  return "%" + t.charCodeAt(0).toString(16).toUpperCase()
                }) : s(h), !n[a].test(c)) throw new TypeError('Expected "' + l.name + '" to match "' + l.pattern +
                '", but received "' + c + '"');
              i += l.prefix + c
            }
          } else i += l
        }
        return i
      }
    }

    function L(t) {
      return t.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1")
    }

    function N(t) {
      return t.replace(/([=!:$\/()])/g, "\\$1")
    }

    function F(t, e) {
      return t.keys = e, t
    }

    function $(t) {
      return t && t.sensitive ? "" : "i"
    }

    function B(t, e, n) {
      E(e) || (n = e || n, e = []);
      for (var r = (n = n || {}).strict, i = !1 !== n.end, o = "", s = 0; s < t.length; s++) {
        var a = t[s];
        if ("string" == typeof a) o += L(a);
        else {
          var l = L(a.prefix),
            c = "(?:" + a.pattern + ")";
          e.push(a), a.repeat && (c += "(?:" + l + c + ")*"), o += c = a.optional ? a.partial ? l + "(" + c +
            ")?" : "(?:" + l + "(" + c + "))?" : l + "(" + c + ")"
        }
      }
      var h = L(n.delimiter || "/"),
        u = o.slice(-h.length) === h;
      return r || (o = (u ? o.slice(0, -h.length) : o) + "(?:" + h + "(?=$))?"), o += i ? "$" : r && u ? "" :
        "(?=" + h + "|$)", F(new RegExp("^" + o, $(n)), e)
    }

    function I(t, e, n) {
      return E(e) || (n = e || n, e = []), n = n || {}, t instanceof RegExp ? function(t, e) {
        var n = t.source.match(/\((?!\?)/g);
        if (n)
          for (var r = 0; r < n.length; r++) e.push({
            name: r,
            prefix: null,
            delimiter: null,
            optional: !1,
            repeat: !1,
            partial: !1,
            asterisk: !1,
            pattern: null
          });
        return F(t, e)
      }(t, e) : E(t) ? function(t, e, n) {
        for (var r = [], i = 0; i < t.length; i++) r.push(I(t[i], e, n).source);
        return F(new RegExp("(?:" + r.join("|") + ")", $(n)), e)
      }(t, e, n) : function(t, e, n) {
        return B(T(t, n), e, n)
      }(t, e, n)
    }
    S.parse = M, S.compile = k, S.tokensToFunction = O, S.tokensToRegExp = P;
    var z = Object.create(null);

    function R(t, e, n) {
      e = e || {};
      try {
        var r = z[t] || (z[t] = S.compile(t));
        return "string" == typeof e.pathMatch && (e[0] = e.pathMatch), r(e, {
          pretty: !0
        })
      } catch (t) {
        return ""
      } finally {
        delete e[0]
      }
    }

    function V(t, e, n, r) {
      var o = "string" == typeof t ? {
        path: t
      } : t;
      if (o._normalized) return o;
      if (o.name) {
        var s = (o = i({}, t)).params;
        return s && "object" == typeof s && (o.params = i({}, s)), o
      }
      if (!o.path && o.params && e) {
        (o = i({}, o))._normalized = !0;
        var a = i(i({}, e.params), o.params);
        if (e.name) o.name = e.name, o.params = a;
        else if (e.matched.length) {
          var l = e.matched[e.matched.length - 1].path;
          o.path = R(l, a, e.path)
        } else 0;
        return o
      }
      var c = function(t) {
          var e = "",
            n = "",
            r = t.indexOf("#");
          r >= 0 && (e = t.slice(r), t = t.slice(0, r));
          var i = t.indexOf("?");
          return i >= 0 && (n = t.slice(i + 1), t = t.slice(0, i)), {
            path: t,
            query: n,
            hash: e
          }
        }(o.path || ""),
        h = e && e.path || "/",
        u = c.path ? w(c.path, h, n || o.append) : h,
        f = function(t, e, n) {
          void 0 === e && (e = {});
          var r, i = n || p;
          try {
            r = i(t || "")
          } catch (t) {
            r = {}
          }
          for (var o in e) {
            var s = e[o];
            r[o] = Array.isArray(s) ? s.map(d) : d(s)
          }
          return r
        }(c.query, o.query, r && r.options.parseQuery),
        g = o.hash || c.hash;
      return g && "#" !== g.charAt(0) && (g = "#" + g), {
        _normalized: !0,
        path: u,
        query: f,
        hash: g
      }
    }
    var H, G = [String, Object],
      U = [String, Array],
      q = function() {},
      W = {
        name: "RouterLink",
        props: {
          to: {
            type: G,
            required: !0
          },
          tag: {
            type: String,
            default: "a"
          },
          exact: Boolean,
          append: Boolean,
          replace: Boolean,
          activeClass: String,
          exactActiveClass: String,
          ariaCurrentValue: {
            type: String,
            default: "page"
          },
          event: {
            type: U,
            default: "click"
          }
        },
        render: function(t) {
          var e = this,
            n = this.$router,
            r = this.$route,
            o = n.resolve(this.to, r, this.append),
            s = o.location,
            a = o.route,
            l = o.href,
            c = {},
            h = n.options.linkActiveClass,
            u = n.options.linkExactActiveClass,
            d = null == h ? "router-link-active" : h,
            p = null == u ? "router-link-exact-active" : u,
            f = null == this.activeClass ? d : this.activeClass,
            v = null == this.exactActiveClass ? p : this.exactActiveClass,
            y = a.redirectedFrom ? m(null, V(a.redirectedFrom), null, n) : a;
          c[v] = C(r, y), c[f] = this.exact ? c[v] : function(t, e) {
            return 0 === t.path.replace(g, "/").indexOf(e.path.replace(g, "/")) && (!e.hash || t.hash === e.hash) &&
              function(t, e) {
                for (var n in e)
                  if (!(n in t)) return !1;
                return !0
              }(t.query, e.query)
          }(r, y);
          var b = c[v] ? this.ariaCurrentValue : null,
            x = function(t) {
              X(t) && (e.replace ? n.replace(s, q) : n.push(s, q))
            },
            w = {
              click: X
            };
          Array.isArray(this.event) ? this.event.forEach(function(t) {
            w[t] = x
          }) : w[this.event] = x;
          var A = {
              class: c
            },
            E = !this.$scopedSlots.$hasNormal && this.$scopedSlots.default && this.$scopedSlots.default({
              href: l,
              route: a,
              navigate: x,
              isActive: c[f],
              isExactActive: c[v]
            });
          if (E) {
            if (1 === E.length) return E[0];
            if (E.length > 1 || !E.length) return 0 === E.length ? t() : t("span", {}, E)
          }
          if ("a" === this.tag) A.on = w, A.attrs = {
            href: l,
            "aria-current": b
          };
          else {
            var S = function t(e) {
              if (e)
                for (var n, r = 0; r < e.length; r++) {
                  if ("a" === (n = e[r]).tag) return n;
                  if (n.children && (n = t(n.children))) return n
                }
            }(this.$slots.default);
            if (S) {
              S.isStatic = !1;
              var M = S.data = i({}, S.data);
              for (var k in M.on = M.on || {}, M.on) {
                var O = M.on[k];
                k in w && (M.on[k] = Array.isArray(O) ? O : [O])
              }
              for (var P in w) P in M.on ? M.on[P].push(w[P]) : M.on[P] = x;
              var D = S.data.attrs = i({}, S.data.attrs);
              D.href = l, D["aria-current"] = b
            } else A.on = w
          }
          return t(this.tag, A, this.$slots.default)
        }
      };

    function X(t) {
      if (!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey || t.defaultPrevented || void 0 !== t.button && 0 !==
          t.button)) {
        if (t.currentTarget && t.currentTarget.getAttribute) {
          var e = t.currentTarget.getAttribute("target");
          if (/\b_blank\b/i.test(e)) return
        }
        return t.preventDefault && t.preventDefault(), !0
      }
    }

    function Y(t) {
      if (!Y.installed || H !== t) {
        Y.installed = !0, H = t;
        var e = function(t) {
            return void 0 !== t
          },
          n = function(t, n) {
            var r = t.$options._parentVnode;
            e(r) && e(r = r.data) && e(r = r.registerRouteInstance) && r(t, n)
          };
        t.mixin({
          beforeCreate: function() {
            e(this.$options.router) ? (this._routerRoot = this, this._router = this.$options.router, this._router
                .init(this), t.util.defineReactive(this, "_route", this._router.history.current)) : this._routerRoot =
              this.$parent && this.$parent._routerRoot || this, n(this, this)
          },
          destroyed: function() {
            n(this)
          }
        }), Object.defineProperty(t.prototype, "$router", {
          get: function() {
            return this._routerRoot._router
          }
        }), Object.defineProperty(t.prototype, "$route", {
          get: function() {
            return this._routerRoot._route
          }
        }), t.component("RouterView", o), t.component("RouterLink", W);
        var r = t.config.optionMergeStrategies;
        r.beforeRouteEnter = r.beforeRouteLeave = r.beforeRouteUpdate = r.created
      }
    }
    var J = "undefined" != typeof window;

    function Z(t, e, n, r) {
      var i = e || [],
        o = n || Object.create(null),
        s = r || Object.create(null);
      t.forEach(function(t) {
        ! function t(e, n, r, i, o, s) {
          var a = i.path;
          var l = i.name;
          0;
          var c = i.pathToRegexpOptions || {};
          var h = function(t, e, n) {
            n || (t = t.replace(/\/$/, ""));
            if ("/" === t[0]) return t;
            if (null == e) return t;
            return A(e.path + "/" + t)
          }(a, o, c.strict);
          "boolean" == typeof i.caseSensitive && (c.sensitive = i.caseSensitive);
          var u = {
            path: h,
            regex: function(t, e) {
              var n = S(t, [], e);
              return n
            }(h, c),
            components: i.components || {
              default: i.component
            },
            instances: {},
            name: l,
            parent: o,
            matchAs: s,
            redirect: i.redirect,
            beforeEnter: i.beforeEnter,
            meta: i.meta || {},
            props: null == i.props ? {} : i.components ? i.props : {
              default: i.props
            }
          };
          i.children && i.children.forEach(function(i) {
            var o = s ? A(s + "/" + i.path) : void 0;
            t(e, n, r, i, u, o)
          });
          n[u.path] || (e.push(u.path), n[u.path] = u);
          if (void 0 !== i.alias)
            for (var d = Array.isArray(i.alias) ? i.alias : [i.alias], p = 0; p < d.length; ++p) {
              var f = d[p];
              0;
              var g = {
                path: f,
                children: i.children
              };
              t(e, n, r, g, o, u.path || "/")
            }
          l && (r[l] || (r[l] = u))
        }(i, o, s, t)
      });
      for (var a = 0, l = i.length; a < l; a++) "*" === i[a] && (i.push(i.splice(a, 1)[0]), l--, a--);
      return {
        pathList: i,
        pathMap: o,
        nameMap: s
      }
    }

    function K(t, e) {
      var n = Z(t),
        r = n.pathList,
        i = n.pathMap,
        o = n.nameMap;

      function s(t, n, s) {
        var a = V(t, n, !1, e),
          c = a.name;
        if (c) {
          var h = o[c];
          if (!h) return l(null, a);
          var u = h.regex.keys.filter(function(t) {
            return !t.optional
          }).map(function(t) {
            return t.name
          });
          if ("object" != typeof a.params && (a.params = {}), n && "object" == typeof n.params)
            for (var d in n.params) !(d in a.params) && u.indexOf(d) > -1 && (a.params[d] = n.params[d]);
          return a.path = R(h.path, a.params), l(h, a, s)
        }
        if (a.path) {
          a.params = {};
          for (var p = 0; p < r.length; p++) {
            var f = r[p],
              g = i[f];
            if (Q(g.regex, a.path, a.params)) return l(g, a, s)
          }
        }
        return l(null, a)
      }

      function a(t, n) {
        var r = t.redirect,
          i = "function" == typeof r ? r(m(t, n, null, e)) : r;
        if ("string" == typeof i && (i = {
            path: i
          }), !i || "object" != typeof i) return l(null, n);
        var a = i,
          c = a.name,
          h = a.path,
          u = n.query,
          d = n.hash,
          p = n.params;
        if (u = a.hasOwnProperty("query") ? a.query : u, d = a.hasOwnProperty("hash") ? a.hash : d, p = a.hasOwnProperty(
            "params") ? a.params : p, c) {
          o[c];
          return s({
            _normalized: !0,
            name: c,
            query: u,
            hash: d,
            params: p
          }, void 0, n)
        }
        if (h) {
          var f = function(t, e) {
            return w(t, e.parent ? e.parent.path : "/", !0)
          }(h, t);
          return s({
            _normalized: !0,
            path: R(f, p),
            query: u,
            hash: d
          }, void 0, n)
        }
        return l(null, n)
      }

      function l(t, n, r) {
        return t && t.redirect ? a(t, r || n) : t && t.matchAs ? function(t, e, n) {
          var r = s({
            _normalized: !0,
            path: R(n, e.params)
          });
          if (r) {
            var i = r.matched,
              o = i[i.length - 1];
            return e.params = r.params, l(o, e)
          }
          return l(null, e)
        }(0, n, t.matchAs) : m(t, n, r, e)
      }
      return {
        match: s,
        addRoutes: function(t) {
          Z(t, r, i, o)
        }
      }
    }

    function Q(t, e, n) {
      var r = e.match(t);
      if (!r) return !1;
      if (!n) return !0;
      for (var i = 1, o = r.length; i < o; ++i) {
        var s = t.keys[i - 1],
          a = "string" == typeof r[i] ? decodeURIComponent(r[i]) : r[i];
        s && (n[s.name || "pathMatch"] = a)
      }
      return !0
    }
    var tt = J && window.performance && window.performance.now ? window.performance : Date;

    function et() {
      return tt.now().toFixed(3)
    }
    var nt = et();

    function rt() {
      return nt
    }

    function it(t) {
      return nt = t
    }
    var ot = Object.create(null);

    function st() {
      "scrollRestoration" in window.history && (window.history.scrollRestoration = "manual");
      var t = window.location.protocol + "//" + window.location.host,
        e = window.location.href.replace(t, ""),
        n = i({}, window.history.state);
      return n.key = rt(), window.history.replaceState(n, "", e), window.addEventListener("popstate", ct),
        function() {
          window.removeEventListener("popstate", ct)
        }
    }

    function at(t, e, n, r) {
      if (t.app) {
        var i = t.options.scrollBehavior;
        i && t.app.$nextTick(function() {
          var o = function() {
              var t = rt();
              if (t) return ot[t]
            }(),
            s = i.call(t, e, n, r ? o : null);
          s && ("function" == typeof s.then ? s.then(function(t) {
            ft(t, o)
          }).catch(function(t) {
            0
          }) : ft(s, o))
        })
      }
    }

    function lt() {
      var t = rt();
      t && (ot[t] = {
        x: window.pageXOffset,
        y: window.pageYOffset
      })
    }

    function ct(t) {
      lt(), t.state && t.state.key && it(t.state.key)
    }

    function ht(t) {
      return dt(t.x) || dt(t.y)
    }

    function ut(t) {
      return {
        x: dt(t.x) ? t.x : window.pageXOffset,
        y: dt(t.y) ? t.y : window.pageYOffset
      }
    }

    function dt(t) {
      return "number" == typeof t
    }
    var pt = /^#\d/;

    function ft(t, e) {
      var n, r = "object" == typeof t;
      if (r && "string" == typeof t.selector) {
        var i = pt.test(t.selector) ? document.getElementById(t.selector.slice(1)) : document.querySelector(t.selector);
        if (i) {
          var o = t.offset && "object" == typeof t.offset ? t.offset : {};
          e = function(t, e) {
            var n = document.documentElement.getBoundingClientRect(),
              r = t.getBoundingClientRect();
            return {
              x: r.left - n.left - e.x,
              y: r.top - n.top - e.y
            }
          }(i, o = {
            x: dt((n = o).x) ? n.x : 0,
            y: dt(n.y) ? n.y : 0
          })
        } else ht(t) && (e = ut(t))
      } else r && ht(t) && (e = ut(t));
      e && window.scrollTo(e.x, e.y)
    }
    var gt, mt = J && ((-1 === (gt = window.navigator.userAgent).indexOf("Android 2.") && -1 === gt.indexOf(
      "Android 4.0") || -1 === gt.indexOf("Mobile Safari") || -1 !== gt.indexOf("Chrome") || -1 !== gt.indexOf(
      "Windows Phone")) && window.history && "function" == typeof window.history.pushState);

    function vt(t, e) {
      lt();
      var n = window.history;
      try {
        if (e) {
          var r = i({}, n.state);
          r.key = rt(), n.replaceState(r, "", t)
        } else n.pushState({
          key: it(et())
        }, "", t)
      } catch (n) {
        window.location[e ? "replace" : "assign"](t)
      }
    }

    function yt(t) {
      vt(t, !0)
    }

    function bt(t, e, n) {
      var r = function(i) {
        i >= t.length ? n() : t[i] ? e(t[i], function() {
          r(i + 1)
        }) : r(i + 1)
      };
      r(0)
    }
    var Ct = {
      redirected: 2,
      aborted: 4,
      cancelled: 8,
      duplicated: 16
    };

    function xt(t, e) {
      return At(t, e, Ct.redirected, 'Redirected when going from "' + t.fullPath + '" to "' + function(t) {
        if ("string" == typeof t) return t;
        if ("path" in t) return t.path;
        var e = {};
        return Et.forEach(function(n) {
          n in t && (e[n] = t[n])
        }), JSON.stringify(e, null, 2)
      }(e) + '" via a navigation guard.')
    }

    function wt(t, e) {
      return At(t, e, Ct.cancelled, 'Navigation cancelled from "' + t.fullPath + '" to "' + e.fullPath +
        '" with a new navigation.')
    }

    function At(t, e, n, r) {
      var i = new Error(r);
      return i._isRouter = !0, i.from = t, i.to = e, i.type = n, i
    }
    var Et = ["params", "query", "hash"];

    function St(t) {
      return Object.prototype.toString.call(t).indexOf("Error") > -1
    }

    function Mt(t, e) {
      return St(t) && t._isRouter && (null == e || t.type === e)
    }

    function kt(t) {
      return function(e, n, r) {
        var i = !1,
          o = 0,
          s = null;
        Ot(t, function(t, e, n, a) {
          if ("function" == typeof t && void 0 === t.cid) {
            i = !0, o++;
            var l, c = Tt(function(e) {
                var i;
                ((i = e).__esModule || Dt && "Module" === i[Symbol.toStringTag]) && (e = e.default), t.resolved =
                  "function" == typeof e ? e : H.extend(e), n.components[a] = e, --o <= 0 && r()
              }),
              h = Tt(function(t) {
                var e = "Failed to resolve async component " + a + ": " + t;
                s || (s = St(t) ? t : new Error(e), r(s))
              });
            try {
              l = t(c, h)
            } catch (t) {
              h(t)
            }
            if (l)
              if ("function" == typeof l.then) l.then(c, h);
              else {
                var u = l.component;
                u && "function" == typeof u.then && u.then(c, h)
              }
          }
        }), i || r()
      }
    }

    function Ot(t, e) {
      return Pt(t.map(function(t) {
        return Object.keys(t.components).map(function(n) {
          return e(t.components[n], t.instances[n], t, n)
        })
      }))
    }

    function Pt(t) {
      return Array.prototype.concat.apply([], t)
    }
    var Dt = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;

    function Tt(t) {
      var e = !1;
      return function() {
        for (var n = [], r = arguments.length; r--;) n[r] = arguments[r];
        if (!e) return e = !0, t.apply(this, n)
      }
    }
    var _t = function(t, e) {
      this.router = t, this.base = function(t) {
          if (!t)
            if (J) {
              var e = document.querySelector("base");
              t = (t = e && e.getAttribute("href") || "/").replace(/^https?:\/\/[^\/]+/, "")
            } else t = "/";
          "/" !== t.charAt(0) && (t = "/" + t);
          return t.replace(/\/$/, "")
        }(e), this.current = y, this.pending = null, this.ready = !1, this.readyCbs = [], this.readyErrorCbs = [],
        this.errorCbs = [], this.listeners = []
    };

    function jt(t, e, n, r) {
      var i = Ot(t, function(t, r, i, o) {
        var s = function(t, e) {
          "function" != typeof t && (t = H.extend(t));
          return t.options[e]
        }(t, e);
        if (s) return Array.isArray(s) ? s.map(function(t) {
          return n(t, r, i, o)
        }) : n(s, r, i, o)
      });
      return Pt(r ? i.reverse() : i)
    }

    function Lt(t, e) {
      if (e) return function() {
        return t.apply(e, arguments)
      }
    }
    _t.prototype.listen = function(t) {
      this.cb = t
    }, _t.prototype.onReady = function(t, e) {
      this.ready ? t() : (this.readyCbs.push(t), e && this.readyErrorCbs.push(e))
    }, _t.prototype.onError = function(t) {
      this.errorCbs.push(t)
    }, _t.prototype.transitionTo = function(t, e, n) {
      var r, i = this;
      try {
        r = this.router.match(t, this.current)
      } catch (t) {
        throw this.errorCbs.forEach(function(e) {
          e(t)
        }), t
      }
      this.confirmTransition(r, function() {
        var t = i.current;
        i.updateRoute(r), e && e(r), i.ensureURL(), i.router.afterHooks.forEach(function(e) {
          e && e(r, t)
        }), i.ready || (i.ready = !0, i.readyCbs.forEach(function(t) {
          t(r)
        }))
      }, function(t) {
        n && n(t), t && !i.ready && (i.ready = !0, Mt(t, Ct.redirected) ? i.readyCbs.forEach(function(t) {
          t(r)
        }) : i.readyErrorCbs.forEach(function(e) {
          e(t)
        }))
      })
    }, _t.prototype.confirmTransition = function(t, e, n) {
      var i, o, s = this,
        a = this.current,
        l = function(t) {
          !Mt(t) && St(t) && (s.errorCbs.length ? s.errorCbs.forEach(function(e) {
            e(t)
          }) : (r(), console.error(t))), n && n(t)
        },
        c = t.matched.length - 1,
        h = a.matched.length - 1;
      if (C(t, a) && c === h && t.matched[c] === a.matched[h]) return this.ensureURL(), l(((o = At(i = a, t, Ct
          .duplicated, 'Avoided redundant navigation to current location: "' + i.fullPath + '".')).name =
        "NavigationDuplicated", o));
      var u = function(t, e) {
          var n, r = Math.max(t.length, e.length);
          for (n = 0; n < r && t[n] === e[n]; n++);
          return {
            updated: e.slice(0, n),
            activated: e.slice(n),
            deactivated: t.slice(n)
          }
        }(this.current.matched, t.matched),
        d = u.updated,
        p = u.deactivated,
        f = u.activated,
        g = [].concat(function(t) {
          return jt(t, "beforeRouteLeave", Lt, !0)
        }(p), this.router.beforeHooks, function(t) {
          return jt(t, "beforeRouteUpdate", Lt)
        }(d), f.map(function(t) {
          return t.beforeEnter
        }), kt(f));
      this.pending = t;
      var m = function(e, n) {
        if (s.pending !== t) return l(wt(a, t));
        try {
          e(t, a, function(e) {
            !1 === e ? (s.ensureURL(!0), l(function(t, e) {
                return At(t, e, Ct.aborted, 'Navigation aborted from "' + t.fullPath + '" to "' + e.fullPath +
                  '" via a navigation guard.')
              }(a, t))) : St(e) ? (s.ensureURL(!0), l(e)) : "string" == typeof e || "object" == typeof e &&
              ("string" == typeof e.path || "string" == typeof e.name) ? (l(xt(a, t)), "object" == typeof e &&
                e.replace ? s.replace(e) : s.push(e)) : n(e)
          })
        } catch (t) {
          l(t)
        }
      };
      bt(g, m, function() {
        var n = [];
        bt(function(t, e, n) {
          return jt(t, "beforeRouteEnter", function(t, r, i, o) {
            return function(t, e, n, r, i) {
              return function(o, s, a) {
                return t(o, s, function(t) {
                  "function" == typeof t && r.push(function() {
                    ! function t(e, n, r, i) {
                      n[r] && !n[r]._isBeingDestroyed ? e(n[r]) : i() && setTimeout(
                        function() {
                          t(e, n, r, i)
                        }, 16)
                    }(t, e.instances, n, i)
                  }), a(t)
                })
              }
            }(t, i, o, e, n)
          })
        }(f, n, function() {
          return s.current === t
        }).concat(s.router.resolveHooks), m, function() {
          if (s.pending !== t) return l(wt(a, t));
          s.pending = null, e(t), s.router.app && s.router.app.$nextTick(function() {
            n.forEach(function(t) {
              t()
            })
          })
        })
      })
    }, _t.prototype.updateRoute = function(t) {
      this.current = t, this.cb && this.cb(t)
    }, _t.prototype.setupListeners = function() {}, _t.prototype.teardownListeners = function() {
      this.listeners.forEach(function(t) {
        t()
      }), this.listeners = []
    };
    var Nt = function(t) {
      function e(e, n) {
        t.call(this, e, n), this._startLocation = Ft(this.base)
      }
      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e,
        e.prototype.setupListeners = function() {
          var t = this;
          if (!(this.listeners.length > 0)) {
            var e = this.router,
              n = e.options.scrollBehavior,
              r = mt && n;
            r && this.listeners.push(st());
            var i = function() {
              var n = t.current,
                i = Ft(t.base);
              t.current === y && i === t._startLocation || t.transitionTo(i, function(t) {
                r && at(e, t, n, !0)
              })
            };
            window.addEventListener("popstate", i), this.listeners.push(function() {
              window.removeEventListener("popstate", i)
            })
          }
        }, e.prototype.go = function(t) {
          window.history.go(t)
        }, e.prototype.push = function(t, e, n) {
          var r = this,
            i = this.current;
          this.transitionTo(t, function(t) {
            vt(A(r.base + t.fullPath)), at(r.router, t, i, !1), e && e(t)
          }, n)
        }, e.prototype.replace = function(t, e, n) {
          var r = this,
            i = this.current;
          this.transitionTo(t, function(t) {
            yt(A(r.base + t.fullPath)), at(r.router, t, i, !1), e && e(t)
          }, n)
        }, e.prototype.ensureURL = function(t) {
          if (Ft(this.base) !== this.current.fullPath) {
            var e = A(this.base + this.current.fullPath);
            t ? vt(e) : yt(e)
          }
        }, e.prototype.getCurrentLocation = function() {
          return Ft(this.base)
        }, e
    }(_t);

    function Ft(t) {
      var e = decodeURI(window.location.pathname);
      return t && 0 === e.toLowerCase().indexOf(t.toLowerCase()) && (e = e.slice(t.length)), (e || "/") + window.location
        .search + window.location.hash
    }
    var $t = function(t) {
      function e(e, n, r) {
        t.call(this, e, n), r && function(t) {
          var e = Ft(t);
          if (!/^\/#/.test(e)) return window.location.replace(A(t + "/#" + e)), !0
        }(this.base) || Bt()
      }
      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e,
        e.prototype.setupListeners = function() {
          var t = this;
          if (!(this.listeners.length > 0)) {
            var e = this.router.options.scrollBehavior,
              n = mt && e;
            n && this.listeners.push(st());
            var r = function() {
                var e = t.current;
                Bt() && t.transitionTo(It(), function(r) {
                  n && at(t.router, r, e, !0), mt || Vt(r.fullPath)
                })
              },
              i = mt ? "popstate" : "hashchange";
            window.addEventListener(i, r), this.listeners.push(function() {
              window.removeEventListener(i, r)
            })
          }
        }, e.prototype.push = function(t, e, n) {
          var r = this,
            i = this.current;
          this.transitionTo(t, function(t) {
            Rt(t.fullPath), at(r.router, t, i, !1), e && e(t)
          }, n)
        }, e.prototype.replace = function(t, e, n) {
          var r = this,
            i = this.current;
          this.transitionTo(t, function(t) {
            Vt(t.fullPath), at(r.router, t, i, !1), e && e(t)
          }, n)
        }, e.prototype.go = function(t) {
          window.history.go(t)
        }, e.prototype.ensureURL = function(t) {
          var e = this.current.fullPath;
          It() !== e && (t ? Rt(e) : Vt(e))
        }, e.prototype.getCurrentLocation = function() {
          return It()
        }, e
    }(_t);

    function Bt() {
      var t = It();
      return "/" === t.charAt(0) || (Vt("/" + t), !1)
    }

    function It() {
      var t = window.location.href,
        e = t.indexOf("#");
      if (e < 0) return "";
      var n = (t = t.slice(e + 1)).indexOf("?");
      if (n < 0) {
        var r = t.indexOf("#");
        t = r > -1 ? decodeURI(t.slice(0, r)) + t.slice(r) : decodeURI(t)
      } else t = decodeURI(t.slice(0, n)) + t.slice(n);
      return t
    }

    function zt(t) {
      var e = window.location.href,
        n = e.indexOf("#");
      return (n >= 0 ? e.slice(0, n) : e) + "#" + t
    }

    function Rt(t) {
      mt ? vt(zt(t)) : window.location.hash = t
    }

    function Vt(t) {
      mt ? yt(zt(t)) : window.location.replace(zt(t))
    }
    var Ht = function(t) {
        function e(e, n) {
          t.call(this, e, n), this.stack = [], this.index = -1
        }
        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e,
          e.prototype.push = function(t, e, n) {
            var r = this;
            this.transitionTo(t, function(t) {
              r.stack = r.stack.slice(0, r.index + 1).concat(t), r.index++, e && e(t)
            }, n)
          }, e.prototype.replace = function(t, e, n) {
            var r = this;
            this.transitionTo(t, function(t) {
              r.stack = r.stack.slice(0, r.index).concat(t), e && e(t)
            }, n)
          }, e.prototype.go = function(t) {
            var e = this,
              n = this.index + t;
            if (!(n < 0 || n >= this.stack.length)) {
              var r = this.stack[n];
              this.confirmTransition(r, function() {
                e.index = n, e.updateRoute(r)
              }, function(t) {
                Mt(t, Ct.duplicated) && (e.index = n)
              })
            }
          }, e.prototype.getCurrentLocation = function() {
            var t = this.stack[this.stack.length - 1];
            return t ? t.fullPath : "/"
          }, e.prototype.ensureURL = function() {}, e
      }(_t),
      Gt = function(t) {
        void 0 === t && (t = {}), this.app = null, this.apps = [], this.options = t, this.beforeHooks = [], this.resolveHooks = [],
          this.afterHooks = [], this.matcher = K(t.routes || [], this);
        var e = t.mode || "hash";
        switch (this.fallback = "history" === e && !mt && !1 !== t.fallback, this.fallback && (e = "hash"), J ||
          (e = "abstract"), this.mode = e, e) {
          case "history":
            this.history = new Nt(this, t.base);
            break;
          case "hash":
            this.history = new $t(this, t.base, this.fallback);
            break;
          case "abstract":
            this.history = new Ht(this, t.base);
            break;
          default:
            0
        }
      },
      Ut = {
        currentRoute: {
          configurable: !0
        }
      };

    function qt(t, e) {
      return t.push(e),
        function() {
          var n = t.indexOf(e);
          n > -1 && t.splice(n, 1)
        }
    }
    Gt.prototype.match = function(t, e, n) {
        return this.matcher.match(t, e, n)
      }, Ut.currentRoute.get = function() {
        return this.history && this.history.current
      }, Gt.prototype.init = function(t) {
        var e = this;
        if (this.apps.push(t), t.$once("hook:destroyed", function() {
            var n = e.apps.indexOf(t);
            n > -1 && e.apps.splice(n, 1), e.app === t && (e.app = e.apps[0] || null), e.app || e.history.teardownListeners()
          }), !this.app) {
          this.app = t;
          var n = this.history;
          if (n instanceof Nt || n instanceof $t) {
            var r = function(t) {
              n.setupListeners(),
                function(t) {
                  var r = n.current,
                    i = e.options.scrollBehavior;
                  mt && i && "fullPath" in t && at(e, t, r, !1)
                }(t)
            };
            n.transitionTo(n.getCurrentLocation(), r, r)
          }
          n.listen(function(t) {
            e.apps.forEach(function(e) {
              e._route = t
            })
          })
        }
      }, Gt.prototype.beforeEach = function(t) {
        return qt(this.beforeHooks, t)
      }, Gt.prototype.beforeResolve = function(t) {
        return qt(this.resolveHooks, t)
      }, Gt.prototype.afterEach = function(t) {
        return qt(this.afterHooks, t)
      }, Gt.prototype.onReady = function(t, e) {
        this.history.onReady(t, e)
      }, Gt.prototype.onError = function(t) {
        this.history.onError(t)
      }, Gt.prototype.push = function(t, e, n) {
        var r = this;
        if (!e && !n && "undefined" != typeof Promise) return new Promise(function(e, n) {
          r.history.push(t, e, n)
        });
        this.history.push(t, e, n)
      }, Gt.prototype.replace = function(t, e, n) {
        var r = this;
        if (!e && !n && "undefined" != typeof Promise) return new Promise(function(e, n) {
          r.history.replace(t, e, n)
        });
        this.history.replace(t, e, n)
      }, Gt.prototype.go = function(t) {
        this.history.go(t)
      }, Gt.prototype.back = function() {
        this.go(-1)
      }, Gt.prototype.forward = function() {
        this.go(1)
      }, Gt.prototype.getMatchedComponents = function(t) {
        var e = t ? t.matched ? t : this.resolve(t).route : this.currentRoute;
        return e ? [].concat.apply([], e.matched.map(function(t) {
          return Object.keys(t.components).map(function(e) {
            return t.components[e]
          })
        })) : []
      }, Gt.prototype.resolve = function(t, e, n) {
        var r = V(t, e = e || this.history.current, n, this),
          i = this.match(r, e),
          o = i.redirectedFrom || i.fullPath;
        return {
          location: r,
          route: i,
          href: function(t, e, n) {
            var r = "hash" === n ? "#" + e : e;
            return t ? A(t + "/" + r) : r
          }(this.history.base, o, this.mode),
          normalizedTo: r,
          resolved: i
        }
      }, Gt.prototype.addRoutes = function(t) {
        this.matcher.addRoutes(t), this.history.current !== y && this.history.transitionTo(this.history.getCurrentLocation())
      }, Object.defineProperties(Gt.prototype, Ut), Gt.install = Y, Gt.version = "3.4.3", Gt.isNavigationFailure =
      Mt, Gt.NavigationFailureType = Ct, J && window.Vue && window.Vue.use(Gt), e.a = Gt
  },
  "5xbe": function(t, e, n) {
    var r, i, o, s;
    /*!
     * jQuery Mousewheel 3.1.13
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license
     * http://jquery.org/license
     */
    /*!
     * jQuery Mousewheel 3.1.13
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license
     * http://jquery.org/license
     */
    s = function(t) {
      var e, n, r = ["wheel", "mousewheel", "DOMMouseScroll", "MozMousePixelScroll"],
        i = "onwheel" in document || document.documentMode >= 9 ? ["wheel"] : ["mousewheel", "DomMouseScroll",
          "MozMousePixelScroll"
        ],
        o = Array.prototype.slice;
      if (t.event.fixHooks)
        for (var s = r.length; s;) t.event.fixHooks[r[--s]] = t.event.mouseHooks;
      var a = t.event.special.mousewheel = {
        version: "3.1.12",
        setup: function() {
          if (this.addEventListener)
            for (var e = i.length; e;) this.addEventListener(i[--e], l, !1);
          else this.onmousewheel = l;
          t.data(this, "mousewheel-line-height", a.getLineHeight(this)), t.data(this,
            "mousewheel-page-height", a.getPageHeight(this))
        },
        teardown: function() {
          if (this.removeEventListener)
            for (var e = i.length; e;) this.removeEventListener(i[--e], l, !1);
          else this.onmousewheel = null;
          t.removeData(this, "mousewheel-line-height"), t.removeData(this, "mousewheel-page-height")
        },
        getLineHeight: function(e) {
          var n = t(e),
            r = n["offsetParent" in t.fn ? "offsetParent" : "parent"]();
          return r.length || (r = t("body")), parseInt(r.css("fontSize"), 10) || parseInt(n.css("fontSize"),
            10) || 16
        },
        getPageHeight: function(e) {
          return t(e).height()
        },
        settings: {
          adjustOldDeltas: !0,
          normalizeOffset: !0
        }
      };

      function l(r) {
        var i, s = r || window.event,
          l = o.call(arguments, 1),
          u = 0,
          d = 0,
          p = 0,
          f = 0,
          g = 0;
        if ((r = t.event.fix(s)).type = "mousewheel", "detail" in s && (p = -1 * s.detail), "wheelDelta" in s &&
          (p = s.wheelDelta), "wheelDeltaY" in s && (p = s.wheelDeltaY), "wheelDeltaX" in s && (d = -1 * s.wheelDeltaX),
          "axis" in s && s.axis === s.HORIZONTAL_AXIS && (d = -1 * p, p = 0), u = 0 === p ? d : p, "deltaY" in
          s && (u = p = -1 * s.deltaY), "deltaX" in s && (d = s.deltaX, 0 === p && (u = -1 * d)), 0 !== p || 0 !==
          d) {
          if (1 === s.deltaMode) {
            var m = t.data(this, "mousewheel-line-height");
            u *= m, p *= m, d *= m
          } else if (2 === s.deltaMode) {
            var v = t.data(this, "mousewheel-page-height");
            u *= v, p *= v, d *= v
          }
          if (i = Math.max(Math.abs(p), Math.abs(d)), (!n || i < n) && (n = i, h(s, i) && (n /= 40)), h(s, i) &&
            (u /= 40, d /= 40, p /= 40), u = Math[u >= 1 ? "floor" : "ceil"](u / n), d = Math[d >= 1 ? "floor" :
              "ceil"](d / n), p = Math[p >= 1 ? "floor" : "ceil"](p / n), a.settings.normalizeOffset && this.getBoundingClientRect
          ) {
            var y = this.getBoundingClientRect();
            f = r.clientX - y.left, g = r.clientY - y.top
          }
          return r.deltaX = d, r.deltaY = p, r.deltaFactor = n, r.offsetX = f, r.offsetY = g, r.deltaMode = 0,
            l.unshift(r, u, d, p), e && clearTimeout(e), e = setTimeout(c, 200), (t.event.dispatch || t.event.handle)
            .apply(this, l)
        }
      }

      function c() {
        n = null
      }

      function h(t, e) {
        return a.settings.adjustOldDeltas && "mousewheel" === t.type && e % 120 == 0
      }
      t.fn.extend({
        mousewheel: function(t) {
          return t ? this.bind("mousewheel", t) : this.trigger("mousewheel")
        },
        unmousewheel: function(t) {
          return this.unbind("mousewheel", t)
        }
      })
    }, i = [n("7t+N")], void 0 === (o = "function" == typeof(r = s) ? r.apply(e, i) : r) || (t.exports = o)
  },
  "6PaC": function(t, e, n) {
    "use strict";
    (function(t) {
      var r = n("nSxQ"),
        i = "object" == typeof exports && exports && !exports.nodeType && exports,
        o = i && "object" == typeof t && t && !t.nodeType && t,
        s = o && o.exports === i && r.a.process,
        a = function() {
          try {
            var t = o && o.require && o.require("util").types;
            return t || s && s.binding && s.binding("util")
          } catch (t) {}
        }();
      e.a = a
    }).call(e, n("f1Eh")(t))
  },
  "7+uW": function(t, e, n) {
    "use strict";
    (function(t) {
      /*!
       * Vue.js v2.6.12
       * (c) 2014-2020 Evan You
       * Released under the MIT License.
       */
      var n = Object.freeze({});

      function r(t) {
        return void 0 === t || null === t
      }

      function i(t) {
        return void 0 !== t && null !== t
      }

      function o(t) {
        return !0 === t
      }

      function s(t) {
        return "string" == typeof t || "number" == typeof t || "symbol" == typeof t || "boolean" == typeof t
      }

      function a(t) {
        return null !== t && "object" == typeof t
      }
      var l = Object.prototype.toString;

      function c(t) {
        return "[object Object]" === l.call(t)
      }

      function h(t) {
        return "[object RegExp]" === l.call(t)
      }

      function u(t) {
        var e = parseFloat(String(t));
        return e >= 0 && Math.floor(e) === e && isFinite(t)
      }

      function d(t) {
        return i(t) && "function" == typeof t.then && "function" == typeof t.catch
      }

      function p(t) {
        return null == t ? "" : Array.isArray(t) || c(t) && t.toString === l ? JSON.stringify(t, null, 2) :
          String(t)
      }

      function f(t) {
        var e = parseFloat(t);
        return isNaN(e) ? t : e
      }

      function g(t, e) {
        for (var n = Object.create(null), r = t.split(","), i = 0; i < r.length; i++) n[r[i]] = !0;
        return e ? function(t) {
          return n[t.toLowerCase()]
        } : function(t) {
          return n[t]
        }
      }
      var m = g("slot,component", !0),
        v = g("key,ref,slot,slot-scope,is");

      function y(t, e) {
        if (t.length) {
          var n = t.indexOf(e);
          if (n > -1) return t.splice(n, 1)
        }
      }
      var b = Object.prototype.hasOwnProperty;

      function C(t, e) {
        return b.call(t, e)
      }

      function x(t) {
        var e = Object.create(null);
        return function(n) {
          return e[n] || (e[n] = t(n))
        }
      }
      var w = /-(\w)/g,
        A = x(function(t) {
          return t.replace(w, function(t, e) {
            return e ? e.toUpperCase() : ""
          })
        }),
        E = x(function(t) {
          return t.charAt(0).toUpperCase() + t.slice(1)
        }),
        S = /\B([A-Z])/g,
        M = x(function(t) {
          return t.replace(S, "-$1").toLowerCase()
        });
      var k = Function.prototype.bind ? function(t, e) {
        return t.bind(e)
      } : function(t, e) {
        function n(n) {
          var r = arguments.length;
          return r ? r > 1 ? t.apply(e, arguments) : t.call(e, n) : t.call(e)
        }
        return n._length = t.length, n
      };

      function O(t, e) {
        e = e || 0;
        for (var n = t.length - e, r = new Array(n); n--;) r[n] = t[n + e];
        return r
      }

      function P(t, e) {
        for (var n in e) t[n] = e[n];
        return t
      }

      function D(t) {
        for (var e = {}, n = 0; n < t.length; n++) t[n] && P(e, t[n]);
        return e
      }

      function T(t, e, n) {}
      var _ = function(t, e, n) {
          return !1
        },
        j = function(t) {
          return t
        };

      function L(t, e) {
        if (t === e) return !0;
        var n = a(t),
          r = a(e);
        if (!n || !r) return !n && !r && String(t) === String(e);
        try {
          var i = Array.isArray(t),
            o = Array.isArray(e);
          if (i && o) return t.length === e.length && t.every(function(t, n) {
            return L(t, e[n])
          });
          if (t instanceof Date && e instanceof Date) return t.getTime() === e.getTime();
          if (i || o) return !1;
          var s = Object.keys(t),
            l = Object.keys(e);
          return s.length === l.length && s.every(function(n) {
            return L(t[n], e[n])
          })
        } catch (t) {
          return !1
        }
      }

      function N(t, e) {
        for (var n = 0; n < t.length; n++)
          if (L(t[n], e)) return n;
        return -1
      }

      function F(t) {
        var e = !1;
        return function() {
          e || (e = !0, t.apply(this, arguments))
        }
      }
      var $ = "data-server-rendered",
        B = ["component", "directive", "filter"],
        I = ["beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeDestroy",
          "destroyed", "activated", "deactivated", "errorCaptured", "serverPrefetch"
        ],
        z = {
          optionMergeStrategies: Object.create(null),
          silent: !1,
          productionTip: !1,
          devtools: !1,
          performance: !1,
          errorHandler: null,
          warnHandler: null,
          ignoredElements: [],
          keyCodes: Object.create(null),
          isReservedTag: _,
          isReservedAttr: _,
          isUnknownElement: _,
          getTagNamespace: T,
          parsePlatformTagName: j,
          mustUseProp: _,
          async: !0,
          _lifecycleHooks: I
        },
        R =
        /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

      function V(t) {
        var e = (t + "").charCodeAt(0);
        return 36 === e || 95 === e
      }

      function H(t, e, n, r) {
        Object.defineProperty(t, e, {
          value: n,
          enumerable: !!r,
          writable: !0,
          configurable: !0
        })
      }
      var G = new RegExp("[^" + R.source + ".$_\\d]");
      var U, q = "__proto__" in {},
        W = "undefined" != typeof window,
        X = "undefined" != typeof WXEnvironment && !!WXEnvironment.platform,
        Y = X && WXEnvironment.platform.toLowerCase(),
        J = W && window.navigator.userAgent.toLowerCase(),
        Z = J && /msie|trident/.test(J),
        K = J && J.indexOf("msie 9.0") > 0,
        Q = J && J.indexOf("edge/") > 0,
        tt = (J && J.indexOf("android"), J && /iphone|ipad|ipod|ios/.test(J) || "ios" === Y),
        et = (J && /chrome\/\d+/.test(J), J && /phantomjs/.test(J), J && J.match(/firefox\/(\d+)/)),
        nt = {}.watch,
        rt = !1;
      if (W) try {
        var it = {};
        Object.defineProperty(it, "passive", {
          get: function() {
            rt = !0
          }
        }), window.addEventListener("test-passive", null, it)
      } catch (t) {}
      var ot = function() {
          return void 0 === U && (U = !W && !X && void 0 !== t && (t.process && "server" === t.process.env.VUE_ENV)),
            U
        },
        st = W && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

      function at(t) {
        return "function" == typeof t && /native code/.test(t.toString())
      }
      var lt, ct = "undefined" != typeof Symbol && at(Symbol) && "undefined" != typeof Reflect && at(Reflect.ownKeys);
      lt = "undefined" != typeof Set && at(Set) ? Set : function() {
        function t() {
          this.set = Object.create(null)
        }
        return t.prototype.has = function(t) {
          return !0 === this.set[t]
        }, t.prototype.add = function(t) {
          this.set[t] = !0
        }, t.prototype.clear = function() {
          this.set = Object.create(null)
        }, t
      }();
      var ht = T,
        ut = 0,
        dt = function() {
          this.id = ut++, this.subs = []
        };
      dt.prototype.addSub = function(t) {
        this.subs.push(t)
      }, dt.prototype.removeSub = function(t) {
        y(this.subs, t)
      }, dt.prototype.depend = function() {
        dt.target && dt.target.addDep(this)
      }, dt.prototype.notify = function() {
        var t = this.subs.slice();
        for (var e = 0, n = t.length; e < n; e++) t[e].update()
      }, dt.target = null;
      var pt = [];

      function ft(t) {
        pt.push(t), dt.target = t
      }

      function gt() {
        pt.pop(), dt.target = pt[pt.length - 1]
      }
      var mt = function(t, e, n, r, i, o, s, a) {
          this.tag = t, this.data = e, this.children = n, this.text = r, this.elm = i, this.ns = void 0, this.context =
            o, this.fnContext = void 0, this.fnOptions = void 0, this.fnScopeId = void 0, this.key = e && e.key,
            this.componentOptions = s, this.componentInstance = void 0, this.parent = void 0, this.raw = !1,
            this.isStatic = !1, this.isRootInsert = !0, this.isComment = !1, this.isCloned = !1, this.isOnce = !
            1, this.asyncFactory = a, this.asyncMeta = void 0, this.isAsyncPlaceholder = !1
        },
        vt = {
          child: {
            configurable: !0
          }
        };
      vt.child.get = function() {
        return this.componentInstance
      }, Object.defineProperties(mt.prototype, vt);
      var yt = function(t) {
        void 0 === t && (t = "");
        var e = new mt;
        return e.text = t, e.isComment = !0, e
      };

      function bt(t) {
        return new mt(void 0, void 0, void 0, String(t))
      }

      function Ct(t) {
        var e = new mt(t.tag, t.data, t.children && t.children.slice(), t.text, t.elm, t.context, t.componentOptions,
          t.asyncFactory);
        return e.ns = t.ns, e.isStatic = t.isStatic, e.key = t.key, e.isComment = t.isComment, e.fnContext = t.fnContext,
          e.fnOptions = t.fnOptions, e.fnScopeId = t.fnScopeId, e.asyncMeta = t.asyncMeta, e.isCloned = !0, e
      }
      var xt = Array.prototype,
        wt = Object.create(xt);
      ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"].forEach(function(t) {
        var e = xt[t];
        H(wt, t, function() {
          for (var n = [], r = arguments.length; r--;) n[r] = arguments[r];
          var i, o = e.apply(this, n),
            s = this.__ob__;
          switch (t) {
            case "push":
            case "unshift":
              i = n;
              break;
            case "splice":
              i = n.slice(2)
          }
          return i && s.observeArray(i), s.dep.notify(), o
        })
      });
      var At = Object.getOwnPropertyNames(wt),
        Et = !0;

      function St(t) {
        Et = t
      }
      var Mt = function(t) {
        var e;
        this.value = t, this.dep = new dt, this.vmCount = 0, H(t, "__ob__", this), Array.isArray(t) ? (q ? (e =
          wt, t.__proto__ = e) : function(t, e, n) {
          for (var r = 0, i = n.length; r < i; r++) {
            var o = n[r];
            H(t, o, e[o])
          }
        }(t, wt, At), this.observeArray(t)) : this.walk(t)
      };

      function kt(t, e) {
        var n;
        if (a(t) && !(t instanceof mt)) return C(t, "__ob__") && t.__ob__ instanceof Mt ? n = t.__ob__ : Et &&
          !ot() && (Array.isArray(t) || c(t)) && Object.isExtensible(t) && !t._isVue && (n = new Mt(t)), e &&
          n && n.vmCount++, n
      }

      function Ot(t, e, n, r, i) {
        var o = new dt,
          s = Object.getOwnPropertyDescriptor(t, e);
        if (!s || !1 !== s.configurable) {
          var a = s && s.get,
            l = s && s.set;
          a && !l || 2 !== arguments.length || (n = t[e]);
          var c = !i && kt(n);
          Object.defineProperty(t, e, {
            enumerable: !0,
            configurable: !0,
            get: function() {
              var e = a ? a.call(t) : n;
              return dt.target && (o.depend(), c && (c.dep.depend(), Array.isArray(e) && function t(e) {
                for (var n = void 0, r = 0, i = e.length; r < i; r++)(n = e[r]) && n.__ob__ && n.__ob__
                  .dep.depend(), Array.isArray(n) && t(n)
              }(e))), e
            },
            set: function(e) {
              var r = a ? a.call(t) : n;
              e === r || e != e && r != r || a && !l || (l ? l.call(t, e) : n = e, c = !i && kt(e), o.notify())
            }
          })
        }
      }

      function Pt(t, e, n) {
        if (Array.isArray(t) && u(e)) return t.length = Math.max(t.length, e), t.splice(e, 1, n), n;
        if (e in t && !(e in Object.prototype)) return t[e] = n, n;
        var r = t.__ob__;
        return t._isVue || r && r.vmCount ? n : r ? (Ot(r.value, e, n), r.dep.notify(), n) : (t[e] = n, n)
      }

      function Dt(t, e) {
        if (Array.isArray(t) && u(e)) t.splice(e, 1);
        else {
          var n = t.__ob__;
          t._isVue || n && n.vmCount || C(t, e) && (delete t[e], n && n.dep.notify())
        }
      }
      Mt.prototype.walk = function(t) {
        for (var e = Object.keys(t), n = 0; n < e.length; n++) Ot(t, e[n])
      }, Mt.prototype.observeArray = function(t) {
        for (var e = 0, n = t.length; e < n; e++) kt(t[e])
      };
      var Tt = z.optionMergeStrategies;

      function _t(t, e) {
        if (!e) return t;
        for (var n, r, i, o = ct ? Reflect.ownKeys(e) : Object.keys(e), s = 0; s < o.length; s++) "__ob__" !==
          (n = o[s]) && (r = t[n], i = e[n], C(t, n) ? r !== i && c(r) && c(i) && _t(r, i) : Pt(t, n, i));
        return t
      }

      function jt(t, e, n) {
        return n ? function() {
          var r = "function" == typeof e ? e.call(n, n) : e,
            i = "function" == typeof t ? t.call(n, n) : t;
          return r ? _t(r, i) : i
        } : e ? t ? function() {
          return _t("function" == typeof e ? e.call(this, this) : e, "function" == typeof t ? t.call(this,
            this) : t)
        } : e : t
      }

      function Lt(t, e) {
        var n = e ? t ? t.concat(e) : Array.isArray(e) ? e : [e] : t;
        return n ? function(t) {
          for (var e = [], n = 0; n < t.length; n++) - 1 === e.indexOf(t[n]) && e.push(t[n]);
          return e
        }(n) : n
      }

      function Nt(t, e, n, r) {
        var i = Object.create(t || null);
        return e ? P(i, e) : i
      }
      Tt.data = function(t, e, n) {
        return n ? jt(t, e, n) : e && "function" != typeof e ? t : jt(t, e)
      }, I.forEach(function(t) {
        Tt[t] = Lt
      }), B.forEach(function(t) {
        Tt[t + "s"] = Nt
      }), Tt.watch = function(t, e, n, r) {
        if (t === nt && (t = void 0), e === nt && (e = void 0), !e) return Object.create(t || null);
        if (!t) return e;
        var i = {};
        for (var o in P(i, t), e) {
          var s = i[o],
            a = e[o];
          s && !Array.isArray(s) && (s = [s]), i[o] = s ? s.concat(a) : Array.isArray(a) ? a : [a]
        }
        return i
      }, Tt.props = Tt.methods = Tt.inject = Tt.computed = function(t, e, n, r) {
        if (!t) return e;
        var i = Object.create(null);
        return P(i, t), e && P(i, e), i
      }, Tt.provide = jt;
      var Ft = function(t, e) {
        return void 0 === e ? t : e
      };

      function $t(t, e, n) {
        if ("function" == typeof e && (e = e.options), function(t, e) {
            var n = t.props;
            if (n) {
              var r, i, o = {};
              if (Array.isArray(n))
                for (r = n.length; r--;) "string" == typeof(i = n[r]) && (o[A(i)] = {
                  type: null
                });
              else if (c(n))
                for (var s in n) i = n[s], o[A(s)] = c(i) ? i : {
                  type: i
                };
              t.props = o
            }
          }(e), function(t, e) {
            var n = t.inject;
            if (n) {
              var r = t.inject = {};
              if (Array.isArray(n))
                for (var i = 0; i < n.length; i++) r[n[i]] = {
                  from: n[i]
                };
              else if (c(n))
                for (var o in n) {
                  var s = n[o];
                  r[o] = c(s) ? P({
                    from: o
                  }, s) : {
                    from: s
                  }
                }
            }
          }(e), function(t) {
            var e = t.directives;
            if (e)
              for (var n in e) {
                var r = e[n];
                "function" == typeof r && (e[n] = {
                  bind: r,
                  update: r
                })
              }
          }(e), !e._base && (e.extends && (t = $t(t, e.extends, n)), e.mixins))
          for (var r = 0, i = e.mixins.length; r < i; r++) t = $t(t, e.mixins[r], n);
        var o, s = {};
        for (o in t) a(o);
        for (o in e) C(t, o) || a(o);

        function a(r) {
          var i = Tt[r] || Ft;
          s[r] = i(t[r], e[r], n, r)
        }
        return s
      }

      function Bt(t, e, n, r) {
        if ("string" == typeof n) {
          var i = t[e];
          if (C(i, n)) return i[n];
          var o = A(n);
          if (C(i, o)) return i[o];
          var s = E(o);
          return C(i, s) ? i[s] : i[n] || i[o] || i[s]
        }
      }

      function It(t, e, n, r) {
        var i = e[t],
          o = !C(n, t),
          s = n[t],
          a = Vt(Boolean, i.type);
        if (a > -1)
          if (o && !C(i, "default")) s = !1;
          else if ("" === s || s === M(t)) {
          var l = Vt(String, i.type);
          (l < 0 || a < l) && (s = !0)
        }
        if (void 0 === s) {
          s = function(t, e, n) {
            if (!C(e, "default")) return;
            var r = e.default;
            0;
            if (t && t.$options.propsData && void 0 === t.$options.propsData[n] && void 0 !== t._props[n])
              return t._props[n];
            return "function" == typeof r && "Function" !== zt(e.type) ? r.call(t) : r
          }(r, i, t);
          var c = Et;
          St(!0), kt(s), St(c)
        }
        return s
      }

      function zt(t) {
        var e = t && t.toString().match(/^\s*function (\w+)/);
        return e ? e[1] : ""
      }

      function Rt(t, e) {
        return zt(t) === zt(e)
      }

      function Vt(t, e) {
        if (!Array.isArray(e)) return Rt(e, t) ? 0 : -1;
        for (var n = 0, r = e.length; n < r; n++)
          if (Rt(e[n], t)) return n;
        return -1
      }

      function Ht(t, e, n) {
        ft();
        try {
          if (e)
            for (var r = e; r = r.$parent;) {
              var i = r.$options.errorCaptured;
              if (i)
                for (var o = 0; o < i.length; o++) try {
                  if (!1 === i[o].call(r, t, e, n)) return
                } catch (t) {
                  Ut(t, r, "errorCaptured hook")
                }
            }
          Ut(t, e, n)
        } finally {
          gt()
        }
      }

      function Gt(t, e, n, r, i) {
        var o;
        try {
          (o = n ? t.apply(e, n) : t.call(e)) && !o._isVue && d(o) && !o._handled && (o.catch(function(t) {
            return Ht(t, r, i + " (Promise/async)")
          }), o._handled = !0)
        } catch (t) {
          Ht(t, r, i)
        }
        return o
      }

      function Ut(t, e, n) {
        if (z.errorHandler) try {
          return z.errorHandler.call(null, t, e, n)
        } catch (e) {
          e !== t && qt(e, null, "config.errorHandler")
        }
        qt(t, e, n)
      }

      function qt(t, e, n) {
        if (!W && !X || "undefined" == typeof console) throw t;
        console.error(t)
      }
      var Wt, Xt = !1,
        Yt = [],
        Jt = !1;

      function Zt() {
        Jt = !1;
        var t = Yt.slice(0);
        Yt.length = 0;
        for (var e = 0; e < t.length; e++) t[e]()
      }
      if ("undefined" != typeof Promise && at(Promise)) {
        var Kt = Promise.resolve();
        Wt = function() {
          Kt.then(Zt), tt && setTimeout(T)
        }, Xt = !0
      } else if (Z || "undefined" == typeof MutationObserver || !at(MutationObserver) &&
        "[object MutationObserverConstructor]" !== MutationObserver.toString()) Wt = "undefined" != typeof setImmediate &&
        at(setImmediate) ? function() {
          setImmediate(Zt)
        } : function() {
          setTimeout(Zt, 0)
        };
      else {
        var Qt = 1,
          te = new MutationObserver(Zt),
          ee = document.createTextNode(String(Qt));
        te.observe(ee, {
          characterData: !0
        }), Wt = function() {
          Qt = (Qt + 1) % 2, ee.data = String(Qt)
        }, Xt = !0
      }

      function ne(t, e) {
        var n;
        if (Yt.push(function() {
            if (t) try {
              t.call(e)
            } catch (t) {
              Ht(t, e, "nextTick")
            } else n && n(e)
          }), Jt || (Jt = !0, Wt()), !t && "undefined" != typeof Promise) return new Promise(function(t) {
          n = t
        })
      }
      var re = new lt;

      function ie(t) {
        ! function t(e, n) {
          var r, i;
          var o = Array.isArray(e);
          if (!o && !a(e) || Object.isFrozen(e) || e instanceof mt) return;
          if (e.__ob__) {
            var s = e.__ob__.dep.id;
            if (n.has(s)) return;
            n.add(s)
          }
          if (o)
            for (r = e.length; r--;) t(e[r], n);
          else
            for (i = Object.keys(e), r = i.length; r--;) t(e[i[r]], n)
        }(t, re), re.clear()
      }
      var oe = x(function(t) {
        var e = "&" === t.charAt(0),
          n = "~" === (t = e ? t.slice(1) : t).charAt(0),
          r = "!" === (t = n ? t.slice(1) : t).charAt(0);
        return {
          name: t = r ? t.slice(1) : t,
          once: n,
          capture: r,
          passive: e
        }
      });

      function se(t, e) {
        function n() {
          var t = arguments,
            r = n.fns;
          if (!Array.isArray(r)) return Gt(r, null, arguments, e, "v-on handler");
          for (var i = r.slice(), o = 0; o < i.length; o++) Gt(i[o], null, t, e, "v-on handler")
        }
        return n.fns = t, n
      }

      function ae(t, e, n, i, s, a) {
        var l, c, h, u;
        for (l in t) c = t[l], h = e[l], u = oe(l), r(c) || (r(h) ? (r(c.fns) && (c = t[l] = se(c, a)), o(u.once) &&
            (c = t[l] = s(u.name, c, u.capture)), n(u.name, c, u.capture, u.passive, u.params)) : c !== h &&
          (h.fns = c, t[l] = h));
        for (l in e) r(t[l]) && i((u = oe(l)).name, e[l], u.capture)
      }

      function le(t, e, n) {
        var s;
        t instanceof mt && (t = t.data.hook || (t.data.hook = {}));
        var a = t[e];

        function l() {
          n.apply(this, arguments), y(s.fns, l)
        }
        r(a) ? s = se([l]) : i(a.fns) && o(a.merged) ? (s = a).fns.push(l) : s = se([a, l]), s.merged = !0, t[e] =
          s
      }

      function ce(t, e, n, r, o) {
        if (i(e)) {
          if (C(e, n)) return t[n] = e[n], o || delete e[n], !0;
          if (C(e, r)) return t[n] = e[r], o || delete e[r], !0
        }
        return !1
      }

      function he(t) {
        return s(t) ? [bt(t)] : Array.isArray(t) ? function t(e, n) {
          var a = [];
          var l, c, h, u;
          for (l = 0; l < e.length; l++) r(c = e[l]) || "boolean" == typeof c || (h = a.length - 1, u = a[h],
            Array.isArray(c) ? c.length > 0 && (ue((c = t(c, (n || "") + "_" + l))[0]) && ue(u) && (a[h] =
              bt(u.text + c[0].text), c.shift()), a.push.apply(a, c)) : s(c) ? ue(u) ? a[h] = bt(u.text + c) :
            "" !== c && a.push(bt(c)) : ue(c) && ue(u) ? a[h] = bt(u.text + c.text) : (o(e._isVList) && i(c
              .tag) && r(c.key) && i(n) && (c.key = "__vlist" + n + "_" + l + "__"), a.push(c)));
          return a
        }(t) : void 0
      }

      function ue(t) {
        return i(t) && i(t.text) && !1 === t.isComment
      }

      function de(t, e) {
        if (t) {
          for (var n = Object.create(null), r = ct ? Reflect.ownKeys(t) : Object.keys(t), i = 0; i < r.length; i++) {
            var o = r[i];
            if ("__ob__" !== o) {
              for (var s = t[o].from, a = e; a;) {
                if (a._provided && C(a._provided, s)) {
                  n[o] = a._provided[s];
                  break
                }
                a = a.$parent
              }
              if (!a)
                if ("default" in t[o]) {
                  var l = t[o].default;
                  n[o] = "function" == typeof l ? l.call(e) : l
                } else 0
            }
          }
          return n
        }
      }

      function pe(t, e) {
        if (!t || !t.length) return {};
        for (var n = {}, r = 0, i = t.length; r < i; r++) {
          var o = t[r],
            s = o.data;
          if (s && s.attrs && s.attrs.slot && delete s.attrs.slot, o.context !== e && o.fnContext !== e || !s ||
            null == s.slot)(n.default || (n.default = [])).push(o);
          else {
            var a = s.slot,
              l = n[a] || (n[a] = []);
            "template" === o.tag ? l.push.apply(l, o.children || []) : l.push(o)
          }
        }
        for (var c in n) n[c].every(fe) && delete n[c];
        return n
      }

      function fe(t) {
        return t.isComment && !t.asyncFactory || " " === t.text
      }

      function ge(t, e, r) {
        var i, o = Object.keys(e).length > 0,
          s = t ? !!t.$stable : !o,
          a = t && t.$key;
        if (t) {
          if (t._normalized) return t._normalized;
          if (s && r && r !== n && a === r.$key && !o && !r.$hasNormal) return r;
          for (var l in i = {}, t) t[l] && "$" !== l[0] && (i[l] = me(e, l, t[l]))
        } else i = {};
        for (var c in e) c in i || (i[c] = ve(e, c));
        return t && Object.isExtensible(t) && (t._normalized = i), H(i, "$stable", s), H(i, "$key", a), H(i,
          "$hasNormal", o), i
      }

      function me(t, e, n) {
        var r = function() {
          var t = arguments.length ? n.apply(null, arguments) : n({});
          return (t = t && "object" == typeof t && !Array.isArray(t) ? [t] : he(t)) && (0 === t.length || 1 ===
            t.length && t[0].isComment) ? void 0 : t
        };
        return n.proxy && Object.defineProperty(t, e, {
          get: r,
          enumerable: !0,
          configurable: !0
        }), r
      }

      function ve(t, e) {
        return function() {
          return t[e]
        }
      }

      function ye(t, e) {
        var n, r, o, s, l;
        if (Array.isArray(t) || "string" == typeof t)
          for (n = new Array(t.length), r = 0, o = t.length; r < o; r++) n[r] = e(t[r], r);
        else if ("number" == typeof t)
          for (n = new Array(t), r = 0; r < t; r++) n[r] = e(r + 1, r);
        else if (a(t))
          if (ct && t[Symbol.iterator]) {
            n = [];
            for (var c = t[Symbol.iterator](), h = c.next(); !h.done;) n.push(e(h.value, n.length)), h = c.next()
          } else
            for (s = Object.keys(t), n = new Array(s.length), r = 0, o = s.length; r < o; r++) l = s[r], n[r] =
              e(t[l], l, r);
        return i(n) || (n = []), n._isVList = !0, n
      }

      function be(t, e, n, r) {
        var i, o = this.$scopedSlots[t];
        o ? (n = n || {}, r && (n = P(P({}, r), n)), i = o(n) || e) : i = this.$slots[t] || e;
        var s = n && n.slot;
        return s ? this.$createElement("template", {
          slot: s
        }, i) : i
      }

      function Ce(t) {
        return Bt(this.$options, "filters", t) || j
      }

      function xe(t, e) {
        return Array.isArray(t) ? -1 === t.indexOf(e) : t !== e
      }

      function we(t, e, n, r, i) {
        var o = z.keyCodes[e] || n;
        return i && r && !z.keyCodes[e] ? xe(i, r) : o ? xe(o, t) : r ? M(r) !== e : void 0
      }

      function Ae(t, e, n, r, i) {
        if (n)
          if (a(n)) {
            var o;
            Array.isArray(n) && (n = D(n));
            var s = function(s) {
              if ("class" === s || "style" === s || v(s)) o = t;
              else {
                var a = t.attrs && t.attrs.type;
                o = r || z.mustUseProp(e, a, s) ? t.domProps || (t.domProps = {}) : t.attrs || (t.attrs = {})
              }
              var l = A(s),
                c = M(s);
              l in o || c in o || (o[s] = n[s], i && ((t.on || (t.on = {}))["update:" + s] = function(t) {
                n[s] = t
              }))
            };
            for (var l in n) s(l)
          } else;
        return t
      }

      function Ee(t, e) {
        var n = this._staticTrees || (this._staticTrees = []),
          r = n[t];
        return r && !e ? r : (Me(r = n[t] = this.$options.staticRenderFns[t].call(this._renderProxy, null, this),
          "__static__" + t, !1), r)
      }

      function Se(t, e, n) {
        return Me(t, "__once__" + e + (n ? "_" + n : ""), !0), t
      }

      function Me(t, e, n) {
        if (Array.isArray(t))
          for (var r = 0; r < t.length; r++) t[r] && "string" != typeof t[r] && ke(t[r], e + "_" + r, n);
        else ke(t, e, n)
      }

      function ke(t, e, n) {
        t.isStatic = !0, t.key = e, t.isOnce = n
      }

      function Oe(t, e) {
        if (e)
          if (c(e)) {
            var n = t.on = t.on ? P({}, t.on) : {};
            for (var r in e) {
              var i = n[r],
                o = e[r];
              n[r] = i ? [].concat(i, o) : o
            }
          } else;
        return t
      }

      function Pe(t, e, n, r) {
        e = e || {
          $stable: !n
        };
        for (var i = 0; i < t.length; i++) {
          var o = t[i];
          Array.isArray(o) ? Pe(o, e, n) : o && (o.proxy && (o.fn.proxy = !0), e[o.key] = o.fn)
        }
        return r && (e.$key = r), e
      }

      function De(t, e) {
        for (var n = 0; n < e.length; n += 2) {
          var r = e[n];
          "string" == typeof r && r && (t[e[n]] = e[n + 1])
        }
        return t
      }

      function Te(t, e) {
        return "string" == typeof t ? e + t : t
      }

      function _e(t) {
        t._o = Se, t._n = f, t._s = p, t._l = ye, t._t = be, t._q = L, t._i = N, t._m = Ee, t._f = Ce, t._k =
          we, t._b = Ae, t._v = bt, t._e = yt, t._u = Pe, t._g = Oe, t._d = De, t._p = Te
      }

      function je(t, e, r, i, s) {
        var a, l = this,
          c = s.options;
        C(i, "_uid") ? (a = Object.create(i))._original = i : (a = i, i = i._original);
        var h = o(c._compiled),
          u = !h;
        this.data = t, this.props = e, this.children = r, this.parent = i, this.listeners = t.on || n, this.injections =
          de(c.inject, i), this.slots = function() {
            return l.$slots || ge(t.scopedSlots, l.$slots = pe(r, i)), l.$slots
          }, Object.defineProperty(this, "scopedSlots", {
            enumerable: !0,
            get: function() {
              return ge(t.scopedSlots, this.slots())
            }
          }), h && (this.$options = c, this.$slots = this.slots(), this.$scopedSlots = ge(t.scopedSlots, this.$slots)),
          c._scopeId ? this._c = function(t, e, n, r) {
            var o = Ve(a, t, e, n, r, u);
            return o && !Array.isArray(o) && (o.fnScopeId = c._scopeId, o.fnContext = i), o
          } : this._c = function(t, e, n, r) {
            return Ve(a, t, e, n, r, u)
          }
      }

      function Le(t, e, n, r, i) {
        var o = Ct(t);
        return o.fnContext = n, o.fnOptions = r, e.slot && ((o.data || (o.data = {})).slot = e.slot), o
      }

      function Ne(t, e) {
        for (var n in e) t[A(n)] = e[n]
      }
      _e(je.prototype);
      var Fe = {
          init: function(t, e) {
            if (t.componentInstance && !t.componentInstance._isDestroyed && t.data.keepAlive) {
              var n = t;
              Fe.prepatch(n, n)
            } else {
              (t.componentInstance = function(t, e) {
                var n = {
                    _isComponent: !0,
                    _parentVnode: t,
                    parent: e
                  },
                  r = t.data.inlineTemplate;
                i(r) && (n.render = r.render, n.staticRenderFns = r.staticRenderFns);
                return new t.componentOptions.Ctor(n)
              }(t, Ke)).$mount(e ? t.elm : void 0, e)
            }
          },
          prepatch: function(t, e) {
            var r = e.componentOptions;
            ! function(t, e, r, i, o) {
              0;
              var s = i.data.scopedSlots,
                a = t.$scopedSlots,
                l = !!(s && !s.$stable || a !== n && !a.$stable || s && t.$scopedSlots.$key !== s.$key),
                c = !!(o || t.$options._renderChildren || l);
              t.$options._parentVnode = i, t.$vnode = i, t._vnode && (t._vnode.parent = i);
              if (t.$options._renderChildren = o, t.$attrs = i.data.attrs || n, t.$listeners = r || n, e && t
                .$options.props) {
                St(!1);
                for (var h = t._props, u = t.$options._propKeys || [], d = 0; d < u.length; d++) {
                  var p = u[d],
                    f = t.$options.props;
                  h[p] = It(p, f, e, t)
                }
                St(!0), t.$options.propsData = e
              }
              r = r || n;
              var g = t.$options._parentListeners;
              t.$options._parentListeners = r, Ze(t, r, g), c && (t.$slots = pe(o, i.context), t.$forceUpdate());
              0
            }(e.componentInstance = t.componentInstance, r.propsData, r.listeners, e, r.children)
          },
          insert: function(t) {
            var e, n = t.context,
              r = t.componentInstance;
            r._isMounted || (r._isMounted = !0, nn(r, "mounted")), t.data.keepAlive && (n._isMounted ? ((e =
              r)._inactive = !1, on.push(e)) : en(r, !0))
          },
          destroy: function(t) {
            var e = t.componentInstance;
            e._isDestroyed || (t.data.keepAlive ? function t(e, n) {
              if (n && (e._directInactive = !0, tn(e))) return;
              if (!e._inactive) {
                e._inactive = !0;
                for (var r = 0; r < e.$children.length; r++) t(e.$children[r]);
                nn(e, "deactivated")
              }
            }(e, !0) : e.$destroy())
          }
        },
        $e = Object.keys(Fe);

      function Be(t, e, s, l, c) {
        if (!r(t)) {
          var h = s.$options._base;
          if (a(t) && (t = h.extend(t)), "function" == typeof t) {
            var u;
            if (r(t.cid) && void 0 === (t = function(t, e) {
                if (o(t.error) && i(t.errorComp)) return t.errorComp;
                if (i(t.resolved)) return t.resolved;
                var n = Ge;
                n && i(t.owners) && -1 === t.owners.indexOf(n) && t.owners.push(n);
                if (o(t.loading) && i(t.loadingComp)) return t.loadingComp;
                if (n && !i(t.owners)) {
                  var s = t.owners = [n],
                    l = !0,
                    c = null,
                    h = null;
                  n.$on("hook:destroyed", function() {
                    return y(s, n)
                  });
                  var u = function(t) {
                      for (var e = 0, n = s.length; e < n; e++) s[e].$forceUpdate();
                      t && (s.length = 0, null !== c && (clearTimeout(c), c = null), null !== h && (
                        clearTimeout(h), h = null))
                    },
                    p = F(function(n) {
                      t.resolved = Ue(n, e), l ? s.length = 0 : u(!0)
                    }),
                    f = F(function(e) {
                      i(t.errorComp) && (t.error = !0, u(!0))
                    }),
                    g = t(p, f);
                  return a(g) && (d(g) ? r(t.resolved) && g.then(p, f) : d(g.component) && (g.component.then(
                    p, f), i(g.error) && (t.errorComp = Ue(g.error, e)), i(g.loading) && (t.loadingComp =
                    Ue(g.loading, e), 0 === g.delay ? t.loading = !0 : c = setTimeout(function() {
                      c = null, r(t.resolved) && r(t.error) && (t.loading = !0, u(!1))
                    }, g.delay || 200)), i(g.timeout) && (h = setTimeout(function() {
                    h = null, r(t.resolved) && f(null)
                  }, g.timeout)))), l = !1, t.loading ? t.loadingComp : t.resolved
                }
              }(u = t, h))) return function(t, e, n, r, i) {
              var o = yt();
              return o.asyncFactory = t, o.asyncMeta = {
                data: e,
                context: n,
                children: r,
                tag: i
              }, o
            }(u, e, s, l, c);
            e = e || {}, Sn(t), i(e.model) && function(t, e) {
              var n = t.model && t.model.prop || "value",
                r = t.model && t.model.event || "input";
              (e.attrs || (e.attrs = {}))[n] = e.model.value;
              var o = e.on || (e.on = {}),
                s = o[r],
                a = e.model.callback;
              i(s) ? (Array.isArray(s) ? -1 === s.indexOf(a) : s !== a) && (o[r] = [a].concat(s)) : o[r] = a
            }(t.options, e);
            var p = function(t, e, n) {
              var o = e.options.props;
              if (!r(o)) {
                var s = {},
                  a = t.attrs,
                  l = t.props;
                if (i(a) || i(l))
                  for (var c in o) {
                    var h = M(c);
                    ce(s, l, c, h, !0) || ce(s, a, c, h, !1)
                  }
                return s
              }
            }(e, t);
            if (o(t.options.functional)) return function(t, e, r, o, s) {
              var a = t.options,
                l = {},
                c = a.props;
              if (i(c))
                for (var h in c) l[h] = It(h, c, e || n);
              else i(r.attrs) && Ne(l, r.attrs), i(r.props) && Ne(l, r.props);
              var u = new je(r, l, s, o, t),
                d = a.render.call(null, u._c, u);
              if (d instanceof mt) return Le(d, r, u.parent, a);
              if (Array.isArray(d)) {
                for (var p = he(d) || [], f = new Array(p.length), g = 0; g < p.length; g++) f[g] = Le(p[g],
                  r, u.parent, a);
                return f
              }
            }(t, p, e, s, l);
            var f = e.on;
            if (e.on = e.nativeOn, o(t.options.abstract)) {
              var g = e.slot;
              e = {}, g && (e.slot = g)
            }! function(t) {
              for (var e = t.hook || (t.hook = {}), n = 0; n < $e.length; n++) {
                var r = $e[n],
                  i = e[r],
                  o = Fe[r];
                i === o || i && i._merged || (e[r] = i ? Ie(o, i) : o)
              }
            }(e);
            var m = t.options.name || c;
            return new mt("vue-component-" + t.cid + (m ? "-" + m : ""), e, void 0, void 0, void 0, s, {
              Ctor: t,
              propsData: p,
              listeners: f,
              tag: c,
              children: l
            }, u)
          }
        }
      }

      function Ie(t, e) {
        var n = function(n, r) {
          t(n, r), e(n, r)
        };
        return n._merged = !0, n
      }
      var ze = 1,
        Re = 2;

      function Ve(t, e, n, l, c, h) {
        return (Array.isArray(n) || s(n)) && (c = l, l = n, n = void 0), o(h) && (c = Re),
          function(t, e, n, s, l) {
            if (i(n) && i(n.__ob__)) return yt();
            i(n) && i(n.is) && (e = n.is);
            if (!e) return yt();
            0;
            Array.isArray(s) && "function" == typeof s[0] && ((n = n || {}).scopedSlots = {
              default: s[0]
            }, s.length = 0);
            l === Re ? s = he(s) : l === ze && (s = function(t) {
              for (var e = 0; e < t.length; e++)
                if (Array.isArray(t[e])) return Array.prototype.concat.apply([], t);
              return t
            }(s));
            var c, h;
            if ("string" == typeof e) {
              var u;
              h = t.$vnode && t.$vnode.ns || z.getTagNamespace(e), c = z.isReservedTag(e) ? new mt(z.parsePlatformTagName(
                e), n, s, void 0, void 0, t) : n && n.pre || !i(u = Bt(t.$options, "components", e)) ? new mt(
                e, n, s, void 0, void 0, t) : Be(u, n, t, s, e)
            } else c = Be(e, n, t, s);
            return Array.isArray(c) ? c : i(c) ? (i(h) && function t(e, n, s) {
              e.ns = n;
              "foreignObject" === e.tag && (n = void 0, s = !0);
              if (i(e.children))
                for (var a = 0, l = e.children.length; a < l; a++) {
                  var c = e.children[a];
                  i(c.tag) && (r(c.ns) || o(s) && "svg" !== c.tag) && t(c, n, s)
                }
            }(c, h), i(n) && function(t) {
              a(t.style) && ie(t.style);
              a(t.class) && ie(t.class)
            }(n), c) : yt()
          }(t, e, n, l, c)
      }
      var He, Ge = null;

      function Ue(t, e) {
        return (t.__esModule || ct && "Module" === t[Symbol.toStringTag]) && (t = t.default), a(t) ? e.extend(t) :
          t
      }

      function qe(t) {
        return t.isComment && t.asyncFactory
      }

      function We(t) {
        if (Array.isArray(t))
          for (var e = 0; e < t.length; e++) {
            var n = t[e];
            if (i(n) && (i(n.componentOptions) || qe(n))) return n
          }
      }

      function Xe(t, e) {
        He.$on(t, e)
      }

      function Ye(t, e) {
        He.$off(t, e)
      }

      function Je(t, e) {
        var n = He;
        return function r() {
          null !== e.apply(null, arguments) && n.$off(t, r)
        }
      }

      function Ze(t, e, n) {
        He = t, ae(e, n || {}, Xe, Ye, Je, t), He = void 0
      }
      var Ke = null;

      function Qe(t) {
        var e = Ke;
        return Ke = t,
          function() {
            Ke = e
          }
      }

      function tn(t) {
        for (; t && (t = t.$parent);)
          if (t._inactive) return !0;
        return !1
      }

      function en(t, e) {
        if (e) {
          if (t._directInactive = !1, tn(t)) return
        } else if (t._directInactive) return;
        if (t._inactive || null === t._inactive) {
          t._inactive = !1;
          for (var n = 0; n < t.$children.length; n++) en(t.$children[n]);
          nn(t, "activated")
        }
      }

      function nn(t, e) {
        ft();
        var n = t.$options[e],
          r = e + " hook";
        if (n)
          for (var i = 0, o = n.length; i < o; i++) Gt(n[i], t, null, t, r);
        t._hasHookEvent && t.$emit("hook:" + e), gt()
      }
      var rn = [],
        on = [],
        sn = {},
        an = !1,
        ln = !1,
        cn = 0;
      var hn = 0,
        un = Date.now;
      if (W && !Z) {
        var dn = window.performance;
        dn && "function" == typeof dn.now && un() > document.createEvent("Event").timeStamp && (un = function() {
          return dn.now()
        })
      }

      function pn() {
        var t, e;
        for (hn = un(), ln = !0, rn.sort(function(t, e) {
            return t.id - e.id
          }), cn = 0; cn < rn.length; cn++)(t = rn[cn]).before && t.before(), e = t.id, sn[e] = null, t.run();
        var n = on.slice(),
          r = rn.slice();
        cn = rn.length = on.length = 0, sn = {}, an = ln = !1,
          function(t) {
            for (var e = 0; e < t.length; e++) t[e]._inactive = !0, en(t[e], !0)
          }(n),
          function(t) {
            var e = t.length;
            for (; e--;) {
              var n = t[e],
                r = n.vm;
              r._watcher === n && r._isMounted && !r._isDestroyed && nn(r, "updated")
            }
          }(r), st && z.devtools && st.emit("flush")
      }
      var fn = 0,
        gn = function(t, e, n, r, i) {
          this.vm = t, i && (t._watcher = this), t._watchers.push(this), r ? (this.deep = !!r.deep, this.user = !
              !r.user, this.lazy = !!r.lazy, this.sync = !!r.sync, this.before = r.before) : this.deep = this.user =
            this.lazy = this.sync = !1, this.cb = n, this.id = ++fn, this.active = !0, this.dirty = this.lazy,
            this.deps = [], this.newDeps = [], this.depIds = new lt, this.newDepIds = new lt, this.expression =
            "", "function" == typeof e ? this.getter = e : (this.getter = function(t) {
              if (!G.test(t)) {
                var e = t.split(".");
                return function(t) {
                  for (var n = 0; n < e.length; n++) {
                    if (!t) return;
                    t = t[e[n]]
                  }
                  return t
                }
              }
            }(e), this.getter || (this.getter = T)), this.value = this.lazy ? void 0 : this.get()
        };
      gn.prototype.get = function() {
        var t;
        ft(this);
        var e = this.vm;
        try {
          t = this.getter.call(e, e)
        } catch (t) {
          if (!this.user) throw t;
          Ht(t, e, 'getter for watcher "' + this.expression + '"')
        } finally {
          this.deep && ie(t), gt(), this.cleanupDeps()
        }
        return t
      }, gn.prototype.addDep = function(t) {
        var e = t.id;
        this.newDepIds.has(e) || (this.newDepIds.add(e), this.newDeps.push(t), this.depIds.has(e) || t.addSub(
          this))
      }, gn.prototype.cleanupDeps = function() {
        for (var t = this.deps.length; t--;) {
          var e = this.deps[t];
          this.newDepIds.has(e.id) || e.removeSub(this)
        }
        var n = this.depIds;
        this.depIds = this.newDepIds, this.newDepIds = n, this.newDepIds.clear(), n = this.deps, this.deps =
          this.newDeps, this.newDeps = n, this.newDeps.length = 0
      }, gn.prototype.update = function() {
        this.lazy ? this.dirty = !0 : this.sync ? this.run() : function(t) {
          var e = t.id;
          if (null == sn[e]) {
            if (sn[e] = !0, ln) {
              for (var n = rn.length - 1; n > cn && rn[n].id > t.id;) n--;
              rn.splice(n + 1, 0, t)
            } else rn.push(t);
            an || (an = !0, ne(pn))
          }
        }(this)
      }, gn.prototype.run = function() {
        if (this.active) {
          var t = this.get();
          if (t !== this.value || a(t) || this.deep) {
            var e = this.value;
            if (this.value = t, this.user) try {
              this.cb.call(this.vm, t, e)
            } catch (t) {
              Ht(t, this.vm, 'callback for watcher "' + this.expression + '"')
            } else this.cb.call(this.vm, t, e)
          }
        }
      }, gn.prototype.evaluate = function() {
        this.value = this.get(), this.dirty = !1
      }, gn.prototype.depend = function() {
        for (var t = this.deps.length; t--;) this.deps[t].depend()
      }, gn.prototype.teardown = function() {
        if (this.active) {
          this.vm._isBeingDestroyed || y(this.vm._watchers, this);
          for (var t = this.deps.length; t--;) this.deps[t].removeSub(this);
          this.active = !1
        }
      };
      var mn = {
        enumerable: !0,
        configurable: !0,
        get: T,
        set: T
      };

      function vn(t, e, n) {
        mn.get = function() {
          return this[e][n]
        }, mn.set = function(t) {
          this[e][n] = t
        }, Object.defineProperty(t, n, mn)
      }

      function yn(t) {
        t._watchers = [];
        var e = t.$options;
        e.props && function(t, e) {
          var n = t.$options.propsData || {},
            r = t._props = {},
            i = t.$options._propKeys = [],
            o = !t.$parent;
          o || St(!1);
          var s = function(o) {
            i.push(o);
            var s = It(o, e, n, t);
            Ot(r, o, s), o in t || vn(t, "_props", o)
          };
          for (var a in e) s(a);
          St(!0)
        }(t, e.props), e.methods && function(t, e) {
          t.$options.props;
          for (var n in e) t[n] = "function" != typeof e[n] ? T : k(e[n], t)
        }(t, e.methods), e.data ? function(t) {
          var e = t.$options.data;
          c(e = t._data = "function" == typeof e ? function(t, e) {
            ft();
            try {
              return t.call(e, e)
            } catch (t) {
              return Ht(t, e, "data()"), {}
            } finally {
              gt()
            }
          }(e, t) : e || {}) || (e = {});
          var n = Object.keys(e),
            r = t.$options.props,
            i = (t.$options.methods, n.length);
          for (; i--;) {
            var o = n[i];
            0, r && C(r, o) || V(o) || vn(t, "_data", o)
          }
          kt(e, !0)
        }(t) : kt(t._data = {}, !0), e.computed && function(t, e) {
          var n = t._computedWatchers = Object.create(null),
            r = ot();
          for (var i in e) {
            var o = e[i],
              s = "function" == typeof o ? o : o.get;
            0, r || (n[i] = new gn(t, s || T, T, bn)), i in t || Cn(t, i, o)
          }
        }(t, e.computed), e.watch && e.watch !== nt && function(t, e) {
          for (var n in e) {
            var r = e[n];
            if (Array.isArray(r))
              for (var i = 0; i < r.length; i++) An(t, n, r[i]);
            else An(t, n, r)
          }
        }(t, e.watch)
      }
      var bn = {
        lazy: !0
      };

      function Cn(t, e, n) {
        var r = !ot();
        "function" == typeof n ? (mn.get = r ? xn(e) : wn(n), mn.set = T) : (mn.get = n.get ? r && !1 !== n.cache ?
          xn(e) : wn(n.get) : T, mn.set = n.set || T), Object.defineProperty(t, e, mn)
      }

      function xn(t) {
        return function() {
          var e = this._computedWatchers && this._computedWatchers[t];
          if (e) return e.dirty && e.evaluate(), dt.target && e.depend(), e.value
        }
      }

      function wn(t) {
        return function() {
          return t.call(this, this)
        }
      }

      function An(t, e, n, r) {
        return c(n) && (r = n, n = n.handler), "string" == typeof n && (n = t[n]), t.$watch(e, n, r)
      }
      var En = 0;

      function Sn(t) {
        var e = t.options;
        if (t.super) {
          var n = Sn(t.super);
          if (n !== t.superOptions) {
            t.superOptions = n;
            var r = function(t) {
              var e, n = t.options,
                r = t.sealedOptions;
              for (var i in n) n[i] !== r[i] && (e || (e = {}), e[i] = n[i]);
              return e
            }(t);
            r && P(t.extendOptions, r), (e = t.options = $t(n, t.extendOptions)).name && (e.components[e.name] =
              t)
          }
        }
        return e
      }

      function Mn(t) {
        this._init(t)
      }

      function kn(t) {
        t.cid = 0;
        var e = 1;
        t.extend = function(t) {
          t = t || {};
          var n = this,
            r = n.cid,
            i = t._Ctor || (t._Ctor = {});
          if (i[r]) return i[r];
          var o = t.name || n.options.name;
          var s = function(t) {
            this._init(t)
          };
          return (s.prototype = Object.create(n.prototype)).constructor = s, s.cid = e++, s.options = $t(n.options,
              t), s.super = n, s.options.props && function(t) {
              var e = t.options.props;
              for (var n in e) vn(t.prototype, "_props", n)
            }(s), s.options.computed && function(t) {
              var e = t.options.computed;
              for (var n in e) Cn(t.prototype, n, e[n])
            }(s), s.extend = n.extend, s.mixin = n.mixin, s.use = n.use, B.forEach(function(t) {
              s[t] = n[t]
            }), o && (s.options.components[o] = s), s.superOptions = n.options, s.extendOptions = t, s.sealedOptions =
            P({}, s.options), i[r] = s, s
        }
      }

      function On(t) {
        return t && (t.Ctor.options.name || t.tag)
      }

      function Pn(t, e) {
        return Array.isArray(t) ? t.indexOf(e) > -1 : "string" == typeof t ? t.split(",").indexOf(e) > -1 : !!h(
          t) && t.test(e)
      }

      function Dn(t, e) {
        var n = t.cache,
          r = t.keys,
          i = t._vnode;
        for (var o in n) {
          var s = n[o];
          if (s) {
            var a = On(s.componentOptions);
            a && !e(a) && Tn(n, o, r, i)
          }
        }
      }

      function Tn(t, e, n, r) {
        var i = t[e];
        !i || r && i.tag === r.tag || i.componentInstance.$destroy(), t[e] = null, y(n, e)
      }! function(t) {
        t.prototype._init = function(t) {
          var e = this;
          e._uid = En++, e._isVue = !0, t && t._isComponent ? function(t, e) {
              var n = t.$options = Object.create(t.constructor.options),
                r = e._parentVnode;
              n.parent = e.parent, n._parentVnode = r;
              var i = r.componentOptions;
              n.propsData = i.propsData, n._parentListeners = i.listeners, n._renderChildren = i.children, n._componentTag =
                i.tag, e.render && (n.render = e.render, n.staticRenderFns = e.staticRenderFns)
            }(e, t) : e.$options = $t(Sn(e.constructor), t || {}, e), e._renderProxy = e, e._self = e,
            function(t) {
              var e = t.$options,
                n = e.parent;
              if (n && !e.abstract) {
                for (; n.$options.abstract && n.$parent;) n = n.$parent;
                n.$children.push(t)
              }
              t.$parent = n, t.$root = n ? n.$root : t, t.$children = [], t.$refs = {}, t._watcher = null, t._inactive =
                null, t._directInactive = !1, t._isMounted = !1, t._isDestroyed = !1, t._isBeingDestroyed = !
                1
            }(e),
            function(t) {
              t._events = Object.create(null), t._hasHookEvent = !1;
              var e = t.$options._parentListeners;
              e && Ze(t, e)
            }(e),
            function(t) {
              t._vnode = null, t._staticTrees = null;
              var e = t.$options,
                r = t.$vnode = e._parentVnode,
                i = r && r.context;
              t.$slots = pe(e._renderChildren, i), t.$scopedSlots = n, t._c = function(e, n, r, i) {
                return Ve(t, e, n, r, i, !1)
              }, t.$createElement = function(e, n, r, i) {
                return Ve(t, e, n, r, i, !0)
              };
              var o = r && r.data;
              Ot(t, "$attrs", o && o.attrs || n, null, !0), Ot(t, "$listeners", e._parentListeners || n, null,
                !0)
            }(e), nn(e, "beforeCreate"),
            function(t) {
              var e = de(t.$options.inject, t);
              e && (St(!1), Object.keys(e).forEach(function(n) {
                Ot(t, n, e[n])
              }), St(!0))
            }(e), yn(e),
            function(t) {
              var e = t.$options.provide;
              e && (t._provided = "function" == typeof e ? e.call(t) : e)
            }(e), nn(e, "created"), e.$options.el && e.$mount(e.$options.el)
        }
      }(Mn),
      function(t) {
        var e = {
            get: function() {
              return this._data
            }
          },
          n = {
            get: function() {
              return this._props
            }
          };
        Object.defineProperty(t.prototype, "$data", e), Object.defineProperty(t.prototype, "$props", n), t.prototype
          .$set = Pt, t.prototype.$delete = Dt, t.prototype.$watch = function(t, e, n) {
            if (c(e)) return An(this, t, e, n);
            (n = n || {}).user = !0;
            var r = new gn(this, t, e, n);
            if (n.immediate) try {
              e.call(this, r.value)
            } catch (t) {
              Ht(t, this, 'callback for immediate watcher "' + r.expression + '"')
            }
            return function() {
              r.teardown()
            }
          }
      }(Mn),
      function(t) {
        var e = /^hook:/;
        t.prototype.$on = function(t, n) {
          var r = this;
          if (Array.isArray(t))
            for (var i = 0, o = t.length; i < o; i++) r.$on(t[i], n);
          else(r._events[t] || (r._events[t] = [])).push(n), e.test(t) && (r._hasHookEvent = !0);
          return r
        }, t.prototype.$once = function(t, e) {
          var n = this;

          function r() {
            n.$off(t, r), e.apply(n, arguments)
          }
          return r.fn = e, n.$on(t, r), n
        }, t.prototype.$off = function(t, e) {
          var n = this;
          if (!arguments.length) return n._events = Object.create(null), n;
          if (Array.isArray(t)) {
            for (var r = 0, i = t.length; r < i; r++) n.$off(t[r], e);
            return n
          }
          var o, s = n._events[t];
          if (!s) return n;
          if (!e) return n._events[t] = null, n;
          for (var a = s.length; a--;)
            if ((o = s[a]) === e || o.fn === e) {
              s.splice(a, 1);
              break
            } return n
        }, t.prototype.$emit = function(t) {
          var e = this,
            n = e._events[t];
          if (n) {
            n = n.length > 1 ? O(n) : n;
            for (var r = O(arguments, 1), i = 'event handler for "' + t + '"', o = 0, s = n.length; o < s; o++)
              Gt(n[o], e, r, e, i)
          }
          return e
        }
      }(Mn),
      function(t) {
        t.prototype._update = function(t, e) {
          var n = this,
            r = n.$el,
            i = n._vnode,
            o = Qe(n);
          n._vnode = t, n.$el = i ? n.__patch__(i, t) : n.__patch__(n.$el, t, e, !1), o(), r && (r.__vue__ =
              null), n.$el && (n.$el.__vue__ = n), n.$vnode && n.$parent && n.$vnode === n.$parent._vnode &&
            (n.$parent.$el = n.$el)
        }, t.prototype.$forceUpdate = function() {
          this._watcher && this._watcher.update()
        }, t.prototype.$destroy = function() {
          var t = this;
          if (!t._isBeingDestroyed) {
            nn(t, "beforeDestroy"), t._isBeingDestroyed = !0;
            var e = t.$parent;
            !e || e._isBeingDestroyed || t.$options.abstract || y(e.$children, t), t._watcher && t._watcher.teardown();
            for (var n = t._watchers.length; n--;) t._watchers[n].teardown();
            t._data.__ob__ && t._data.__ob__.vmCount--, t._isDestroyed = !0, t.__patch__(t._vnode, null), nn(
              t, "destroyed"), t.$off(), t.$el && (t.$el.__vue__ = null), t.$vnode && (t.$vnode.parent =
              null)
          }
        }
      }(Mn),
      function(t) {
        _e(t.prototype), t.prototype.$nextTick = function(t) {
          return ne(t, this)
        }, t.prototype._render = function() {
          var t, e = this,
            n = e.$options,
            r = n.render,
            i = n._parentVnode;
          i && (e.$scopedSlots = ge(i.data.scopedSlots, e.$slots, e.$scopedSlots)), e.$vnode = i;
          try {
            Ge = e, t = r.call(e._renderProxy, e.$createElement)
          } catch (n) {
            Ht(n, e, "render"), t = e._vnode
          } finally {
            Ge = null
          }
          return Array.isArray(t) && 1 === t.length && (t = t[0]), t instanceof mt || (t = yt()), t.parent =
            i, t
        }
      }(Mn);
      var _n = [String, RegExp, Array],
        jn = {
          KeepAlive: {
            name: "keep-alive",
            abstract: !0,
            props: {
              include: _n,
              exclude: _n,
              max: [String, Number]
            },
            created: function() {
              this.cache = Object.create(null), this.keys = []
            },
            destroyed: function() {
              for (var t in this.cache) Tn(this.cache, t, this.keys)
            },
            mounted: function() {
              var t = this;
              this.$watch("include", function(e) {
                Dn(t, function(t) {
                  return Pn(e, t)
                })
              }), this.$watch("exclude", function(e) {
                Dn(t, function(t) {
                  return !Pn(e, t)
                })
              })
            },
            render: function() {
              var t = this.$slots.default,
                e = We(t),
                n = e && e.componentOptions;
              if (n) {
                var r = On(n),
                  i = this.include,
                  o = this.exclude;
                if (i && (!r || !Pn(i, r)) || o && r && Pn(o, r)) return e;
                var s = this.cache,
                  a = this.keys,
                  l = null == e.key ? n.Ctor.cid + (n.tag ? "::" + n.tag : "") : e.key;
                s[l] ? (e.componentInstance = s[l].componentInstance, y(a, l), a.push(l)) : (s[l] = e, a.push(
                    l), this.max && a.length > parseInt(this.max) && Tn(s, a[0], a, this._vnode)), e.data.keepAlive = !
                  0
              }
              return e || t && t[0]
            }
          }
        };
      ! function(t) {
        var e = {
          get: function() {
            return z
          }
        };
        Object.defineProperty(t, "config", e), t.util = {
            warn: ht,
            extend: P,
            mergeOptions: $t,
            defineReactive: Ot
          }, t.set = Pt, t.delete = Dt, t.nextTick = ne, t.observable = function(t) {
            return kt(t), t
          }, t.options = Object.create(null), B.forEach(function(e) {
            t.options[e + "s"] = Object.create(null)
          }), t.options._base = t, P(t.options.components, jn),
          function(t) {
            t.use = function(t) {
              var e = this._installedPlugins || (this._installedPlugins = []);
              if (e.indexOf(t) > -1) return this;
              var n = O(arguments, 1);
              return n.unshift(this), "function" == typeof t.install ? t.install.apply(t, n) : "function" ==
                typeof t && t.apply(null, n), e.push(t), this
            }
          }(t),
          function(t) {
            t.mixin = function(t) {
              return this.options = $t(this.options, t), this
            }
          }(t), kn(t),
          function(t) {
            B.forEach(function(e) {
              t[e] = function(t, n) {
                return n ? ("component" === e && c(n) && (n.name = n.name || t, n = this.options._base.extend(
                  n)), "directive" === e && "function" == typeof n && (n = {
                  bind: n,
                  update: n
                }), this.options[e + "s"][t] = n, n) : this.options[e + "s"][t]
              }
            })
          }(t)
      }(Mn), Object.defineProperty(Mn.prototype, "$isServer", {
        get: ot
      }), Object.defineProperty(Mn.prototype, "$ssrContext", {
        get: function() {
          return this.$vnode && this.$vnode.ssrContext
        }
      }), Object.defineProperty(Mn, "FunctionalRenderContext", {
        value: je
      }), Mn.version = "2.6.12";
      var Ln = g("style,class"),
        Nn = g("input,textarea,option,select,progress"),
        Fn = function(t, e, n) {
          return "value" === n && Nn(t) && "button" !== e || "selected" === n && "option" === t || "checked" ===
            n && "input" === t || "muted" === n && "video" === t
        },
        $n = g("contenteditable,draggable,spellcheck"),
        Bn = g("events,caret,typing,plaintext-only"),
        In = function(t, e) {
          return Gn(e) || "false" === e ? "false" : "contenteditable" === t && Bn(e) ? e : "true"
        },
        zn = g(
          "allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible"
        ),
        Rn = "http://www.w3.org/1999/xlink",
        Vn = function(t) {
          return ":" === t.charAt(5) && "xlink" === t.slice(0, 5)
        },
        Hn = function(t) {
          return Vn(t) ? t.slice(6, t.length) : ""
        },
        Gn = function(t) {
          return null == t || !1 === t
        };

      function Un(t) {
        for (var e = t.data, n = t, r = t; i(r.componentInstance);)(r = r.componentInstance._vnode) && r.data &&
          (e = qn(r.data, e));
        for (; i(n = n.parent);) n && n.data && (e = qn(e, n.data));
        return function(t, e) {
          if (i(t) || i(e)) return Wn(t, Xn(e));
          return ""
        }(e.staticClass, e.class)
      }

      function qn(t, e) {
        return {
          staticClass: Wn(t.staticClass, e.staticClass),
          class: i(t.class) ? [t.class, e.class] : e.class
        }
      }

      function Wn(t, e) {
        return t ? e ? t + " " + e : t : e || ""
      }

      function Xn(t) {
        return Array.isArray(t) ? function(t) {
          for (var e, n = "", r = 0, o = t.length; r < o; r++) i(e = Xn(t[r])) && "" !== e && (n && (n += " "),
            n += e);
          return n
        }(t) : a(t) ? function(t) {
          var e = "";
          for (var n in t) t[n] && (e && (e += " "), e += n);
          return e
        }(t) : "string" == typeof t ? t : ""
      }
      var Yn = {
          svg: "http://www.w3.org/2000/svg",
          math: "http://www.w3.org/1998/Math/MathML"
        },
        Jn = g(
          "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"
        ),
        Zn = g(
          "svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",
          !0),
        Kn = function(t) {
          return Jn(t) || Zn(t)
        };

      function Qn(t) {
        return Zn(t) ? "svg" : "math" === t ? "math" : void 0
      }
      var tr = Object.create(null);
      var er = g("text,number,password,search,email,tel,url");

      function nr(t) {
        if ("string" == typeof t) {
          var e = document.querySelector(t);
          return e || document.createElement("div")
        }
        return t
      }
      var rr = Object.freeze({
          createElement: function(t, e) {
            var n = document.createElement(t);
            return "select" !== t ? n : (e.data && e.data.attrs && void 0 !== e.data.attrs.multiple && n.setAttribute(
              "multiple", "multiple"), n)
          },
          createElementNS: function(t, e) {
            return document.createElementNS(Yn[t], e)
          },
          createTextNode: function(t) {
            return document.createTextNode(t)
          },
          createComment: function(t) {
            return document.createComment(t)
          },
          insertBefore: function(t, e, n) {
            t.insertBefore(e, n)
          },
          removeChild: function(t, e) {
            t.removeChild(e)
          },
          appendChild: function(t, e) {
            t.appendChild(e)
          },
          parentNode: function(t) {
            return t.parentNode
          },
          nextSibling: function(t) {
            return t.nextSibling
          },
          tagName: function(t) {
            return t.tagName
          },
          setTextContent: function(t, e) {
            t.textContent = e
          },
          setStyleScope: function(t, e) {
            t.setAttribute(e, "")
          }
        }),
        ir = {
          create: function(t, e) {
            or(e)
          },
          update: function(t, e) {
            t.data.ref !== e.data.ref && (or(t, !0), or(e))
          },
          destroy: function(t) {
            or(t, !0)
          }
        };

      function or(t, e) {
        var n = t.data.ref;
        if (i(n)) {
          var r = t.context,
            o = t.componentInstance || t.elm,
            s = r.$refs;
          e ? Array.isArray(s[n]) ? y(s[n], o) : s[n] === o && (s[n] = void 0) : t.data.refInFor ? Array.isArray(
            s[n]) ? s[n].indexOf(o) < 0 && s[n].push(o) : s[n] = [o] : s[n] = o
        }
      }
      var sr = new mt("", {}, []),
        ar = ["create", "activate", "update", "remove", "destroy"];

      function lr(t, e) {
        return t.key === e.key && (t.tag === e.tag && t.isComment === e.isComment && i(t.data) === i(e.data) &&
          function(t, e) {
            if ("input" !== t.tag) return !0;
            var n, r = i(n = t.data) && i(n = n.attrs) && n.type,
              o = i(n = e.data) && i(n = n.attrs) && n.type;
            return r === o || er(r) && er(o)
          }(t, e) || o(t.isAsyncPlaceholder) && t.asyncFactory === e.asyncFactory && r(e.asyncFactory.error))
      }

      function cr(t, e, n) {
        var r, o, s = {};
        for (r = e; r <= n; ++r) i(o = t[r].key) && (s[o] = r);
        return s
      }
      var hr = {
        create: ur,
        update: ur,
        destroy: function(t) {
          ur(t, sr)
        }
      };

      function ur(t, e) {
        (t.data.directives || e.data.directives) && function(t, e) {
          var n, r, i, o = t === sr,
            s = e === sr,
            a = pr(t.data.directives, t.context),
            l = pr(e.data.directives, e.context),
            c = [],
            h = [];
          for (n in l) r = a[n], i = l[n], r ? (i.oldValue = r.value, i.oldArg = r.arg, gr(i, "update", e, t),
            i.def && i.def.componentUpdated && h.push(i)) : (gr(i, "bind", e, t), i.def && i.def.inserted &&
            c.push(i));
          if (c.length) {
            var u = function() {
              for (var n = 0; n < c.length; n++) gr(c[n], "inserted", e, t)
            };
            o ? le(e, "insert", u) : u()
          }
          h.length && le(e, "postpatch", function() {
            for (var n = 0; n < h.length; n++) gr(h[n], "componentUpdated", e, t)
          });
          if (!o)
            for (n in a) l[n] || gr(a[n], "unbind", t, t, s)
        }(t, e)
      }
      var dr = Object.create(null);

      function pr(t, e) {
        var n, r, i = Object.create(null);
        if (!t) return i;
        for (n = 0; n < t.length; n++)(r = t[n]).modifiers || (r.modifiers = dr), i[fr(r)] = r, r.def = Bt(e.$options,
          "directives", r.name);
        return i
      }

      function fr(t) {
        return t.rawName || t.name + "." + Object.keys(t.modifiers || {}).join(".")
      }

      function gr(t, e, n, r, i) {
        var o = t.def && t.def[e];
        if (o) try {
          o(n.elm, t, n, r, i)
        } catch (r) {
          Ht(r, n.context, "directive " + t.name + " " + e + " hook")
        }
      }
      var mr = [ir, hr];

      function vr(t, e) {
        var n = e.componentOptions;
        if (!(i(n) && !1 === n.Ctor.options.inheritAttrs || r(t.data.attrs) && r(e.data.attrs))) {
          var o, s, a = e.elm,
            l = t.data.attrs || {},
            c = e.data.attrs || {};
          for (o in i(c.__ob__) && (c = e.data.attrs = P({}, c)), c) s = c[o], l[o] !== s && yr(a, o, s);
          for (o in (Z || Q) && c.value !== l.value && yr(a, "value", c.value), l) r(c[o]) && (Vn(o) ? a.removeAttributeNS(
            Rn, Hn(o)) : $n(o) || a.removeAttribute(o))
        }
      }

      function yr(t, e, n) {
        t.tagName.indexOf("-") > -1 ? br(t, e, n) : zn(e) ? Gn(n) ? t.removeAttribute(e) : (n =
          "allowfullscreen" === e && "EMBED" === t.tagName ? "true" : e, t.setAttribute(e, n)) : $n(e) ? t.setAttribute(
          e, In(e, n)) : Vn(e) ? Gn(n) ? t.removeAttributeNS(Rn, Hn(e)) : t.setAttributeNS(Rn, e, n) : br(t,
          e, n)
      }

      function br(t, e, n) {
        if (Gn(n)) t.removeAttribute(e);
        else {
          if (Z && !K && "TEXTAREA" === t.tagName && "placeholder" === e && "" !== n && !t.__ieph) {
            var r = function(e) {
              e.stopImmediatePropagation(), t.removeEventListener("input", r)
            };
            t.addEventListener("input", r), t.__ieph = !0
          }
          t.setAttribute(e, n)
        }
      }
      var Cr = {
        create: vr,
        update: vr
      };

      function xr(t, e) {
        var n = e.elm,
          o = e.data,
          s = t.data;
        if (!(r(o.staticClass) && r(o.class) && (r(s) || r(s.staticClass) && r(s.class)))) {
          var a = Un(e),
            l = n._transitionClasses;
          i(l) && (a = Wn(a, Xn(l))), a !== n._prevClass && (n.setAttribute("class", a), n._prevClass = a)
        }
      }
      var wr, Ar, Er, Sr, Mr, kr, Or = {
          create: xr,
          update: xr
        },
        Pr = /[\w).+\-_$\]]/;

      function Dr(t) {
        var e, n, r, i, o, s = !1,
          a = !1,
          l = !1,
          c = !1,
          h = 0,
          u = 0,
          d = 0,
          p = 0;
        for (r = 0; r < t.length; r++)
          if (n = e, e = t.charCodeAt(r), s) 39 === e && 92 !== n && (s = !1);
          else if (a) 34 === e && 92 !== n && (a = !1);
        else if (l) 96 === e && 92 !== n && (l = !1);
        else if (c) 47 === e && 92 !== n && (c = !1);
        else if (124 !== e || 124 === t.charCodeAt(r + 1) || 124 === t.charCodeAt(r - 1) || h || u || d) {
          switch (e) {
            case 34:
              a = !0;
              break;
            case 39:
              s = !0;
              break;
            case 96:
              l = !0;
              break;
            case 40:
              d++;
              break;
            case 41:
              d--;
              break;
            case 91:
              u++;
              break;
            case 93:
              u--;
              break;
            case 123:
              h++;
              break;
            case 125:
              h--
          }
          if (47 === e) {
            for (var f = r - 1, g = void 0; f >= 0 && " " === (g = t.charAt(f)); f--);
            g && Pr.test(g) || (c = !0)
          }
        } else void 0 === i ? (p = r + 1, i = t.slice(0, r).trim()) : m();

        function m() {
          (o || (o = [])).push(t.slice(p, r).trim()), p = r + 1
        }
        if (void 0 === i ? i = t.slice(0, r).trim() : 0 !== p && m(), o)
          for (r = 0; r < o.length; r++) i = Tr(i, o[r]);
        return i
      }

      function Tr(t, e) {
        var n = e.indexOf("(");
        if (n < 0) return '_f("' + e + '")(' + t + ")";
        var r = e.slice(0, n),
          i = e.slice(n + 1);
        return '_f("' + r + '")(' + t + (")" !== i ? "," + i : i)
      }

      function _r(t, e) {
        console.error("[Vue compiler]: " + t)
      }

      function jr(t, e) {
        return t ? t.map(function(t) {
          return t[e]
        }).filter(function(t) {
          return t
        }) : []
      }

      function Lr(t, e, n, r, i) {
        (t.props || (t.props = [])).push(Gr({
          name: e,
          value: n,
          dynamic: i
        }, r)), t.plain = !1
      }

      function Nr(t, e, n, r, i) {
        (i ? t.dynamicAttrs || (t.dynamicAttrs = []) : t.attrs || (t.attrs = [])).push(Gr({
          name: e,
          value: n,
          dynamic: i
        }, r)), t.plain = !1
      }

      function Fr(t, e, n, r) {
        t.attrsMap[e] = n, t.attrsList.push(Gr({
          name: e,
          value: n
        }, r))
      }

      function $r(t, e, n, r, i, o, s, a) {
        (t.directives || (t.directives = [])).push(Gr({
          name: e,
          rawName: n,
          value: r,
          arg: i,
          isDynamicArg: o,
          modifiers: s
        }, a)), t.plain = !1
      }

      function Br(t, e, n) {
        return n ? "_p(" + e + ',"' + t + '")' : t + e
      }

      function Ir(t, e, r, i, o, s, a, l) {
        var c;
        (i = i || n).right ? l ? e = "(" + e + ")==='click'?'contextmenu':(" + e + ")" : "click" === e && (e =
          "contextmenu", delete i.right) : i.middle && (l ? e = "(" + e + ")==='click'?'mouseup':(" + e + ")" :
          "click" === e && (e = "mouseup")), i.capture && (delete i.capture, e = Br("!", e, l)), i.once && (
          delete i.once, e = Br("~", e, l)), i.passive && (delete i.passive, e = Br("&", e, l)), i.native ? (
          delete i.native, c = t.nativeEvents || (t.nativeEvents = {})) : c = t.events || (t.events = {});
        var h = Gr({
          value: r.trim(),
          dynamic: l
        }, a);
        i !== n && (h.modifiers = i);
        var u = c[e];
        Array.isArray(u) ? o ? u.unshift(h) : u.push(h) : c[e] = u ? o ? [h, u] : [u, h] : h, t.plain = !1
      }

      function zr(t, e) {
        return t.rawAttrsMap[":" + e] || t.rawAttrsMap["v-bind:" + e] || t.rawAttrsMap[e]
      }

      function Rr(t, e, n) {
        var r = Vr(t, ":" + e) || Vr(t, "v-bind:" + e);
        if (null != r) return Dr(r);
        if (!1 !== n) {
          var i = Vr(t, e);
          if (null != i) return JSON.stringify(i)
        }
      }

      function Vr(t, e, n) {
        var r;
        if (null != (r = t.attrsMap[e]))
          for (var i = t.attrsList, o = 0, s = i.length; o < s; o++)
            if (i[o].name === e) {
              i.splice(o, 1);
              break
            } return n && delete t.attrsMap[e], r
      }

      function Hr(t, e) {
        for (var n = t.attrsList, r = 0, i = n.length; r < i; r++) {
          var o = n[r];
          if (e.test(o.name)) return n.splice(r, 1), o
        }
      }

      function Gr(t, e) {
        return e && (null != e.start && (t.start = e.start), null != e.end && (t.end = e.end)), t
      }

      function Ur(t, e, n) {
        var r = n || {},
          i = r.number,
          o = "$$v";
        r.trim && (o = "(typeof $$v === 'string'? $$v.trim(): $$v)"), i && (o = "_n(" + o + ")");
        var s = qr(e, o);
        t.model = {
          value: "(" + e + ")",
          expression: JSON.stringify(e),
          callback: "function ($$v) {" + s + "}"
        }
      }

      function qr(t, e) {
        var n = function(t) {
          if (t = t.trim(), wr = t.length, t.indexOf("[") < 0 || t.lastIndexOf("]") < wr - 1) return (Sr = t.lastIndexOf(
            ".")) > -1 ? {
            exp: t.slice(0, Sr),
            key: '"' + t.slice(Sr + 1) + '"'
          } : {
            exp: t,
            key: null
          };
          Ar = t, Sr = Mr = kr = 0;
          for (; !Xr();) Yr(Er = Wr()) ? Zr(Er) : 91 === Er && Jr(Er);
          return {
            exp: t.slice(0, Mr),
            key: t.slice(Mr + 1, kr)
          }
        }(t);
        return null === n.key ? t + "=" + e : "$set(" + n.exp + ", " + n.key + ", " + e + ")"
      }

      function Wr() {
        return Ar.charCodeAt(++Sr)
      }

      function Xr() {
        return Sr >= wr
      }

      function Yr(t) {
        return 34 === t || 39 === t
      }

      function Jr(t) {
        var e = 1;
        for (Mr = Sr; !Xr();)
          if (Yr(t = Wr())) Zr(t);
          else if (91 === t && e++, 93 === t && e--, 0 === e) {
          kr = Sr;
          break
        }
      }

      function Zr(t) {
        for (var e = t; !Xr() && (t = Wr()) !== e;);
      }
      var Kr, Qr = "__r",
        ti = "__c";

      function ei(t, e, n) {
        var r = Kr;
        return function i() {
          null !== e.apply(null, arguments) && ii(t, i, n, r)
        }
      }
      var ni = Xt && !(et && Number(et[1]) <= 53);

      function ri(t, e, n, r) {
        if (ni) {
          var i = hn,
            o = e;
          e = o._wrapper = function(t) {
            if (t.target === t.currentTarget || t.timeStamp >= i || t.timeStamp <= 0 || t.target.ownerDocument !==
              document) return o.apply(this, arguments)
          }
        }
        Kr.addEventListener(t, e, rt ? {
          capture: n,
          passive: r
        } : n)
      }

      function ii(t, e, n, r) {
        (r || Kr).removeEventListener(t, e._wrapper || e, n)
      }

      function oi(t, e) {
        if (!r(t.data.on) || !r(e.data.on)) {
          var n = e.data.on || {},
            o = t.data.on || {};
          Kr = e.elm,
            function(t) {
              if (i(t[Qr])) {
                var e = Z ? "change" : "input";
                t[e] = [].concat(t[Qr], t[e] || []), delete t[Qr]
              }
              i(t[ti]) && (t.change = [].concat(t[ti], t.change || []), delete t[ti])
            }(n), ae(n, o, ri, ii, ei, e.context), Kr = void 0
        }
      }
      var si, ai = {
        create: oi,
        update: oi
      };

      function li(t, e) {
        if (!r(t.data.domProps) || !r(e.data.domProps)) {
          var n, o, s = e.elm,
            a = t.data.domProps || {},
            l = e.data.domProps || {};
          for (n in i(l.__ob__) && (l = e.data.domProps = P({}, l)), a) n in l || (s[n] = "");
          for (n in l) {
            if (o = l[n], "textContent" === n || "innerHTML" === n) {
              if (e.children && (e.children.length = 0), o === a[n]) continue;
              1 === s.childNodes.length && s.removeChild(s.childNodes[0])
            }
            if ("value" === n && "PROGRESS" !== s.tagName) {
              s._value = o;
              var c = r(o) ? "" : String(o);
              ci(s, c) && (s.value = c)
            } else if ("innerHTML" === n && Zn(s.tagName) && r(s.innerHTML)) {
              (si = si || document.createElement("div")).innerHTML = "<svg>" + o + "</svg>";
              for (var h = si.firstChild; s.firstChild;) s.removeChild(s.firstChild);
              for (; h.firstChild;) s.appendChild(h.firstChild)
            } else if (o !== a[n]) try {
              s[n] = o
            } catch (t) {}
          }
        }
      }

      function ci(t, e) {
        return !t.composing && ("OPTION" === t.tagName || function(t, e) {
          var n = !0;
          try {
            n = document.activeElement !== t
          } catch (t) {}
          return n && t.value !== e
        }(t, e) || function(t, e) {
          var n = t.value,
            r = t._vModifiers;
          if (i(r)) {
            if (r.number) return f(n) !== f(e);
            if (r.trim) return n.trim() !== e.trim()
          }
          return n !== e
        }(t, e))
      }
      var hi = {
          create: li,
          update: li
        },
        ui = x(function(t) {
          var e = {},
            n = /:(.+)/;
          return t.split(/;(?![^(]*\))/g).forEach(function(t) {
            if (t) {
              var r = t.split(n);
              r.length > 1 && (e[r[0].trim()] = r[1].trim())
            }
          }), e
        });

      function di(t) {
        var e = pi(t.style);
        return t.staticStyle ? P(t.staticStyle, e) : e
      }

      function pi(t) {
        return Array.isArray(t) ? D(t) : "string" == typeof t ? ui(t) : t
      }
      var fi, gi = /^--/,
        mi = /\s*!important$/,
        vi = function(t, e, n) {
          if (gi.test(e)) t.style.setProperty(e, n);
          else if (mi.test(n)) t.style.setProperty(M(e), n.replace(mi, ""), "important");
          else {
            var r = bi(e);
            if (Array.isArray(n))
              for (var i = 0, o = n.length; i < o; i++) t.style[r] = n[i];
            else t.style[r] = n
          }
        },
        yi = ["Webkit", "Moz", "ms"],
        bi = x(function(t) {
          if (fi = fi || document.createElement("div").style, "filter" !== (t = A(t)) && t in fi) return t;
          for (var e = t.charAt(0).toUpperCase() + t.slice(1), n = 0; n < yi.length; n++) {
            var r = yi[n] + e;
            if (r in fi) return r
          }
        });

      function Ci(t, e) {
        var n = e.data,
          o = t.data;
        if (!(r(n.staticStyle) && r(n.style) && r(o.staticStyle) && r(o.style))) {
          var s, a, l = e.elm,
            c = o.staticStyle,
            h = o.normalizedStyle || o.style || {},
            u = c || h,
            d = pi(e.data.style) || {};
          e.data.normalizedStyle = i(d.__ob__) ? P({}, d) : d;
          var p = function(t, e) {
            var n, r = {};
            if (e)
              for (var i = t; i.componentInstance;)(i = i.componentInstance._vnode) && i.data && (n = di(i.data)) &&
                P(r, n);
            (n = di(t.data)) && P(r, n);
            for (var o = t; o = o.parent;) o.data && (n = di(o.data)) && P(r, n);
            return r
          }(e, !0);
          for (a in u) r(p[a]) && vi(l, a, "");
          for (a in p)(s = p[a]) !== u[a] && vi(l, a, null == s ? "" : s)
        }
      }
      var xi = {
          create: Ci,
          update: Ci
        },
        wi = /\s+/;

      function Ai(t, e) {
        if (e && (e = e.trim()))
          if (t.classList) e.indexOf(" ") > -1 ? e.split(wi).forEach(function(e) {
            return t.classList.add(e)
          }) : t.classList.add(e);
          else {
            var n = " " + (t.getAttribute("class") || "") + " ";
            n.indexOf(" " + e + " ") < 0 && t.setAttribute("class", (n + e).trim())
          }
      }

      function Ei(t, e) {
        if (e && (e = e.trim()))
          if (t.classList) e.indexOf(" ") > -1 ? e.split(wi).forEach(function(e) {
            return t.classList.remove(e)
          }) : t.classList.remove(e), t.classList.length || t.removeAttribute("class");
          else {
            for (var n = " " + (t.getAttribute("class") || "") + " ", r = " " + e + " "; n.indexOf(r) >= 0;) n =
              n.replace(r, " ");
            (n = n.trim()) ? t.setAttribute("class", n): t.removeAttribute("class")
          }
      }

      function Si(t) {
        if (t) {
          if ("object" == typeof t) {
            var e = {};
            return !1 !== t.css && P(e, Mi(t.name || "v")), P(e, t), e
          }
          return "string" == typeof t ? Mi(t) : void 0
        }
      }
      var Mi = x(function(t) {
          return {
            enterClass: t + "-enter",
            enterToClass: t + "-enter-to",
            enterActiveClass: t + "-enter-active",
            leaveClass: t + "-leave",
            leaveToClass: t + "-leave-to",
            leaveActiveClass: t + "-leave-active"
          }
        }),
        ki = W && !K,
        Oi = "transition",
        Pi = "animation",
        Di = "transition",
        Ti = "transitionend",
        _i = "animation",
        ji = "animationend";
      ki && (void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend && (Di =
          "WebkitTransition", Ti = "webkitTransitionEnd"), void 0 === window.onanimationend && void 0 !==
        window.onwebkitanimationend && (_i = "WebkitAnimation", ji = "webkitAnimationEnd"));
      var Li = W ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :
        function(t) {
          return t()
        };

      function Ni(t) {
        Li(function() {
          Li(t)
        })
      }

      function Fi(t, e) {
        var n = t._transitionClasses || (t._transitionClasses = []);
        n.indexOf(e) < 0 && (n.push(e), Ai(t, e))
      }

      function $i(t, e) {
        t._transitionClasses && y(t._transitionClasses, e), Ei(t, e)
      }

      function Bi(t, e, n) {
        var r = zi(t, e),
          i = r.type,
          o = r.timeout,
          s = r.propCount;
        if (!i) return n();
        var a = i === Oi ? Ti : ji,
          l = 0,
          c = function() {
            t.removeEventListener(a, h), n()
          },
          h = function(e) {
            e.target === t && ++l >= s && c()
          };
        setTimeout(function() {
          l < s && c()
        }, o + 1), t.addEventListener(a, h)
      }
      var Ii = /\b(transform|all)(,|$)/;

      function zi(t, e) {
        var n, r = window.getComputedStyle(t),
          i = (r[Di + "Delay"] || "").split(", "),
          o = (r[Di + "Duration"] || "").split(", "),
          s = Ri(i, o),
          a = (r[_i + "Delay"] || "").split(", "),
          l = (r[_i + "Duration"] || "").split(", "),
          c = Ri(a, l),
          h = 0,
          u = 0;
        return e === Oi ? s > 0 && (n = Oi, h = s, u = o.length) : e === Pi ? c > 0 && (n = Pi, h = c, u = l.length) :
          u = (n = (h = Math.max(s, c)) > 0 ? s > c ? Oi : Pi : null) ? n === Oi ? o.length : l.length : 0, {
            type: n,
            timeout: h,
            propCount: u,
            hasTransform: n === Oi && Ii.test(r[Di + "Property"])
          }
      }

      function Ri(t, e) {
        for (; t.length < e.length;) t = t.concat(t);
        return Math.max.apply(null, e.map(function(e, n) {
          return Vi(e) + Vi(t[n])
        }))
      }

      function Vi(t) {
        return 1e3 * Number(t.slice(0, -1).replace(",", "."))
      }

      function Hi(t, e) {
        var n = t.elm;
        i(n._leaveCb) && (n._leaveCb.cancelled = !0, n._leaveCb());
        var o = Si(t.data.transition);
        if (!r(o) && !i(n._enterCb) && 1 === n.nodeType) {
          for (var s = o.css, l = o.type, c = o.enterClass, h = o.enterToClass, u = o.enterActiveClass, d = o.appearClass,
              p = o.appearToClass, g = o.appearActiveClass, m = o.beforeEnter, v = o.enter, y = o.afterEnter, b =
              o.enterCancelled, C = o.beforeAppear, x = o.appear, w = o.afterAppear, A = o.appearCancelled, E =
              o.duration, S = Ke, M = Ke.$vnode; M && M.parent;) S = M.context, M = M.parent;
          var k = !S._isMounted || !t.isRootInsert;
          if (!k || x || "" === x) {
            var O = k && d ? d : c,
              P = k && g ? g : u,
              D = k && p ? p : h,
              T = k && C || m,
              _ = k && "function" == typeof x ? x : v,
              j = k && w || y,
              L = k && A || b,
              N = f(a(E) ? E.enter : E);
            0;
            var $ = !1 !== s && !K,
              B = qi(_),
              I = n._enterCb = F(function() {
                $ && ($i(n, D), $i(n, P)), I.cancelled ? ($ && $i(n, O), L && L(n)) : j && j(n), n._enterCb =
                  null
              });
            t.data.show || le(t, "insert", function() {
              var e = n.parentNode,
                r = e && e._pending && e._pending[t.key];
              r && r.tag === t.tag && r.elm._leaveCb && r.elm._leaveCb(), _ && _(n, I)
            }), T && T(n), $ && (Fi(n, O), Fi(n, P), Ni(function() {
              $i(n, O), I.cancelled || (Fi(n, D), B || (Ui(N) ? setTimeout(I, N) : Bi(n, l, I)))
            })), t.data.show && (e && e(), _ && _(n, I)), $ || B || I()
          }
        }
      }

      function Gi(t, e) {
        var n = t.elm;
        i(n._enterCb) && (n._enterCb.cancelled = !0, n._enterCb());
        var o = Si(t.data.transition);
        if (r(o) || 1 !== n.nodeType) return e();
        if (!i(n._leaveCb)) {
          var s = o.css,
            l = o.type,
            c = o.leaveClass,
            h = o.leaveToClass,
            u = o.leaveActiveClass,
            d = o.beforeLeave,
            p = o.leave,
            g = o.afterLeave,
            m = o.leaveCancelled,
            v = o.delayLeave,
            y = o.duration,
            b = !1 !== s && !K,
            C = qi(p),
            x = f(a(y) ? y.leave : y);
          0;
          var w = n._leaveCb = F(function() {
            n.parentNode && n.parentNode._pending && (n.parentNode._pending[t.key] = null), b && ($i(n, h),
              $i(n, u)), w.cancelled ? (b && $i(n, c), m && m(n)) : (e(), g && g(n)), n._leaveCb = null
          });
          v ? v(A) : A()
        }

        function A() {
          w.cancelled || (!t.data.show && n.parentNode && ((n.parentNode._pending || (n.parentNode._pending = {}))[
            t.key] = t), d && d(n), b && (Fi(n, c), Fi(n, u), Ni(function() {
            $i(n, c), w.cancelled || (Fi(n, h), C || (Ui(x) ? setTimeout(w, x) : Bi(n, l, w)))
          })), p && p(n, w), b || C || w())
        }
      }

      function Ui(t) {
        return "number" == typeof t && !isNaN(t)
      }

      function qi(t) {
        if (r(t)) return !1;
        var e = t.fns;
        return i(e) ? qi(Array.isArray(e) ? e[0] : e) : (t._length || t.length) > 1
      }

      function Wi(t, e) {
        !0 !== e.data.show && Hi(e)
      }
      var Xi = function(t) {
        var e, n, a = {},
          l = t.modules,
          c = t.nodeOps;
        for (e = 0; e < ar.length; ++e)
          for (a[ar[e]] = [], n = 0; n < l.length; ++n) i(l[n][ar[e]]) && a[ar[e]].push(l[n][ar[e]]);

        function h(t) {
          var e = c.parentNode(t);
          i(e) && c.removeChild(e, t)
        }

        function u(t, e, n, r, s, l, h) {
          if (i(t.elm) && i(l) && (t = l[h] = Ct(t)), t.isRootInsert = !s, ! function(t, e, n, r) {
              var s = t.data;
              if (i(s)) {
                var l = i(t.componentInstance) && s.keepAlive;
                if (i(s = s.hook) && i(s = s.init) && s(t, !1), i(t.componentInstance)) return d(t, e), p(n,
                  t.elm, r), o(l) && function(t, e, n, r) {
                  for (var o, s = t; s.componentInstance;)
                    if (s = s.componentInstance._vnode, i(o = s.data) && i(o = o.transition)) {
                      for (o = 0; o < a.activate.length; ++o) a.activate[o](sr, s);
                      e.push(s);
                      break
                    } p(n, t.elm, r)
                }(t, e, n, r), !0
              }
            }(t, e, n, r)) {
            var u = t.data,
              g = t.children,
              m = t.tag;
            i(m) ? (t.elm = t.ns ? c.createElementNS(t.ns, m) : c.createElement(m, t), y(t), f(t, g, e), i(u) &&
                v(t, e), p(n, t.elm, r)) : o(t.isComment) ? (t.elm = c.createComment(t.text), p(n, t.elm, r)) :
              (t.elm = c.createTextNode(t.text), p(n, t.elm, r))
          }
        }

        function d(t, e) {
          i(t.data.pendingInsert) && (e.push.apply(e, t.data.pendingInsert), t.data.pendingInsert = null), t.elm =
            t.componentInstance.$el, m(t) ? (v(t, e), y(t)) : (or(t), e.push(t))
        }

        function p(t, e, n) {
          i(t) && (i(n) ? c.parentNode(n) === t && c.insertBefore(t, e, n) : c.appendChild(t, e))
        }

        function f(t, e, n) {
          if (Array.isArray(e))
            for (var r = 0; r < e.length; ++r) u(e[r], n, t.elm, null, !0, e, r);
          else s(t.text) && c.appendChild(t.elm, c.createTextNode(String(t.text)))
        }

        function m(t) {
          for (; t.componentInstance;) t = t.componentInstance._vnode;
          return i(t.tag)
        }

        function v(t, n) {
          for (var r = 0; r < a.create.length; ++r) a.create[r](sr, t);
          i(e = t.data.hook) && (i(e.create) && e.create(sr, t), i(e.insert) && n.push(t))
        }

        function y(t) {
          var e;
          if (i(e = t.fnScopeId)) c.setStyleScope(t.elm, e);
          else
            for (var n = t; n;) i(e = n.context) && i(e = e.$options._scopeId) && c.setStyleScope(t.elm, e),
              n = n.parent;
          i(e = Ke) && e !== t.context && e !== t.fnContext && i(e = e.$options._scopeId) && c.setStyleScope(
            t.elm, e)
        }

        function b(t, e, n, r, i, o) {
          for (; r <= i; ++r) u(n[r], o, t, e, !1, n, r)
        }

        function C(t) {
          var e, n, r = t.data;
          if (i(r))
            for (i(e = r.hook) && i(e = e.destroy) && e(t), e = 0; e < a.destroy.length; ++e) a.destroy[e](t);
          if (i(e = t.children))
            for (n = 0; n < t.children.length; ++n) C(t.children[n])
        }

        function x(t, e, n) {
          for (; e <= n; ++e) {
            var r = t[e];
            i(r) && (i(r.tag) ? (w(r), C(r)) : h(r.elm))
          }
        }

        function w(t, e) {
          if (i(e) || i(t.data)) {
            var n, r = a.remove.length + 1;
            for (i(e) ? e.listeners += r : e = function(t, e) {
                function n() {
                  0 == --n.listeners && h(t)
                }
                return n.listeners = e, n
              }(t.elm, r), i(n = t.componentInstance) && i(n = n._vnode) && i(n.data) && w(n, e), n = 0; n <
              a.remove.length; ++n) a.remove[n](t, e);
            i(n = t.data.hook) && i(n = n.remove) ? n(t, e) : e()
          } else h(t.elm)
        }

        function A(t, e, n, r) {
          for (var o = n; o < r; o++) {
            var s = e[o];
            if (i(s) && lr(t, s)) return o
          }
        }

        function E(t, e, n, s, l, h) {
          if (t !== e) {
            i(e.elm) && i(s) && (e = s[l] = Ct(e));
            var d = e.elm = t.elm;
            if (o(t.isAsyncPlaceholder)) i(e.asyncFactory.resolved) ? k(t.elm, e, n) : e.isAsyncPlaceholder = !
              0;
            else if (o(e.isStatic) && o(t.isStatic) && e.key === t.key && (o(e.isCloned) || o(e.isOnce))) e.componentInstance =
              t.componentInstance;
            else {
              var p, f = e.data;
              i(f) && i(p = f.hook) && i(p = p.prepatch) && p(t, e);
              var g = t.children,
                v = e.children;
              if (i(f) && m(e)) {
                for (p = 0; p < a.update.length; ++p) a.update[p](t, e);
                i(p = f.hook) && i(p = p.update) && p(t, e)
              }
              r(e.text) ? i(g) && i(v) ? g !== v && function(t, e, n, o, s) {
                  for (var a, l, h, d = 0, p = 0, f = e.length - 1, g = e[0], m = e[f], v = n.length - 1, y =
                      n[0], C = n[v], w = !s; d <= f && p <= v;) r(g) ? g = e[++d] : r(m) ? m = e[--f] : lr(g,
                    y) ? (E(g, y, o, n, p), g = e[++d], y = n[++p]) : lr(m, C) ? (E(m, C, o, n, v), m = e[
                    --f], C = n[--v]) : lr(g, C) ? (E(g, C, o, n, v), w && c.insertBefore(t, g.elm, c.nextSibling(
                    m.elm)), g = e[++d], C = n[--v]) : lr(m, y) ? (E(m, y, o, n, p), w && c.insertBefore(t,
                    m.elm, g.elm), m = e[--f], y = n[++p]) : (r(a) && (a = cr(e, d, f)), r(l = i(y.key) ? a[
                    y.key] : A(y, e, d, f)) ? u(y, o, t, g.elm, !1, n, p) : lr(h = e[l], y) ? (E(h, y, o,
                    n, p), e[l] = void 0, w && c.insertBefore(t, h.elm, g.elm)) : u(y, o, t, g.elm, !1, n,
                    p), y = n[++p]);
                  d > f ? b(t, r(n[v + 1]) ? null : n[v + 1].elm, n, p, v, o) : p > v && x(e, d, f)
                }(d, g, v, n, h) : i(v) ? (i(t.text) && c.setTextContent(d, ""), b(d, null, v, 0, v.length -
                  1, n)) : i(g) ? x(g, 0, g.length - 1) : i(t.text) && c.setTextContent(d, "") : t.text !==
                e.text && c.setTextContent(d, e.text), i(f) && i(p = f.hook) && i(p = p.postpatch) && p(t, e)
            }
          }
        }

        function S(t, e, n) {
          if (o(n) && i(t.parent)) t.parent.data.pendingInsert = e;
          else
            for (var r = 0; r < e.length; ++r) e[r].data.hook.insert(e[r])
        }
        var M = g("attrs,class,staticClass,staticStyle,key");

        function k(t, e, n, r) {
          var s, a = e.tag,
            l = e.data,
            c = e.children;
          if (r = r || l && l.pre, e.elm = t, o(e.isComment) && i(e.asyncFactory)) return e.isAsyncPlaceholder = !
            0, !0;
          if (i(l) && (i(s = l.hook) && i(s = s.init) && s(e, !0), i(s = e.componentInstance))) return d(e, n),
            !0;
          if (i(a)) {
            if (i(c))
              if (t.hasChildNodes())
                if (i(s = l) && i(s = s.domProps) && i(s = s.innerHTML)) {
                  if (s !== t.innerHTML) return !1
                } else {
                  for (var h = !0, u = t.firstChild, p = 0; p < c.length; p++) {
                    if (!u || !k(u, c[p], n, r)) {
                      h = !1;
                      break
                    }
                    u = u.nextSibling
                  }
                  if (!h || u) return !1
                }
            else f(e, c, n);
            if (i(l)) {
              var g = !1;
              for (var m in l)
                if (!M(m)) {
                  g = !0, v(e, n);
                  break
                }! g && l.class && ie(l.class)
            }
          } else t.data !== e.text && (t.data = e.text);
          return !0
        }
        return function(t, e, n, s) {
          if (!r(e)) {
            var l, h = !1,
              d = [];
            if (r(t)) h = !0, u(e, d);
            else {
              var p = i(t.nodeType);
              if (!p && lr(t, e)) E(t, e, d, null, null, s);
              else {
                if (p) {
                  if (1 === t.nodeType && t.hasAttribute($) && (t.removeAttribute($), n = !0), o(n) && k(t,
                      e, d)) return S(e, d, !0), t;
                  l = t, t = new mt(c.tagName(l).toLowerCase(), {}, [], void 0, l)
                }
                var f = t.elm,
                  g = c.parentNode(f);
                if (u(e, d, f._leaveCb ? null : g, c.nextSibling(f)), i(e.parent))
                  for (var v = e.parent, y = m(e); v;) {
                    for (var b = 0; b < a.destroy.length; ++b) a.destroy[b](v);
                    if (v.elm = e.elm, y) {
                      for (var w = 0; w < a.create.length; ++w) a.create[w](sr, v);
                      var A = v.data.hook.insert;
                      if (A.merged)
                        for (var M = 1; M < A.fns.length; M++) A.fns[M]()
                    } else or(v);
                    v = v.parent
                  }
                i(g) ? x([t], 0, 0) : i(t.tag) && C(t)
              }
            }
            return S(e, d, h), e.elm
          }
          i(t) && C(t)
        }
      }({
        nodeOps: rr,
        modules: [Cr, Or, ai, hi, xi, W ? {
          create: Wi,
          activate: Wi,
          remove: function(t, e) {
            !0 !== t.data.show ? Gi(t, e) : e()
          }
        } : {}].concat(mr)
      });
      K && document.addEventListener("selectionchange", function() {
        var t = document.activeElement;
        t && t.vmodel && no(t, "input")
      });
      var Yi = {
        inserted: function(t, e, n, r) {
          "select" === n.tag ? (r.elm && !r.elm._vOptions ? le(n, "postpatch", function() {
            Yi.componentUpdated(t, e, n)
          }) : Ji(t, e, n.context), t._vOptions = [].map.call(t.options, Qi)) : ("textarea" === n.tag ||
            er(t.type)) && (t._vModifiers = e.modifiers, e.modifiers.lazy || (t.addEventListener(
            "compositionstart", to), t.addEventListener("compositionend", eo), t.addEventListener(
            "change", eo), K && (t.vmodel = !0)))
        },
        componentUpdated: function(t, e, n) {
          if ("select" === n.tag) {
            Ji(t, e, n.context);
            var r = t._vOptions,
              i = t._vOptions = [].map.call(t.options, Qi);
            if (i.some(function(t, e) {
                return !L(t, r[e])
              }))(t.multiple ? e.value.some(function(t) {
              return Ki(t, i)
            }) : e.value !== e.oldValue && Ki(e.value, i)) && no(t, "change")
          }
        }
      };

      function Ji(t, e, n) {
        Zi(t, e, n), (Z || Q) && setTimeout(function() {
          Zi(t, e, n)
        }, 0)
      }

      function Zi(t, e, n) {
        var r = e.value,
          i = t.multiple;
        if (!i || Array.isArray(r)) {
          for (var o, s, a = 0, l = t.options.length; a < l; a++)
            if (s = t.options[a], i) o = N(r, Qi(s)) > -1, s.selected !== o && (s.selected = o);
            else if (L(Qi(s), r)) return void(t.selectedIndex !== a && (t.selectedIndex = a));
          i || (t.selectedIndex = -1)
        }
      }

      function Ki(t, e) {
        return e.every(function(e) {
          return !L(e, t)
        })
      }

      function Qi(t) {
        return "_value" in t ? t._value : t.value
      }

      function to(t) {
        t.target.composing = !0
      }

      function eo(t) {
        t.target.composing && (t.target.composing = !1, no(t.target, "input"))
      }

      function no(t, e) {
        var n = document.createEvent("HTMLEvents");
        n.initEvent(e, !0, !0), t.dispatchEvent(n)
      }

      function ro(t) {
        return !t.componentInstance || t.data && t.data.transition ? t : ro(t.componentInstance._vnode)
      }
      var io = {
          model: Yi,
          show: {
            bind: function(t, e, n) {
              var r = e.value,
                i = (n = ro(n)).data && n.data.transition,
                o = t.__vOriginalDisplay = "none" === t.style.display ? "" : t.style.display;
              r && i ? (n.data.show = !0, Hi(n, function() {
                t.style.display = o
              })) : t.style.display = r ? o : "none"
            },
            update: function(t, e, n) {
              var r = e.value;
              !r != !e.oldValue && ((n = ro(n)).data && n.data.transition ? (n.data.show = !0, r ? Hi(n,
                function() {
                  t.style.display = t.__vOriginalDisplay
                }) : Gi(n, function() {
                t.style.display = "none"
              })) : t.style.display = r ? t.__vOriginalDisplay : "none")
            },
            unbind: function(t, e, n, r, i) {
              i || (t.style.display = t.__vOriginalDisplay)
            }
          }
        },
        oo = {
          name: String,
          appear: Boolean,
          css: Boolean,
          mode: String,
          type: String,
          enterClass: String,
          leaveClass: String,
          enterToClass: String,
          leaveToClass: String,
          enterActiveClass: String,
          leaveActiveClass: String,
          appearClass: String,
          appearActiveClass: String,
          appearToClass: String,
          duration: [Number, String, Object]
        };

      function so(t) {
        var e = t && t.componentOptions;
        return e && e.Ctor.options.abstract ? so(We(e.children)) : t
      }

      function ao(t) {
        var e = {},
          n = t.$options;
        for (var r in n.propsData) e[r] = t[r];
        var i = n._parentListeners;
        for (var o in i) e[A(o)] = i[o];
        return e
      }

      function lo(t, e) {
        if (/\d-keep-alive$/.test(e.tag)) return t("keep-alive", {
          props: e.componentOptions.propsData
        })
      }
      var co = function(t) {
          return t.tag || qe(t)
        },
        ho = function(t) {
          return "show" === t.name
        },
        uo = {
          name: "transition",
          props: oo,
          abstract: !0,
          render: function(t) {
            var e = this,
              n = this.$slots.default;
            if (n && (n = n.filter(co)).length) {
              0;
              var r = this.mode;
              0;
              var i = n[0];
              if (function(t) {
                  for (; t = t.parent;)
                    if (t.data.transition) return !0
                }(this.$vnode)) return i;
              var o = so(i);
              if (!o) return i;
              if (this._leaving) return lo(t, i);
              var a = "__transition-" + this._uid + "-";
              o.key = null == o.key ? o.isComment ? a + "comment" : a + o.tag : s(o.key) ? 0 === String(o.key)
                .indexOf(a) ? o.key : a + o.key : o.key;
              var l = (o.data || (o.data = {})).transition = ao(this),
                c = this._vnode,
                h = so(c);
              if (o.data.directives && o.data.directives.some(ho) && (o.data.show = !0), h && h.data && !
                function(t, e) {
                  return e.key === t.key && e.tag === t.tag
                }(o, h) && !qe(h) && (!h.componentInstance || !h.componentInstance._vnode.isComment)) {
                var u = h.data.transition = P({}, l);
                if ("out-in" === r) return this._leaving = !0, le(u, "afterLeave", function() {
                  e._leaving = !1, e.$forceUpdate()
                }), lo(t, i);
                if ("in-out" === r) {
                  if (qe(o)) return c;
                  var d, p = function() {
                    d()
                  };
                  le(l, "afterEnter", p), le(l, "enterCancelled", p), le(u, "delayLeave", function(t) {
                    d = t
                  })
                }
              }
              return i
            }
          }
        },
        po = P({
          tag: String,
          moveClass: String
        }, oo);

      function fo(t) {
        t.elm._moveCb && t.elm._moveCb(), t.elm._enterCb && t.elm._enterCb()
      }

      function go(t) {
        t.data.newPos = t.elm.getBoundingClientRect()
      }

      function mo(t) {
        var e = t.data.pos,
          n = t.data.newPos,
          r = e.left - n.left,
          i = e.top - n.top;
        if (r || i) {
          t.data.moved = !0;
          var o = t.elm.style;
          o.transform = o.WebkitTransform = "translate(" + r + "px," + i + "px)", o.transitionDuration = "0s"
        }
      }
      delete po.mode;
      var vo = {
        Transition: uo,
        TransitionGroup: {
          props: po,
          beforeMount: function() {
            var t = this,
              e = this._update;
            this._update = function(n, r) {
              var i = Qe(t);
              t.__patch__(t._vnode, t.kept, !1, !0), t._vnode = t.kept, i(), e.call(t, n, r)
            }
          },
          render: function(t) {
            for (var e = this.tag || this.$vnode.data.tag || "span", n = Object.create(null), r = this.prevChildren =
                this.children, i = this.$slots.default || [], o = this.children = [], s = ao(this), a = 0; a <
              i.length; a++) {
              var l = i[a];
              if (l.tag)
                if (null != l.key && 0 !== String(l.key).indexOf("__vlist")) o.push(l), n[l.key] = l, (l.data ||
                  (l.data = {})).transition = s;
                else;
            }
            if (r) {
              for (var c = [], h = [], u = 0; u < r.length; u++) {
                var d = r[u];
                d.data.transition = s, d.data.pos = d.elm.getBoundingClientRect(), n[d.key] ? c.push(d) : h
                  .push(d)
              }
              this.kept = t(e, null, c), this.removed = h
            }
            return t(e, null, o)
          },
          updated: function() {
            var t = this.prevChildren,
              e = this.moveClass || (this.name || "v") + "-move";
            t.length && this.hasMove(t[0].elm, e) && (t.forEach(fo), t.forEach(go), t.forEach(mo), this._reflow =
              document.body.offsetHeight, t.forEach(function(t) {
                if (t.data.moved) {
                  var n = t.elm,
                    r = n.style;
                  Fi(n, e), r.transform = r.WebkitTransform = r.transitionDuration = "", n.addEventListener(
                    Ti, n._moveCb = function t(r) {
                      r && r.target !== n || r && !/transform$/.test(r.propertyName) || (n.removeEventListener(
                        Ti, t), n._moveCb = null, $i(n, e))
                    })
                }
              }))
          },
          methods: {
            hasMove: function(t, e) {
              if (!ki) return !1;
              if (this._hasMove) return this._hasMove;
              var n = t.cloneNode();
              t._transitionClasses && t._transitionClasses.forEach(function(t) {
                Ei(n, t)
              }), Ai(n, e), n.style.display = "none", this.$el.appendChild(n);
              var r = zi(n);
              return this.$el.removeChild(n), this._hasMove = r.hasTransform
            }
          }
        }
      };
      Mn.config.mustUseProp = Fn, Mn.config.isReservedTag = Kn, Mn.config.isReservedAttr = Ln, Mn.config.getTagNamespace =
        Qn, Mn.config.isUnknownElement = function(t) {
          if (!W) return !0;
          if (Kn(t)) return !1;
          if (t = t.toLowerCase(), null != tr[t]) return tr[t];
          var e = document.createElement(t);
          return t.indexOf("-") > -1 ? tr[t] = e.constructor === window.HTMLUnknownElement || e.constructor ===
            window.HTMLElement : tr[t] = /HTMLUnknownElement/.test(e.toString())
        }, P(Mn.options.directives, io), P(Mn.options.components, vo), Mn.prototype.__patch__ = W ? Xi : T, Mn.prototype
        .$mount = function(t, e) {
          return function(t, e, n) {
            return t.$el = e, t.$options.render || (t.$options.render = yt), nn(t, "beforeMount"), new gn(t,
              function() {
                t._update(t._render(), n)
              }, T, {
                before: function() {
                  t._isMounted && !t._isDestroyed && nn(t, "beforeUpdate")
                }
              }, !0), n = !1, null == t.$vnode && (t._isMounted = !0, nn(t, "mounted")), t
          }(this, t = t && W ? nr(t) : void 0, e)
        }, W && setTimeout(function() {
          z.devtools && st && st.emit("init", Mn)
        }, 0);
      var yo = /\{\{((?:.|\r?\n)+?)\}\}/g,
        bo = /[-.*+?^${}()|[\]\/\\]/g,
        Co = x(function(t) {
          var e = t[0].replace(bo, "\\$&"),
            n = t[1].replace(bo, "\\$&");
          return new RegExp(e + "((?:.|\\n)+?)" + n, "g")
        });

      function xo(t, e) {
        var n = e ? Co(e) : yo;
        if (n.test(t)) {
          for (var r, i, o, s = [], a = [], l = n.lastIndex = 0; r = n.exec(t);) {
            (i = r.index) > l && (a.push(o = t.slice(l, i)), s.push(JSON.stringify(o)));
            var c = Dr(r[1].trim());
            s.push("_s(" + c + ")"), a.push({
              "@binding": c
            }), l = i + r[0].length
          }
          return l < t.length && (a.push(o = t.slice(l)), s.push(JSON.stringify(o))), {
            expression: s.join("+"),
            tokens: a
          }
        }
      }
      var wo = {
        staticKeys: ["staticClass"],
        transformNode: function(t, e) {
          e.warn;
          var n = Vr(t, "class");
          n && (t.staticClass = JSON.stringify(n));
          var r = Rr(t, "class", !1);
          r && (t.classBinding = r)
        },
        genData: function(t) {
          var e = "";
          return t.staticClass && (e += "staticClass:" + t.staticClass + ","), t.classBinding && (e +=
            "class:" + t.classBinding + ","), e
        }
      };
      var Ao, Eo = {
          staticKeys: ["staticStyle"],
          transformNode: function(t, e) {
            e.warn;
            var n = Vr(t, "style");
            n && (t.staticStyle = JSON.stringify(ui(n)));
            var r = Rr(t, "style", !1);
            r && (t.styleBinding = r)
          },
          genData: function(t) {
            var e = "";
            return t.staticStyle && (e += "staticStyle:" + t.staticStyle + ","), t.styleBinding && (e +=
              "style:(" + t.styleBinding + "),"), e
          }
        },
        So = function(t) {
          return (Ao = Ao || document.createElement("div")).innerHTML = t, Ao.textContent
        },
        Mo = g("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),
        ko = g("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),
        Oo = g(
          "address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"
        ),
        Po = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,
        Do =
        /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,
        To = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + R.source + "]*",
        _o = "((?:" + To + "\\:)?" + To + ")",
        jo = new RegExp("^<" + _o),
        Lo = /^\s*(\/?)>/,
        No = new RegExp("^<\\/" + _o + "[^>]*>"),
        Fo = /^<!DOCTYPE [^>]+>/i,
        $o = /^<!\--/,
        Bo = /^<!\[/,
        Io = g("script,style,textarea", !0),
        zo = {},
        Ro = {
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&amp;": "&",
          "&#10;": "\n",
          "&#9;": "\t",
          "&#39;": "'"
        },
        Vo = /&(?:lt|gt|quot|amp|#39);/g,
        Ho = /&(?:lt|gt|quot|amp|#39|#10|#9);/g,
        Go = g("pre,textarea", !0),
        Uo = function(t, e) {
          return t && Go(t) && "\n" === e[0]
        };

      function qo(t, e) {
        var n = e ? Ho : Vo;
        return t.replace(n, function(t) {
          return Ro[t]
        })
      }
      var Wo, Xo, Yo, Jo, Zo, Ko, Qo, ts, es = /^@|^v-on:/,
        ns = /^v-|^@|^:|^#/,
        rs = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,
        is = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/,
        os = /^\(|\)$/g,
        ss = /^\[.*\]$/,
        as = /:(.*)$/,
        ls = /^:|^\.|^v-bind:/,
        cs = /\.[^.\]]+(?=[^\]]*$)/g,
        hs = /^v-slot(:|$)|^#/,
        us = /[\r\n]/,
        ds = /\s+/g,
        ps = x(So),
        fs = "_empty_";

      function gs(t, e, n) {
        return {
          type: 1,
          tag: t,
          attrsList: e,
          attrsMap: function(t) {
            for (var e = {}, n = 0, r = t.length; n < r; n++) e[t[n].name] = t[n].value;
            return e
          }(e),
          rawAttrsMap: {},
          parent: n,
          children: []
        }
      }

      function ms(t, e) {
        Wo = e.warn || _r, Ko = e.isPreTag || _, Qo = e.mustUseProp || _, ts = e.getTagNamespace || _;
        var n = e.isReservedTag || _;
        (function(t) {
          return !!t.component || !n(t.tag)
        }), Yo = jr(e.modules, "transformNode"), Jo = jr(e.modules, "preTransformNode"), Zo = jr(e.modules,
          "postTransformNode"), Xo = e.delimiters;
        var r, i, o = [],
          s = !1 !== e.preserveWhitespace,
          a = e.whitespace,
          l = !1,
          c = !1;

        function h(t) {
          if (u(t), l || t.processed || (t = vs(t, e)), o.length || t === r || r.if && (t.elseif || t.else) &&
            bs(r, {
              exp: t.elseif,
              block: t
            }), i && !t.forbidden)
            if (t.elseif || t.else) s = t, (a = function(t) {
              var e = t.length;
              for (; e--;) {
                if (1 === t[e].type) return t[e];
                t.pop()
              }
            }(i.children)) && a.if && bs(a, {
              exp: s.elseif,
              block: s
            });
            else {
              if (t.slotScope) {
                var n = t.slotTarget || '"default"';
                (i.scopedSlots || (i.scopedSlots = {}))[n] = t
              }
              i.children.push(t), t.parent = i
            } var s, a;
          t.children = t.children.filter(function(t) {
            return !t.slotScope
          }), u(t), t.pre && (l = !1), Ko(t.tag) && (c = !1);
          for (var h = 0; h < Zo.length; h++) Zo[h](t, e)
        }

        function u(t) {
          if (!c)
            for (var e;
              (e = t.children[t.children.length - 1]) && 3 === e.type && " " === e.text;) t.children.pop()
        }
        return function(t, e) {
          for (var n, r, i = [], o = e.expectHTML, s = e.isUnaryTag || _, a = e.canBeLeftOpenTag || _, l = 0; t;) {
            if (n = t, r && Io(r)) {
              var c = 0,
                h = r.toLowerCase(),
                u = zo[h] || (zo[h] = new RegExp("([\\s\\S]*?)(</" + h + "[^>]*>)", "i")),
                d = t.replace(u, function(t, n, r) {
                  return c = r.length, Io(h) || "noscript" === h || (n = n.replace(/<!\--([\s\S]*?)-->/g,
                      "$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g, "$1")), Uo(h, n) && (n = n.slice(1)), e.chars &&
                    e.chars(n), ""
                });
              l += t.length - d.length, t = d, M(h, l - c, l)
            } else {
              var p = t.indexOf("<");
              if (0 === p) {
                if ($o.test(t)) {
                  var f = t.indexOf("--\x3e");
                  if (f >= 0) {
                    e.shouldKeepComment && e.comment(t.substring(4, f), l, l + f + 3), A(f + 3);
                    continue
                  }
                }
                if (Bo.test(t)) {
                  var g = t.indexOf("]>");
                  if (g >= 0) {
                    A(g + 2);
                    continue
                  }
                }
                var m = t.match(Fo);
                if (m) {
                  A(m[0].length);
                  continue
                }
                var v = t.match(No);
                if (v) {
                  var y = l;
                  A(v[0].length), M(v[1], y, l);
                  continue
                }
                var b = E();
                if (b) {
                  S(b), Uo(b.tagName, t) && A(1);
                  continue
                }
              }
              var C = void 0,
                x = void 0,
                w = void 0;
              if (p >= 0) {
                for (x = t.slice(p); !(No.test(x) || jo.test(x) || $o.test(x) || Bo.test(x) || (w = x.indexOf(
                    "<", 1)) < 0);) p += w, x = t.slice(p);
                C = t.substring(0, p)
              }
              p < 0 && (C = t), C && A(C.length), e.chars && C && e.chars(C, l - C.length, l)
            }
            if (t === n) {
              e.chars && e.chars(t);
              break
            }
          }

          function A(e) {
            l += e, t = t.substring(e)
          }

          function E() {
            var e = t.match(jo);
            if (e) {
              var n, r, i = {
                tagName: e[1],
                attrs: [],
                start: l
              };
              for (A(e[0].length); !(n = t.match(Lo)) && (r = t.match(Do) || t.match(Po));) r.start = l, A(r[
                0].length), r.end = l, i.attrs.push(r);
              if (n) return i.unarySlash = n[1], A(n[0].length), i.end = l, i
            }
          }

          function S(t) {
            var n = t.tagName,
              l = t.unarySlash;
            o && ("p" === r && Oo(n) && M(r), a(n) && r === n && M(n));
            for (var c = s(n) || !!l, h = t.attrs.length, u = new Array(h), d = 0; d < h; d++) {
              var p = t.attrs[d],
                f = p[3] || p[4] || p[5] || "",
                g = "a" === n && "href" === p[1] ? e.shouldDecodeNewlinesForHref : e.shouldDecodeNewlines;
              u[d] = {
                name: p[1],
                value: qo(f, g)
              }
            }
            c || (i.push({
              tag: n,
              lowerCasedTag: n.toLowerCase(),
              attrs: u,
              start: t.start,
              end: t.end
            }), r = n), e.start && e.start(n, u, c, t.start, t.end)
          }

          function M(t, n, o) {
            var s, a;
            if (null == n && (n = l), null == o && (o = l), t)
              for (a = t.toLowerCase(), s = i.length - 1; s >= 0 && i[s].lowerCasedTag !== a; s--);
            else s = 0;
            if (s >= 0) {
              for (var c = i.length - 1; c >= s; c--) e.end && e.end(i[c].tag, n, o);
              i.length = s, r = s && i[s - 1].tag
            } else "br" === a ? e.start && e.start(t, [], !0, n, o) : "p" === a && (e.start && e.start(t, [],
              !1, n, o), e.end && e.end(t, n, o))
          }
          M()
        }(t, {
          warn: Wo,
          expectHTML: e.expectHTML,
          isUnaryTag: e.isUnaryTag,
          canBeLeftOpenTag: e.canBeLeftOpenTag,
          shouldDecodeNewlines: e.shouldDecodeNewlines,
          shouldDecodeNewlinesForHref: e.shouldDecodeNewlinesForHref,
          shouldKeepComment: e.comments,
          outputSourceRange: e.outputSourceRange,
          start: function(t, n, s, a, u) {
            var d = i && i.ns || ts(t);
            Z && "svg" === d && (n = function(t) {
              for (var e = [], n = 0; n < t.length; n++) {
                var r = t[n];
                ws.test(r.name) || (r.name = r.name.replace(As, ""), e.push(r))
              }
              return e
            }(n));
            var p, f = gs(t, n, i);
            d && (f.ns = d), "style" !== (p = f).tag && ("script" !== p.tag || p.attrsMap.type &&
              "text/javascript" !== p.attrsMap.type) || ot() || (f.forbidden = !0);
            for (var g = 0; g < Jo.length; g++) f = Jo[g](f, e) || f;
            l || (! function(t) {
              null != Vr(t, "v-pre") && (t.pre = !0)
            }(f), f.pre && (l = !0)), Ko(f.tag) && (c = !0), l ? function(t) {
              var e = t.attrsList,
                n = e.length;
              if (n)
                for (var r = t.attrs = new Array(n), i = 0; i < n; i++) r[i] = {
                  name: e[i].name,
                  value: JSON.stringify(e[i].value)
                }, null != e[i].start && (r[i].start = e[i].start, r[i].end = e[i].end);
              else t.pre || (t.plain = !0)
            }(f) : f.processed || (ys(f), function(t) {
              var e = Vr(t, "v-if");
              if (e) t.if = e, bs(t, {
                exp: e,
                block: t
              });
              else {
                null != Vr(t, "v-else") && (t.else = !0);
                var n = Vr(t, "v-else-if");
                n && (t.elseif = n)
              }
            }(f), function(t) {
              null != Vr(t, "v-once") && (t.once = !0)
            }(f)), r || (r = f), s ? h(f) : (i = f, o.push(f))
          },
          end: function(t, e, n) {
            var r = o[o.length - 1];
            o.length -= 1, i = o[o.length - 1], h(r)
          },
          chars: function(t, e, n) {
            if (i && (!Z || "textarea" !== i.tag || i.attrsMap.placeholder !== t)) {
              var r, o, h, u = i.children;
              if (t = c || t.trim() ? "script" === (r = i).tag || "style" === r.tag ? t : ps(t) : u.length ?
                a ? "condense" === a && us.test(t) ? "" : " " : s ? " " : "" : "") c || "condense" !== a ||
                (t = t.replace(ds, " ")), !l && " " !== t && (o = xo(t, Xo)) ? h = {
                  type: 2,
                  expression: o.expression,
                  tokens: o.tokens,
                  text: t
                } : " " === t && u.length && " " === u[u.length - 1].text || (h = {
                  type: 3,
                  text: t
                }), h && u.push(h)
            }
          },
          comment: function(t, e, n) {
            if (i) {
              var r = {
                type: 3,
                text: t,
                isComment: !0
              };
              0, i.children.push(r)
            }
          }
        }), r
      }

      function vs(t, e) {
        var n, r;
        ! function(t) {
          var e = Rr(t, "key");
          if (e) {
            t.key = e
          }
        }(t), t.plain = !t.key && !t.scopedSlots && !t.attrsList.length, (r = Rr(n = t, "ref")) && (n.ref = r,
            n.refInFor = function(t) {
              for (var e = t; e;) {
                if (void 0 !== e.for) return !0;
                e = e.parent
              }
              return !1
            }(n)),
          function(t) {
            var e;
            "template" === t.tag ? (e = Vr(t, "scope"), t.slotScope = e || Vr(t, "slot-scope")) : (e = Vr(t,
              "slot-scope")) && (t.slotScope = e);
            var n = Rr(t, "slot");
            n && (t.slotTarget = '""' === n ? '"default"' : n, t.slotTargetDynamic = !(!t.attrsMap[":slot"] &&
              !t.attrsMap["v-bind:slot"]), "template" === t.tag || t.slotScope || Nr(t, "slot", n, zr(t,
              "slot")));
            if ("template" === t.tag) {
              var r = Hr(t, hs);
              if (r) {
                0;
                var i = Cs(r),
                  o = i.name,
                  s = i.dynamic;
                t.slotTarget = o, t.slotTargetDynamic = s, t.slotScope = r.value || fs
              }
            } else {
              var a = Hr(t, hs);
              if (a) {
                0;
                var l = t.scopedSlots || (t.scopedSlots = {}),
                  c = Cs(a),
                  h = c.name,
                  u = c.dynamic,
                  d = l[h] = gs("template", [], t);
                d.slotTarget = h, d.slotTargetDynamic = u, d.children = t.children.filter(function(t) {
                  if (!t.slotScope) return t.parent = d, !0
                }), d.slotScope = a.value || fs, t.children = [], t.plain = !1
              }
            }
          }(t),
          function(t) {
            "slot" === t.tag && (t.slotName = Rr(t, "name"))
          }(t),
          function(t) {
            var e;
            (e = Rr(t, "is")) && (t.component = e);
            null != Vr(t, "inline-template") && (t.inlineTemplate = !0)
          }(t);
        for (var i = 0; i < Yo.length; i++) t = Yo[i](t, e) || t;
        return function(t) {
          var e, n, r, i, o, s, a, l, c = t.attrsList;
          for (e = 0, n = c.length; e < n; e++) {
            if (r = i = c[e].name, o = c[e].value, ns.test(r))
              if (t.hasBindings = !0, (s = xs(r.replace(ns, ""))) && (r = r.replace(cs, "")), ls.test(r)) r =
                r.replace(ls, ""), o = Dr(o), (l = ss.test(r)) && (r = r.slice(1, -1)), s && (s.prop && !l &&
                  "innerHtml" === (r = A(r)) && (r = "innerHTML"), s.camel && !l && (r = A(r)), s.sync && (a =
                    qr(o, "$event"), l ? Ir(t, '"update:"+(' + r + ")", a, null, !1, 0, c[e], !0) : (Ir(t,
                      "update:" + A(r), a, null, !1, 0, c[e]), M(r) !== A(r) && Ir(t, "update:" + M(r), a,
                      null, !1, 0, c[e])))), s && s.prop || !t.component && Qo(t.tag, t.attrsMap.type, r) ?
                Lr(t, r, o, c[e], l) : Nr(t, r, o, c[e], l);
              else if (es.test(r)) r = r.replace(es, ""), (l = ss.test(r)) && (r = r.slice(1, -1)), Ir(t, r,
              o, s, !1, 0, c[e], l);
            else {
              var h = (r = r.replace(ns, "")).match(as),
                u = h && h[1];
              l = !1, u && (r = r.slice(0, -(u.length + 1)), ss.test(u) && (u = u.slice(1, -1), l = !0)), $r(
                t, r, i, o, u, l, s, c[e])
            } else Nr(t, r, JSON.stringify(o), c[e]), !t.component && "muted" === r && Qo(t.tag, t.attrsMap.type,
              r) && Lr(t, r, "true", c[e])
          }
        }(t), t
      }

      function ys(t) {
        var e;
        if (e = Vr(t, "v-for")) {
          var n = function(t) {
            var e = t.match(rs);
            if (!e) return;
            var n = {};
            n.for = e[2].trim();
            var r = e[1].trim().replace(os, ""),
              i = r.match(is);
            i ? (n.alias = r.replace(is, "").trim(), n.iterator1 = i[1].trim(), i[2] && (n.iterator2 = i[2].trim())) :
              n.alias = r;
            return n
          }(e);
          n && P(t, n)
        }
      }

      function bs(t, e) {
        t.ifConditions || (t.ifConditions = []), t.ifConditions.push(e)
      }

      function Cs(t) {
        var e = t.name.replace(hs, "");
        return e || "#" !== t.name[0] && (e = "default"), ss.test(e) ? {
          name: e.slice(1, -1),
          dynamic: !0
        } : {
          name: '"' + e + '"',
          dynamic: !1
        }
      }

      function xs(t) {
        var e = t.match(cs);
        if (e) {
          var n = {};
          return e.forEach(function(t) {
            n[t.slice(1)] = !0
          }), n
        }
      }
      var ws = /^xmlns:NS\d+/,
        As = /^NS\d+:/;

      function Es(t) {
        return gs(t.tag, t.attrsList.slice(), t.parent)
      }
      var Ss = [wo, Eo, {
        preTransformNode: function(t, e) {
          if ("input" === t.tag) {
            var n, r = t.attrsMap;
            if (!r["v-model"]) return;
            if ((r[":type"] || r["v-bind:type"]) && (n = Rr(t, "type")), r.type || n || !r["v-bind"] || (
                n = "(" + r["v-bind"] + ").type"), n) {
              var i = Vr(t, "v-if", !0),
                o = i ? "&&(" + i + ")" : "",
                s = null != Vr(t, "v-else", !0),
                a = Vr(t, "v-else-if", !0),
                l = Es(t);
              ys(l), Fr(l, "type", "checkbox"), vs(l, e), l.processed = !0, l.if = "(" + n +
                ")==='checkbox'" + o, bs(l, {
                  exp: l.if,
                  block: l
                });
              var c = Es(t);
              Vr(c, "v-for", !0), Fr(c, "type", "radio"), vs(c, e), bs(l, {
                exp: "(" + n + ")==='radio'" + o,
                block: c
              });
              var h = Es(t);
              return Vr(h, "v-for", !0), Fr(h, ":type", n), vs(h, e), bs(l, {
                exp: i,
                block: h
              }), s ? l.else = !0 : a && (l.elseif = a), l
            }
          }
        }
      }];
      var Ms, ks, Os = {
          expectHTML: !0,
          modules: Ss,
          directives: {
            model: function(t, e, n) {
              n;
              var r = e.value,
                i = e.modifiers,
                o = t.tag,
                s = t.attrsMap.type;
              if (t.component) return Ur(t, r, i), !1;
              if ("select" === o) ! function(t, e, n) {
                var r =
                  'var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return ' +
                  (n && n.number ? "_n(val)" : "val") + "});";
                r = r + " " + qr(e, "$event.target.multiple ? $$selectedVal : $$selectedVal[0]"), Ir(t,
                  "change", r, null, !0)
              }(t, r, i);
              else if ("input" === o && "checkbox" === s) ! function(t, e, n) {
                var r = n && n.number,
                  i = Rr(t, "value") || "null",
                  o = Rr(t, "true-value") || "true",
                  s = Rr(t, "false-value") || "false";
                Lr(t, "checked", "Array.isArray(" + e + ")?_i(" + e + "," + i + ")>-1" + ("true" === o ?
                  ":(" + e + ")" : ":_q(" + e + "," + o + ")")), Ir(t, "change", "var $$a=" + e +
                  ",$$el=$event.target,$$c=$$el.checked?(" + o + "):(" + s +
                  ");if(Array.isArray($$a)){var $$v=" + (r ? "_n(" + i + ")" : i) +
                  ",$$i=_i($$a,$$v);if($$el.checked){$$i<0&&(" + qr(e, "$$a.concat([$$v])") +
                  ")}else{$$i>-1&&(" + qr(e, "$$a.slice(0,$$i).concat($$a.slice($$i+1))") + ")}}else{" +
                  qr(e, "$$c") + "}", null, !0)
              }(t, r, i);
              else if ("input" === o && "radio" === s) ! function(t, e, n) {
                var r = n && n.number,
                  i = Rr(t, "value") || "null";
                Lr(t, "checked", "_q(" + e + "," + (i = r ? "_n(" + i + ")" : i) + ")"), Ir(t, "change", qr(
                  e, i), null, !0)
              }(t, r, i);
              else if ("input" === o || "textarea" === o) ! function(t, e, n) {
                var r = t.attrsMap.type,
                  i = n || {},
                  o = i.lazy,
                  s = i.number,
                  a = i.trim,
                  l = !o && "range" !== r,
                  c = o ? "change" : "range" === r ? Qr : "input",
                  h = "$event.target.value";
                a && (h = "$event.target.value.trim()"), s && (h = "_n(" + h + ")");
                var u = qr(e, h);
                l && (u = "if($event.target.composing)return;" + u), Lr(t, "value", "(" + e + ")"), Ir(t, c,
                  u, null, !0), (a || s) && Ir(t, "blur", "$forceUpdate()")
              }(t, r, i);
              else if (!z.isReservedTag(o)) return Ur(t, r, i), !1;
              return !0
            },
            text: function(t, e) {
              e.value && Lr(t, "textContent", "_s(" + e.value + ")", e)
            },
            html: function(t, e) {
              e.value && Lr(t, "innerHTML", "_s(" + e.value + ")", e)
            }
          },
          isPreTag: function(t) {
            return "pre" === t
          },
          isUnaryTag: Mo,
          mustUseProp: Fn,
          canBeLeftOpenTag: ko,
          isReservedTag: Kn,
          getTagNamespace: Qn,
          staticKeys: function(t) {
            return t.reduce(function(t, e) {
              return t.concat(e.staticKeys || [])
            }, []).join(",")
          }(Ss)
        },
        Ps = x(function(t) {
          return g("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap" + (t ? "," +
            t : ""))
        });

      function Ds(t, e) {
        t && (Ms = Ps(e.staticKeys || ""), ks = e.isReservedTag || _, function t(e) {
          e.static = function(t) {
            if (2 === t.type) return !1;
            if (3 === t.type) return !0;
            return !(!t.pre && (t.hasBindings || t.if || t.for || m(t.tag) || !ks(t.tag) || function(t) {
              for (; t.parent;) {
                if ("template" !== (t = t.parent).tag) return !1;
                if (t.for) return !0
              }
              return !1
            }(t) || !Object.keys(t).every(Ms)))
          }(e);
          if (1 === e.type) {
            if (!ks(e.tag) && "slot" !== e.tag && null == e.attrsMap["inline-template"]) return;
            for (var n = 0, r = e.children.length; n < r; n++) {
              var i = e.children[n];
              t(i), i.static || (e.static = !1)
            }
            if (e.ifConditions)
              for (var o = 1, s = e.ifConditions.length; o < s; o++) {
                var a = e.ifConditions[o].block;
                t(a), a.static || (e.static = !1)
              }
          }
        }(t), function t(e, n) {
          if (1 === e.type) {
            if ((e.static || e.once) && (e.staticInFor = n), e.static && e.children.length && (1 !== e.children
                .length || 3 !== e.children[0].type)) return void(e.staticRoot = !0);
            if (e.staticRoot = !1, e.children)
              for (var r = 0, i = e.children.length; r < i; r++) t(e.children[r], n || !!e.for);
            if (e.ifConditions)
              for (var o = 1, s = e.ifConditions.length; o < s; o++) t(e.ifConditions[o].block, n)
          }
        }(t, !1))
      }
      var Ts = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/,
        _s = /\([^)]*?\);*$/,
        js = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,
        Ls = {
          esc: 27,
          tab: 9,
          enter: 13,
          space: 32,
          up: 38,
          left: 37,
          right: 39,
          down: 40,
          delete: [8, 46]
        },
        Ns = {
          esc: ["Esc", "Escape"],
          tab: "Tab",
          enter: "Enter",
          space: [" ", "Spacebar"],
          up: ["Up", "ArrowUp"],
          left: ["Left", "ArrowLeft"],
          right: ["Right", "ArrowRight"],
          down: ["Down", "ArrowDown"],
          delete: ["Backspace", "Delete", "Del"]
        },
        Fs = function(t) {
          return "if(" + t + ")return null;"
        },
        $s = {
          stop: "$event.stopPropagation();",
          prevent: "$event.preventDefault();",
          self: Fs("$event.target !== $event.currentTarget"),
          ctrl: Fs("!$event.ctrlKey"),
          shift: Fs("!$event.shiftKey"),
          alt: Fs("!$event.altKey"),
          meta: Fs("!$event.metaKey"),
          left: Fs("'button' in $event && $event.button !== 0"),
          middle: Fs("'button' in $event && $event.button !== 1"),
          right: Fs("'button' in $event && $event.button !== 2")
        };

      function Bs(t, e) {
        var n = e ? "nativeOn:" : "on:",
          r = "",
          i = "";
        for (var o in t) {
          var s = Is(t[o]);
          t[o] && t[o].dynamic ? i += o + "," + s + "," : r += '"' + o + '":' + s + ","
        }
        return r = "{" + r.slice(0, -1) + "}", i ? n + "_d(" + r + ",[" + i.slice(0, -1) + "])" : n + r
      }

      function Is(t) {
        if (!t) return "function(){}";
        if (Array.isArray(t)) return "[" + t.map(function(t) {
          return Is(t)
        }).join(",") + "]";
        var e = js.test(t.value),
          n = Ts.test(t.value),
          r = js.test(t.value.replace(_s, ""));
        if (t.modifiers) {
          var i = "",
            o = "",
            s = [];
          for (var a in t.modifiers)
            if ($s[a]) o += $s[a], Ls[a] && s.push(a);
            else if ("exact" === a) {
            var l = t.modifiers;
            o += Fs(["ctrl", "shift", "alt", "meta"].filter(function(t) {
              return !l[t]
            }).map(function(t) {
              return "$event." + t + "Key"
            }).join("||"))
          } else s.push(a);
          return s.length && (i += function(t) {
            return "if(!$event.type.indexOf('key')&&" + t.map(zs).join("&&") + ")return null;"
          }(s)), o && (i += o), "function($event){" + i + (e ? "return " + t.value + "($event)" : n ?
            "return (" + t.value + ")($event)" : r ? "return " + t.value : t.value) + "}"
        }
        return e || n ? t.value : "function($event){" + (r ? "return " + t.value : t.value) + "}"
      }

      function zs(t) {
        var e = parseInt(t, 10);
        if (e) return "$event.keyCode!==" + e;
        var n = Ls[t],
          r = Ns[t];
        return "_k($event.keyCode," + JSON.stringify(t) + "," + JSON.stringify(n) + ",$event.key," + JSON.stringify(
          r) + ")"
      }
      var Rs = {
          on: function(t, e) {
            t.wrapListeners = function(t) {
              return "_g(" + t + "," + e.value + ")"
            }
          },
          bind: function(t, e) {
            t.wrapData = function(n) {
              return "_b(" + n + ",'" + t.tag + "'," + e.value + "," + (e.modifiers && e.modifiers.prop ?
                "true" : "false") + (e.modifiers && e.modifiers.sync ? ",true" : "") + ")"
            }
          },
          cloak: T
        },
        Vs = function(t) {
          this.options = t, this.warn = t.warn || _r, this.transforms = jr(t.modules, "transformCode"), this.dataGenFns =
            jr(t.modules, "genData"), this.directives = P(P({}, Rs), t.directives);
          var e = t.isReservedTag || _;
          this.maybeComponent = function(t) {
            return !!t.component || !e(t.tag)
          }, this.onceId = 0, this.staticRenderFns = [], this.pre = !1
        };

      function Hs(t, e) {
        var n = new Vs(e);
        return {
          render: "with(this){return " + (t ? Gs(t, n) : '_c("div")') + "}",
          staticRenderFns: n.staticRenderFns
        }
      }

      function Gs(t, e) {
        if (t.parent && (t.pre = t.pre || t.parent.pre), t.staticRoot && !t.staticProcessed) return Us(t, e);
        if (t.once && !t.onceProcessed) return qs(t, e);
        if (t.for && !t.forProcessed) return Xs(t, e);
        if (t.if && !t.ifProcessed) return Ws(t, e);
        if ("template" !== t.tag || t.slotTarget || e.pre) {
          if ("slot" === t.tag) return function(t, e) {
            var n = t.slotName || '"default"',
              r = Ks(t, e),
              i = "_t(" + n + (r ? "," + r : ""),
              o = t.attrs || t.dynamicAttrs ? ea((t.attrs || []).concat(t.dynamicAttrs || []).map(function(
                t) {
                return {
                  name: A(t.name),
                  value: t.value,
                  dynamic: t.dynamic
                }
              })) : null,
              s = t.attrsMap["v-bind"];
            !o && !s || r || (i += ",null");
            o && (i += "," + o);
            s && (i += (o ? "" : ",null") + "," + s);
            return i + ")"
          }(t, e);
          var n;
          if (t.component) n = function(t, e, n) {
            var r = e.inlineTemplate ? null : Ks(e, n, !0);
            return "_c(" + t + "," + Ys(e, n) + (r ? "," + r : "") + ")"
          }(t.component, t, e);
          else {
            var r;
            (!t.plain || t.pre && e.maybeComponent(t)) && (r = Ys(t, e));
            var i = t.inlineTemplate ? null : Ks(t, e, !0);
            n = "_c('" + t.tag + "'" + (r ? "," + r : "") + (i ? "," + i : "") + ")"
          }
          for (var o = 0; o < e.transforms.length; o++) n = e.transforms[o](t, n);
          return n
        }
        return Ks(t, e) || "void 0"
      }

      function Us(t, e) {
        t.staticProcessed = !0;
        var n = e.pre;
        return t.pre && (e.pre = t.pre), e.staticRenderFns.push("with(this){return " + Gs(t, e) + "}"), e.pre =
          n, "_m(" + (e.staticRenderFns.length - 1) + (t.staticInFor ? ",true" : "") + ")"
      }

      function qs(t, e) {
        if (t.onceProcessed = !0, t.if && !t.ifProcessed) return Ws(t, e);
        if (t.staticInFor) {
          for (var n = "", r = t.parent; r;) {
            if (r.for) {
              n = r.key;
              break
            }
            r = r.parent
          }
          return n ? "_o(" + Gs(t, e) + "," + e.onceId++ + "," + n + ")" : Gs(t, e)
        }
        return Us(t, e)
      }

      function Ws(t, e, n, r) {
        return t.ifProcessed = !0,
          function t(e, n, r, i) {
            if (!e.length) return i || "_e()";
            var o = e.shift();
            return o.exp ? "(" + o.exp + ")?" + s(o.block) + ":" + t(e, n, r, i) : "" + s(o.block);

            function s(t) {
              return r ? r(t, n) : t.once ? qs(t, n) : Gs(t, n)
            }
          }(t.ifConditions.slice(), e, n, r)
      }

      function Xs(t, e, n, r) {
        var i = t.for,
          o = t.alias,
          s = t.iterator1 ? "," + t.iterator1 : "",
          a = t.iterator2 ? "," + t.iterator2 : "";
        return t.forProcessed = !0, (r || "_l") + "((" + i + "),function(" + o + s + a + "){return " + (n || Gs)
          (t, e) + "})"
      }

      function Ys(t, e) {
        var n = "{",
          r = function(t, e) {
            var n = t.directives;
            if (!n) return;
            var r, i, o, s, a = "directives:[",
              l = !1;
            for (r = 0, i = n.length; r < i; r++) {
              o = n[r], s = !0;
              var c = e.directives[o.name];
              c && (s = !!c(t, o, e.warn)), s && (l = !0, a += '{name:"' + o.name + '",rawName:"' + o.rawName +
                '"' + (o.value ? ",value:(" + o.value + "),expression:" + JSON.stringify(o.value) : "") + (o.arg ?
                  ",arg:" + (o.isDynamicArg ? o.arg : '"' + o.arg + '"') : "") + (o.modifiers ? ",modifiers:" +
                  JSON.stringify(o.modifiers) : "") + "},")
            }
            if (l) return a.slice(0, -1) + "]"
          }(t, e);
        r && (n += r + ","), t.key && (n += "key:" + t.key + ","), t.ref && (n += "ref:" + t.ref + ","), t.refInFor &&
          (n += "refInFor:true,"), t.pre && (n += "pre:true,"), t.component && (n += 'tag:"' + t.tag + '",');
        for (var i = 0; i < e.dataGenFns.length; i++) n += e.dataGenFns[i](t);
        if (t.attrs && (n += "attrs:" + ea(t.attrs) + ","), t.props && (n += "domProps:" + ea(t.props) + ","),
          t.events && (n += Bs(t.events, !1) + ","), t.nativeEvents && (n += Bs(t.nativeEvents, !0) + ","), t.slotTarget &&
          !t.slotScope && (n += "slot:" + t.slotTarget + ","), t.scopedSlots && (n += function(t, e, n) {
            var r = t.for || Object.keys(e).some(function(t) {
                var n = e[t];
                return n.slotTargetDynamic || n.if || n.for || Js(n)
              }),
              i = !!t.if;
            if (!r)
              for (var o = t.parent; o;) {
                if (o.slotScope && o.slotScope !== fs || o.for) {
                  r = !0;
                  break
                }
                o.if && (i = !0), o = o.parent
              }
            var s = Object.keys(e).map(function(t) {
              return Zs(e[t], n)
            }).join(",");
            return "scopedSlots:_u([" + s + "]" + (r ? ",null,true" : "") + (!r && i ? ",null,false," +
              function(t) {
                var e = 5381,
                  n = t.length;
                for (; n;) e = 33 * e ^ t.charCodeAt(--n);
                return e >>> 0
              }(s) : "") + ")"
          }(t, t.scopedSlots, e) + ","), t.model && (n += "model:{value:" + t.model.value + ",callback:" + t.model
            .callback + ",expression:" + t.model.expression + "},"), t.inlineTemplate) {
          var o = function(t, e) {
            var n = t.children[0];
            0;
            if (n && 1 === n.type) {
              var r = Hs(n, e.options);
              return "inlineTemplate:{render:function(){" + r.render + "},staticRenderFns:[" + r.staticRenderFns
                .map(function(t) {
                  return "function(){" + t + "}"
                }).join(",") + "]}"
            }
          }(t, e);
          o && (n += o + ",")
        }
        return n = n.replace(/,$/, "") + "}", t.dynamicAttrs && (n = "_b(" + n + ',"' + t.tag + '",' + ea(t.dynamicAttrs) +
          ")"), t.wrapData && (n = t.wrapData(n)), t.wrapListeners && (n = t.wrapListeners(n)), n
      }

      function Js(t) {
        return 1 === t.type && ("slot" === t.tag || t.children.some(Js))
      }

      function Zs(t, e) {
        var n = t.attrsMap["slot-scope"];
        if (t.if && !t.ifProcessed && !n) return Ws(t, e, Zs, "null");
        if (t.for && !t.forProcessed) return Xs(t, e, Zs);
        var r = t.slotScope === fs ? "" : String(t.slotScope),
          i = "function(" + r + "){return " + ("template" === t.tag ? t.if && n ? "(" + t.if+")?" + (Ks(t, e) ||
            "undefined") + ":undefined" : Ks(t, e) || "undefined" : Gs(t, e)) + "}",
          o = r ? "" : ",proxy:true";
        return "{key:" + (t.slotTarget || '"default"') + ",fn:" + i + o + "}"
      }

      function Ks(t, e, n, r, i) {
        var o = t.children;
        if (o.length) {
          var s = o[0];
          if (1 === o.length && s.for && "template" !== s.tag && "slot" !== s.tag) {
            var a = n ? e.maybeComponent(s) ? ",1" : ",0" : "";
            return "" + (r || Gs)(s, e) + a
          }
          var l = n ? function(t, e) {
              for (var n = 0, r = 0; r < t.length; r++) {
                var i = t[r];
                if (1 === i.type) {
                  if (Qs(i) || i.ifConditions && i.ifConditions.some(function(t) {
                      return Qs(t.block)
                    })) {
                    n = 2;
                    break
                  }(e(i) || i.ifConditions && i.ifConditions.some(function(t) {
                    return e(t.block)
                  })) && (n = 1)
                }
              }
              return n
            }(o, e.maybeComponent) : 0,
            c = i || ta;
          return "[" + o.map(function(t) {
            return c(t, e)
          }).join(",") + "]" + (l ? "," + l : "")
        }
      }

      function Qs(t) {
        return void 0 !== t.for || "template" === t.tag || "slot" === t.tag
      }

      function ta(t, e) {
        return 1 === t.type ? Gs(t, e) : 3 === t.type && t.isComment ? (r = t, "_e(" + JSON.stringify(r.text) +
          ")") : "_v(" + (2 === (n = t).type ? n.expression : na(JSON.stringify(n.text))) + ")";
        var n, r
      }

      function ea(t) {
        for (var e = "", n = "", r = 0; r < t.length; r++) {
          var i = t[r],
            o = na(i.value);
          i.dynamic ? n += i.name + "," + o + "," : e += '"' + i.name + '":' + o + ","
        }
        return e = "{" + e.slice(0, -1) + "}", n ? "_d(" + e + ",[" + n.slice(0, -1) + "])" : e
      }

      function na(t) {
        return t.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029")
      }
      new RegExp("\\b" +
        "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments"
        .split(",").join("\\b|\\b") + "\\b"), new RegExp("\\b" + "delete,typeof,void".split(",").join(
        "\\s*\\([^\\)]*\\)|\\b") + "\\s*\\([^\\)]*\\)");

      function ra(t, e) {
        try {
          return new Function(t)
        } catch (n) {
          return e.push({
            err: n,
            code: t
          }), T
        }
      }

      function ia(t) {
        var e = Object.create(null);
        return function(n, r, i) {
          (r = P({}, r)).warn;
          delete r.warn;
          var o = r.delimiters ? String(r.delimiters) + n : n;
          if (e[o]) return e[o];
          var s = t(n, r);
          var a = {},
            l = [];
          return a.render = ra(s.render, l), a.staticRenderFns = s.staticRenderFns.map(function(t) {
            return ra(t, l)
          }), e[o] = a
        }
      }
      var oa, sa, aa = (oa = function(t, e) {
          var n = ms(t.trim(), e);
          !1 !== e.optimize && Ds(n, e);
          var r = Hs(n, e);
          return {
            ast: n,
            render: r.render,
            staticRenderFns: r.staticRenderFns
          }
        }, function(t) {
          function e(e, n) {
            var r = Object.create(t),
              i = [],
              o = [],
              s = function(t, e, n) {
                (n ? o : i).push(t)
              };
            if (n)
              for (var a in n.modules && (r.modules = (t.modules || []).concat(n.modules)), n.directives && (
                  r.directives = P(Object.create(t.directives || null), n.directives)), n) "modules" !== a &&
                "directives" !== a && (r[a] = n[a]);
            r.warn = s;
            var l = oa(e.trim(), r);
            return l.errors = i, l.tips = o, l
          }
          return {
            compile: e,
            compileToFunctions: ia(e)
          }
        })(Os),
        la = (aa.compile, aa.compileToFunctions);

      function ca(t) {
        return (sa = sa || document.createElement("div")).innerHTML = t ? '<a href="\n"/>' : '<div a="\n"/>',
          sa.innerHTML.indexOf("&#10;") > 0
      }
      var ha = !!W && ca(!1),
        ua = !!W && ca(!0),
        da = x(function(t) {
          var e = nr(t);
          return e && e.innerHTML
        }),
        pa = Mn.prototype.$mount;
      Mn.prototype.$mount = function(t, e) {
        if ((t = t && nr(t)) === document.body || t === document.documentElement) return this;
        var n = this.$options;
        if (!n.render) {
          var r = n.template;
          if (r)
            if ("string" == typeof r) "#" === r.charAt(0) && (r = da(r));
            else {
              if (!r.nodeType) return this;
              r = r.innerHTML
            }
          else t && (r = function(t) {
            if (t.outerHTML) return t.outerHTML;
            var e = document.createElement("div");
            return e.appendChild(t.cloneNode(!0)), e.innerHTML
          }(t));
          if (r) {
            0;
            var i = la(r, {
                outputSourceRange: !1,
                shouldDecodeNewlines: ha,
                shouldDecodeNewlinesForHref: ua,
                delimiters: n.delimiters,
                comments: n.comments
              }, this),
              o = i.render,
              s = i.staticRenderFns;
            n.render = o, n.staticRenderFns = s
          }
        }
        return pa.call(this, t, e)
      }, Mn.compile = la, e.a = Mn
    }).call(e, n("DuR2"))
  },
  "7t+N": function(t, e, n) {
    var r;
    /*!
     * jQuery JavaScript Library v3.5.1
     * https://jquery.com/
     *
     * Includes Sizzle.js
     * https://sizzlejs.com/
     *
     * Copyright JS Foundation and other contributors
     * Released under the MIT license
     * https://jquery.org/license
     *
     * Date: 2020-05-04T22:49Z
     */
    /*!
     * jQuery JavaScript Library v3.5.1
     * https://jquery.com/
     *
     * Includes Sizzle.js
     * https://sizzlejs.com/
     *
     * Copyright JS Foundation and other contributors
     * Released under the MIT license
     * https://jquery.org/license
     *
     * Date: 2020-05-04T22:49Z
     */
    ! function(e, n) {
      "use strict";
      "object" == typeof t && "object" == typeof t.exports ? t.exports = e.document ? n(e, !0) : function(t) {
        if (!t.document) throw new Error("jQuery requires a window with a document");
        return n(t)
      } : n(e)
    }("undefined" != typeof window ? window : this, function(n, i) {
      "use strict";
      var o = [],
        s = Object.getPrototypeOf,
        a = o.slice,
        l = o.flat ? function(t) {
          return o.flat.call(t)
        } : function(t) {
          return o.concat.apply([], t)
        },
        c = o.push,
        h = o.indexOf,
        u = {},
        d = u.toString,
        p = u.hasOwnProperty,
        f = p.toString,
        g = f.call(Object),
        m = {},
        v = function(t) {
          return "function" == typeof t && "number" != typeof t.nodeType
        },
        y = function(t) {
          return null != t && t === t.window
        },
        b = n.document,
        C = {
          type: !0,
          src: !0,
          nonce: !0,
          noModule: !0
        };

      function x(t, e, n) {
        var r, i, o = (n = n || b).createElement("script");
        if (o.text = t, e)
          for (r in C)(i = e[r] || e.getAttribute && e.getAttribute(r)) && o.setAttribute(r, i);
        n.head.appendChild(o).parentNode.removeChild(o)
      }

      function w(t) {
        return null == t ? t + "" : "object" == typeof t || "function" == typeof t ? u[d.call(t)] || "object" :
          typeof t
      }
      var A = function(t, e) {
        return new A.fn.init(t, e)
      };

      function E(t) {
        var e = !!t && "length" in t && t.length,
          n = w(t);
        return !v(t) && !y(t) && ("array" === n || 0 === e || "number" == typeof e && e > 0 && e - 1 in t)
      }
      A.fn = A.prototype = {
        jquery: "3.5.1",
        constructor: A,
        length: 0,
        toArray: function() {
          return a.call(this)
        },
        get: function(t) {
          return null == t ? a.call(this) : t < 0 ? this[t + this.length] : this[t]
        },
        pushStack: function(t) {
          var e = A.merge(this.constructor(), t);
          return e.prevObject = this, e
        },
        each: function(t) {
          return A.each(this, t)
        },
        map: function(t) {
          return this.pushStack(A.map(this, function(e, n) {
            return t.call(e, n, e)
          }))
        },
        slice: function() {
          return this.pushStack(a.apply(this, arguments))
        },
        first: function() {
          return this.eq(0)
        },
        last: function() {
          return this.eq(-1)
        },
        even: function() {
          return this.pushStack(A.grep(this, function(t, e) {
            return (e + 1) % 2
          }))
        },
        odd: function() {
          return this.pushStack(A.grep(this, function(t, e) {
            return e % 2
          }))
        },
        eq: function(t) {
          var e = this.length,
            n = +t + (t < 0 ? e : 0);
          return this.pushStack(n >= 0 && n < e ? [this[n]] : [])
        },
        end: function() {
          return this.prevObject || this.constructor()
        },
        push: c,
        sort: o.sort,
        splice: o.splice
      }, A.extend = A.fn.extend = function() {
        var t, e, n, r, i, o, s = arguments[0] || {},
          a = 1,
          l = arguments.length,
          c = !1;
        for ("boolean" == typeof s && (c = s, s = arguments[a] || {}, a++), "object" == typeof s || v(s) || (
            s = {}), a === l && (s = this, a--); a < l; a++)
          if (null != (t = arguments[a]))
            for (e in t) r = t[e], "__proto__" !== e && s !== r && (c && r && (A.isPlainObject(r) || (i =
              Array.isArray(r))) ? (n = s[e], o = i && !Array.isArray(n) ? [] : i || A.isPlainObject(n) ?
              n : {}, i = !1, s[e] = A.extend(c, o, r)) : void 0 !== r && (s[e] = r));
        return s
      }, A.extend({
        expando: "jQuery" + ("3.5.1" + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function(t) {
          throw new Error(t)
        },
        noop: function() {},
        isPlainObject: function(t) {
          var e, n;
          return !(!t || "[object Object]" !== d.call(t)) && (!(e = s(t)) || "function" == typeof(n = p.call(
            e, "constructor") && e.constructor) && f.call(n) === g)
        },
        isEmptyObject: function(t) {
          var e;
          for (e in t) return !1;
          return !0
        },
        globalEval: function(t, e, n) {
          x(t, {
            nonce: e && e.nonce
          }, n)
        },
        each: function(t, e) {
          var n, r = 0;
          if (E(t))
            for (n = t.length; r < n && !1 !== e.call(t[r], r, t[r]); r++);
          else
            for (r in t)
              if (!1 === e.call(t[r], r, t[r])) break;
          return t
        },
        makeArray: function(t, e) {
          var n = e || [];
          return null != t && (E(Object(t)) ? A.merge(n, "string" == typeof t ? [t] : t) : c.call(n, t)),
            n
        },
        inArray: function(t, e, n) {
          return null == e ? -1 : h.call(e, t, n)
        },
        merge: function(t, e) {
          for (var n = +e.length, r = 0, i = t.length; r < n; r++) t[i++] = e[r];
          return t.length = i, t
        },
        grep: function(t, e, n) {
          for (var r = [], i = 0, o = t.length, s = !n; i < o; i++) !e(t[i], i) !== s && r.push(t[i]);
          return r
        },
        map: function(t, e, n) {
          var r, i, o = 0,
            s = [];
          if (E(t))
            for (r = t.length; o < r; o++) null != (i = e(t[o], o, n)) && s.push(i);
          else
            for (o in t) null != (i = e(t[o], o, n)) && s.push(i);
          return l(s)
        },
        guid: 1,
        support: m
      }), "function" == typeof Symbol && (A.fn[Symbol.iterator] = o[Symbol.iterator]), A.each(
        "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
        function(t, e) {
          u["[object " + e + "]"] = e.toLowerCase()
        });
      var S =
        /*!
         * Sizzle CSS Selector Engine v2.3.5
         * https://sizzlejs.com/
         *
         * Copyright JS Foundation and other contributors
         * Released under the MIT license
         * https://js.foundation/
         *
         * Date: 2020-03-14
         */
        function(t) {
          var e, n, r, i, o, s, a, l, c, h, u, d, p, f, g, m, v, y, b, C = "sizzle" + 1 * new Date,
            x = t.document,
            w = 0,
            A = 0,
            E = lt(),
            S = lt(),
            M = lt(),
            k = lt(),
            O = function(t, e) {
              return t === e && (u = !0), 0
            },
            P = {}.hasOwnProperty,
            D = [],
            T = D.pop,
            _ = D.push,
            j = D.push,
            L = D.slice,
            N = function(t, e) {
              for (var n = 0, r = t.length; n < r; n++)
                if (t[n] === e) return n;
              return -1
            },
            F =
            "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
            $ = "[\\x20\\t\\r\\n\\f]",
            B = "(?:\\\\[\\da-fA-F]{1,6}" + $ + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
            I = "\\[" + $ + "*(" + B + ")(?:" + $ + "*([*^$|!~]?=)" + $ +
            "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + B + "))|)" + $ + "*\\]",
            z = ":(" + B +
            ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + I +
            ")*)|.*)\\)|)",
            R = new RegExp($ + "+", "g"),
            V = new RegExp("^" + $ + "+|((?:^|[^\\\\])(?:\\\\.)*)" + $ + "+$", "g"),
            H = new RegExp("^" + $ + "*," + $ + "*"),
            G = new RegExp("^" + $ + "*([>+~]|" + $ + ")" + $ + "*"),
            U = new RegExp($ + "|>"),
            q = new RegExp(z),
            W = new RegExp("^" + B + "$"),
            X = {
              ID: new RegExp("^#(" + B + ")"),
              CLASS: new RegExp("^\\.(" + B + ")"),
              TAG: new RegExp("^(" + B + "|[*])"),
              ATTR: new RegExp("^" + I),
              PSEUDO: new RegExp("^" + z),
              CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + $ +
                "*(even|odd|(([+-]|)(\\d*)n|)" + $ + "*(?:([+-]|)" + $ + "*(\\d+)|))" + $ + "*\\)|)", "i"),
              bool: new RegExp("^(?:" + F + ")$", "i"),
              needsContext: new RegExp("^" + $ + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + $ +
                "*((?:-\\d)?\\d*)" + $ + "*\\)|)(?=[^-]|$)", "i")
            },
            Y = /HTML$/i,
            J = /^(?:input|select|textarea|button)$/i,
            Z = /^h\d$/i,
            K = /^[^{]+\{\s*\[native \w/,
            Q = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
            tt = /[+~]/,
            et = new RegExp("\\\\[\\da-fA-F]{1,6}" + $ + "?|\\\\([^\\r\\n\\f])", "g"),
            nt = function(t, e) {
              var n = "0x" + t.slice(1) - 65536;
              return e || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 &
                n | 56320))
            },
            rt = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
            it = function(t, e) {
              return e ? "\0" === t ? "�" : t.slice(0, -1) + "\\" + t.charCodeAt(t.length - 1).toString(16) +
                " " : "\\" + t
            },
            ot = function() {
              d()
            },
            st = Ct(function(t) {
              return !0 === t.disabled && "fieldset" === t.nodeName.toLowerCase()
            }, {
              dir: "parentNode",
              next: "legend"
            });
          try {
            j.apply(D = L.call(x.childNodes), x.childNodes), D[x.childNodes.length].nodeType
          } catch (t) {
            j = {
              apply: D.length ? function(t, e) {
                _.apply(t, L.call(e))
              } : function(t, e) {
                for (var n = t.length, r = 0; t[n++] = e[r++];);
                t.length = n - 1
              }
            }
          }

          function at(t, e, r, i) {
            var o, a, c, h, u, f, v, y = e && e.ownerDocument,
              x = e ? e.nodeType : 9;
            if (r = r || [], "string" != typeof t || !t || 1 !== x && 9 !== x && 11 !== x) return r;
            if (!i && (d(e), e = e || p, g)) {
              if (11 !== x && (u = Q.exec(t)))
                if (o = u[1]) {
                  if (9 === x) {
                    if (!(c = e.getElementById(o))) return r;
                    if (c.id === o) return r.push(c), r
                  } else if (y && (c = y.getElementById(o)) && b(e, c) && c.id === o) return r.push(c), r
                } else {
                  if (u[2]) return j.apply(r, e.getElementsByTagName(t)), r;
                  if ((o = u[3]) && n.getElementsByClassName && e.getElementsByClassName) return j.apply(r, e.getElementsByClassName(
                    o)), r
                } if (n.qsa && !k[t + " "] && (!m || !m.test(t)) && (1 !== x || "object" !== e.nodeName.toLowerCase())) {
                if (v = t, y = e, 1 === x && (U.test(t) || G.test(t))) {
                  for ((y = tt.test(t) && vt(e.parentNode) || e) === e && n.scope || ((h = e.getAttribute("id")) ?
                      h = h.replace(rt, it) : e.setAttribute("id", h = C)), a = (f = s(t)).length; a--;) f[a] =
                    (h ? "#" + h : ":scope") + " " + bt(f[a]);
                  v = f.join(",")
                }
                try {
                  return j.apply(r, y.querySelectorAll(v)), r
                } catch (e) {
                  k(t, !0)
                } finally {
                  h === C && e.removeAttribute("id")
                }
              }
            }
            return l(t.replace(V, "$1"), e, r, i)
          }

          function lt() {
            var t = [];
            return function e(n, i) {
              return t.push(n + " ") > r.cacheLength && delete e[t.shift()], e[n + " "] = i
            }
          }

          function ct(t) {
            return t[C] = !0, t
          }

          function ht(t) {
            var e = p.createElement("fieldset");
            try {
              return !!t(e)
            } catch (t) {
              return !1
            } finally {
              e.parentNode && e.parentNode.removeChild(e), e = null
            }
          }

          function ut(t, e) {
            for (var n = t.split("|"), i = n.length; i--;) r.attrHandle[n[i]] = e
          }

          function dt(t, e) {
            var n = e && t,
              r = n && 1 === t.nodeType && 1 === e.nodeType && t.sourceIndex - e.sourceIndex;
            if (r) return r;
            if (n)
              for (; n = n.nextSibling;)
                if (n === e) return -1;
            return t ? 1 : -1
          }

          function pt(t) {
            return function(e) {
              return "input" === e.nodeName.toLowerCase() && e.type === t
            }
          }

          function ft(t) {
            return function(e) {
              var n = e.nodeName.toLowerCase();
              return ("input" === n || "button" === n) && e.type === t
            }
          }

          function gt(t) {
            return function(e) {
              return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ?
                e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t &&
                st(e) === t : e.disabled === t : "label" in e && e.disabled === t
            }
          }

          function mt(t) {
            return ct(function(e) {
              return e = +e, ct(function(n, r) {
                for (var i, o = t([], n.length, e), s = o.length; s--;) n[i = o[s]] && (n[i] = !(r[i] =
                  n[i]))
              })
            })
          }

          function vt(t) {
            return t && void 0 !== t.getElementsByTagName && t
          }
          for (e in n = at.support = {}, o = at.isXML = function(t) {
              var e = t.namespaceURI,
                n = (t.ownerDocument || t).documentElement;
              return !Y.test(e || n && n.nodeName || "HTML")
            }, d = at.setDocument = function(t) {
              var e, i, s = t ? t.ownerDocument || t : x;
              return s != p && 9 === s.nodeType && s.documentElement ? (f = (p = s).documentElement, g = !o(p),
                x != p && (i = p.defaultView) && i.top !== i && (i.addEventListener ? i.addEventListener(
                  "unload", ot, !1) : i.attachEvent && i.attachEvent("onunload", ot)), n.scope = ht(function(
                  t) {
                  return f.appendChild(t).appendChild(p.createElement("div")), void 0 !== t.querySelectorAll &&
                    !t.querySelectorAll(":scope fieldset div").length
                }), n.attributes = ht(function(t) {
                  return t.className = "i", !t.getAttribute("className")
                }), n.getElementsByTagName = ht(function(t) {
                  return t.appendChild(p.createComment("")), !t.getElementsByTagName("*").length
                }), n.getElementsByClassName = K.test(p.getElementsByClassName), n.getById = ht(function(t) {
                  return f.appendChild(t).id = C, !p.getElementsByName || !p.getElementsByName(C).length
                }), n.getById ? (r.filter.ID = function(t) {
                  var e = t.replace(et, nt);
                  return function(t) {
                    return t.getAttribute("id") === e
                  }
                }, r.find.ID = function(t, e) {
                  if (void 0 !== e.getElementById && g) {
                    var n = e.getElementById(t);
                    return n ? [n] : []
                  }
                }) : (r.filter.ID = function(t) {
                  var e = t.replace(et, nt);
                  return function(t) {
                    var n = void 0 !== t.getAttributeNode && t.getAttributeNode("id");
                    return n && n.value === e
                  }
                }, r.find.ID = function(t, e) {
                  if (void 0 !== e.getElementById && g) {
                    var n, r, i, o = e.getElementById(t);
                    if (o) {
                      if ((n = o.getAttributeNode("id")) && n.value === t) return [o];
                      for (i = e.getElementsByName(t), r = 0; o = i[r++];)
                        if ((n = o.getAttributeNode("id")) && n.value === t) return [o]
                    }
                    return []
                  }
                }), r.find.TAG = n.getElementsByTagName ? function(t, e) {
                  return void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t) : n.qsa ? e.querySelectorAll(
                    t) : void 0
                } : function(t, e) {
                  var n, r = [],
                    i = 0,
                    o = e.getElementsByTagName(t);
                  if ("*" === t) {
                    for (; n = o[i++];) 1 === n.nodeType && r.push(n);
                    return r
                  }
                  return o
                }, r.find.CLASS = n.getElementsByClassName && function(t, e) {
                  if (void 0 !== e.getElementsByClassName && g) return e.getElementsByClassName(t)
                }, v = [], m = [], (n.qsa = K.test(p.querySelectorAll)) && (ht(function(t) {
                  var e;
                  f.appendChild(t).innerHTML = "<a id='" + C + "'></a><select id='" + C +
                    "-\r\\' msallowcapture=''><option selected=''></option></select>", t.querySelectorAll(
                      "[msallowcapture^='']").length && m.push("[*^$]=" + $ + "*(?:''|\"\")"), t.querySelectorAll(
                      "[selected]").length || m.push("\\[" + $ + "*(?:value|" + F + ")"), t.querySelectorAll(
                      "[id~=" + C + "-]").length || m.push("~="), (e = p.createElement("input")).setAttribute(
                      "name", ""), t.appendChild(e), t.querySelectorAll("[name='']").length || m.push(
                      "\\[" + $ + "*name" + $ + "*=" + $ + "*(?:''|\"\")"), t.querySelectorAll(":checked")
                    .length || m.push(":checked"), t.querySelectorAll("a#" + C + "+*").length || m.push(
                      ".#.+[+~]"), t.querySelectorAll("\\\f"), m.push("[\\r\\n\\f]")
                }), ht(function(t) {
                  t.innerHTML =
                    "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                  var e = p.createElement("input");
                  e.setAttribute("type", "hidden"), t.appendChild(e).setAttribute("name", "D"), t.querySelectorAll(
                      "[name=d]").length && m.push("name" + $ + "*[*^$|!~]?="), 2 !== t.querySelectorAll(
                      ":enabled").length && m.push(":enabled", ":disabled"), f.appendChild(t).disabled = !
                    0, 2 !== t.querySelectorAll(":disabled").length && m.push(":enabled", ":disabled"), t
                    .querySelectorAll("*,:x"), m.push(",.*:")
                })), (n.matchesSelector = K.test(y = f.matches || f.webkitMatchesSelector || f.mozMatchesSelector ||
                  f.oMatchesSelector || f.msMatchesSelector)) && ht(function(t) {
                  n.disconnectedMatch = y.call(t, "*"), y.call(t, "[s!='']:x"), v.push("!=", z)
                }), m = m.length && new RegExp(m.join("|")), v = v.length && new RegExp(v.join("|")), e = K.test(
                  f.compareDocumentPosition), b = e || K.test(f.contains) ? function(t, e) {
                  var n = 9 === t.nodeType ? t.documentElement : t,
                    r = e && e.parentNode;
                  return t === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : t.compareDocumentPosition &&
                    16 & t.compareDocumentPosition(r)))
                } : function(t, e) {
                  if (e)
                    for (; e = e.parentNode;)
                      if (e === t) return !0;
                  return !1
                }, O = e ? function(t, e) {
                  if (t === e) return u = !0, 0;
                  var r = !t.compareDocumentPosition - !e.compareDocumentPosition;
                  return r || (1 & (r = (t.ownerDocument || t) == (e.ownerDocument || e) ? t.compareDocumentPosition(
                      e) : 1) || !n.sortDetached && e.compareDocumentPosition(t) === r ? t == p || t.ownerDocument ==
                    x && b(x, t) ? -1 : e == p || e.ownerDocument == x && b(x, e) ? 1 : h ? N(h, t) - N(h,
                      e) : 0 : 4 & r ? -1 : 1)
                } : function(t, e) {
                  if (t === e) return u = !0, 0;
                  var n, r = 0,
                    i = t.parentNode,
                    o = e.parentNode,
                    s = [t],
                    a = [e];
                  if (!i || !o) return t == p ? -1 : e == p ? 1 : i ? -1 : o ? 1 : h ? N(h, t) - N(h, e) : 0;
                  if (i === o) return dt(t, e);
                  for (n = t; n = n.parentNode;) s.unshift(n);
                  for (n = e; n = n.parentNode;) a.unshift(n);
                  for (; s[r] === a[r];) r++;
                  return r ? dt(s[r], a[r]) : s[r] == x ? -1 : a[r] == x ? 1 : 0
                }, p) : p
            }, at.matches = function(t, e) {
              return at(t, null, null, e)
            }, at.matchesSelector = function(t, e) {
              if (d(t), n.matchesSelector && g && !k[e + " "] && (!v || !v.test(e)) && (!m || !m.test(e))) try {
                var r = y.call(t, e);
                if (r || n.disconnectedMatch || t.document && 11 !== t.document.nodeType) return r
              } catch (t) {
                k(e, !0)
              }
              return at(e, p, null, [t]).length > 0
            }, at.contains = function(t, e) {
              return (t.ownerDocument || t) != p && d(t), b(t, e)
            }, at.attr = function(t, e) {
              (t.ownerDocument || t) != p && d(t);
              var i = r.attrHandle[e.toLowerCase()],
                o = i && P.call(r.attrHandle, e.toLowerCase()) ? i(t, e, !g) : void 0;
              return void 0 !== o ? o : n.attributes || !g ? t.getAttribute(e) : (o = t.getAttributeNode(e)) &&
                o.specified ? o.value : null
            }, at.escape = function(t) {
              return (t + "").replace(rt, it)
            }, at.error = function(t) {
              throw new Error("Syntax error, unrecognized expression: " + t)
            }, at.uniqueSort = function(t) {
              var e, r = [],
                i = 0,
                o = 0;
              if (u = !n.detectDuplicates, h = !n.sortStable && t.slice(0), t.sort(O), u) {
                for (; e = t[o++];) e === t[o] && (i = r.push(o));
                for (; i--;) t.splice(r[i], 1)
              }
              return h = null, t
            }, i = at.getText = function(t) {
              var e, n = "",
                r = 0,
                o = t.nodeType;
              if (o) {
                if (1 === o || 9 === o || 11 === o) {
                  if ("string" == typeof t.textContent) return t.textContent;
                  for (t = t.firstChild; t; t = t.nextSibling) n += i(t)
                } else if (3 === o || 4 === o) return t.nodeValue
              } else
                for (; e = t[r++];) n += i(e);
              return n
            }, (r = at.selectors = {
              cacheLength: 50,
              createPseudo: ct,
              match: X,
              attrHandle: {},
              find: {},
              relative: {
                ">": {
                  dir: "parentNode",
                  first: !0
                },
                " ": {
                  dir: "parentNode"
                },
                "+": {
                  dir: "previousSibling",
                  first: !0
                },
                "~": {
                  dir: "previousSibling"
                }
              },
              preFilter: {
                ATTR: function(t) {
                  return t[1] = t[1].replace(et, nt), t[3] = (t[3] || t[4] || t[5] || "").replace(et, nt),
                    "~=" === t[2] && (t[3] = " " + t[3] + " "), t.slice(0, 4)
                },
                CHILD: function(t) {
                  return t[1] = t[1].toLowerCase(), "nth" === t[1].slice(0, 3) ? (t[3] || at.error(t[0]), t[
                      4] = +(t[4] ? t[5] + (t[6] || 1) : 2 * ("even" === t[3] || "odd" === t[3])), t[5] = +
                    (t[7] + t[8] || "odd" === t[3])) : t[3] && at.error(t[0]), t
                },
                PSEUDO: function(t) {
                  var e, n = !t[6] && t[2];
                  return X.CHILD.test(t[0]) ? null : (t[3] ? t[2] = t[4] || t[5] || "" : n && q.test(n) &&
                    (e = s(n, !0)) && (e = n.indexOf(")", n.length - e) - n.length) && (t[0] = t[0].slice(
                      0, e), t[2] = n.slice(0, e)), t.slice(0, 3))
                }
              },
              filter: {
                TAG: function(t) {
                  var e = t.replace(et, nt).toLowerCase();
                  return "*" === t ? function() {
                    return !0
                  } : function(t) {
                    return t.nodeName && t.nodeName.toLowerCase() === e
                  }
                },
                CLASS: function(t) {
                  var e = E[t + " "];
                  return e || (e = new RegExp("(^|" + $ + ")" + t + "(" + $ + "|$)")) && E(t, function(t) {
                    return e.test("string" == typeof t.className && t.className || void 0 !== t.getAttribute &&
                      t.getAttribute("class") || "")
                  })
                },
                ATTR: function(t, e, n) {
                  return function(r) {
                    var i = at.attr(r, t);
                    return null == i ? "!=" === e : !e || (i += "", "=" === e ? i === n : "!=" === e ? i !==
                      n : "^=" === e ? n && 0 === i.indexOf(n) : "*=" === e ? n && i.indexOf(n) > -1 :
                      "$=" === e ? n && i.slice(-n.length) === n : "~=" === e ? (" " + i.replace(R, " ") +
                        " ").indexOf(n) > -1 : "|=" === e && (i === n || i.slice(0, n.length + 1) ===
                        n + "-"))
                  }
                },
                CHILD: function(t, e, n, r, i) {
                  var o = "nth" !== t.slice(0, 3),
                    s = "last" !== t.slice(-4),
                    a = "of-type" === e;
                  return 1 === r && 0 === i ? function(t) {
                    return !!t.parentNode
                  } : function(e, n, l) {
                    var c, h, u, d, p, f, g = o !== s ? "nextSibling" : "previousSibling",
                      m = e.parentNode,
                      v = a && e.nodeName.toLowerCase(),
                      y = !l && !a,
                      b = !1;
                    if (m) {
                      if (o) {
                        for (; g;) {
                          for (d = e; d = d[g];)
                            if (a ? d.nodeName.toLowerCase() === v : 1 === d.nodeType) return !1;
                          f = g = "only" === t && !f && "nextSibling"
                        }
                        return !0
                      }
                      if (f = [s ? m.firstChild : m.lastChild], s && y) {
                        for (b = (p = (c = (h = (u = (d = m)[C] || (d[C] = {}))[d.uniqueID] || (u[d.uniqueID] = {}))[
                            t] || [])[0] === w && c[1]) && c[2], d = p && m.childNodes[p]; d = ++p && d &&
                          d[g] || (b = p = 0) || f.pop();)
                          if (1 === d.nodeType && ++b && d === e) {
                            h[t] = [w, p, b];
                            break
                          }
                      } else if (y && (b = p = (c = (h = (u = (d = e)[C] || (d[C] = {}))[d.uniqueID] || (
                          u[d.uniqueID] = {}))[t] || [])[0] === w && c[1]), !1 === b)
                        for (;
                          (d = ++p && d && d[g] || (b = p = 0) || f.pop()) && ((a ? d.nodeName.toLowerCase() !==
                            v : 1 !== d.nodeType) || !++b || (y && ((h = (u = d[C] || (d[C] = {}))[d.uniqueID] ||
                            (u[d.uniqueID] = {}))[t] = [w, b]), d !== e)););
                      return (b -= i) === r || b % r == 0 && b / r >= 0
                    }
                  }
                },
                PSEUDO: function(t, e) {
                  var n, i = r.pseudos[t] || r.setFilters[t.toLowerCase()] || at.error(
                    "unsupported pseudo: " + t);
                  return i[C] ? i(e) : i.length > 1 ? (n = [t, t, "", e], r.setFilters.hasOwnProperty(t.toLowerCase()) ?
                    ct(function(t, n) {
                      for (var r, o = i(t, e), s = o.length; s--;) t[r = N(t, o[s])] = !(n[r] = o[s])
                    }) : function(t) {
                      return i(t, 0, n)
                    }) : i
                }
              },
              pseudos: {
                not: ct(function(t) {
                  var e = [],
                    n = [],
                    r = a(t.replace(V, "$1"));
                  return r[C] ? ct(function(t, e, n, i) {
                    for (var o, s = r(t, null, i, []), a = t.length; a--;)(o = s[a]) && (t[a] = !(e[a] =
                      o))
                  }) : function(t, i, o) {
                    return e[0] = t, r(e, null, o, n), e[0] = null, !n.pop()
                  }
                }),
                has: ct(function(t) {
                  return function(e) {
                    return at(t, e).length > 0
                  }
                }),
                contains: ct(function(t) {
                  return t = t.replace(et, nt),
                    function(e) {
                      return (e.textContent || i(e)).indexOf(t) > -1
                    }
                }),
                lang: ct(function(t) {
                  return W.test(t || "") || at.error("unsupported lang: " + t), t = t.replace(et, nt).toLowerCase(),
                    function(e) {
                      var n;
                      do {
                        if (n = g ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (
                          n = n.toLowerCase()) === t || 0 === n.indexOf(t + "-")
                      } while ((e = e.parentNode) && 1 === e.nodeType);
                      return !1
                    }
                }),
                target: function(e) {
                  var n = t.location && t.location.hash;
                  return n && n.slice(1) === e.id
                },
                root: function(t) {
                  return t === f
                },
                focus: function(t) {
                  return t === p.activeElement && (!p.hasFocus || p.hasFocus()) && !!(t.type || t.href || ~
                    t.tabIndex)
                },
                enabled: gt(!1),
                disabled: gt(!0),
                checked: function(t) {
                  var e = t.nodeName.toLowerCase();
                  return "input" === e && !!t.checked || "option" === e && !!t.selected
                },
                selected: function(t) {
                  return t.parentNode && t.parentNode.selectedIndex, !0 === t.selected
                },
                empty: function(t) {
                  for (t = t.firstChild; t; t = t.nextSibling)
                    if (t.nodeType < 6) return !1;
                  return !0
                },
                parent: function(t) {
                  return !r.pseudos.empty(t)
                },
                header: function(t) {
                  return Z.test(t.nodeName)
                },
                input: function(t) {
                  return J.test(t.nodeName)
                },
                button: function(t) {
                  var e = t.nodeName.toLowerCase();
                  return "input" === e && "button" === t.type || "button" === e
                },
                text: function(t) {
                  var e;
                  return "input" === t.nodeName.toLowerCase() && "text" === t.type && (null == (e = t.getAttribute(
                    "type")) || "text" === e.toLowerCase())
                },
                first: mt(function() {
                  return [0]
                }),
                last: mt(function(t, e) {
                  return [e - 1]
                }),
                eq: mt(function(t, e, n) {
                  return [n < 0 ? n + e : n]
                }),
                even: mt(function(t, e) {
                  for (var n = 0; n < e; n += 2) t.push(n);
                  return t
                }),
                odd: mt(function(t, e) {
                  for (var n = 1; n < e; n += 2) t.push(n);
                  return t
                }),
                lt: mt(function(t, e, n) {
                  for (var r = n < 0 ? n + e : n > e ? e : n; --r >= 0;) t.push(r);
                  return t
                }),
                gt: mt(function(t, e, n) {
                  for (var r = n < 0 ? n + e : n; ++r < e;) t.push(r);
                  return t
                })
              }
            }).pseudos.nth = r.pseudos.eq, {
              radio: !0,
              checkbox: !0,
              file: !0,
              password: !0,
              image: !0
            }) r.pseudos[e] = pt(e);
          for (e in {
              submit: !0,
              reset: !0
            }) r.pseudos[e] = ft(e);

          function yt() {}

          function bt(t) {
            for (var e = 0, n = t.length, r = ""; e < n; e++) r += t[e].value;
            return r
          }

          function Ct(t, e, n) {
            var r = e.dir,
              i = e.next,
              o = i || r,
              s = n && "parentNode" === o,
              a = A++;
            return e.first ? function(e, n, i) {
              for (; e = e[r];)
                if (1 === e.nodeType || s) return t(e, n, i);
              return !1
            } : function(e, n, l) {
              var c, h, u, d = [w, a];
              if (l) {
                for (; e = e[r];)
                  if ((1 === e.nodeType || s) && t(e, n, l)) return !0
              } else
                for (; e = e[r];)
                  if (1 === e.nodeType || s)
                    if (h = (u = e[C] || (e[C] = {}))[e.uniqueID] || (u[e.uniqueID] = {}), i && i === e.nodeName
                      .toLowerCase()) e = e[r] || e;
                    else {
                      if ((c = h[o]) && c[0] === w && c[1] === a) return d[2] = c[2];
                      if (h[o] = d, d[2] = t(e, n, l)) return !0
                    } return !1
            }
          }

          function xt(t) {
            return t.length > 1 ? function(e, n, r) {
              for (var i = t.length; i--;)
                if (!t[i](e, n, r)) return !1;
              return !0
            } : t[0]
          }

          function wt(t, e, n, r, i) {
            for (var o, s = [], a = 0, l = t.length, c = null != e; a < l; a++)(o = t[a]) && (n && !n(o, r, i) ||
              (s.push(o), c && e.push(a)));
            return s
          }

          function At(t, e, n, r, i, o) {
            return r && !r[C] && (r = At(r)), i && !i[C] && (i = At(i, o)), ct(function(o, s, a, l) {
              var c, h, u, d = [],
                p = [],
                f = s.length,
                g = o || function(t, e, n) {
                  for (var r = 0, i = e.length; r < i; r++) at(t, e[r], n);
                  return n
                }(e || "*", a.nodeType ? [a] : a, []),
                m = !t || !o && e ? g : wt(g, d, t, a, l),
                v = n ? i || (o ? t : f || r) ? [] : s : m;
              if (n && n(m, v, a, l), r)
                for (c = wt(v, p), r(c, [], a, l), h = c.length; h--;)(u = c[h]) && (v[p[h]] = !(m[p[h]] =
                  u));
              if (o) {
                if (i || t) {
                  if (i) {
                    for (c = [], h = v.length; h--;)(u = v[h]) && c.push(m[h] = u);
                    i(null, v = [], c, l)
                  }
                  for (h = v.length; h--;)(u = v[h]) && (c = i ? N(o, u) : d[h]) > -1 && (o[c] = !(s[c] = u))
                }
              } else v = wt(v === s ? v.splice(f, v.length) : v), i ? i(null, s, v, l) : j.apply(s, v)
            })
          }

          function Et(t) {
            for (var e, n, i, o = t.length, s = r.relative[t[0].type], a = s || r.relative[" "], l = s ? 1 : 0,
                h = Ct(function(t) {
                  return t === e
                }, a, !0), u = Ct(function(t) {
                  return N(e, t) > -1
                }, a, !0), d = [function(t, n, r) {
                  var i = !s && (r || n !== c) || ((e = n).nodeType ? h(t, n, r) : u(t, n, r));
                  return e = null, i
                }]; l < o; l++)
              if (n = r.relative[t[l].type]) d = [Ct(xt(d), n)];
              else {
                if ((n = r.filter[t[l].type].apply(null, t[l].matches))[C]) {
                  for (i = ++l; i < o && !r.relative[t[i].type]; i++);
                  return At(l > 1 && xt(d), l > 1 && bt(t.slice(0, l - 1).concat({
                      value: " " === t[l - 2].type ? "*" : ""
                    })).replace(V, "$1"), n, l < i && Et(t.slice(l, i)), i < o && Et(t = t.slice(i)), i < o &&
                    bt(t))
                }
                d.push(n)
              } return xt(d)
          }
          return yt.prototype = r.filters = r.pseudos, r.setFilters = new yt, s = at.tokenize = function(t, e) {
              var n, i, o, s, a, l, c, h = S[t + " "];
              if (h) return e ? 0 : h.slice(0);
              for (a = t, l = [], c = r.preFilter; a;) {
                for (s in n && !(i = H.exec(a)) || (i && (a = a.slice(i[0].length) || a), l.push(o = [])), n = !
                  1, (i = G.exec(a)) && (n = i.shift(), o.push({
                    value: n,
                    type: i[0].replace(V, " ")
                  }), a = a.slice(n.length)), r.filter) !(i = X[s].exec(a)) || c[s] && !(i = c[s](i)) || (n = i
                  .shift(), o.push({
                    value: n,
                    type: s,
                    matches: i
                  }), a = a.slice(n.length));
                if (!n) break
              }
              return e ? a.length : a ? at.error(t) : S(t, l).slice(0)
            }, a = at.compile = function(t, e) {
              var n, i = [],
                o = [],
                a = M[t + " "];
              if (!a) {
                for (e || (e = s(t)), n = e.length; n--;)(a = Et(e[n]))[C] ? i.push(a) : o.push(a);
                (a = M(t, function(t, e) {
                  var n = e.length > 0,
                    i = t.length > 0,
                    o = function(o, s, a, l, h) {
                      var u, f, m, v = 0,
                        y = "0",
                        b = o && [],
                        C = [],
                        x = c,
                        A = o || i && r.find.TAG("*", h),
                        E = w += null == x ? 1 : Math.random() || .1,
                        S = A.length;
                      for (h && (c = s == p || s || h); y !== S && null != (u = A[y]); y++) {
                        if (i && u) {
                          for (f = 0, s || u.ownerDocument == p || (d(u), a = !g); m = t[f++];)
                            if (m(u, s || p, a)) {
                              l.push(u);
                              break
                            } h && (w = E)
                        }
                        n && ((u = !m && u) && v--, o && b.push(u))
                      }
                      if (v += y, n && y !== v) {
                        for (f = 0; m = e[f++];) m(b, C, s, a);
                        if (o) {
                          if (v > 0)
                            for (; y--;) b[y] || C[y] || (C[y] = T.call(l));
                          C = wt(C)
                        }
                        j.apply(l, C), h && !o && C.length > 0 && v + e.length > 1 && at.uniqueSort(l)
                      }
                      return h && (w = E, c = x), b
                    };
                  return n ? ct(o) : o
                }(o, i))).selector = t
              }
              return a
            }, l = at.select = function(t, e, n, i) {
              var o, l, c, h, u, d = "function" == typeof t && t,
                p = !i && s(t = d.selector || t);
              if (n = n || [], 1 === p.length) {
                if ((l = p[0] = p[0].slice(0)).length > 2 && "ID" === (c = l[0]).type && 9 === e.nodeType && g &&
                  r.relative[l[1].type]) {
                  if (!(e = (r.find.ID(c.matches[0].replace(et, nt), e) || [])[0])) return n;
                  d && (e = e.parentNode), t = t.slice(l.shift().value.length)
                }
                for (o = X.needsContext.test(t) ? 0 : l.length; o-- && (c = l[o], !r.relative[h = c.type]);)
                  if ((u = r.find[h]) && (i = u(c.matches[0].replace(et, nt), tt.test(l[0].type) && vt(e.parentNode) ||
                      e))) {
                    if (l.splice(o, 1), !(t = i.length && bt(l))) return j.apply(n, i), n;
                    break
                  }
              }
              return (d || a(t, p))(i, e, !g, n, !e || tt.test(t) && vt(e.parentNode) || e), n
            }, n.sortStable = C.split("").sort(O).join("") === C, n.detectDuplicates = !!u, d(), n.sortDetached =
            ht(function(t) {
              return 1 & t.compareDocumentPosition(p.createElement("fieldset"))
            }), ht(function(t) {
              return t.innerHTML = "<a href='#'></a>", "#" === t.firstChild.getAttribute("href")
            }) || ut("type|href|height|width", function(t, e, n) {
              if (!n) return t.getAttribute(e, "type" === e.toLowerCase() ? 1 : 2)
            }), n.attributes && ht(function(t) {
              return t.innerHTML = "<input/>", t.firstChild.setAttribute("value", ""), "" === t.firstChild.getAttribute(
                "value")
            }) || ut("value", function(t, e, n) {
              if (!n && "input" === t.nodeName.toLowerCase()) return t.defaultValue
            }), ht(function(t) {
              return null == t.getAttribute("disabled")
            }) || ut(F, function(t, e, n) {
              var r;
              if (!n) return !0 === t[e] ? e.toLowerCase() : (r = t.getAttributeNode(e)) && r.specified ? r.value :
                null
            }), at
        }(n);
      A.find = S, A.expr = S.selectors, A.expr[":"] = A.expr.pseudos, A.uniqueSort = A.unique = S.uniqueSort, A
        .text = S.getText, A.isXMLDoc = S.isXML, A.contains = S.contains, A.escapeSelector = S.escape;
      var M = function(t, e, n) {
          for (var r = [], i = void 0 !== n;
            (t = t[e]) && 9 !== t.nodeType;)
            if (1 === t.nodeType) {
              if (i && A(t).is(n)) break;
              r.push(t)
            } return r
        },
        k = function(t, e) {
          for (var n = []; t; t = t.nextSibling) 1 === t.nodeType && t !== e && n.push(t);
          return n
        },
        O = A.expr.match.needsContext;

      function P(t, e) {
        return t.nodeName && t.nodeName.toLowerCase() === e.toLowerCase()
      }
      var D = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

      function T(t, e, n) {
        return v(e) ? A.grep(t, function(t, r) {
          return !!e.call(t, r, t) !== n
        }) : e.nodeType ? A.grep(t, function(t) {
          return t === e !== n
        }) : "string" != typeof e ? A.grep(t, function(t) {
          return h.call(e, t) > -1 !== n
        }) : A.filter(e, t, n)
      }
      A.filter = function(t, e, n) {
        var r = e[0];
        return n && (t = ":not(" + t + ")"), 1 === e.length && 1 === r.nodeType ? A.find.matchesSelector(r, t) ?
          [r] : [] : A.find.matches(t, A.grep(e, function(t) {
            return 1 === t.nodeType
          }))
      }, A.fn.extend({
        find: function(t) {
          var e, n, r = this.length,
            i = this;
          if ("string" != typeof t) return this.pushStack(A(t).filter(function() {
            for (e = 0; e < r; e++)
              if (A.contains(i[e], this)) return !0
          }));
          for (n = this.pushStack([]), e = 0; e < r; e++) A.find(t, i[e], n);
          return r > 1 ? A.uniqueSort(n) : n
        },
        filter: function(t) {
          return this.pushStack(T(this, t || [], !1))
        },
        not: function(t) {
          return this.pushStack(T(this, t || [], !0))
        },
        is: function(t) {
          return !!T(this, "string" == typeof t && O.test(t) ? A(t) : t || [], !1).length
        }
      });
      var _, j = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
      (A.fn.init = function(t, e, n) {
        var r, i;
        if (!t) return this;
        if (n = n || _, "string" == typeof t) {
          if (!(r = "<" === t[0] && ">" === t[t.length - 1] && t.length >= 3 ? [null, t, null] : j.exec(t)) ||
            !r[1] && e) return !e || e.jquery ? (e || n).find(t) : this.constructor(e).find(t);
          if (r[1]) {
            if (e = e instanceof A ? e[0] : e, A.merge(this, A.parseHTML(r[1], e && e.nodeType ? e.ownerDocument ||
                e : b, !0)), D.test(r[1]) && A.isPlainObject(e))
              for (r in e) v(this[r]) ? this[r](e[r]) : this.attr(r, e[r]);
            return this
          }
          return (i = b.getElementById(r[2])) && (this[0] = i, this.length = 1), this
        }
        return t.nodeType ? (this[0] = t, this.length = 1, this) : v(t) ? void 0 !== n.ready ? n.ready(t) : t(
          A) : A.makeArray(t, this)
      }).prototype = A.fn, _ = A(b);
      var L = /^(?:parents|prev(?:Until|All))/,
        N = {
          children: !0,
          contents: !0,
          next: !0,
          prev: !0
        };

      function F(t, e) {
        for (;
          (t = t[e]) && 1 !== t.nodeType;);
        return t
      }
      A.fn.extend({
        has: function(t) {
          var e = A(t, this),
            n = e.length;
          return this.filter(function() {
            for (var t = 0; t < n; t++)
              if (A.contains(this, e[t])) return !0
          })
        },
        closest: function(t, e) {
          var n, r = 0,
            i = this.length,
            o = [],
            s = "string" != typeof t && A(t);
          if (!O.test(t))
            for (; r < i; r++)
              for (n = this[r]; n && n !== e; n = n.parentNode)
                if (n.nodeType < 11 && (s ? s.index(n) > -1 : 1 === n.nodeType && A.find.matchesSelector(
                    n, t))) {
                  o.push(n);
                  break
                } return this.pushStack(o.length > 1 ? A.uniqueSort(o) : o)
        },
        index: function(t) {
          return t ? "string" == typeof t ? h.call(A(t), this[0]) : h.call(this, t.jquery ? t[0] : t) :
            this[0] && this[0].parentNode ? this.first().prevAll().length : -1
        },
        add: function(t, e) {
          return this.pushStack(A.uniqueSort(A.merge(this.get(), A(t, e))))
        },
        addBack: function(t) {
          return this.add(null == t ? this.prevObject : this.prevObject.filter(t))
        }
      }), A.each({
        parent: function(t) {
          var e = t.parentNode;
          return e && 11 !== e.nodeType ? e : null
        },
        parents: function(t) {
          return M(t, "parentNode")
        },
        parentsUntil: function(t, e, n) {
          return M(t, "parentNode", n)
        },
        next: function(t) {
          return F(t, "nextSibling")
        },
        prev: function(t) {
          return F(t, "previousSibling")
        },
        nextAll: function(t) {
          return M(t, "nextSibling")
        },
        prevAll: function(t) {
          return M(t, "previousSibling")
        },
        nextUntil: function(t, e, n) {
          return M(t, "nextSibling", n)
        },
        prevUntil: function(t, e, n) {
          return M(t, "previousSibling", n)
        },
        siblings: function(t) {
          return k((t.parentNode || {}).firstChild, t)
        },
        children: function(t) {
          return k(t.firstChild)
        },
        contents: function(t) {
          return null != t.contentDocument && s(t.contentDocument) ? t.contentDocument : (P(t, "template") &&
            (t = t.content || t), A.merge([], t.childNodes))
        }
      }, function(t, e) {
        A.fn[t] = function(n, r) {
          var i = A.map(this, e, n);
          return "Until" !== t.slice(-5) && (r = n), r && "string" == typeof r && (i = A.filter(r, i)),
            this.length > 1 && (N[t] || A.uniqueSort(i), L.test(t) && i.reverse()), this.pushStack(i)
        }
      });
      var $ = /[^\x20\t\r\n\f]+/g;

      function B(t) {
        return t
      }

      function I(t) {
        throw t
      }

      function z(t, e, n, r) {
        var i;
        try {
          t && v(i = t.promise) ? i.call(t).done(e).fail(n) : t && v(i = t.then) ? i.call(t, e, n) : e.apply(
            void 0, [t].slice(r))
        } catch (t) {
          n.apply(void 0, [t])
        }
      }
      A.Callbacks = function(t) {
        t = "string" == typeof t ? function(t) {
          var e = {};
          return A.each(t.match($) || [], function(t, n) {
            e[n] = !0
          }), e
        }(t) : A.extend({}, t);
        var e, n, r, i, o = [],
          s = [],
          a = -1,
          l = function() {
            for (i = i || t.once, r = e = !0; s.length; a = -1)
              for (n = s.shift(); ++a < o.length;) !1 === o[a].apply(n[0], n[1]) && t.stopOnFalse && (a = o.length,
                n = !1);
            t.memory || (n = !1), e = !1, i && (o = n ? [] : "")
          },
          c = {
            add: function() {
              return o && (n && !e && (a = o.length - 1, s.push(n)), function e(n) {
                A.each(n, function(n, r) {
                  v(r) ? t.unique && c.has(r) || o.push(r) : r && r.length && "string" !== w(r) &&
                    e(r)
                })
              }(arguments), n && !e && l()), this
            },
            remove: function() {
              return A.each(arguments, function(t, e) {
                for (var n;
                  (n = A.inArray(e, o, n)) > -1;) o.splice(n, 1), n <= a && a--
              }), this
            },
            has: function(t) {
              return t ? A.inArray(t, o) > -1 : o.length > 0
            },
            empty: function() {
              return o && (o = []), this
            },
            disable: function() {
              return i = s = [], o = n = "", this
            },
            disabled: function() {
              return !o
            },
            lock: function() {
              return i = s = [], n || e || (o = n = ""), this
            },
            locked: function() {
              return !!i
            },
            fireWith: function(t, n) {
              return i || (n = [t, (n = n || []).slice ? n.slice() : n], s.push(n), e || l()), this
            },
            fire: function() {
              return c.fireWith(this, arguments), this
            },
            fired: function() {
              return !!r
            }
          };
        return c
      }, A.extend({
        Deferred: function(t) {
          var e = [
              ["notify", "progress", A.Callbacks("memory"), A.Callbacks("memory"), 2],
              ["resolve", "done", A.Callbacks("once memory"), A.Callbacks("once memory"), 0, "resolved"],
              ["reject", "fail", A.Callbacks("once memory"), A.Callbacks("once memory"), 1, "rejected"]
            ],
            r = "pending",
            i = {
              state: function() {
                return r
              },
              always: function() {
                return o.done(arguments).fail(arguments), this
              },
              catch: function(t) {
                return i.then(null, t)
              },
              pipe: function() {
                var t = arguments;
                return A.Deferred(function(n) {
                  A.each(e, function(e, r) {
                    var i = v(t[r[4]]) && t[r[4]];
                    o[r[1]](function() {
                      var t = i && i.apply(this, arguments);
                      t && v(t.promise) ? t.promise().progress(n.notify).done(n.resolve).fail(
                        n.reject) : n[r[0] + "With"](this, i ? [t] : arguments)
                    })
                  }), t = null
                }).promise()
              },
              then: function(t, r, i) {
                var o = 0;

                function s(t, e, r, i) {
                  return function() {
                    var a = this,
                      l = arguments,
                      c = function() {
                        var n, c;
                        if (!(t < o)) {
                          if ((n = r.apply(a, l)) === e.promise()) throw new TypeError(
                            "Thenable self-resolution");
                          c = n && ("object" == typeof n || "function" == typeof n) && n.then, v(c) ?
                            i ? c.call(n, s(o, e, B, i), s(o, e, I, i)) : (o++, c.call(n, s(o, e, B,
                              i), s(o, e, I, i), s(o, e, B, e.notifyWith))) : (r !== B && (a = void 0,
                              l = [n]), (i || e.resolveWith)(a, l))
                        }
                      },
                      h = i ? c : function() {
                        try {
                          c()
                        } catch (n) {
                          A.Deferred.exceptionHook && A.Deferred.exceptionHook(n, h.stackTrace), t +
                            1 >= o && (r !== I && (a = void 0, l = [n]), e.rejectWith(a, l))
                        }
                      };
                    t ? h() : (A.Deferred.getStackHook && (h.stackTrace = A.Deferred.getStackHook()),
                      n.setTimeout(h))
                  }
                }
                return A.Deferred(function(n) {
                  e[0][3].add(s(0, n, v(i) ? i : B, n.notifyWith)), e[1][3].add(s(0, n, v(t) ? t :
                    B)), e[2][3].add(s(0, n, v(r) ? r : I))
                }).promise()
              },
              promise: function(t) {
                return null != t ? A.extend(t, i) : i
              }
            },
            o = {};
          return A.each(e, function(t, n) {
            var s = n[2],
              a = n[5];
            i[n[1]] = s.add, a && s.add(function() {
                r = a
              }, e[3 - t][2].disable, e[3 - t][3].disable, e[0][2].lock, e[0][3].lock), s.add(n[3].fire),
              o[n[0]] = function() {
                return o[n[0] + "With"](this === o ? void 0 : this, arguments), this
              }, o[n[0] + "With"] = s.fireWith
          }), i.promise(o), t && t.call(o, o), o
        },
        when: function(t) {
          var e = arguments.length,
            n = e,
            r = Array(n),
            i = a.call(arguments),
            o = A.Deferred(),
            s = function(t) {
              return function(n) {
                r[t] = this, i[t] = arguments.length > 1 ? a.call(arguments) : n, --e || o.resolveWith(
                  r, i)
              }
            };
          if (e <= 1 && (z(t, o.done(s(n)).resolve, o.reject, !e), "pending" === o.state() || v(i[n] && i[
              n].then))) return o.then();
          for (; n--;) z(i[n], s(n), o.reject);
          return o.promise()
        }
      });
      var R = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
      A.Deferred.exceptionHook = function(t, e) {
        n.console && n.console.warn && t && R.test(t.name) && n.console.warn("jQuery.Deferred exception: " +
          t.message, t.stack, e)
      }, A.readyException = function(t) {
        n.setTimeout(function() {
          throw t
        })
      };
      var V = A.Deferred();

      function H() {
        b.removeEventListener("DOMContentLoaded", H), n.removeEventListener("load", H), A.ready()
      }
      A.fn.ready = function(t) {
          return V.then(t).catch(function(t) {
            A.readyException(t)
          }), this
        }, A.extend({
          isReady: !1,
          readyWait: 1,
          ready: function(t) {
            (!0 === t ? --A.readyWait : A.isReady) || (A.isReady = !0, !0 !== t && --A.readyWait > 0 || V.resolveWith(
              b, [A]))
          }
        }), A.ready.then = V.then, "complete" === b.readyState || "loading" !== b.readyState && !b.documentElement
        .doScroll ? n.setTimeout(A.ready) : (b.addEventListener("DOMContentLoaded", H), n.addEventListener(
          "load", H));
      var G = function(t, e, n, r, i, o, s) {
          var a = 0,
            l = t.length,
            c = null == n;
          if ("object" === w(n))
            for (a in i = !0, n) G(t, e, a, n[a], !0, o, s);
          else if (void 0 !== r && (i = !0, v(r) || (s = !0), c && (s ? (e.call(t, r), e = null) : (c = e, e =
              function(t, e, n) {
                return c.call(A(t), n)
              })), e))
            for (; a < l; a++) e(t[a], n, s ? r : r.call(t[a], a, e(t[a], n)));
          return i ? t : c ? e.call(t) : l ? e(t[0], n) : o
        },
        U = /^-ms-/,
        q = /-([a-z])/g;

      function W(t, e) {
        return e.toUpperCase()
      }

      function X(t) {
        return t.replace(U, "ms-").replace(q, W)
      }
      var Y = function(t) {
        return 1 === t.nodeType || 9 === t.nodeType || !+t.nodeType
      };

      function J() {
        this.expando = A.expando + J.uid++
      }
      J.uid = 1, J.prototype = {
        cache: function(t) {
          var e = t[this.expando];
          return e || (e = {}, Y(t) && (t.nodeType ? t[this.expando] = e : Object.defineProperty(t, this.expando, {
            value: e,
            configurable: !0
          }))), e
        },
        set: function(t, e, n) {
          var r, i = this.cache(t);
          if ("string" == typeof e) i[X(e)] = n;
          else
            for (r in e) i[X(r)] = e[r];
          return i
        },
        get: function(t, e) {
          return void 0 === e ? this.cache(t) : t[this.expando] && t[this.expando][X(e)]
        },
        access: function(t, e, n) {
          return void 0 === e || e && "string" == typeof e && void 0 === n ? this.get(t, e) : (this.set(t,
            e, n), void 0 !== n ? n : e)
        },
        remove: function(t, e) {
          var n, r = t[this.expando];
          if (void 0 !== r) {
            if (void 0 !== e) {
              n = (e = Array.isArray(e) ? e.map(X) : (e = X(e)) in r ? [e] : e.match($) || []).length;
              for (; n--;) delete r[e[n]]
            }(void 0 === e || A.isEmptyObject(r)) && (t.nodeType ? t[this.expando] = void 0 : delete t[this
              .expando])
          }
        },
        hasData: function(t) {
          var e = t[this.expando];
          return void 0 !== e && !A.isEmptyObject(e)
        }
      };
      var Z = new J,
        K = new J,
        Q = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        tt = /[A-Z]/g;

      function et(t, e, n) {
        var r;
        if (void 0 === n && 1 === t.nodeType)
          if (r = "data-" + e.replace(tt, "-$&").toLowerCase(), "string" == typeof(n = t.getAttribute(r))) {
            try {
              n = function(t) {
                return "true" === t || "false" !== t && ("null" === t ? null : t === +t + "" ? +t : Q.test(t) ?
                  JSON.parse(t) : t)
              }(n)
            } catch (t) {}
            K.set(t, e, n)
          } else n = void 0;
        return n
      }
      A.extend({
        hasData: function(t) {
          return K.hasData(t) || Z.hasData(t)
        },
        data: function(t, e, n) {
          return K.access(t, e, n)
        },
        removeData: function(t, e) {
          K.remove(t, e)
        },
        _data: function(t, e, n) {
          return Z.access(t, e, n)
        },
        _removeData: function(t, e) {
          Z.remove(t, e)
        }
      }), A.fn.extend({
        data: function(t, e) {
          var n, r, i, o = this[0],
            s = o && o.attributes;
          if (void 0 === t) {
            if (this.length && (i = K.get(o), 1 === o.nodeType && !Z.get(o, "hasDataAttrs"))) {
              for (n = s.length; n--;) s[n] && 0 === (r = s[n].name).indexOf("data-") && (r = X(r.slice(5)),
                et(o, r, i[r]));
              Z.set(o, "hasDataAttrs", !0)
            }
            return i
          }
          return "object" == typeof t ? this.each(function() {
            K.set(this, t)
          }) : G(this, function(e) {
            var n;
            if (o && void 0 === e) return void 0 !== (n = K.get(o, t)) ? n : void 0 !== (n = et(o, t)) ?
              n : void 0;
            this.each(function() {
              K.set(this, t, e)
            })
          }, null, e, arguments.length > 1, null, !0)
        },
        removeData: function(t) {
          return this.each(function() {
            K.remove(this, t)
          })
        }
      }), A.extend({
        queue: function(t, e, n) {
          var r;
          if (t) return e = (e || "fx") + "queue", r = Z.get(t, e), n && (!r || Array.isArray(n) ? r = Z.access(
            t, e, A.makeArray(n)) : r.push(n)), r || []
        },
        dequeue: function(t, e) {
          e = e || "fx";
          var n = A.queue(t, e),
            r = n.length,
            i = n.shift(),
            o = A._queueHooks(t, e);
          "inprogress" === i && (i = n.shift(), r--), i && ("fx" === e && n.unshift("inprogress"), delete o
            .stop, i.call(t, function() {
              A.dequeue(t, e)
            }, o)), !r && o && o.empty.fire()
        },
        _queueHooks: function(t, e) {
          var n = e + "queueHooks";
          return Z.get(t, n) || Z.access(t, n, {
            empty: A.Callbacks("once memory").add(function() {
              Z.remove(t, [e + "queue", n])
            })
          })
        }
      }), A.fn.extend({
        queue: function(t, e) {
          var n = 2;
          return "string" != typeof t && (e = t, t = "fx", n--), arguments.length < n ? A.queue(this[0],
            t) : void 0 === e ? this : this.each(function() {
            var n = A.queue(this, t, e);
            A._queueHooks(this, t), "fx" === t && "inprogress" !== n[0] && A.dequeue(this, t)
          })
        },
        dequeue: function(t) {
          return this.each(function() {
            A.dequeue(this, t)
          })
        },
        clearQueue: function(t) {
          return this.queue(t || "fx", [])
        },
        promise: function(t, e) {
          var n, r = 1,
            i = A.Deferred(),
            o = this,
            s = this.length,
            a = function() {
              --r || i.resolveWith(o, [o])
            };
          for ("string" != typeof t && (e = t, t = void 0), t = t || "fx"; s--;)(n = Z.get(o[s], t +
            "queueHooks")) && n.empty && (r++, n.empty.add(a));
          return a(), i.promise(e)
        }
      });
      var nt = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
        rt = new RegExp("^(?:([+-])=|)(" + nt + ")([a-z%]*)$", "i"),
        it = ["Top", "Right", "Bottom", "Left"],
        ot = b.documentElement,
        st = function(t) {
          return A.contains(t.ownerDocument, t)
        },
        at = {
          composed: !0
        };
      ot.getRootNode && (st = function(t) {
        return A.contains(t.ownerDocument, t) || t.getRootNode(at) === t.ownerDocument
      });
      var lt = function(t, e) {
        return "none" === (t = e || t).style.display || "" === t.style.display && st(t) && "none" === A.css(t,
          "display")
      };

      function ct(t, e, n, r) {
        var i, o, s = 20,
          a = r ? function() {
            return r.cur()
          } : function() {
            return A.css(t, e, "")
          },
          l = a(),
          c = n && n[3] || (A.cssNumber[e] ? "" : "px"),
          h = t.nodeType && (A.cssNumber[e] || "px" !== c && +l) && rt.exec(A.css(t, e));
        if (h && h[3] !== c) {
          for (l /= 2, c = c || h[3], h = +l || 1; s--;) A.style(t, e, h + c), (1 - o) * (1 - (o = a() / l ||
            .5)) <= 0 && (s = 0), h /= o;
          h *= 2, A.style(t, e, h + c), n = n || []
        }
        return n && (h = +h || +l || 0, i = n[1] ? h + (n[1] + 1) * n[2] : +n[2], r && (r.unit = c, r.start = h,
          r.end = i)), i
      }
      var ht = {};

      function ut(t) {
        var e, n = t.ownerDocument,
          r = t.nodeName,
          i = ht[r];
        return i || (e = n.body.appendChild(n.createElement(r)), i = A.css(e, "display"), e.parentNode.removeChild(
          e), "none" === i && (i = "block"), ht[r] = i, i)
      }

      function dt(t, e) {
        for (var n, r, i = [], o = 0, s = t.length; o < s; o++)(r = t[o]).style && (n = r.style.display, e ? (
          "none" === n && (i[o] = Z.get(r, "display") || null, i[o] || (r.style.display = "")), "" === r.style
          .display && lt(r) && (i[o] = ut(r))) : "none" !== n && (i[o] = "none", Z.set(r, "display", n)));
        for (o = 0; o < s; o++) null != i[o] && (t[o].style.display = i[o]);
        return t
      }
      A.fn.extend({
        show: function() {
          return dt(this, !0)
        },
        hide: function() {
          return dt(this)
        },
        toggle: function(t) {
          return "boolean" == typeof t ? t ? this.show() : this.hide() : this.each(function() {
            lt(this) ? A(this).show() : A(this).hide()
          })
        }
      });
      var pt, ft, gt = /^(?:checkbox|radio)$/i,
        mt = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
        vt = /^$|^module$|\/(?:java|ecma)script/i;
      pt = b.createDocumentFragment().appendChild(b.createElement("div")), (ft = b.createElement("input")).setAttribute(
          "type", "radio"), ft.setAttribute("checked", "checked"), ft.setAttribute("name", "t"), pt.appendChild(
          ft), m.checkClone = pt.cloneNode(!0).cloneNode(!0).lastChild.checked, pt.innerHTML =
        "<textarea>x</textarea>", m.noCloneChecked = !!pt.cloneNode(!0).lastChild.defaultValue, pt.innerHTML =
        "<option></option>", m.option = !!pt.lastChild;
      var yt = {
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
      };

      function bt(t, e) {
        var n;
        return n = void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e || "*") : void 0 !== t.querySelectorAll ?
          t.querySelectorAll(e || "*") : [], void 0 === e || e && P(t, e) ? A.merge([t], n) : n
      }

      function Ct(t, e) {
        for (var n = 0, r = t.length; n < r; n++) Z.set(t[n], "globalEval", !e || Z.get(e[n], "globalEval"))
      }
      yt.tbody = yt.tfoot = yt.colgroup = yt.caption = yt.thead, yt.th = yt.td, m.option || (yt.optgroup = yt.option = [
        1, "<select multiple='multiple'>", "</select>"
      ]);
      var xt = /<|&#?\w+;/;

      function wt(t, e, n, r, i) {
        for (var o, s, a, l, c, h, u = e.createDocumentFragment(), d = [], p = 0, f = t.length; p < f; p++)
          if ((o = t[p]) || 0 === o)
            if ("object" === w(o)) A.merge(d, o.nodeType ? [o] : o);
            else if (xt.test(o)) {
          for (s = s || u.appendChild(e.createElement("div")), a = (mt.exec(o) || ["", ""])[1].toLowerCase(), l =
            yt[a] || yt._default, s.innerHTML = l[1] + A.htmlPrefilter(o) + l[2], h = l[0]; h--;) s = s.lastChild;
          A.merge(d, s.childNodes), (s = u.firstChild).textContent = ""
        } else d.push(e.createTextNode(o));
        for (u.textContent = "", p = 0; o = d[p++];)
          if (r && A.inArray(o, r) > -1) i && i.push(o);
          else if (c = st(o), s = bt(u.appendChild(o), "script"), c && Ct(s), n)
          for (h = 0; o = s[h++];) vt.test(o.type || "") && n.push(o);
        return u
      }
      var At = /^key/,
        Et = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
        St = /^([^.]*)(?:\.(.+)|)/;

      function Mt() {
        return !0
      }

      function kt() {
        return !1
      }

      function Ot(t, e) {
        return t === function() {
          try {
            return b.activeElement
          } catch (t) {}
        }() == ("focus" === e)
      }

      function Pt(t, e, n, r, i, o) {
        var s, a;
        if ("object" == typeof e) {
          for (a in "string" != typeof n && (r = r || n, n = void 0), e) Pt(t, a, n, r, e[a], o);
          return t
        }
        if (null == r && null == i ? (i = n, r = n = void 0) : null == i && ("string" == typeof n ? (i = r, r =
            void 0) : (i = r, r = n, n = void 0)), !1 === i) i = kt;
        else if (!i) return t;
        return 1 === o && (s = i, (i = function(t) {
          return A().off(t), s.apply(this, arguments)
        }).guid = s.guid || (s.guid = A.guid++)), t.each(function() {
          A.event.add(this, e, i, r, n)
        })
      }

      function Dt(t, e, n) {
        n ? (Z.set(t, e, !1), A.event.add(t, e, {
          namespace: !1,
          handler: function(t) {
            var r, i, o = Z.get(this, e);
            if (1 & t.isTrigger && this[e]) {
              if (o.length)(A.event.special[e] || {}).delegateType && t.stopPropagation();
              else if (o = a.call(arguments), Z.set(this, e, o), r = n(this, e), this[e](), o !== (i =
                  Z.get(this, e)) || r ? Z.set(this, e, !1) : i = {}, o !== i) return t.stopImmediatePropagation(),
                t.preventDefault(), i.value
            } else o.length && (Z.set(this, e, {
              value: A.event.trigger(A.extend(o[0], A.Event.prototype), o.slice(1), this)
            }), t.stopImmediatePropagation())
          }
        })) : void 0 === Z.get(t, e) && A.event.add(t, e, Mt)
      }
      A.event = {
        global: {},
        add: function(t, e, n, r, i) {
          var o, s, a, l, c, h, u, d, p, f, g, m = Z.get(t);
          if (Y(t))
            for (n.handler && (n = (o = n).handler, i = o.selector), i && A.find.matchesSelector(ot, i), n.guid ||
              (n.guid = A.guid++), (l = m.events) || (l = m.events = Object.create(null)), (s = m.handle) ||
              (s = m.handle = function(e) {
                return void 0 !== A && A.event.triggered !== e.type ? A.event.dispatch.apply(t, arguments) :
                  void 0
              }), c = (e = (e || "").match($) || [""]).length; c--;) p = g = (a = St.exec(e[c]) || [])[1],
              f = (a[2] || "").split(".").sort(), p && (u = A.event.special[p] || {}, p = (i ? u.delegateType :
                u.bindType) || p, u = A.event.special[p] || {}, h = A.extend({
                type: p,
                origType: g,
                data: r,
                handler: n,
                guid: n.guid,
                selector: i,
                needsContext: i && A.expr.match.needsContext.test(i),
                namespace: f.join(".")
              }, o), (d = l[p]) || ((d = l[p] = []).delegateCount = 0, u.setup && !1 !== u.setup.call(t,
                r, f, s) || t.addEventListener && t.addEventListener(p, s)), u.add && (u.add.call(t, h),
                h.handler.guid || (h.handler.guid = n.guid)), i ? d.splice(d.delegateCount++, 0, h) : d.push(
                h), A.event.global[p] = !0)
        },
        remove: function(t, e, n, r, i) {
          var o, s, a, l, c, h, u, d, p, f, g, m = Z.hasData(t) && Z.get(t);
          if (m && (l = m.events)) {
            for (c = (e = (e || "").match($) || [""]).length; c--;)
              if (p = g = (a = St.exec(e[c]) || [])[1], f = (a[2] || "").split(".").sort(), p) {
                for (u = A.event.special[p] || {}, d = l[p = (r ? u.delegateType : u.bindType) || p] || [],
                  a = a[2] && new RegExp("(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)"), s = o = d.length; o--;
                ) h = d[o], !i && g !== h.origType || n && n.guid !== h.guid || a && !a.test(h.namespace) ||
                  r && r !== h.selector && ("**" !== r || !h.selector) || (d.splice(o, 1), h.selector && d.delegateCount--,
                    u.remove && u.remove.call(t, h));
                s && !d.length && (u.teardown && !1 !== u.teardown.call(t, f, m.handle) || A.removeEvent(t,
                  p, m.handle), delete l[p])
              } else
                for (p in l) A.event.remove(t, p + e[c], n, r, !0);
            A.isEmptyObject(l) && Z.remove(t, "handle events")
          }
        },
        dispatch: function(t) {
          var e, n, r, i, o, s, a = new Array(arguments.length),
            l = A.event.fix(t),
            c = (Z.get(this, "events") || Object.create(null))[l.type] || [],
            h = A.event.special[l.type] || {};
          for (a[0] = l, e = 1; e < arguments.length; e++) a[e] = arguments[e];
          if (l.delegateTarget = this, !h.preDispatch || !1 !== h.preDispatch.call(this, l)) {
            for (s = A.event.handlers.call(this, l, c), e = 0;
              (i = s[e++]) && !l.isPropagationStopped();)
              for (l.currentTarget = i.elem, n = 0;
                (o = i.handlers[n++]) && !l.isImmediatePropagationStopped();) l.rnamespace && !1 !== o.namespace &&
                !l.rnamespace.test(o.namespace) || (l.handleObj = o, l.data = o.data, void 0 !== (r = ((A.event
                  .special[o.origType] || {}).handle || o.handler).apply(i.elem, a)) && !1 === (l.result =
                  r) && (l.preventDefault(), l.stopPropagation()));
            return h.postDispatch && h.postDispatch.call(this, l), l.result
          }
        },
        handlers: function(t, e) {
          var n, r, i, o, s, a = [],
            l = e.delegateCount,
            c = t.target;
          if (l && c.nodeType && !("click" === t.type && t.button >= 1))
            for (; c !== this; c = c.parentNode || this)
              if (1 === c.nodeType && ("click" !== t.type || !0 !== c.disabled)) {
                for (o = [], s = {}, n = 0; n < l; n++) void 0 === s[i = (r = e[n]).selector + " "] && (s[i] =
                    r.needsContext ? A(i, this).index(c) > -1 : A.find(i, this, null, [c]).length), s[i] &&
                  o.push(r);
                o.length && a.push({
                  elem: c,
                  handlers: o
                })
              } return c = this, l < e.length && a.push({
            elem: c,
            handlers: e.slice(l)
          }), a
        },
        addProp: function(t, e) {
          Object.defineProperty(A.Event.prototype, t, {
            enumerable: !0,
            configurable: !0,
            get: v(e) ? function() {
              if (this.originalEvent) return e(this.originalEvent)
            } : function() {
              if (this.originalEvent) return this.originalEvent[t]
            },
            set: function(e) {
              Object.defineProperty(this, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: e
              })
            }
          })
        },
        fix: function(t) {
          return t[A.expando] ? t : new A.Event(t)
        },
        special: {
          load: {
            noBubble: !0
          },
          click: {
            setup: function(t) {
              var e = this || t;
              return gt.test(e.type) && e.click && P(e, "input") && Dt(e, "click", Mt), !1
            },
            trigger: function(t) {
              var e = this || t;
              return gt.test(e.type) && e.click && P(e, "input") && Dt(e, "click"), !0
            },
            _default: function(t) {
              var e = t.target;
              return gt.test(e.type) && e.click && P(e, "input") && Z.get(e, "click") || P(e, "a")
            }
          },
          beforeunload: {
            postDispatch: function(t) {
              void 0 !== t.result && t.originalEvent && (t.originalEvent.returnValue = t.result)
            }
          }
        }
      }, A.removeEvent = function(t, e, n) {
        t.removeEventListener && t.removeEventListener(e, n)
      }, A.Event = function(t, e) {
        if (!(this instanceof A.Event)) return new A.Event(t, e);
        t && t.type ? (this.originalEvent = t, this.type = t.type, this.isDefaultPrevented = t.defaultPrevented ||
            void 0 === t.defaultPrevented && !1 === t.returnValue ? Mt : kt, this.target = t.target && 3 ===
            t.target.nodeType ? t.target.parentNode : t.target, this.currentTarget = t.currentTarget, this.relatedTarget =
            t.relatedTarget) : this.type = t, e && A.extend(this, e), this.timeStamp = t && t.timeStamp ||
          Date.now(), this[A.expando] = !0
      }, A.Event.prototype = {
        constructor: A.Event,
        isDefaultPrevented: kt,
        isPropagationStopped: kt,
        isImmediatePropagationStopped: kt,
        isSimulated: !1,
        preventDefault: function() {
          var t = this.originalEvent;
          this.isDefaultPrevented = Mt, t && !this.isSimulated && t.preventDefault()
        },
        stopPropagation: function() {
          var t = this.originalEvent;
          this.isPropagationStopped = Mt, t && !this.isSimulated && t.stopPropagation()
        },
        stopImmediatePropagation: function() {
          var t = this.originalEvent;
          this.isImmediatePropagationStopped = Mt, t && !this.isSimulated && t.stopImmediatePropagation(),
            this.stopPropagation()
        }
      }, A.each({
        altKey: !0,
        bubbles: !0,
        cancelable: !0,
        changedTouches: !0,
        ctrlKey: !0,
        detail: !0,
        eventPhase: !0,
        metaKey: !0,
        pageX: !0,
        pageY: !0,
        shiftKey: !0,
        view: !0,
        char: !0,
        code: !0,
        charCode: !0,
        key: !0,
        keyCode: !0,
        button: !0,
        buttons: !0,
        clientX: !0,
        clientY: !0,
        offsetX: !0,
        offsetY: !0,
        pointerId: !0,
        pointerType: !0,
        screenX: !0,
        screenY: !0,
        targetTouches: !0,
        toElement: !0,
        touches: !0,
        which: function(t) {
          var e = t.button;
          return null == t.which && At.test(t.type) ? null != t.charCode ? t.charCode : t.keyCode : !t.which &&
            void 0 !== e && Et.test(t.type) ? 1 & e ? 1 : 2 & e ? 3 : 4 & e ? 2 : 0 : t.which
        }
      }, A.event.addProp), A.each({
        focus: "focusin",
        blur: "focusout"
      }, function(t, e) {
        A.event.special[t] = {
          setup: function() {
            return Dt(this, t, Ot), !1
          },
          trigger: function() {
            return Dt(this, t), !0
          },
          delegateType: e
        }
      }), A.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
      }, function(t, e) {
        A.event.special[t] = {
          delegateType: e,
          bindType: e,
          handle: function(t) {
            var n, r = t.relatedTarget,
              i = t.handleObj;
            return r && (r === this || A.contains(this, r)) || (t.type = i.origType, n = i.handler.apply(
              this, arguments), t.type = e), n
          }
        }
      }), A.fn.extend({
        on: function(t, e, n, r) {
          return Pt(this, t, e, n, r)
        },
        one: function(t, e, n, r) {
          return Pt(this, t, e, n, r, 1)
        },
        off: function(t, e, n) {
          var r, i;
          if (t && t.preventDefault && t.handleObj) return r = t.handleObj, A(t.delegateTarget).off(r.namespace ?
            r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this;
          if ("object" == typeof t) {
            for (i in t) this.off(i, e, t[i]);
            return this
          }
          return !1 !== e && "function" != typeof e || (n = e, e = void 0), !1 === n && (n = kt), this.each(
            function() {
              A.event.remove(this, t, n, e)
            })
        }
      });
      var Tt = /<script|<style|<link/i,
        _t = /checked\s*(?:[^=]|=\s*.checked.)/i,
        jt = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

      function Lt(t, e) {
        return P(t, "table") && P(11 !== e.nodeType ? e : e.firstChild, "tr") && A(t).children("tbody")[0] || t
      }

      function Nt(t) {
        return t.type = (null !== t.getAttribute("type")) + "/" + t.type, t
      }

      function Ft(t) {
        return "true/" === (t.type || "").slice(0, 5) ? t.type = t.type.slice(5) : t.removeAttribute("type"), t
      }

      function $t(t, e) {
        var n, r, i, o, s, a;
        if (1 === e.nodeType) {
          if (Z.hasData(t) && (a = Z.get(t).events))
            for (i in Z.remove(e, "handle events"), a)
              for (n = 0, r = a[i].length; n < r; n++) A.event.add(e, i, a[i][n]);
          K.hasData(t) && (o = K.access(t), s = A.extend({}, o), K.set(e, s))
        }
      }

      function Bt(t, e, n, r) {
        e = l(e);
        var i, o, s, a, c, h, u = 0,
          d = t.length,
          p = d - 1,
          f = e[0],
          g = v(f);
        if (g || d > 1 && "string" == typeof f && !m.checkClone && _t.test(f)) return t.each(function(i) {
          var o = t.eq(i);
          g && (e[0] = f.call(this, i, o.html())), Bt(o, e, n, r)
        });
        if (d && (o = (i = wt(e, t[0].ownerDocument, !1, t, r)).firstChild, 1 === i.childNodes.length && (i = o),
            o || r)) {
          for (a = (s = A.map(bt(i, "script"), Nt)).length; u < d; u++) c = i, u !== p && (c = A.clone(c, !0, !
            0), a && A.merge(s, bt(c, "script"))), n.call(t[u], c, u);
          if (a)
            for (h = s[s.length - 1].ownerDocument, A.map(s, Ft), u = 0; u < a; u++) c = s[u], vt.test(c.type ||
              "") && !Z.access(c, "globalEval") && A.contains(h, c) && (c.src && "module" !== (c.type || "").toLowerCase() ?
              A._evalUrl && !c.noModule && A._evalUrl(c.src, {
                nonce: c.nonce || c.getAttribute("nonce")
              }, h) : x(c.textContent.replace(jt, ""), c, h))
        }
        return t
      }

      function It(t, e, n) {
        for (var r, i = e ? A.filter(e, t) : t, o = 0; null != (r = i[o]); o++) n || 1 !== r.nodeType || A.cleanData(
          bt(r)), r.parentNode && (n && st(r) && Ct(bt(r, "script")), r.parentNode.removeChild(r));
        return t
      }
      A.extend({
        htmlPrefilter: function(t) {
          return t
        },
        clone: function(t, e, n) {
          var r, i, o, s, a, l, c, h = t.cloneNode(!0),
            u = st(t);
          if (!(m.noCloneChecked || 1 !== t.nodeType && 11 !== t.nodeType || A.isXMLDoc(t)))
            for (s = bt(h), r = 0, i = (o = bt(t)).length; r < i; r++) a = o[r], l = s[r], void 0,
              "input" === (c = l.nodeName.toLowerCase()) && gt.test(a.type) ? l.checked = a.checked :
              "input" !== c && "textarea" !== c || (l.defaultValue = a.defaultValue);
          if (e)
            if (n)
              for (o = o || bt(t), s = s || bt(h), r = 0, i = o.length; r < i; r++) $t(o[r], s[r]);
            else $t(t, h);
          return (s = bt(h, "script")).length > 0 && Ct(s, !u && bt(t, "script")), h
        },
        cleanData: function(t) {
          for (var e, n, r, i = A.event.special, o = 0; void 0 !== (n = t[o]); o++)
            if (Y(n)) {
              if (e = n[Z.expando]) {
                if (e.events)
                  for (r in e.events) i[r] ? A.event.remove(n, r) : A.removeEvent(n, r, e.handle);
                n[Z.expando] = void 0
              }
              n[K.expando] && (n[K.expando] = void 0)
            }
        }
      }), A.fn.extend({
        detach: function(t) {
          return It(this, t, !0)
        },
        remove: function(t) {
          return It(this, t)
        },
        text: function(t) {
          return G(this, function(t) {
            return void 0 === t ? A.text(this) : this.empty().each(function() {
              1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent =
                t)
            })
          }, null, t, arguments.length)
        },
        append: function() {
          return Bt(this, arguments, function(t) {
            1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || Lt(this, t).appendChild(
              t)
          })
        },
        prepend: function() {
          return Bt(this, arguments, function(t) {
            if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
              var e = Lt(this, t);
              e.insertBefore(t, e.firstChild)
            }
          })
        },
        before: function() {
          return Bt(this, arguments, function(t) {
            this.parentNode && this.parentNode.insertBefore(t, this)
          })
        },
        after: function() {
          return Bt(this, arguments, function(t) {
            this.parentNode && this.parentNode.insertBefore(t, this.nextSibling)
          })
        },
        empty: function() {
          for (var t, e = 0; null != (t = this[e]); e++) 1 === t.nodeType && (A.cleanData(bt(t, !1)), t.textContent =
            "");
          return this
        },
        clone: function(t, e) {
          return t = null != t && t, e = null == e ? t : e, this.map(function() {
            return A.clone(this, t, e)
          })
        },
        html: function(t) {
          return G(this, function(t) {
            var e = this[0] || {},
              n = 0,
              r = this.length;
            if (void 0 === t && 1 === e.nodeType) return e.innerHTML;
            if ("string" == typeof t && !Tt.test(t) && !yt[(mt.exec(t) || ["", ""])[1].toLowerCase()]) {
              t = A.htmlPrefilter(t);
              try {
                for (; n < r; n++) 1 === (e = this[n] || {}).nodeType && (A.cleanData(bt(e, !1)), e.innerHTML =
                  t);
                e = 0
              } catch (t) {}
            }
            e && this.empty().append(t)
          }, null, t, arguments.length)
        },
        replaceWith: function() {
          var t = [];
          return Bt(this, arguments, function(e) {
            var n = this.parentNode;
            A.inArray(this, t) < 0 && (A.cleanData(bt(this)), n && n.replaceChild(e, this))
          }, t)
        }
      }), A.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
      }, function(t, e) {
        A.fn[t] = function(t) {
          for (var n, r = [], i = A(t), o = i.length - 1, s = 0; s <= o; s++) n = s === o ? this : this.clone(
            !0), A(i[s])[e](n), c.apply(r, n.get());
          return this.pushStack(r)
        }
      });
      var zt = new RegExp("^(" + nt + ")(?!px)[a-z%]+$", "i"),
        Rt = function(t) {
          var e = t.ownerDocument.defaultView;
          return e && e.opener || (e = n), e.getComputedStyle(t)
        },
        Vt = function(t, e, n) {
          var r, i, o = {};
          for (i in e) o[i] = t.style[i], t.style[i] = e[i];
          for (i in r = n.call(t), e) t.style[i] = o[i];
          return r
        },
        Ht = new RegExp(it.join("|"), "i");

      function Gt(t, e, n) {
        var r, i, o, s, a = t.style;
        return (n = n || Rt(t)) && ("" !== (s = n.getPropertyValue(e) || n[e]) || st(t) || (s = A.style(t, e)),
            !m.pixelBoxStyles() && zt.test(s) && Ht.test(e) && (r = a.width, i = a.minWidth, o = a.maxWidth, a.minWidth =
              a.maxWidth = a.width = s, s = n.width, a.width = r, a.minWidth = i, a.maxWidth = o)), void 0 !==
          s ? s + "" : s
      }

      function Ut(t, e) {
        return {
          get: function() {
            if (!t()) return (this.get = e).apply(this, arguments);
            delete this.get
          }
        }
      }! function() {
        function t() {
          if (h) {
            c.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", h
              .style.cssText =
              "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",
              ot.appendChild(c).appendChild(h);
            var t = n.getComputedStyle(h);
            r = "1%" !== t.top, l = 12 === e(t.marginLeft), h.style.right = "60%", s = 36 === e(t.right), i =
              36 === e(t.width), h.style.position = "absolute", o = 12 === e(h.offsetWidth / 3), ot.removeChild(
                c), h = null
          }
        }

        function e(t) {
          return Math.round(parseFloat(t))
        }
        var r, i, o, s, a, l, c = b.createElement("div"),
          h = b.createElement("div");
        h.style && (h.style.backgroundClip = "content-box", h.cloneNode(!0).style.backgroundClip = "", m.clearCloneStyle =
          "content-box" === h.style.backgroundClip, A.extend(m, {
            boxSizingReliable: function() {
              return t(), i
            },
            pixelBoxStyles: function() {
              return t(), s
            },
            pixelPosition: function() {
              return t(), r
            },
            reliableMarginLeft: function() {
              return t(), l
            },
            scrollboxSize: function() {
              return t(), o
            },
            reliableTrDimensions: function() {
              var t, e, r, i;
              return null == a && (t = b.createElement("table"), e = b.createElement("tr"), r = b.createElement(
                  "div"), t.style.cssText = "position:absolute;left:-11111px", e.style.height = "1px",
                r.style.height = "9px", ot.appendChild(t).appendChild(e).appendChild(r), i = n.getComputedStyle(
                  e), a = parseInt(i.height) > 3, ot.removeChild(t)), a
            }
          }))
      }();
      var qt = ["Webkit", "Moz", "ms"],
        Wt = b.createElement("div").style,
        Xt = {};

      function Yt(t) {
        var e = A.cssProps[t] || Xt[t];
        return e || (t in Wt ? t : Xt[t] = function(t) {
          for (var e = t[0].toUpperCase() + t.slice(1), n = qt.length; n--;)
            if ((t = qt[n] + e) in Wt) return t
        }(t) || t)
      }
      var Jt = /^(none|table(?!-c[ea]).+)/,
        Zt = /^--/,
        Kt = {
          position: "absolute",
          visibility: "hidden",
          display: "block"
        },
        Qt = {
          letterSpacing: "0",
          fontWeight: "400"
        };

      function te(t, e, n) {
        var r = rt.exec(e);
        return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : e
      }

      function ee(t, e, n, r, i, o) {
        var s = "width" === e ? 1 : 0,
          a = 0,
          l = 0;
        if (n === (r ? "border" : "content")) return 0;
        for (; s < 4; s += 2) "margin" === n && (l += A.css(t, n + it[s], !0, i)), r ? ("content" === n && (l -=
          A.css(t, "padding" + it[s], !0, i)), "margin" !== n && (l -= A.css(t, "border" + it[s] + "Width",
          !0, i))) : (l += A.css(t, "padding" + it[s], !0, i), "padding" !== n ? l += A.css(t, "border" + it[
          s] + "Width", !0, i) : a += A.css(t, "border" + it[s] + "Width", !0, i));
        return !r && o >= 0 && (l += Math.max(0, Math.ceil(t["offset" + e[0].toUpperCase() + e.slice(1)] - o -
          l - a - .5)) || 0), l
      }

      function ne(t, e, n) {
        var r = Rt(t),
          i = (!m.boxSizingReliable() || n) && "border-box" === A.css(t, "boxSizing", !1, r),
          o = i,
          s = Gt(t, e, r),
          a = "offset" + e[0].toUpperCase() + e.slice(1);
        if (zt.test(s)) {
          if (!n) return s;
          s = "auto"
        }
        return (!m.boxSizingReliable() && i || !m.reliableTrDimensions() && P(t, "tr") || "auto" === s || !
            parseFloat(s) && "inline" === A.css(t, "display", !1, r)) && t.getClientRects().length && (i =
            "border-box" === A.css(t, "boxSizing", !1, r), (o = a in t) && (s = t[a])), (s = parseFloat(s) || 0) +
          ee(t, e, n || (i ? "border" : "content"), o, r, s) + "px"
      }

      function re(t, e, n, r, i) {
        return new re.prototype.init(t, e, n, r, i)
      }
      A.extend({
        cssHooks: {
          opacity: {
            get: function(t, e) {
              if (e) {
                var n = Gt(t, "opacity");
                return "" === n ? "1" : n
              }
            }
          }
        },
        cssNumber: {
          animationIterationCount: !0,
          columnCount: !0,
          fillOpacity: !0,
          flexGrow: !0,
          flexShrink: !0,
          fontWeight: !0,
          gridArea: !0,
          gridColumn: !0,
          gridColumnEnd: !0,
          gridColumnStart: !0,
          gridRow: !0,
          gridRowEnd: !0,
          gridRowStart: !0,
          lineHeight: !0,
          opacity: !0,
          order: !0,
          orphans: !0,
          widows: !0,
          zIndex: !0,
          zoom: !0
        },
        cssProps: {},
        style: function(t, e, n, r) {
          if (t && 3 !== t.nodeType && 8 !== t.nodeType && t.style) {
            var i, o, s, a = X(e),
              l = Zt.test(e),
              c = t.style;
            if (l || (e = Yt(a)), s = A.cssHooks[e] || A.cssHooks[a], void 0 === n) return s && "get" in
              s && void 0 !== (i = s.get(t, !1, r)) ? i : c[e];
            "string" === (o = typeof n) && (i = rt.exec(n)) && i[1] && (n = ct(t, e, i), o = "number"),
              null != n && n == n && ("number" !== o || l || (n += i && i[3] || (A.cssNumber[a] ? "" :
                "px")), m.clearCloneStyle || "" !== n || 0 !== e.indexOf("background") || (c[e] =
                "inherit"), s && "set" in s && void 0 === (n = s.set(t, n, r)) || (l ? c.setProperty(e,
                n) : c[e] = n))
          }
        },
        css: function(t, e, n, r) {
          var i, o, s, a = X(e);
          return Zt.test(e) || (e = Yt(a)), (s = A.cssHooks[e] || A.cssHooks[a]) && "get" in s && (i = s.get(
              t, !0, n)), void 0 === i && (i = Gt(t, e, r)), "normal" === i && e in Qt && (i = Qt[e]), "" ===
            n || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i
        }
      }), A.each(["height", "width"], function(t, e) {
        A.cssHooks[e] = {
          get: function(t, n, r) {
            if (n) return !Jt.test(A.css(t, "display")) || t.getClientRects().length && t.getBoundingClientRect()
              .width ? ne(t, e, r) : Vt(t, Kt, function() {
                return ne(t, e, r)
              })
          },
          set: function(t, n, r) {
            var i, o = Rt(t),
              s = !m.scrollboxSize() && "absolute" === o.position,
              a = (s || r) && "border-box" === A.css(t, "boxSizing", !1, o),
              l = r ? ee(t, e, r, a, o) : 0;
            return a && s && (l -= Math.ceil(t["offset" + e[0].toUpperCase() + e.slice(1)] - parseFloat(
              o[e]) - ee(t, e, "border", !1, o) - .5)), l && (i = rt.exec(n)) && "px" !== (i[3] ||
              "px") && (t.style[e] = n, n = A.css(t, e)), te(0, n, l)
          }
        }
      }), A.cssHooks.marginLeft = Ut(m.reliableMarginLeft, function(t, e) {
        if (e) return (parseFloat(Gt(t, "marginLeft")) || t.getBoundingClientRect().left - Vt(t, {
          marginLeft: 0
        }, function() {
          return t.getBoundingClientRect().left
        })) + "px"
      }), A.each({
        margin: "",
        padding: "",
        border: "Width"
      }, function(t, e) {
        A.cssHooks[t + e] = {
          expand: function(n) {
            for (var r = 0, i = {}, o = "string" == typeof n ? n.split(" ") : [n]; r < 4; r++) i[t + it[
              r] + e] = o[r] || o[r - 2] || o[0];
            return i
          }
        }, "margin" !== t && (A.cssHooks[t + e].set = te)
      }), A.fn.extend({
        css: function(t, e) {
          return G(this, function(t, e, n) {
            var r, i, o = {},
              s = 0;
            if (Array.isArray(e)) {
              for (r = Rt(t), i = e.length; s < i; s++) o[e[s]] = A.css(t, e[s], !1, r);
              return o
            }
            return void 0 !== n ? A.style(t, e, n) : A.css(t, e)
          }, t, e, arguments.length > 1)
        }
      }), A.Tween = re, re.prototype = {
        constructor: re,
        init: function(t, e, n, r, i, o) {
          this.elem = t, this.prop = n, this.easing = i || A.easing._default, this.options = e, this.start =
            this.now = this.cur(), this.end = r, this.unit = o || (A.cssNumber[n] ? "" : "px")
        },
        cur: function() {
          var t = re.propHooks[this.prop];
          return t && t.get ? t.get(this) : re.propHooks._default.get(this)
        },
        run: function(t) {
          var e, n = re.propHooks[this.prop];
          return this.options.duration ? this.pos = e = A.easing[this.easing](t, this.options.duration * t,
              0, 1, this.options.duration) : this.pos = e = t, this.now = (this.end - this.start) * e +
            this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ?
            n.set(this) : re.propHooks._default.set(this), this
        }
      }, re.prototype.init.prototype = re.prototype, re.propHooks = {
        _default: {
          get: function(t) {
            var e;
            return 1 !== t.elem.nodeType || null != t.elem[t.prop] && null == t.elem.style[t.prop] ? t.elem[
              t.prop] : (e = A.css(t.elem, t.prop, "")) && "auto" !== e ? e : 0
          },
          set: function(t) {
            A.fx.step[t.prop] ? A.fx.step[t.prop](t) : 1 !== t.elem.nodeType || !A.cssHooks[t.prop] && null ==
              t.elem.style[Yt(t.prop)] ? t.elem[t.prop] = t.now : A.style(t.elem, t.prop, t.now + t.unit)
          }
        }
      }, re.propHooks.scrollTop = re.propHooks.scrollLeft = {
        set: function(t) {
          t.elem.nodeType && t.elem.parentNode && (t.elem[t.prop] = t.now)
        }
      }, A.easing = {
        linear: function(t) {
          return t
        },
        swing: function(t) {
          return .5 - Math.cos(t * Math.PI) / 2
        },
        _default: "swing"
      }, A.fx = re.prototype.init, A.fx.step = {};
      var ie, oe, se = /^(?:toggle|show|hide)$/,
        ae = /queueHooks$/;

      function le() {
        oe && (!1 === b.hidden && n.requestAnimationFrame ? n.requestAnimationFrame(le) : n.setTimeout(le, A.fx
          .interval), A.fx.tick())
      }

      function ce() {
        return n.setTimeout(function() {
          ie = void 0
        }), ie = Date.now()
      }

      function he(t, e) {
        var n, r = 0,
          i = {
            height: t
          };
        for (e = e ? 1 : 0; r < 4; r += 2 - e) i["margin" + (n = it[r])] = i["padding" + n] = t;
        return e && (i.opacity = i.width = t), i
      }

      function ue(t, e, n) {
        for (var r, i = (de.tweeners[e] || []).concat(de.tweeners["*"]), o = 0, s = i.length; o < s; o++)
          if (r = i[o].call(n, e, t)) return r
      }

      function de(t, e, n) {
        var r, i, o = 0,
          s = de.prefilters.length,
          a = A.Deferred().always(function() {
            delete l.elem
          }),
          l = function() {
            if (i) return !1;
            for (var e = ie || ce(), n = Math.max(0, c.startTime + c.duration - e), r = 1 - (n / c.duration ||
                0), o = 0, s = c.tweens.length; o < s; o++) c.tweens[o].run(r);
            return a.notifyWith(t, [c, r, n]), r < 1 && s ? n : (s || a.notifyWith(t, [c, 1, 0]), a.resolveWith(
              t, [c]), !1)
          },
          c = a.promise({
            elem: t,
            props: A.extend({}, e),
            opts: A.extend(!0, {
              specialEasing: {},
              easing: A.easing._default
            }, n),
            originalProperties: e,
            originalOptions: n,
            startTime: ie || ce(),
            duration: n.duration,
            tweens: [],
            createTween: function(e, n) {
              var r = A.Tween(t, c.opts, e, n, c.opts.specialEasing[e] || c.opts.easing);
              return c.tweens.push(r), r
            },
            stop: function(e) {
              var n = 0,
                r = e ? c.tweens.length : 0;
              if (i) return this;
              for (i = !0; n < r; n++) c.tweens[n].run(1);
              return e ? (a.notifyWith(t, [c, 1, 0]), a.resolveWith(t, [c, e])) : a.rejectWith(t, [c, e]),
                this
            }
          }),
          h = c.props;
        for (! function(t, e) {
            var n, r, i, o, s;
            for (n in t)
              if (i = e[r = X(n)], o = t[n], Array.isArray(o) && (i = o[1], o = t[n] = o[0]), n !== r && (t[r] =
                  o, delete t[n]), (s = A.cssHooks[r]) && "expand" in s)
                for (n in o = s.expand(o), delete t[r], o) n in t || (t[n] = o[n], e[n] = i);
              else e[r] = i
          }(h, c.opts.specialEasing); o < s; o++)
          if (r = de.prefilters[o].call(c, t, h, c.opts)) return v(r.stop) && (A._queueHooks(c.elem, c.opts.queue)
            .stop = r.stop.bind(r)), r;
        return A.map(h, ue, c), v(c.opts.start) && c.opts.start.call(t, c), c.progress(c.opts.progress).done(c.opts
          .done, c.opts.complete).fail(c.opts.fail).always(c.opts.always), A.fx.timer(A.extend(l, {
          elem: t,
          anim: c,
          queue: c.opts.queue
        })), c
      }
      A.Animation = A.extend(de, {
          tweeners: {
            "*": [function(t, e) {
              var n = this.createTween(t, e);
              return ct(n.elem, t, rt.exec(e), n), n
            }]
          },
          tweener: function(t, e) {
            v(t) ? (e = t, t = ["*"]) : t = t.match($);
            for (var n, r = 0, i = t.length; r < i; r++) n = t[r], de.tweeners[n] = de.tweeners[n] || [],
              de.tweeners[n].unshift(e)
          },
          prefilters: [function(t, e, n) {
            var r, i, o, s, a, l, c, h, u = "width" in e || "height" in e,
              d = this,
              p = {},
              f = t.style,
              g = t.nodeType && lt(t),
              m = Z.get(t, "fxshow");
            for (r in n.queue || (null == (s = A._queueHooks(t, "fx")).unqueued && (s.unqueued = 0, a = s
                .empty.fire, s.empty.fire = function() {
                  s.unqueued || a()
                }), s.unqueued++, d.always(function() {
                d.always(function() {
                  s.unqueued--, A.queue(t, "fx").length || s.empty.fire()
                })
              })), e)
              if (i = e[r], se.test(i)) {
                if (delete e[r], o = o || "toggle" === i, i === (g ? "hide" : "show")) {
                  if ("show" !== i || !m || void 0 === m[r]) continue;
                  g = !0
                }
                p[r] = m && m[r] || A.style(t, r)
              } if ((l = !A.isEmptyObject(e)) || !A.isEmptyObject(p))
              for (r in u && 1 === t.nodeType && (n.overflow = [f.overflow, f.overflowX, f.overflowY],
                  null == (c = m && m.display) && (c = Z.get(t, "display")), "none" === (h = A.css(t,
                    "display")) && (c ? h = c : (dt([t], !0), c = t.style.display || c, h = A.css(t,
                    "display"), dt([t]))), ("inline" === h || "inline-block" === h && null != c) &&
                  "none" === A.css(t, "float") && (l || (d.done(function() {
                      f.display = c
                    }), null == c && (h = f.display, c = "none" === h ? "" : h)), f.display =
                    "inline-block")), n.overflow && (f.overflow = "hidden", d.always(function() {
                  f.overflow = n.overflow[0], f.overflowX = n.overflow[1], f.overflowY = n.overflow[2]
                })), l = !1, p) l || (m ? "hidden" in m && (g = m.hidden) : m = Z.access(t, "fxshow", {
                display: c
              }), o && (m.hidden = !g), g && dt([t], !0), d.done(function() {
                for (r in g || dt([t]), Z.remove(t, "fxshow"), p) A.style(t, r, p[r])
              })), l = ue(g ? m[r] : 0, r, d), r in m || (m[r] = l.start, g && (l.end = l.start, l.start =
                0))
          }],
          prefilter: function(t, e) {
            e ? de.prefilters.unshift(t) : de.prefilters.push(t)
          }
        }), A.speed = function(t, e, n) {
          var r = t && "object" == typeof t ? A.extend({}, t) : {
            complete: n || !n && e || v(t) && t,
            duration: t,
            easing: n && e || e && !v(e) && e
          };
          return A.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in A.fx.speeds ? r.duration =
              A.fx.speeds[r.duration] : r.duration = A.fx.speeds._default), null != r.queue && !0 !== r.queue ||
            (r.queue = "fx"), r.old = r.complete, r.complete = function() {
              v(r.old) && r.old.call(this), r.queue && A.dequeue(this, r.queue)
            }, r
        }, A.fn.extend({
          fadeTo: function(t, e, n, r) {
            return this.filter(lt).css("opacity", 0).show().end().animate({
              opacity: e
            }, t, n, r)
          },
          animate: function(t, e, n, r) {
            var i = A.isEmptyObject(t),
              o = A.speed(e, n, r),
              s = function() {
                var e = de(this, A.extend({}, t), o);
                (i || Z.get(this, "finish")) && e.stop(!0)
              };
            return s.finish = s, i || !1 === o.queue ? this.each(s) : this.queue(o.queue, s)
          },
          stop: function(t, e, n) {
            var r = function(t) {
              var e = t.stop;
              delete t.stop, e(n)
            };
            return "string" != typeof t && (n = e, e = t, t = void 0), e && this.queue(t || "fx", []), this
              .each(function() {
                var e = !0,
                  i = null != t && t + "queueHooks",
                  o = A.timers,
                  s = Z.get(this);
                if (i) s[i] && s[i].stop && r(s[i]);
                else
                  for (i in s) s[i] && s[i].stop && ae.test(i) && r(s[i]);
                for (i = o.length; i--;) o[i].elem !== this || null != t && o[i].queue !== t || (o[i].anim
                  .stop(n), e = !1, o.splice(i, 1));
                !e && n || A.dequeue(this, t)
              })
          },
          finish: function(t) {
            return !1 !== t && (t = t || "fx"), this.each(function() {
              var e, n = Z.get(this),
                r = n[t + "queue"],
                i = n[t + "queueHooks"],
                o = A.timers,
                s = r ? r.length : 0;
              for (n.finish = !0, A.queue(this, t, []), i && i.stop && i.stop.call(this, !0), e = o.length; e--;)
                o[e].elem === this && o[e].queue === t && (o[e].anim.stop(!0), o.splice(e, 1));
              for (e = 0; e < s; e++) r[e] && r[e].finish && r[e].finish.call(this);
              delete n.finish
            })
          }
        }), A.each(["toggle", "show", "hide"], function(t, e) {
          var n = A.fn[e];
          A.fn[e] = function(t, r, i) {
            return null == t || "boolean" == typeof t ? n.apply(this, arguments) : this.animate(he(e, !0),
              t, r, i)
          }
        }), A.each({
          slideDown: he("show"),
          slideUp: he("hide"),
          slideToggle: he("toggle"),
          fadeIn: {
            opacity: "show"
          },
          fadeOut: {
            opacity: "hide"
          },
          fadeToggle: {
            opacity: "toggle"
          }
        }, function(t, e) {
          A.fn[t] = function(t, n, r) {
            return this.animate(e, t, n, r)
          }
        }), A.timers = [], A.fx.tick = function() {
          var t, e = 0,
            n = A.timers;
          for (ie = Date.now(); e < n.length; e++)(t = n[e])() || n[e] !== t || n.splice(e--, 1);
          n.length || A.fx.stop(), ie = void 0
        }, A.fx.timer = function(t) {
          A.timers.push(t), A.fx.start()
        }, A.fx.interval = 13, A.fx.start = function() {
          oe || (oe = !0, le())
        }, A.fx.stop = function() {
          oe = null
        }, A.fx.speeds = {
          slow: 600,
          fast: 200,
          _default: 400
        }, A.fn.delay = function(t, e) {
          return t = A.fx && A.fx.speeds[t] || t, e = e || "fx", this.queue(e, function(e, r) {
            var i = n.setTimeout(e, t);
            r.stop = function() {
              n.clearTimeout(i)
            }
          })
        },
        function() {
          var t = b.createElement("input"),
            e = b.createElement("select").appendChild(b.createElement("option"));
          t.type = "checkbox", m.checkOn = "" !== t.value, m.optSelected = e.selected, (t = b.createElement(
            "input")).value = "t", t.type = "radio", m.radioValue = "t" === t.value
        }();
      var pe, fe = A.expr.attrHandle;
      A.fn.extend({
        attr: function(t, e) {
          return G(this, A.attr, t, e, arguments.length > 1)
        },
        removeAttr: function(t) {
          return this.each(function() {
            A.removeAttr(this, t)
          })
        }
      }), A.extend({
        attr: function(t, e, n) {
          var r, i, o = t.nodeType;
          if (3 !== o && 8 !== o && 2 !== o) return void 0 === t.getAttribute ? A.prop(t, e, n) : (1 ===
            o && A.isXMLDoc(t) || (i = A.attrHooks[e.toLowerCase()] || (A.expr.match.bool.test(e) ?
              pe : void 0)), void 0 !== n ? null === n ? void A.removeAttr(t, e) : i && "set" in i &&
            void 0 !== (r = i.set(t, n, e)) ? r : (t.setAttribute(e, n + ""), n) : i && "get" in i &&
            null !== (r = i.get(t, e)) ? r : null == (r = A.find.attr(t, e)) ? void 0 : r)
        },
        attrHooks: {
          type: {
            set: function(t, e) {
              if (!m.radioValue && "radio" === e && P(t, "input")) {
                var n = t.value;
                return t.setAttribute("type", e), n && (t.value = n), e
              }
            }
          }
        },
        removeAttr: function(t, e) {
          var n, r = 0,
            i = e && e.match($);
          if (i && 1 === t.nodeType)
            for (; n = i[r++];) t.removeAttribute(n)
        }
      }), pe = {
        set: function(t, e, n) {
          return !1 === e ? A.removeAttr(t, n) : t.setAttribute(n, n), n
        }
      }, A.each(A.expr.match.bool.source.match(/\w+/g), function(t, e) {
        var n = fe[e] || A.find.attr;
        fe[e] = function(t, e, r) {
          var i, o, s = e.toLowerCase();
          return r || (o = fe[s], fe[s] = i, i = null != n(t, e, r) ? s : null, fe[s] = o), i
        }
      });
      var ge = /^(?:input|select|textarea|button)$/i,
        me = /^(?:a|area)$/i;

      function ve(t) {
        return (t.match($) || []).join(" ")
      }

      function ye(t) {
        return t.getAttribute && t.getAttribute("class") || ""
      }

      function be(t) {
        return Array.isArray(t) ? t : "string" == typeof t && t.match($) || []
      }
      A.fn.extend({
        prop: function(t, e) {
          return G(this, A.prop, t, e, arguments.length > 1)
        },
        removeProp: function(t) {
          return this.each(function() {
            delete this[A.propFix[t] || t]
          })
        }
      }), A.extend({
        prop: function(t, e, n) {
          var r, i, o = t.nodeType;
          if (3 !== o && 8 !== o && 2 !== o) return 1 === o && A.isXMLDoc(t) || (e = A.propFix[e] || e, i =
              A.propHooks[e]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(t, n, e)) ? r :
            t[e] = n : i && "get" in i && null !== (r = i.get(t, e)) ? r : t[e]
        },
        propHooks: {
          tabIndex: {
            get: function(t) {
              var e = A.find.attr(t, "tabindex");
              return e ? parseInt(e, 10) : ge.test(t.nodeName) || me.test(t.nodeName) && t.href ? 0 : -1
            }
          }
        },
        propFix: {
          for: "htmlFor",
          class: "className"
        }
      }), m.optSelected || (A.propHooks.selected = {
        get: function(t) {
          var e = t.parentNode;
          return e && e.parentNode && e.parentNode.selectedIndex, null
        },
        set: function(t) {
          var e = t.parentNode;
          e && (e.selectedIndex, e.parentNode && e.parentNode.selectedIndex)
        }
      }), A.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan",
        "useMap", "frameBorder", "contentEditable"
      ], function() {
        A.propFix[this.toLowerCase()] = this
      }), A.fn.extend({
        addClass: function(t) {
          var e, n, r, i, o, s, a, l = 0;
          if (v(t)) return this.each(function(e) {
            A(this).addClass(t.call(this, e, ye(this)))
          });
          if ((e = be(t)).length)
            for (; n = this[l++];)
              if (i = ye(n), r = 1 === n.nodeType && " " + ve(i) + " ") {
                for (s = 0; o = e[s++];) r.indexOf(" " + o + " ") < 0 && (r += o + " ");
                i !== (a = ve(r)) && n.setAttribute("class", a)
              } return this
        },
        removeClass: function(t) {
          var e, n, r, i, o, s, a, l = 0;
          if (v(t)) return this.each(function(e) {
            A(this).removeClass(t.call(this, e, ye(this)))
          });
          if (!arguments.length) return this.attr("class", "");
          if ((e = be(t)).length)
            for (; n = this[l++];)
              if (i = ye(n), r = 1 === n.nodeType && " " + ve(i) + " ") {
                for (s = 0; o = e[s++];)
                  for (; r.indexOf(" " + o + " ") > -1;) r = r.replace(" " + o + " ", " ");
                i !== (a = ve(r)) && n.setAttribute("class", a)
              } return this
        },
        toggleClass: function(t, e) {
          var n = typeof t,
            r = "string" === n || Array.isArray(t);
          return "boolean" == typeof e && r ? e ? this.addClass(t) : this.removeClass(t) : v(t) ? this.each(
            function(n) {
              A(this).toggleClass(t.call(this, n, ye(this), e), e)
            }) : this.each(function() {
            var e, i, o, s;
            if (r)
              for (i = 0, o = A(this), s = be(t); e = s[i++];) o.hasClass(e) ? o.removeClass(e) : o.addClass(
                e);
            else void 0 !== t && "boolean" !== n || ((e = ye(this)) && Z.set(this, "__className__", e),
              this.setAttribute && this.setAttribute("class", e || !1 === t ? "" : Z.get(this,
                "__className__") || ""))
          })
        },
        hasClass: function(t) {
          var e, n, r = 0;
          for (e = " " + t + " "; n = this[r++];)
            if (1 === n.nodeType && (" " + ve(ye(n)) + " ").indexOf(e) > -1) return !0;
          return !1
        }
      });
      var Ce = /\r/g;
      A.fn.extend({
        val: function(t) {
          var e, n, r, i = this[0];
          return arguments.length ? (r = v(t), this.each(function(n) {
              var i;
              1 === this.nodeType && (null == (i = r ? t.call(this, n, A(this).val()) : t) ? i = "" :
                "number" == typeof i ? i += "" : Array.isArray(i) && (i = A.map(i, function(t) {
                  return null == t ? "" : t + ""
                })), (e = A.valHooks[this.type] || A.valHooks[this.nodeName.toLowerCase()]) &&
                "set" in e && void 0 !== e.set(this, i, "value") || (this.value = i))
            })) : i ? (e = A.valHooks[i.type] || A.valHooks[i.nodeName.toLowerCase()]) && "get" in e &&
            void 0 !== (n = e.get(i, "value")) ? n : "string" == typeof(n = i.value) ? n.replace(Ce, "") :
            null == n ? "" : n : void 0
        }
      }), A.extend({
        valHooks: {
          option: {
            get: function(t) {
              var e = A.find.attr(t, "value");
              return null != e ? e : ve(A.text(t))
            }
          },
          select: {
            get: function(t) {
              var e, n, r, i = t.options,
                o = t.selectedIndex,
                s = "select-one" === t.type,
                a = s ? null : [],
                l = s ? o + 1 : i.length;
              for (r = o < 0 ? l : s ? o : 0; r < l; r++)
                if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !P(n.parentNode,
                    "optgroup"))) {
                  if (e = A(n).val(), s) return e;
                  a.push(e)
                } return a
            },
            set: function(t, e) {
              for (var n, r, i = t.options, o = A.makeArray(e), s = i.length; s--;)((r = i[s]).selected =
                A.inArray(A.valHooks.option.get(r), o) > -1) && (n = !0);
              return n || (t.selectedIndex = -1), o
            }
          }
        }
      }), A.each(["radio", "checkbox"], function() {
        A.valHooks[this] = {
          set: function(t, e) {
            if (Array.isArray(e)) return t.checked = A.inArray(A(t).val(), e) > -1
          }
        }, m.checkOn || (A.valHooks[this].get = function(t) {
          return null === t.getAttribute("value") ? "on" : t.value
        })
      }), m.focusin = "onfocusin" in n;
      var xe = /^(?:focusinfocus|focusoutblur)$/,
        we = function(t) {
          t.stopPropagation()
        };
      A.extend(A.event, {
        trigger: function(t, e, r, i) {
          var o, s, a, l, c, h, u, d, f = [r || b],
            g = p.call(t, "type") ? t.type : t,
            m = p.call(t, "namespace") ? t.namespace.split(".") : [];
          if (s = d = a = r = r || b, 3 !== r.nodeType && 8 !== r.nodeType && !xe.test(g + A.event.triggered) &&
            (g.indexOf(".") > -1 && (g = (m = g.split(".")).shift(), m.sort()), c = g.indexOf(":") < 0 &&
              "on" + g, (t = t[A.expando] ? t : new A.Event(g, "object" == typeof t && t)).isTrigger = i ?
              2 : 3, t.namespace = m.join("."), t.rnamespace = t.namespace ? new RegExp("(^|\\.)" + m.join(
                "\\.(?:.*\\.|)") + "(\\.|$)") : null, t.result = void 0, t.target || (t.target = r), e =
              null == e ? [t] : A.makeArray(e, [t]), u = A.event.special[g] || {}, i || !u.trigger || !1 !==
              u.trigger.apply(r, e))) {
            if (!i && !u.noBubble && !y(r)) {
              for (l = u.delegateType || g, xe.test(l + g) || (s = s.parentNode); s; s = s.parentNode) f.push(
                s), a = s;
              a === (r.ownerDocument || b) && f.push(a.defaultView || a.parentWindow || n)
            }
            for (o = 0;
              (s = f[o++]) && !t.isPropagationStopped();) d = s, t.type = o > 1 ? l : u.bindType || g, (h =
              (Z.get(s, "events") || Object.create(null))[t.type] && Z.get(s, "handle")) && h.apply(s,
              e), (h = c && s[c]) && h.apply && Y(s) && (t.result = h.apply(s, e), !1 === t.result && t
              .preventDefault());
            return t.type = g, i || t.isDefaultPrevented() || u._default && !1 !== u._default.apply(f.pop(),
              e) || !Y(r) || c && v(r[g]) && !y(r) && ((a = r[c]) && (r[c] = null), A.event.triggered =
              g, t.isPropagationStopped() && d.addEventListener(g, we), r[g](), t.isPropagationStopped() &&
              d.removeEventListener(g, we), A.event.triggered = void 0, a && (r[c] = a)), t.result
          }
        },
        simulate: function(t, e, n) {
          var r = A.extend(new A.Event, n, {
            type: t,
            isSimulated: !0
          });
          A.event.trigger(r, null, e)
        }
      }), A.fn.extend({
        trigger: function(t, e) {
          return this.each(function() {
            A.event.trigger(t, e, this)
          })
        },
        triggerHandler: function(t, e) {
          var n = this[0];
          if (n) return A.event.trigger(t, e, n, !0)
        }
      }), m.focusin || A.each({
        focus: "focusin",
        blur: "focusout"
      }, function(t, e) {
        var n = function(t) {
          A.event.simulate(e, t.target, A.event.fix(t))
        };
        A.event.special[e] = {
          setup: function() {
            var r = this.ownerDocument || this.document || this,
              i = Z.access(r, e);
            i || r.addEventListener(t, n, !0), Z.access(r, e, (i || 0) + 1)
          },
          teardown: function() {
            var r = this.ownerDocument || this.document || this,
              i = Z.access(r, e) - 1;
            i ? Z.access(r, e, i) : (r.removeEventListener(t, n, !0), Z.remove(r, e))
          }
        }
      });
      var Ae = n.location,
        Ee = {
          guid: Date.now()
        },
        Se = /\?/;
      A.parseXML = function(t) {
        var e;
        if (!t || "string" != typeof t) return null;
        try {
          e = (new n.DOMParser).parseFromString(t, "text/xml")
        } catch (t) {
          e = void 0
        }
        return e && !e.getElementsByTagName("parsererror").length || A.error("Invalid XML: " + t), e
      };
      var Me = /\[\]$/,
        ke = /\r?\n/g,
        Oe = /^(?:submit|button|image|reset|file)$/i,
        Pe = /^(?:input|select|textarea|keygen)/i;

      function De(t, e, n, r) {
        var i;
        if (Array.isArray(e)) A.each(e, function(e, i) {
          n || Me.test(t) ? r(t, i) : De(t + "[" + ("object" == typeof i && null != i ? e : "") + "]", i, n,
            r)
        });
        else if (n || "object" !== w(e)) r(t, e);
        else
          for (i in e) De(t + "[" + i + "]", e[i], n, r)
      }
      A.param = function(t, e) {
        var n, r = [],
          i = function(t, e) {
            var n = v(e) ? e() : e;
            r[r.length] = encodeURIComponent(t) + "=" + encodeURIComponent(null == n ? "" : n)
          };
        if (null == t) return "";
        if (Array.isArray(t) || t.jquery && !A.isPlainObject(t)) A.each(t, function() {
          i(this.name, this.value)
        });
        else
          for (n in t) De(n, t[n], e, i);
        return r.join("&")
      }, A.fn.extend({
        serialize: function() {
          return A.param(this.serializeArray())
        },
        serializeArray: function() {
          return this.map(function() {
            var t = A.prop(this, "elements");
            return t ? A.makeArray(t) : this
          }).filter(function() {
            var t = this.type;
            return this.name && !A(this).is(":disabled") && Pe.test(this.nodeName) && !Oe.test(t) &&
              (this.checked || !gt.test(t))
          }).map(function(t, e) {
            var n = A(this).val();
            return null == n ? null : Array.isArray(n) ? A.map(n, function(t) {
              return {
                name: e.name,
                value: t.replace(ke, "\r\n")
              }
            }) : {
              name: e.name,
              value: n.replace(ke, "\r\n")
            }
          }).get()
        }
      });
      var Te = /%20/g,
        _e = /#.*$/,
        je = /([?&])_=[^&]*/,
        Le = /^(.*?):[ \t]*([^\r\n]*)$/gm,
        Ne = /^(?:GET|HEAD)$/,
        Fe = /^\/\//,
        $e = {},
        Be = {},
        Ie = "*/".concat("*"),
        ze = b.createElement("a");

      function Re(t) {
        return function(e, n) {
          "string" != typeof e && (n = e, e = "*");
          var r, i = 0,
            o = e.toLowerCase().match($) || [];
          if (v(n))
            for (; r = o[i++];) "+" === r[0] ? (r = r.slice(1) || "*", (t[r] = t[r] || []).unshift(n)) : (t[r] =
              t[r] || []).push(n)
        }
      }

      function Ve(t, e, n, r) {
        var i = {},
          o = t === Be;

        function s(a) {
          var l;
          return i[a] = !0, A.each(t[a] || [], function(t, a) {
            var c = a(e, n, r);
            return "string" != typeof c || o || i[c] ? o ? !(l = c) : void 0 : (e.dataTypes.unshift(c), s(c),
              !1)
          }), l
        }
        return s(e.dataTypes[0]) || !i["*"] && s("*")
      }

      function He(t, e) {
        var n, r, i = A.ajaxSettings.flatOptions || {};
        for (n in e) void 0 !== e[n] && ((i[n] ? t : r || (r = {}))[n] = e[n]);
        return r && A.extend(!0, t, r), t
      }
      ze.href = Ae.href, A.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
          url: Ae.href,
          type: "GET",
          isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Ae.protocol),
          global: !0,
          processData: !0,
          async: !0,
          contentType: "application/x-www-form-urlencoded; charset=UTF-8",
          accepts: {
            "*": Ie,
            text: "text/plain",
            html: "text/html",
            xml: "application/xml, text/xml",
            json: "application/json, text/javascript"
          },
          contents: {
            xml: /\bxml\b/,
            html: /\bhtml/,
            json: /\bjson\b/
          },
          responseFields: {
            xml: "responseXML",
            text: "responseText",
            json: "responseJSON"
          },
          converters: {
            "* text": String,
            "text html": !0,
            "text json": JSON.parse,
            "text xml": A.parseXML
          },
          flatOptions: {
            url: !0,
            context: !0
          }
        },
        ajaxSetup: function(t, e) {
          return e ? He(He(t, A.ajaxSettings), e) : He(A.ajaxSettings, t)
        },
        ajaxPrefilter: Re($e),
        ajaxTransport: Re(Be),
        ajax: function(t, e) {
          "object" == typeof t && (e = t, t = void 0), e = e || {};
          var r, i, o, s, a, l, c, h, u, d, p = A.ajaxSetup({}, e),
            f = p.context || p,
            g = p.context && (f.nodeType || f.jquery) ? A(f) : A.event,
            m = A.Deferred(),
            v = A.Callbacks("once memory"),
            y = p.statusCode || {},
            C = {},
            x = {},
            w = "canceled",
            E = {
              readyState: 0,
              getResponseHeader: function(t) {
                var e;
                if (c) {
                  if (!s)
                    for (s = {}; e = Le.exec(o);) s[e[1].toLowerCase() + " "] = (s[e[1].toLowerCase() +
                      " "] || []).concat(e[2]);
                  e = s[t.toLowerCase() + " "]
                }
                return null == e ? null : e.join(", ")
              },
              getAllResponseHeaders: function() {
                return c ? o : null
              },
              setRequestHeader: function(t, e) {
                return null == c && (t = x[t.toLowerCase()] = x[t.toLowerCase()] || t, C[t] = e), this
              },
              overrideMimeType: function(t) {
                return null == c && (p.mimeType = t), this
              },
              statusCode: function(t) {
                var e;
                if (t)
                  if (c) E.always(t[E.status]);
                  else
                    for (e in t) y[e] = [y[e], t[e]];
                return this
              },
              abort: function(t) {
                var e = t || w;
                return r && r.abort(e), S(0, e), this
              }
            };
          if (m.promise(E), p.url = ((t || p.url || Ae.href) + "").replace(Fe, Ae.protocol + "//"), p.type =
            e.method || e.type || p.method || p.type, p.dataTypes = (p.dataType || "*").toLowerCase().match(
              $) || [""], null == p.crossDomain) {
            l = b.createElement("a");
            try {
              l.href = p.url, l.href = l.href, p.crossDomain = ze.protocol + "//" + ze.host != l.protocol +
                "//" + l.host
            } catch (t) {
              p.crossDomain = !0
            }
          }
          if (p.data && p.processData && "string" != typeof p.data && (p.data = A.param(p.data, p.traditional)),
            Ve($e, p, e, E), c) return E;
          for (u in (h = A.event && p.global) && 0 == A.active++ && A.event.trigger("ajaxStart"), p.type =
            p.type.toUpperCase(), p.hasContent = !Ne.test(p.type), i = p.url.replace(_e, ""), p.hasContent ?
            p.data && p.processData && 0 === (p.contentType || "").indexOf(
              "application/x-www-form-urlencoded") && (p.data = p.data.replace(Te, "+")) : (d = p.url.slice(
              i.length), p.data && (p.processData || "string" == typeof p.data) && (i += (Se.test(i) ?
              "&" : "?") + p.data, delete p.data), !1 === p.cache && (i = i.replace(je, "$1"), d = (Se.test(
              i) ? "&" : "?") + "_=" + Ee.guid++ + d), p.url = i + d), p.ifModified && (A.lastModified[i] &&
              E.setRequestHeader("If-Modified-Since", A.lastModified[i]), A.etag[i] && E.setRequestHeader(
                "If-None-Match", A.etag[i])), (p.data && p.hasContent && !1 !== p.contentType || e.contentType) &&
            E.setRequestHeader("Content-Type", p.contentType), E.setRequestHeader("Accept", p.dataTypes[0] &&
              p.accepts[p.dataTypes[0]] ? p.accepts[p.dataTypes[0]] + ("*" !== p.dataTypes[0] ? ", " + Ie +
                "; q=0.01" : "") : p.accepts["*"]), p.headers) E.setRequestHeader(u, p.headers[u]);
          if (p.beforeSend && (!1 === p.beforeSend.call(f, E, p) || c)) return E.abort();
          if (w = "abort", v.add(p.complete), E.done(p.success), E.fail(p.error), r = Ve(Be, p, e, E)) {
            if (E.readyState = 1, h && g.trigger("ajaxSend", [E, p]), c) return E;
            p.async && p.timeout > 0 && (a = n.setTimeout(function() {
              E.abort("timeout")
            }, p.timeout));
            try {
              c = !1, r.send(C, S)
            } catch (t) {
              if (c) throw t;
              S(-1, t)
            }
          } else S(-1, "No Transport");

          function S(t, e, s, l) {
            var u, d, b, C, x, w = e;
            c || (c = !0, a && n.clearTimeout(a), r = void 0, o = l || "", E.readyState = t > 0 ? 4 : 0,
              u = t >= 200 && t < 300 || 304 === t, s && (C = function(t, e, n) {
                for (var r, i, o, s, a = t.contents, l = t.dataTypes;
                  "*" === l[0];) l.shift(), void 0 === r && (r = t.mimeType || e.getResponseHeader(
                  "Content-Type"));
                if (r)
                  for (i in a)
                    if (a[i] && a[i].test(r)) {
                      l.unshift(i);
                      break
                    } if (l[0] in n) o = l[0];
                else {
                  for (i in n) {
                    if (!l[0] || t.converters[i + " " + l[0]]) {
                      o = i;
                      break
                    }
                    s || (s = i)
                  }
                  o = o || s
                }
                if (o) return o !== l[0] && l.unshift(o), n[o]
              }(p, E, s)), !u && A.inArray("script", p.dataTypes) > -1 && (p.converters["text script"] =
                function() {}), C = function(t, e, n, r) {
                var i, o, s, a, l, c = {},
                  h = t.dataTypes.slice();
                if (h[1])
                  for (s in t.converters) c[s.toLowerCase()] = t.converters[s];
                for (o = h.shift(); o;)
                  if (t.responseFields[o] && (n[t.responseFields[o]] = e), !l && r && t.dataFilter && (
                      e = t.dataFilter(e, t.dataType)), l = o, o = h.shift())
                    if ("*" === o) o = l;
                    else if ("*" !== l && l !== o) {
                  if (!(s = c[l + " " + o] || c["* " + o]))
                    for (i in c)
                      if ((a = i.split(" "))[1] === o && (s = c[l + " " + a[0]] || c["* " + a[0]])) {
                        !0 === s ? s = c[i] : !0 !== c[i] && (o = a[0], h.unshift(a[1]));
                        break
                      } if (!0 !== s)
                    if (s && t.throws) e = s(e);
                    else try {
                      e = s(e)
                    } catch (t) {
                      return {
                        state: "parsererror",
                        error: s ? t : "No conversion from " + l + " to " + o
                      }
                    }
                }
                return {
                  state: "success",
                  data: e
                }
              }(p, C, E, u), u ? (p.ifModified && ((x = E.getResponseHeader("Last-Modified")) && (A.lastModified[
                  i] = x), (x = E.getResponseHeader("etag")) && (A.etag[i] = x)), 204 === t || "HEAD" ===
                p.type ? w = "nocontent" : 304 === t ? w = "notmodified" : (w = C.state, d = C.data, u = !
                  (b = C.error))) : (b = w, !t && w || (w = "error", t < 0 && (t = 0))), E.status = t,
              E.statusText = (e || w) + "", u ? m.resolveWith(f, [d, w, E]) : m.rejectWith(f, [E, w, b]),
              E.statusCode(y), y = void 0, h && g.trigger(u ? "ajaxSuccess" : "ajaxError", [E, p, u ? d :
                b
              ]), v.fireWith(f, [E, w]), h && (g.trigger("ajaxComplete", [E, p]), --A.active || A.event
                .trigger("ajaxStop")))
          }
          return E
        },
        getJSON: function(t, e, n) {
          return A.get(t, e, n, "json")
        },
        getScript: function(t, e) {
          return A.get(t, void 0, e, "script")
        }
      }), A.each(["get", "post"], function(t, e) {
        A[e] = function(t, n, r, i) {
          return v(n) && (i = i || r, r = n, n = void 0), A.ajax(A.extend({
            url: t,
            type: e,
            dataType: i,
            data: n,
            success: r
          }, A.isPlainObject(t) && t))
        }
      }), A.ajaxPrefilter(function(t) {
        var e;
        for (e in t.headers) "content-type" === e.toLowerCase() && (t.contentType = t.headers[e] || "")
      }), A._evalUrl = function(t, e, n) {
        return A.ajax({
          url: t,
          type: "GET",
          dataType: "script",
          cache: !0,
          async: !1,
          global: !1,
          converters: {
            "text script": function() {}
          },
          dataFilter: function(t) {
            A.globalEval(t, e, n)
          }
        })
      }, A.fn.extend({
        wrapAll: function(t) {
          var e;
          return this[0] && (v(t) && (t = t.call(this[0])), e = A(t, this[0].ownerDocument).eq(0).clone(!
            0), this[0].parentNode && e.insertBefore(this[0]), e.map(function() {
            for (var t = this; t.firstElementChild;) t = t.firstElementChild;
            return t
          }).append(this)), this
        },
        wrapInner: function(t) {
          return v(t) ? this.each(function(e) {
            A(this).wrapInner(t.call(this, e))
          }) : this.each(function() {
            var e = A(this),
              n = e.contents();
            n.length ? n.wrapAll(t) : e.append(t)
          })
        },
        wrap: function(t) {
          var e = v(t);
          return this.each(function(n) {
            A(this).wrapAll(e ? t.call(this, n) : t)
          })
        },
        unwrap: function(t) {
          return this.parent(t).not("body").each(function() {
            A(this).replaceWith(this.childNodes)
          }), this
        }
      }), A.expr.pseudos.hidden = function(t) {
        return !A.expr.pseudos.visible(t)
      }, A.expr.pseudos.visible = function(t) {
        return !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length)
      }, A.ajaxSettings.xhr = function() {
        try {
          return new n.XMLHttpRequest
        } catch (t) {}
      };
      var Ge = {
          0: 200,
          1223: 204
        },
        Ue = A.ajaxSettings.xhr();
      m.cors = !!Ue && "withCredentials" in Ue, m.ajax = Ue = !!Ue, A.ajaxTransport(function(t) {
        var e, r;
        if (m.cors || Ue && !t.crossDomain) return {
          send: function(i, o) {
            var s, a = t.xhr();
            if (a.open(t.type, t.url, t.async, t.username, t.password), t.xhrFields)
              for (s in t.xhrFields) a[s] = t.xhrFields[s];
            for (s in t.mimeType && a.overrideMimeType && a.overrideMimeType(t.mimeType), t.crossDomain ||
              i["X-Requested-With"] || (i["X-Requested-With"] = "XMLHttpRequest"), i) a.setRequestHeader(
              s, i[s]);
            e = function(t) {
                return function() {
                  e && (e = r = a.onload = a.onerror = a.onabort = a.ontimeout = a.onreadystatechange =
                    null, "abort" === t ? a.abort() : "error" === t ? "number" != typeof a.status ?
                    o(0, "error") : o(a.status, a.statusText) : o(Ge[a.status] || a.status, a.statusText,
                      "text" !== (a.responseType || "text") || "string" != typeof a.responseText ? {
                        binary: a.response
                      } : {
                        text: a.responseText
                      }, a.getAllResponseHeaders()))
                }
              }, a.onload = e(), r = a.onerror = a.ontimeout = e("error"), void 0 !== a.onabort ? a.onabort =
              r : a.onreadystatechange = function() {
                4 === a.readyState && n.setTimeout(function() {
                  e && r()
                })
              }, e = e("abort");
            try {
              a.send(t.hasContent && t.data || null)
            } catch (t) {
              if (e) throw t
            }
          },
          abort: function() {
            e && e()
          }
        }
      }), A.ajaxPrefilter(function(t) {
        t.crossDomain && (t.contents.script = !1)
      }), A.ajaxSetup({
        accepts: {
          script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
          script: /\b(?:java|ecma)script\b/
        },
        converters: {
          "text script": function(t) {
            return A.globalEval(t), t
          }
        }
      }), A.ajaxPrefilter("script", function(t) {
        void 0 === t.cache && (t.cache = !1), t.crossDomain && (t.type = "GET")
      }), A.ajaxTransport("script", function(t) {
        var e, n;
        if (t.crossDomain || t.scriptAttrs) return {
          send: function(r, i) {
            e = A("<script>").attr(t.scriptAttrs || {}).prop({
              charset: t.scriptCharset,
              src: t.url
            }).on("load error", n = function(t) {
              e.remove(), n = null, t && i("error" === t.type ? 404 : 200, t.type)
            }), b.head.appendChild(e[0])
          },
          abort: function() {
            n && n()
          }
        }
      });
      var qe, We = [],
        Xe = /(=)\?(?=&|$)|\?\?/;
      A.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
          var t = We.pop() || A.expando + "_" + Ee.guid++;
          return this[t] = !0, t
        }
      }), A.ajaxPrefilter("json jsonp", function(t, e, r) {
        var i, o, s, a = !1 !== t.jsonp && (Xe.test(t.url) ? "url" : "string" == typeof t.data && 0 === (t.contentType ||
          "").indexOf("application/x-www-form-urlencoded") && Xe.test(t.data) && "data");
        if (a || "jsonp" === t.dataTypes[0]) return i = t.jsonpCallback = v(t.jsonpCallback) ? t.jsonpCallback() :
          t.jsonpCallback, a ? t[a] = t[a].replace(Xe, "$1" + i) : !1 !== t.jsonp && (t.url += (Se.test(t
            .url) ? "&" : "?") + t.jsonp + "=" + i), t.converters["script json"] = function() {
            return s || A.error(i + " was not called"), s[0]
          }, t.dataTypes[0] = "json", o = n[i], n[i] = function() {
            s = arguments
          }, r.always(function() {
            void 0 === o ? A(n).removeProp(i) : n[i] = o, t[i] && (t.jsonpCallback = e.jsonpCallback,
              We.push(i)), s && v(o) && o(s[0]), s = o = void 0
          }), "script"
      }), m.createHTMLDocument = ((qe = b.implementation.createHTMLDocument("").body).innerHTML =
        "<form></form><form></form>", 2 === qe.childNodes.length), A.parseHTML = function(t, e, n) {
        return "string" != typeof t ? [] : ("boolean" == typeof e && (n = e, e = !1), e || (m.createHTMLDocument ?
          ((r = (e = b.implementation.createHTMLDocument("")).createElement("base")).href = b.location.href,
            e.head.appendChild(r)) : e = b), i = D.exec(t), o = !n && [], i ? [e.createElement(i[1])] : (
          i = wt([t], e, o), o && o.length && A(o).remove(), A.merge([], i.childNodes)));
        var r, i, o
      }, A.fn.load = function(t, e, n) {
        var r, i, o, s = this,
          a = t.indexOf(" ");
        return a > -1 && (r = ve(t.slice(a)), t = t.slice(0, a)), v(e) ? (n = e, e = void 0) : e && "object" ==
          typeof e && (i = "POST"), s.length > 0 && A.ajax({
            url: t,
            type: i || "GET",
            dataType: "html",
            data: e
          }).done(function(t) {
            o = arguments, s.html(r ? A("<div>").append(A.parseHTML(t)).find(r) : t)
          }).always(n && function(t, e) {
            s.each(function() {
              n.apply(this, o || [t.responseText, e, t])
            })
          }), this
      }, A.expr.pseudos.animated = function(t) {
        return A.grep(A.timers, function(e) {
          return t === e.elem
        }).length
      }, A.offset = {
        setOffset: function(t, e, n) {
          var r, i, o, s, a, l, c = A.css(t, "position"),
            h = A(t),
            u = {};
          "static" === c && (t.style.position = "relative"), a = h.offset(), o = A.css(t, "top"), l = A.css(
              t, "left"), ("absolute" === c || "fixed" === c) && (o + l).indexOf("auto") > -1 ? (s = (r = h
              .position()).top, i = r.left) : (s = parseFloat(o) || 0, i = parseFloat(l) || 0), v(e) && (e =
              e.call(t, n, A.extend({}, a))), null != e.top && (u.top = e.top - a.top + s), null != e.left &&
            (u.left = e.left - a.left + i), "using" in e ? e.using.call(t, u) : ("number" == typeof u.top &&
              (u.top += "px"), "number" == typeof u.left && (u.left += "px"), h.css(u))
        }
      }, A.fn.extend({
        offset: function(t) {
          if (arguments.length) return void 0 === t ? this : this.each(function(e) {
            A.offset.setOffset(this, t, e)
          });
          var e, n, r = this[0];
          return r ? r.getClientRects().length ? (e = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, {
            top: e.top + n.pageYOffset,
            left: e.left + n.pageXOffset
          }) : {
            top: 0,
            left: 0
          } : void 0
        },
        position: function() {
          if (this[0]) {
            var t, e, n, r = this[0],
              i = {
                top: 0,
                left: 0
              };
            if ("fixed" === A.css(r, "position")) e = r.getBoundingClientRect();
            else {
              for (e = this.offset(), n = r.ownerDocument, t = r.offsetParent || n.documentElement; t &&
                (t === n.body || t === n.documentElement) && "static" === A.css(t, "position");) t = t.parentNode;
              t && t !== r && 1 === t.nodeType && ((i = A(t).offset()).top += A.css(t, "borderTopWidth",
                !0), i.left += A.css(t, "borderLeftWidth", !0))
            }
            return {
              top: e.top - i.top - A.css(r, "marginTop", !0),
              left: e.left - i.left - A.css(r, "marginLeft", !0)
            }
          }
        },
        offsetParent: function() {
          return this.map(function() {
            for (var t = this.offsetParent; t && "static" === A.css(t, "position");) t = t.offsetParent;
            return t || ot
          })
        }
      }), A.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
      }, function(t, e) {
        var n = "pageYOffset" === e;
        A.fn[t] = function(r) {
          return G(this, function(t, r, i) {
            var o;
            if (y(t) ? o = t : 9 === t.nodeType && (o = t.defaultView), void 0 === i) return o ? o[e] :
              t[r];
            o ? o.scrollTo(n ? o.pageXOffset : i, n ? i : o.pageYOffset) : t[r] = i
          }, t, r, arguments.length)
        }
      }), A.each(["top", "left"], function(t, e) {
        A.cssHooks[e] = Ut(m.pixelPosition, function(t, n) {
          if (n) return n = Gt(t, e), zt.test(n) ? A(t).position()[e] + "px" : n
        })
      }), A.each({
        Height: "height",
        Width: "width"
      }, function(t, e) {
        A.each({
          padding: "inner" + t,
          content: e,
          "": "outer" + t
        }, function(n, r) {
          A.fn[r] = function(i, o) {
            var s = arguments.length && (n || "boolean" != typeof i),
              a = n || (!0 === i || !0 === o ? "margin" : "border");
            return G(this, function(e, n, i) {
              var o;
              return y(e) ? 0 === r.indexOf("outer") ? e["inner" + t] : e.document.documentElement[
                "client" + t] : 9 === e.nodeType ? (o = e.documentElement, Math.max(e.body[
                "scroll" + t], o["scroll" + t], e.body["offset" + t], o["offset" + t], o[
                "client" + t])) : void 0 === i ? A.css(e, n, a) : A.style(e, n, i, a)
            }, e, s ? i : void 0, s)
          }
        })
      }), A.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(
        t, e) {
        A.fn[e] = function(t) {
          return this.on(e, t)
        }
      }), A.fn.extend({
        bind: function(t, e, n) {
          return this.on(t, null, e, n)
        },
        unbind: function(t, e) {
          return this.off(t, null, e)
        },
        delegate: function(t, e, n, r) {
          return this.on(e, t, n, r)
        },
        undelegate: function(t, e, n) {
          return 1 === arguments.length ? this.off(t, "**") : this.off(e, t || "**", n)
        },
        hover: function(t, e) {
          return this.mouseenter(t).mouseleave(e || t)
        }
      }), A.each(
        "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu"
        .split(" "),
        function(t, e) {
          A.fn[e] = function(t, n) {
            return arguments.length > 0 ? this.on(e, null, t, n) : this.trigger(e)
          }
        });
      var Ye = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
      A.proxy = function(t, e) {
          var n, r, i;
          if ("string" == typeof e && (n = t[e], e = t, t = n), v(t)) return r = a.call(arguments, 2), (i =
            function() {
              return t.apply(e || this, r.concat(a.call(arguments)))
            }).guid = t.guid = t.guid || A.guid++, i
        }, A.holdReady = function(t) {
          t ? A.readyWait++ : A.ready(!0)
        }, A.isArray = Array.isArray, A.parseJSON = JSON.parse, A.nodeName = P, A.isFunction = v, A.isWindow =
        y, A.camelCase = X, A.type = w, A.now = Date.now, A.isNumeric = function(t) {
          var e = A.type(t);
          return ("number" === e || "string" === e) && !isNaN(t - parseFloat(t))
        }, A.trim = function(t) {
          return null == t ? "" : (t + "").replace(Ye, "")
        }, void 0 === (r = function() {
          return A
        }.apply(e, [])) || (t.exports = r);
      var Je = n.jQuery,
        Ze = n.$;
      return A.noConflict = function(t) {
        return n.$ === A && (n.$ = Ze), t && n.jQuery === A && (n.jQuery = Je), A
      }, void 0 === i && (n.jQuery = n.$ = A), A
    })
  },
  DuR2: function(t, e) {
    var n;
    n = function() {
      return this
    }();
    try {
      n = n || Function("return this")() || (0, eval)("this")
    } catch (t) {
      "object" == typeof window && (n = window)
    }
    t.exports = n
  },
  FvOO: function(t, e, n) {
    "use strict";
    (function(t) {
      var r = n("WlpS"),
        i = n("YXvJ"),
        o = "object" == typeof exports && exports && !exports.nodeType && exports,
        s = o && "object" == typeof t && t && !t.nodeType && t,
        a = s && s.exports === o ? r.a.Buffer : void 0,
        l = (a ? a.isBuffer : void 0) || i.a;
      e.a = l
    }).call(e, n("f1Eh")(t))
  },
  PPKb: function(t, e, n) {
    "use strict";
    (function(t) {
      n.d(e, "a", function() {
        return i
      });
      const r = navigator.userAgent;
      var i;
      ! function(t) {
        t.IS_MAC = navigator.appVersion.indexOf("Mac") > 0, t.IS_IOS = !!r.match(/(iPad|iPhone|iPod)/g), t.IS_WINDOWS =
          navigator.appVersion.indexOf("Win") > 0, t.IS_IE = r.indexOf("MSIE") >= 0, t.IS_IE11 = !!r.match(
            /Trident\/7\./), t.IS_EDGE = !!r.match(/Edge\//), t.IS_NETSCAPE = r.indexOf("Mozilla/") >= 0 && r.indexOf(
            "MSIE") < 0 && r.indexOf("Edge/") < 0, t.IS_CHROME_APP = null != window.chrome && null != window.chrome
          .app && null != window.chrome.app.runtime, t.IS_CHROME = r.indexOf("Chrome/") >= 0 && r.indexOf(
            "Edge/") < 0, t.IS_OPERA = r.indexOf("Opera/") >= 0 || r.indexOf("OPR/") >= 0, t.IS_FIREFOX = r.indexOf(
            "Firefox/") >= 0, t.IS_SAFARI = r.indexOf("AppleWebKit/") >= 0 && r.indexOf("Chrome/") < 0 && r.indexOf(
            "Edge/") < 0, t.SUPPORT_TOUCH = "ontouchstart" in document.documentElement, t.SUPPORT_POINTER =
          null != window.PointerEvent && !t.IS_MAC, t.SUPPORT_PASSIVE = !1;
        try {
          const e = Object.defineProperty({}, "passive", {
              get() {
                t.SUPPORT_PASSIVE = !0
              }
            }),
            n = document.createElement("div");
          n.addEventListener && n.addEventListener("click", () => {}, e)
        } catch (t) {}
        t.NO_FOREIGNOBJECT = !document.createElementNS || "[object SVGForeignObjectElement]" !==
          `${document.createElementNS("http://www.w3.org/2000/svg","foreignObject")}` || r.indexOf("Opera/") >=
          0, t.SUPPORT_FOREIGNOBJECT = !t.NO_FOREIGNOBJECT
      }(i || (i = {})),
      function(e) {
        function n() {
          const e = t;
          return null != e && null != e.hot && null != e.hot.status ? e.hot.status() : "unkonwn"
        }
        e.getHMRStatus = n, e.isApplyingHMR = function() {
          return "apply" === n()
        };
        const r = {
          select: "input",
          change: "input",
          submit: "form",
          reset: "form",
          error: "img",
          load: "img",
          abort: "img"
        };
        e.isEventSupported = function(t) {
          const e = document.createElement(r[t] || "div"),
            n = `on${t}`;
          let i = n in e;
          return i || (e.setAttribute(n, "return;"), i = "function" == typeof e[n]), i
        }
      }(i || (i = {}))
    }).call(e, n("f1Eh")(t))
  },
  "VU/8": function(t, e) {
    t.exports = function(t, e, n, r, i, o) {
      var s, a = t = t || {},
        l = typeof t.default;
      "object" !== l && "function" !== l || (s = t, a = t.default);
      var c, h = "function" == typeof a ? a.options : a;
      if (e && (h.render = e.render, h.staticRenderFns = e.staticRenderFns, h._compiled = !0), n && (h.functional = !
          0), i && (h._scopeId = i), o ? (c = function(t) {
          (t = t || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent
            .$vnode.ssrContext) || "undefined" == typeof __VUE_SSR_CONTEXT__ || (t = __VUE_SSR_CONTEXT__), r &&
            r.call(this, t), t && t._registeredComponents && t._registeredComponents.add(o)
        }, h._ssrRegister = c) : r && (c = r), c) {
        var u = h.functional,
          d = u ? h.render : h.beforeCreate;
        u ? (h._injectStyles = c, h.render = function(t, e) {
          return c.call(e), d(t, e)
        }) : h.beforeCreate = d ? [].concat(d, c) : [c]
      }
      return {
        esModule: s,
        exports: a,
        options: h
      }
    }
  },
  WlpS: function(t, e, n) {
    "use strict";
    var r = n("nSxQ"),
      i = "object" == typeof self && self && self.Object === Object && self,
      o = r.a || i || Function("return this")();
    e.a = o
  },
  YXvJ: function(t, e, n) {
    "use strict";
    e.a = function() {
      return !1
    }
  },
  f1Eh: function(t, e) {
    t.exports = function(t) {
      if (!t.webpackPolyfill) {
        var e = Object.create(t);
        e.children || (e.children = []), Object.defineProperty(e, "loaded", {
          enumerable: !0,
          get: function() {
            return e.l
          }
        }), Object.defineProperty(e, "id", {
          enumerable: !0,
          get: function() {
            return e.i
          }
        }), Object.defineProperty(e, "exports", {
          enumerable: !0
        }), e.webpackPolyfill = 1
      }
      return e
    }
  },
  gzeU: function(t, e, n) {
    "use strict";
    (function(t) {
      var r = n("WlpS"),
        i = "object" == typeof exports && exports && !exports.nodeType && exports,
        o = i && "object" == typeof t && t && !t.nodeType && t,
        s = o && o.exports === i ? r.a.Buffer : void 0,
        a = s ? s.allocUnsafe : void 0;
      e.a = function(t, e) {
        if (e) return t.slice();
        var n = t.length,
          r = a ? a(n) : new t.constructor(n);
        return t.copy(r), r
      }
    }).call(e, n("f1Eh")(t))
  },
  iqcg: function(t, e, n) {
    "use strict";
    var r = {};
    n.d(r, "isNull", function() {
      return bd
    }), n.d(r, "isNil", function() {
      return yd
    }), n.d(r, "isUndefined", function() {
      return Md
    }), n.d(r, "isString", function() {
      return vu
    }), n.d(r, "isNumber", function() {
      return dd
    }), n.d(r, "isBoolean", function() {
      return Xu
    }), n.d(r, "isObject", function() {
      return rt
    }), n.d(r, "isArray", function() {
      return J
    }), n.d(r, "isArrayLike", function() {
      return In
    }), n.d(r, "isFunction", function() {
      return At
    }), n.d(r, "isWindow", function() {
      return uy
    }), n.d(r, "isNumeric", function() {
      return dy
    });
    var i = {};
    n.d(i, "isArray", function() {
      return J
    }), n.d(i, "isArrayLike", function() {
      return In
    }), n.d(i, "toArray", function() {
      return bp
    }), n.d(i, "uniq", function() {
      return cv
    }), n.d(i, "union", function() {
      return sv
    }), n.d(i, "sortedIndex", function() {
      return Ng
    }), n.d(i, "sortedIndexBy", function() {
      return Fg
    }), n.d(i, "sortBy", function() {
      return Og
    }), n.d(i, "groupBy", function() {
      return iu
    }), n.d(i, "difference", function() {
      return Dc
    }), n.d(i, "without", function() {
      return Av
    });
    var o = {};
    n.d(o, "has", function() {
      return uu
    }), n.d(o, "pick", function() {
      return wf
    }), n.d(o, "forIn", function() {
      return Yh
    }), n.d(o, "merge", function() {
      return sp
    }), n.d(o, "extend", function() {
      return vr
    }), n.d(o, "isEqual", function() {
      return id
    }), n.d(o, "isEmpty", function() {
      return rd
    }), n.d(o, "isObject", function() {
      return rt
    }), n.d(o, "isPlainObject", function() {
      return Oi
    }), n.d(o, "clone", function() {
      return wa
    }), n.d(o, "cloneDeep", function() {
      return Sa
    }), n.d(o, "defaults", function() {
      return pc
    }), n.d(o, "defaultsDeep", function() {
      return wc
    }), n.d(o, "ensure", function() {
      return yy
    }), n.d(o, "getValue", function() {
      return by
    }), n.d(o, "getNumber", function() {
      return Cy
    }), n.d(o, "getBoolean", function() {
      return xy
    }), n.d(o, "getByPath", function() {
      return wy
    }), n.d(o, "setByPath", function() {
      return Ay
    }), n.d(o, "unsetByPath", function() {
      return Ey
    }), n.d(o, "flatten", function() {
      return Sy
    }), n.d(o, "applyMixins", function() {
      return py
    }), n.d(o, "inherit", function() {
      return gy
    }), n.d(o, "createClass", function() {
      return vy
    });
    var s = {};
    n.d(s, "isString", function() {
      return vu
    }), n.d(s, "toString", function() {
      return ai
    }), n.d(s, "escape", function() {
      return ih
    }), n.d(s, "unescape", function() {
      return nv
    }), n.d(s, "startsWith", function() {
      return Jg
    }), n.d(s, "endsWith", function() {
      return Wc
    }), n.d(s, "split", function() {
      return Ug
    }), n.d(s, "repeat", function() {
      return eg
    }), n.d(s, "pad", function() {
      return hf
    }), n.d(s, "padEnd", function() {
      return uf
    }), n.d(s, "padStart", function() {
      return df
    }), n.d(s, "truncate", function() {
      return Zm
    }), n.d(s, "template", function() {
      return Am
    }), n.d(s, "uniqueId", function() {
      return pv
    }), n.d(s, "eval", function() {
      return My
    }), n.d(s, "camelCase", function() {
      return Fo
    }), n.d(s, "kebabCase", function() {
      return Nd
    }), n.d(s, "startCase", function() {
      return Yg
    }), n.d(s, "snakeCase", function() {
      return Sg
    }), n.d(s, "lowerCase", function() {
      return Rd
    }), n.d(s, "upperCase", function() {
      return xv
    }), n.d(s, "lowerFirst", function() {
      return Vd
    }), n.d(s, "upperFirst", function() {
      return io
    }), n.d(s, "capitalize", function() {
      return oo
    }), n.d(s, "pascalCase", function() {
      return ky
    }), n.d(s, "constantCase", function() {
      return Oy
    }), n.d(s, "dotCase", function() {
      return Py
    }), n.d(s, "pathCase", function() {
      return Dy
    }), n.d(s, "sentenceCase", function() {
      return Ty
    }), n.d(s, "titleCase", function() {
      return _y
    }), n.d(s, "hashcode", function() {
      return jy
    }), n.d(s, "uuid", function() {
      return Ly
    }), n.d(s, "sanitizeHTML", function() {
      return Ny
    }), n.d(s, "getSpellingSuggestion", function() {
      return Fy
    });
    var a = {};
    n.d(a, "isNumber", function() {
      return dd
    }), n.d(a, "isFinite", function() {
      return ad
    }), n.d(a, "isNaN", function() {
      return pd
    }), n.d(a, "isInteger", function() {
      return ld
    }), n.d(a, "isSafeInteger", function() {
      return Sd
    }), n.d(a, "clamp", function() {
      return Wo
    }), n.d(a, "inRange", function() {
      return gu
    }), n.d(a, "toFinite", function() {
      return pt
    }), n.d(a, "toNumber", function() {
      return ht
    }), n.d(a, "toInteger", function() {
      return ft
    }), n.d(a, "toSafeInteger", function() {
      return $m
    }), n.d(a, "parseInt", function() {
      return gf
    }), n.d(a, "isNumeric", function() {
      return dy
    }), n.d(a, "mod", function() {
      return By
    }), n.d(a, "random", function() {
      return Iy
    }), n.d(a, "isPercentage", function() {
      return zy
    }), n.d(a, "normalizePercentage", function() {
      return Ry
    }), n.d(a, "parseCssNumeric", function() {
      return Vy
    }), n.d(a, "normalizeSides", function() {
      return Hy
    });
    var l = {};
    n.d(l, "isFunction", function() {
      return At
    }), n.d(l, "once", function() {
      return Tp
    }), n.d(l, "noop", function() {
      return ne
    }), n.d(l, "debounce", function() {
      return cc
    }), n.d(l, "defer", function() {
      return Sc
    }), n.d(l, "apply", function() {
      return Gy
    }), n.d(l, "call", function() {
      return Uy
    }), n.d(l, "cacher", function() {
      return qy
    }), n.d(l, "isAsyncLike", function() {
      return Wy
    }), n.d(l, "isAsync", function() {
      return Xy
    }), n.d(l, "toAsyncBoolean", function() {
      return Yy
    }), n.d(l, "toDeferredBoolean", function() {
      return Jy
    });
    var c = {};
    n.d(c, "annotate", function() {
      return $b
    }), n.d(c, "findAnnotationsAtIndex", function() {
      return Bb
    }), n.d(c, "findAnnotationsBetweenIndexes", function() {
      return Ib
    }), n.d(c, "shiftAnnotations", function() {
      return zb
    }), n.d(c, "sanitize", function() {
      return Rb
    });
    var h = {};
    n.d(h, "isVector", function() {
      return Px
    }), n.d(h, "createVector", function() {
      return Dx
    }), n.d(h, "createVectors", function() {
      return Tx
    }), n.d(h, "toHTMLElement", function() {
      return _x
    }), n.d(h, "toHTMLElements", function() {
      return jx
    }), n.d(h, "requestAnimationFrame", function() {
      return Ub
    }), n.d(h, "cancelAnimationFrame", function() {
      return qb
    }), n.d(h, "getAttribute", function() {
      return Pb
    }), n.d(h, "removeAttribute", function() {
      return Db
    }), n.d(h, "setAttribute", function() {
      return Tb
    }), n.d(h, "setAttributes", function() {
      return _b
    }), n.d(h, "attr", function() {
      return jb
    }), n.d(h, "qualifyAttr", function() {
      return Lb
    }), n.d(h, "styleToObject", function() {
      return Nb
    }), n.d(h, "mergeAttrs", function() {
      return Fb
    }), n.d(h, "uniqueId", function() {
      return sb
    }), n.d(h, "ensureId", function() {
      return ab
    }), n.d(h, "isSVGGraphicsElement", function() {
      return lb
    }), n.d(h, "ns", function() {
      return cb
    }), n.d(h, "svgVersion", function() {
      return hb
    }), n.d(h, "createElement", function() {
      return ub
    }), n.d(h, "createElementNS", function() {
      return db
    }), n.d(h, "createSvgElement", function() {
      return pb
    }), n.d(h, "createSvgDocument", function() {
      return fb
    }), n.d(h, "parseXML", function() {
      return gb
    }), n.d(h, "tagName", function() {
      return mb
    }), n.d(h, "index", function() {
      return vb
    }), n.d(h, "find", function() {
      return yb
    }), n.d(h, "findOne", function() {
      return bb
    }), n.d(h, "findParentByClass", function() {
      return Cb
    }), n.d(h, "contains", function() {
      return xb
    }), n.d(h, "remove", function() {
      return wb
    }), n.d(h, "empty", function() {
      return Ab
    }), n.d(h, "append", function() {
      return Eb
    }), n.d(h, "prepend", function() {
      return Sb
    }), n.d(h, "before", function() {
      return Mb
    }), n.d(h, "appendTo", function() {
      return kb
    }), n.d(h, "isHTMLElement", function() {
      return Ob
    }), n.d(h, "getClass", function() {
      return tb
    }), n.d(h, "hasClass", function() {
      return eb
    }), n.d(h, "addClass", function() {
      return nb
    }), n.d(h, "removeClass", function() {
      return rb
    }), n.d(h, "toggleClass", function() {
      return ib
    }), n.d(h, "setPrefixedStyle", function() {
      return Kb
    }), n.d(h, "getComputedStyle", function() {
      return Qb
    }), n.d(h, "hasScrollbars", function() {
      return tC
    }), n.d(h, "getVendorPrefixedName", function() {
      return Zb
    }), n.d(h, "clearSelection", function() {
      return eC
    }), n.d(h, "text", function() {
      return LC
    }), n.d(h, "breakText", function() {
      return NC
    }), n.d(h, "KAPPA", function() {
      return FC
    }), n.d(h, "sample", function() {
      return BC
    }), n.d(h, "lineToPathData", function() {
      return IC
    }), n.d(h, "polygonToPathData", function() {
      return zC
    }), n.d(h, "polylineToPathData", function() {
      return RC
    }), n.d(h, "getPointsFromSvgElement", function() {
      return HC
    }), n.d(h, "circleToPathData", function() {
      return GC
    }), n.d(h, "ellipseToPathData", function() {
      return UC
    }), n.d(h, "rectangleToPathData", function() {
      return qC
    }), n.d(h, "rectToPathData", function() {
      return WC
    }), n.d(h, "toPath", function() {
      return XC
    }), n.d(h, "toPathData", function() {
      return YC
    }), n.d(h, "createSlicePathData", function() {
      return JC
    }), n.d(h, "bbox", function() {
      return mx
    }), n.d(h, "getBBox", function() {
      return vx
    }), n.d(h, "getTransformToElement", function() {
      return yx
    }), n.d(h, "toLocalPoint", function() {
      return bx
    }), n.d(h, "toGeometryShape", function() {
      return Cx
    }), n.d(h, "getIntersection", function() {
      return xx
    }), n.d(h, "animateAlongPath", function() {
      return wx
    }), n.d(h, "getBoundingOffsetRect", function() {
      return Ax
    }), n.d(h, "createSVGPoint", function() {
      return ex
    }), n.d(h, "createSVGMatrix", function() {
      return nx
    }), n.d(h, "createSVGTransform", function() {
      return rx
    }), n.d(h, "transformStringToMatrix", function() {
      return ix
    }), n.d(h, "matrixToTransformString", function() {
      return ox
    }), n.d(h, "parseTransformString", function() {
      return sx
    }), n.d(h, "decomposeMatrix", function() {
      return lx
    }), n.d(h, "matrixToScale", function() {
      return cx
    }), n.d(h, "matrixToRotation", function() {
      return hx
    }), n.d(h, "matrixToTranslation", function() {
      return ux
    }), n.d(h, "transformPoint", function() {
      return dx
    }), n.d(h, "transformLine", function() {
      return px
    }), n.d(h, "transformPolyline", function() {
      return fx
    }), n.d(h, "transformRectangle", function() {
      return gx
    }), n.d(h, "transform", function() {
      return Ex
    }), n.d(h, "translate", function() {
      return Sx
    }), n.d(h, "rotate", function() {
      return Mx
    }), n.d(h, "scale", function() {
      return kx
    }), n.d(h, "translateAndAutoOrient", function() {
      return Ox
    });
    var u = {};
    n.d(u, "block", function() {
      return Zw
    }), n.d(u, "classic", function() {
      return Kw
    }), n.d(u, "diamond", function() {
      return eA
    }), n.d(u, "path", function() {
      return rA
    }), n.d(u, "cross", function() {
      return oA
    }), n.d(u, "async", function() {
      return aA
    }), n.d(u, "circle", function() {
      return cA
    }), n.d(u, "circlePlus", function() {
      return hA
    }), n.d(u, "ellipse", function() {
      return dA
    });
    var d = {};
    n.d(d, "ref", function() {
      return tw
    }), n.d(d, "refX", function() {
      return ew
    }), n.d(d, "refY", function() {
      return nw
    }), n.d(d, "refDx", function() {
      return rw
    }), n.d(d, "refDy", function() {
      return iw
    }), n.d(d, "refWidth", function() {
      return ow
    }), n.d(d, "refHeight", function() {
      return sw
    }), n.d(d, "refRx", function() {
      return aw
    }), n.d(d, "refRy", function() {
      return lw
    }), n.d(d, "refRInscribed", function() {
      return cw
    }), n.d(d, "refRCircumscribed", function() {
      return hw
    }), n.d(d, "refCx", function() {
      return uw
    }), n.d(d, "refCy", function() {
      return dw
    }), n.d(d, "refDResetOffset", function() {
      return pw
    }), n.d(d, "refDKeepOffset", function() {
      return fw
    }), n.d(d, "refPointsResetOffset", function() {
      return gw
    }), n.d(d, "refPointsKeepOffset", function() {
      return mw
    }), n.d(d, "refR", function() {
      return vw
    }), n.d(d, "refD", function() {
      return yw
    }), n.d(d, "refPoints", function() {
      return bw
    }), n.d(d, "refX2", function() {
      return Cw
    }), n.d(d, "refY2", function() {
      return xw
    }), n.d(d, "refWidth2", function() {
      return ww
    }), n.d(d, "refHeight2", function() {
      return Aw
    }), n.d(d, "fill", function() {
      return Pw
    }), n.d(d, "stroke", function() {
      return Dw
    }), n.d(d, "text", function() {
      return Tw
    }), n.d(d, "textWrap", function() {
      return _w
    }), n.d(d, "lineHeight", function() {
      return Lw
    }), n.d(d, "textVerticalAnchor", function() {
      return Nw
    }), n.d(d, "textPath", function() {
      return Fw
    }), n.d(d, "annotations", function() {
      return $w
    }), n.d(d, "eol", function() {
      return Bw
    }), n.d(d, "displayEmpty", function() {
      return Iw
    }), n.d(d, "title", function() {
      return zw
    }), n.d(d, "xAlign", function() {
      return Rw
    }), n.d(d, "yAlign", function() {
      return Vw
    }), n.d(d, "resetOffset", function() {
      return Hw
    }), n.d(d, "style", function() {
      return Uw
    }), n.d(d, "html", function() {
      return qw
    }), n.d(d, "filter", function() {
      return Ww
    }), n.d(d, "port", function() {
      return Xw
    }), n.d(d, "sourceMarker", function() {
      return vA
    }), n.d(d, "targetMarker", function() {
      return yA
    }), n.d(d, "vertexMarker", function() {
      return bA
    }), n.d(d, "connection", function() {
      return wA
    }), n.d(d, "atConnectionLengthKeepGradient", function() {
      return AA
    }), n.d(d, "atConnectionLengthIgnoreGradient", function() {
      return EA
    }), n.d(d, "atConnectionRatioKeepGradient", function() {
      return SA
    }), n.d(d, "atConnectionRatioIgnoreGradient", function() {
      return MA
    }), n.d(d, "atConnectionLength", function() {
      return kA
    }), n.d(d, "atConnectionRatio", function() {
      return OA
    });
    var p = {};
    n.d(p, "dot", function() {
      return _A
    }), n.d(p, "fixedDot", function() {
      return jA
    }), n.d(p, "mesh", function() {
      return LA
    }), n.d(p, "doubleMesh", function() {
      return NA
    });
    var f = {};
    n.d(f, "outline", function() {
      return VA
    }), n.d(f, "highlight", function() {
      return HA
    }), n.d(f, "blur", function() {
      return GA
    }), n.d(f, "dropShadow", function() {
      return UA
    }), n.d(f, "grayScale", function() {
      return qA
    }), n.d(f, "sepia", function() {
      return WA
    }), n.d(f, "saturate", function() {
      return XA
    }), n.d(f, "hueRotate", function() {
      return YA
    }), n.d(f, "invert", function() {
      return JA
    }), n.d(f, "brightness", function() {
      return ZA
    }), n.d(f, "contrast", function() {
      return KA
    });
    var g = {};
    n.d(g, "flipX", function() {
      return QA
    }), n.d(g, "flipY", function() {
      return tE
    }), n.d(g, "flipXY", function() {
      return eE
    }), n.d(g, "watermark", function() {
      return nE
    });
    var m = {};
    n.d(m, "className", function() {
      return lE
    }), n.d(m, "opacity", function() {
      return hE
    }), n.d(m, "stroke", function() {
      return dE
    });
    var v = {};
    n.d(v, "absolute", function() {
      return yE
    }), n.d(v, "ellipse", function() {
      return bE
    }), n.d(v, "ellipseSpread", function() {
      return CE
    }), n.d(v, "line", function() {
      return AE
    }), n.d(v, "left", function() {
      return EE
    }), n.d(v, "right", function() {
      return SE
    }), n.d(v, "top", function() {
      return ME
    }), n.d(v, "bottom", function() {
      return kE
    });
    var y = {};
    n.d(y, "manual", function() {
      return jE
    }), n.d(y, "left", function() {
      return LE
    }), n.d(y, "right", function() {
      return NE
    }), n.d(y, "top", function() {
      return FE
    }), n.d(y, "bottom", function() {
      return $E
    }), n.d(y, "outside", function() {
      return BE
    }), n.d(y, "outsideOriented", function() {
      return IE
    }), n.d(y, "inside", function() {
      return zE
    }), n.d(y, "insideOriented", function() {
      return RE
    }), n.d(y, "radial", function() {
      return UE
    }), n.d(y, "radialOriented", function() {
      return qE
    });
    var b = {};
    n.d(b, "noop", function() {
      return KE
    }), n.d(b, "pinRelative", function() {
      return eS
    }), n.d(b, "pinAbsolute", function() {
      return nS
    });
    var C = {};
    n.d(C, "center", function() {
      return LS
    }), n.d(C, "top", function() {
      return NS
    }), n.d(C, "bottom", function() {
      return FS
    }), n.d(C, "left", function() {
      return $S
    }), n.d(C, "right", function() {
      return BS
    }), n.d(C, "topLeft", function() {
      return IS
    }), n.d(C, "topRight", function() {
      return zS
    }), n.d(C, "bottomLeft", function() {
      return RS
    }), n.d(C, "bottomRight", function() {
      return VS
    }), n.d(C, "orth", function() {
      return qS
    }), n.d(C, "nodeCenter", function() {
      return WS
    }), n.d(C, "midSide", function() {
      return XS
    });
    var x = {};
    n.d(x, "closest", function() {
      return tM
    }), n.d(x, "ratio", function() {
      return ZS
    }), n.d(x, "length", function() {
      return KS
    }), n.d(x, "orth", function() {
      return eM
    });
    var w = {};
    n.d(w, "bbox", function() {
      return sM
    }), n.d(w, "rect", function() {
      return aM
    }), n.d(w, "boundary", function() {
      return lM
    }), n.d(w, "anchor", function() {
      return cM
    });
    var A = {};
    n.d(A, "normal", function() {
      return dM
    }), n.d(A, "oneSide", function() {
      return pM
    }), n.d(A, "orth", function() {
      return yM
    }), n.d(A, "metro", function() {
      return VM
    }), n.d(A, "manhattan", function() {
      return zM
    }), n.d(A, "er", function() {
      return HM
    });
    var E = {};
    n.d(E, "normal", function() {
      return qM
    }), n.d(E, "rounded", function() {
      return WM
    }), n.d(E, "smooth", function() {
      return XM
    }), n.d(E, "jumpover", function() {
      return rk
    });
    var S = {};
    n.d(S, "create", function() {
      return sk
    }), n.d(S, "Attr", function() {
      return DA
    }), n.d(S, "Grid", function() {
      return FA
    }), n.d(S, "Filter", function() {
      return BA
    }), n.d(S, "Background", function() {
      return rE
    }), n.d(S, "Highlighter", function() {
      return fE
    }), n.d(S, "PortLayout", function() {
      return PE
    }), n.d(S, "PortLabelLayout", function() {
      return XE
    }), n.d(S, "NodeTool", function() {
      return PS
    }), n.d(S, "EdgeTool", function() {
      return TS
    }), n.d(S, "Marker", function() {
      return pA
    }), n.d(S, "NodeAnchor", function() {
      return YS
    }), n.d(S, "EdgeAnchor", function() {
      return nM
    }), n.d(S, "ConnectionPoint", function() {
      return hM
    }), n.d(S, "Router", function() {
      return GM
    }), n.d(S, "Connector", function() {
      return ik
    }), n.d(S, "ConnectionStrategy", function() {
      return rS
    }), n.d(S, "Registry", function() {
      return Kx
    });
    var M = {};
    n.d(M, "HTML", function() {
      return Pk
    }), n.d(M, "Rect", function() {
      return dP
    }), n.d(M, "HeaderedRect", function() {
      return pP
    }), n.d(M, "Circle", function() {
      return fP
    }), n.d(M, "Cylinder", function() {
      return gP
    }), n.d(M, "Ellipse", function() {
      return mP
    }), n.d(M, "Polygon", function() {
      return bP
    }), n.d(M, "Polyline", function() {
      return CP
    }), n.d(M, "Path", function() {
      return wP
    }), n.d(M, "TextBlock", function() {
      return AP
    }), n.d(M, "Image", function() {
      return EP
    }), n.d(M, "BorderedImage", function() {
      return SP
    }), n.d(M, "EmbeddedImage", function() {
      return MP
    }), n.d(M, "InscribedImage", function() {
      return kP
    }), n.d(M, "Edge", function() {
      return hO
    }), n.d(M, "ShadowEdge", function() {
      return OP
    }), n.d(M, "DoubleEdge", function() {
      return PP
    });
    var k = {};
    n.d(k, "AutoSave", function() {
      return FP
    }), n.d(k, "Clipboard", function() {
      return lO
    }), n.d(k, "Halo", function() {
      return IP
    }), n.d(k, "MiniMap", function() {
      return Ik
    }), n.d(k, "Scroller", function() {
      return Xk
    }), n.d(k, "Selection", function() {
      return aO
    }), n.d(k, "Snapline", function() {
      return Vk
    }), n.d(k, "Transform", function() {
      return cO
    }), n.d(k, "Dnd", function() {
      return RP
    }), n.d(k, "Stencil", function() {
      return VP
    }), n.d(k, "PathDrawer", function() {
      return zP
    });
    var O = n("7t+N"),
      P = n.n(O),
      D = (n("5xbe"), n("PPKb"));
    if (D.a.SUPPORT_PASSIVE) {
      P.a.event.special.touchstart = {
        setup(t, e, n) {
          this.addEventListener("touchstart", n, {
            passive: !0
          })
        }
      };
      const t = P.a.event.special.mousewheel;
      if (t) {
        const e = t.setup;
        t.setup = function() {
          const t = this.addEventListener;
          this.addEventListener = ((e, n) => {
            t.call(this, e, n, {
              passive: !0
            })
          }), e.call(this), this.addEventListener = t
        }
      }
    }
    var T = n("WlpS"),
      _ = T.a.Symbol,
      j = Object.prototype,
      L = j.hasOwnProperty,
      N = j.toString,
      F = _ ? _.toStringTag : void 0;
    var $ = function(t) {
        var e = L.call(t, F),
          n = t[F];
        try {
          t[F] = void 0;
          var r = !0
        } catch (t) {}
        var i = N.call(t);
        return r && (e ? t[F] = n : delete t[F]), i
      },
      B = Object.prototype.toString;
    var I = function(t) {
        return B.call(t)
      },
      z = "[object Null]",
      R = "[object Undefined]",
      V = _ ? _.toStringTag : void 0;
    var H = function(t) {
      return null == t ? void 0 === t ? R : z : V && V in Object(t) ? $(t) : I(t)
    };
    var G = function(t) {
        return null != t && "object" == typeof t
      },
      U = "[object Symbol]";
    var q = function(t) {
        return "symbol" == typeof t || G(t) && H(t) == U
      },
      W = NaN;
    var X = function(t) {
      return "number" == typeof t ? t : q(t) ? W : +t
    };
    var Y = function(t, e) {
        for (var n = -1, r = null == t ? 0 : t.length, i = Array(r); ++n < r;) i[n] = e(t[n], n, t);
        return i
      },
      J = Array.isArray,
      Z = 1 / 0,
      K = _ ? _.prototype : void 0,
      Q = K ? K.toString : void 0;
    var tt = function t(e) {
      if ("string" == typeof e) return e;
      if (J(e)) return Y(e, t) + "";
      if (q(e)) return Q ? Q.call(e) : "";
      var n = e + "";
      return "0" == n && 1 / e == -Z ? "-0" : n
    };
    var et = function(t, e) {
        return function(n, r) {
          var i;
          if (void 0 === n && void 0 === r) return e;
          if (void 0 !== n && (i = n), void 0 !== r) {
            if (void 0 === i) return r;
            "string" == typeof n || "string" == typeof r ? (n = tt(n), r = tt(r)) : (n = X(n), r = X(r)), i = t(
              n, r)
          }
          return i
        }
      },
      nt = et(function(t, e) {
        return t + e
      }, 0);
    var rt = function(t) {
        var e = typeof t;
        return null != t && ("object" == e || "function" == e)
      },
      it = NaN,
      ot = /^\s+|\s+$/g,
      st = /^[-+]0x[0-9a-f]+$/i,
      at = /^0b[01]+$/i,
      lt = /^0o[0-7]+$/i,
      ct = parseInt;
    var ht = function(t) {
        if ("number" == typeof t) return t;
        if (q(t)) return it;
        if (rt(t)) {
          var e = "function" == typeof t.valueOf ? t.valueOf() : t;
          t = rt(e) ? e + "" : e
        }
        if ("string" != typeof t) return 0 === t ? t : +t;
        t = t.replace(ot, "");
        var n = at.test(t);
        return n || lt.test(t) ? ct(t.slice(2), n ? 2 : 8) : st.test(t) ? it : +t
      },
      ut = 1 / 0,
      dt = 1.7976931348623157e308;
    var pt = function(t) {
      return t ? (t = ht(t)) === ut || t === -ut ? (t < 0 ? -1 : 1) * dt : t == t ? t : 0 : 0 === t ? t : 0
    };
    var ft = function(t) {
        var e = pt(t),
          n = e % 1;
        return e == e ? n ? e - n : e : 0
      },
      gt = "Expected a function";
    var mt = function(t, e) {
      if ("function" != typeof e) throw new TypeError(gt);
      return t = ft(t),
        function() {
          if (--t < 1) return e.apply(this, arguments)
        }
    };
    var vt = function(t) {
        return t
      },
      yt = "[object AsyncFunction]",
      bt = "[object Function]",
      Ct = "[object GeneratorFunction]",
      xt = "[object Proxy]";
    var wt, At = function(t) {
        if (!rt(t)) return !1;
        var e = H(t);
        return e == bt || e == Ct || e == yt || e == xt
      },
      Et = T.a["__core-js_shared__"],
      St = (wt = /[^.]+$/.exec(Et && Et.keys && Et.keys.IE_PROTO || "")) ? "Symbol(src)_1." + wt : "";
    var Mt = function(t) {
        return !!St && St in t
      },
      kt = Function.prototype.toString;
    var Ot = function(t) {
        if (null != t) {
          try {
            return kt.call(t)
          } catch (t) {}
          try {
            return t + ""
          } catch (t) {}
        }
        return ""
      },
      Pt = /^\[object .+?Constructor\]$/,
      Dt = Function.prototype,
      Tt = Object.prototype,
      _t = Dt.toString,
      jt = Tt.hasOwnProperty,
      Lt = RegExp("^" + _t.call(jt).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(
        /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Nt = function(t) {
      return !(!rt(t) || Mt(t)) && (At(t) ? Lt : Pt).test(Ot(t))
    };
    var Ft = function(t, e) {
      return null == t ? void 0 : t[e]
    };
    var $t = function(t, e) {
        var n = Ft(t, e);
        return Nt(n) ? n : void 0
      },
      Bt = $t(T.a, "WeakMap"),
      It = Bt && new Bt,
      zt = It ? function(t, e) {
        return It.set(t, e), t
      } : vt,
      Rt = Object.create,
      Vt = function() {
        function t() {}
        return function(e) {
          if (!rt(e)) return {};
          if (Rt) return Rt(e);
          t.prototype = e;
          var n = new t;
          return t.prototype = void 0, n
        }
      }();
    var Ht = function(t) {
        return function() {
          var e = arguments;
          switch (e.length) {
            case 0:
              return new t;
            case 1:
              return new t(e[0]);
            case 2:
              return new t(e[0], e[1]);
            case 3:
              return new t(e[0], e[1], e[2]);
            case 4:
              return new t(e[0], e[1], e[2], e[3]);
            case 5:
              return new t(e[0], e[1], e[2], e[3], e[4]);
            case 6:
              return new t(e[0], e[1], e[2], e[3], e[4], e[5]);
            case 7:
              return new t(e[0], e[1], e[2], e[3], e[4], e[5], e[6])
          }
          var n = Vt(t.prototype),
            r = t.apply(n, e);
          return rt(r) ? r : n
        }
      },
      Gt = 1;
    var Ut = function(t, e, n) {
      var r = e & Gt,
        i = Ht(t);
      return function e() {
        return (this && this !== T.a && this instanceof e ? i : t).apply(r ? n : this, arguments)
      }
    };
    var qt = function(t, e, n) {
        switch (n.length) {
          case 0:
            return t.call(e);
          case 1:
            return t.call(e, n[0]);
          case 2:
            return t.call(e, n[0], n[1]);
          case 3:
            return t.call(e, n[0], n[1], n[2])
        }
        return t.apply(e, n)
      },
      Wt = Math.max;
    var Xt = function(t, e, n, r) {
        for (var i = -1, o = t.length, s = n.length, a = -1, l = e.length, c = Wt(o - s, 0), h = Array(l + c), u = !
            r; ++a < l;) h[a] = e[a];
        for (; ++i < s;)(u || i < o) && (h[n[i]] = t[i]);
        for (; c--;) h[a++] = t[i++];
        return h
      },
      Yt = Math.max;
    var Jt = function(t, e, n, r) {
      for (var i = -1, o = t.length, s = -1, a = n.length, l = -1, c = e.length, h = Yt(o - a, 0), u = Array(h +
          c), d = !r; ++i < h;) u[i] = t[i];
      for (var p = i; ++l < c;) u[p + l] = e[l];
      for (; ++s < a;)(d || i < o) && (u[p + n[s]] = t[i++]);
      return u
    };
    var Zt = function(t, e) {
      for (var n = t.length, r = 0; n--;) t[n] === e && ++r;
      return r
    };
    var Kt = function() {},
      Qt = 4294967295;

    function te(t) {
      this.__wrapped__ = t, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [],
        this.__takeCount__ = Qt, this.__views__ = []
    }
    te.prototype = Vt(Kt.prototype), te.prototype.constructor = te;
    var ee = te;
    var ne = function() {},
      re = It ? function(t) {
        return It.get(t)
      } : ne,
      ie = {},
      oe = Object.prototype.hasOwnProperty;
    var se = function(t) {
      for (var e = t.name + "", n = ie[e], r = oe.call(ie, e) ? n.length : 0; r--;) {
        var i = n[r],
          o = i.func;
        if (null == o || o == t) return i.name
      }
      return e
    };

    function ae(t, e) {
      this.__wrapped__ = t, this.__actions__ = [], this.__chain__ = !!e, this.__index__ = 0, this.__values__ =
        void 0
    }
    ae.prototype = Vt(Kt.prototype), ae.prototype.constructor = ae;
    var le = ae;
    var ce = function(t, e) {
      var n = -1,
        r = t.length;
      for (e || (e = Array(r)); ++n < r;) e[n] = t[n];
      return e
    };
    var he = function(t) {
        if (t instanceof ee) return t.clone();
        var e = new le(t.__wrapped__, t.__chain__);
        return e.__actions__ = ce(t.__actions__), e.__index__ = t.__index__, e.__values__ = t.__values__, e
      },
      ue = Object.prototype.hasOwnProperty;

    function de(t) {
      if (G(t) && !J(t) && !(t instanceof ee)) {
        if (t instanceof le) return t;
        if (ue.call(t, "__wrapped__")) return he(t)
      }
      return new le(t)
    }
    de.prototype = Kt.prototype, de.prototype.constructor = de;
    var pe = de;
    var fe = function(t) {
        var e = se(t),
          n = pe[e];
        if ("function" != typeof n || !(e in ee.prototype)) return !1;
        if (t === n) return !0;
        var r = re(n);
        return !!r && t === r[0]
      },
      ge = 800,
      me = 16,
      ve = Date.now;
    var ye = function(t) {
        var e = 0,
          n = 0;
        return function() {
          var r = ve(),
            i = me - (r - n);
          if (n = r, i > 0) {
            if (++e >= ge) return arguments[0]
          } else e = 0;
          return t.apply(void 0, arguments)
        }
      },
      be = ye(zt),
      Ce = /\{\n\/\* \[wrapped with (.+)\] \*/,
      xe = /,? & /;
    var we = function(t) {
        var e = t.match(Ce);
        return e ? e[1].split(xe) : []
      },
      Ae = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
    var Ee = function(t, e) {
      var n = e.length;
      if (!n) return t;
      var r = n - 1;
      return e[r] = (n > 1 ? "& " : "") + e[r], e = e.join(n > 2 ? ", " : " "), t.replace(Ae,
        "{\n/* [wrapped with " + e + "] */\n")
    };
    var Se = function(t) {
        return function() {
          return t
        }
      },
      Me = function() {
        try {
          var t = $t(Object, "defineProperty");
          return t({}, "", {}), t
        } catch (t) {}
      }(),
      ke = ye(Me ? function(t, e) {
        return Me(t, "toString", {
          configurable: !0,
          enumerable: !1,
          value: Se(e),
          writable: !0
        })
      } : vt);
    var Oe = function(t, e) {
      for (var n = -1, r = null == t ? 0 : t.length; ++n < r && !1 !== e(t[n], n, t););
      return t
    };
    var Pe = function(t, e, n, r) {
      for (var i = t.length, o = n + (r ? 1 : -1); r ? o-- : ++o < i;)
        if (e(t[o], o, t)) return o;
      return -1
    };
    var De = function(t) {
      return t != t
    };
    var Te = function(t, e, n) {
      for (var r = n - 1, i = t.length; ++r < i;)
        if (t[r] === e) return r;
      return -1
    };
    var _e = function(t, e, n) {
      return e == e ? Te(t, e, n) : Pe(t, De, n)
    };
    var je = function(t, e) {
        return !(null == t || !t.length) && _e(t, e, 0) > -1
      },
      Le = [
        ["ary", 128],
        ["bind", 1],
        ["bindKey", 2],
        ["curry", 8],
        ["curryRight", 16],
        ["flip", 512],
        ["partial", 32],
        ["partialRight", 64],
        ["rearg", 256]
      ];
    var Ne = function(t, e) {
      return Oe(Le, function(n) {
        var r = "_." + n[0];
        e & n[1] && !je(t, r) && t.push(r)
      }), t.sort()
    };
    var Fe = function(t, e, n) {
        var r = e + "";
        return ke(t, Ee(r, Ne(we(r), n)))
      },
      $e = 1,
      Be = 2,
      Ie = 4,
      ze = 8,
      Re = 32,
      Ve = 64;
    var He = function(t, e, n, r, i, o, s, a, l, c) {
      var h = e & ze;
      e |= h ? Re : Ve, (e &= ~(h ? Ve : Re)) & Ie || (e &= ~($e | Be));
      var u = [t, e, i, h ? o : void 0, h ? s : void 0, h ? void 0 : o, h ? void 0 : s, a, l, c],
        d = n.apply(void 0, u);
      return fe(t) && be(d, u), d.placeholder = r, Fe(d, t, e)
    };
    var Ge = function(t) {
        return t.placeholder
      },
      Ue = 9007199254740991,
      qe = /^(?:0|[1-9]\d*)$/;
    var We = function(t, e) {
        var n = typeof t;
        return !!(e = null == e ? Ue : e) && ("number" == n || "symbol" != n && qe.test(t)) && t > -1 && t % 1 ==
          0 && t < e
      },
      Xe = Math.min;
    var Ye = function(t, e) {
        for (var n = t.length, r = Xe(e.length, n), i = ce(t); r--;) {
          var o = e[r];
          t[r] = We(o, n) ? i[o] : void 0
        }
        return t
      },
      Je = "__lodash_placeholder__";
    var Ze = function(t, e) {
        for (var n = -1, r = t.length, i = 0, o = []; ++n < r;) {
          var s = t[n];
          s !== e && s !== Je || (t[n] = Je, o[i++] = n)
        }
        return o
      },
      Ke = 1,
      Qe = 2,
      tn = 8,
      en = 16,
      nn = 128,
      rn = 512;
    var on = function t(e, n, r, i, o, s, a, l, c, h) {
      var u = n & nn,
        d = n & Ke,
        p = n & Qe,
        f = n & (tn | en),
        g = n & rn,
        m = p ? void 0 : Ht(e);
      return function v() {
        for (var y = arguments.length, b = Array(y), C = y; C--;) b[C] = arguments[C];
        if (f) var x = Ge(v),
          w = Zt(b, x);
        if (i && (b = Xt(b, i, o, f)), s && (b = Jt(b, s, a, f)), y -= w, f && y < h) {
          var A = Ze(b, x);
          return He(e, n, t, v.placeholder, r, b, A, l, c, h - y)
        }
        var E = d ? r : this,
          S = p ? E[e] : e;
        return y = b.length, l ? b = Ye(b, l) : g && y > 1 && b.reverse(), u && c < y && (b.length = c), this &&
          this !== T.a && this instanceof v && (S = m || Ht(S)), S.apply(E, b)
      }
    };
    var sn = function(t, e, n) {
        var r = Ht(t);
        return function i() {
          for (var o = arguments.length, s = Array(o), a = o, l = Ge(i); a--;) s[a] = arguments[a];
          var c = o < 3 && s[0] !== l && s[o - 1] !== l ? [] : Ze(s, l);
          if ((o -= c.length) < n) return He(t, e, on, i.placeholder, void 0, s, c, void 0, void 0, n - o);
          var h = this && this !== T.a && this instanceof i ? r : t;
          return qt(h, this, s)
        }
      },
      an = 1;
    var ln = function(t, e, n, r) {
        var i = e & an,
          o = Ht(t);
        return function e() {
          for (var s = -1, a = arguments.length, l = -1, c = r.length, h = Array(c + a), u = this && this !==
              T.a && this instanceof e ? o : t; ++l < c;) h[l] = r[l];
          for (; a--;) h[l++] = arguments[++s];
          return qt(u, i ? n : this, h)
        }
      },
      cn = "__lodash_placeholder__",
      hn = 1,
      un = 2,
      dn = 4,
      pn = 8,
      fn = 128,
      gn = 256,
      mn = Math.min;
    var vn = function(t, e) {
        var n = t[1],
          r = e[1],
          i = n | r,
          o = i < (hn | un | fn),
          s = r == fn && n == pn || r == fn && n == gn && t[7].length <= e[8] || r == (fn | gn) && e[7].length <=
          e[8] && n == pn;
        if (!o && !s) return t;
        r & hn && (t[2] = e[2], i |= n & hn ? 0 : dn);
        var a = e[3];
        if (a) {
          var l = t[3];
          t[3] = l ? Xt(l, a, e[4]) : a, t[4] = l ? Ze(t[3], cn) : e[4]
        }
        return (a = e[5]) && (l = t[5], t[5] = l ? Jt(l, a, e[6]) : a, t[6] = l ? Ze(t[5], cn) : e[6]), (a = e[7]) &&
          (t[7] = a), r & fn && (t[8] = null == t[8] ? e[8] : mn(t[8], e[8])), null == t[9] && (t[9] = e[9]), t[0] =
          e[0], t[1] = i, t
      },
      yn = "Expected a function",
      bn = 1,
      Cn = 2,
      xn = 8,
      wn = 16,
      An = 32,
      En = 64,
      Sn = Math.max;
    var Mn = function(t, e, n, r, i, o, s, a) {
        var l = e & Cn;
        if (!l && "function" != typeof t) throw new TypeError(yn);
        var c = r ? r.length : 0;
        if (c || (e &= ~(An | En), r = i = void 0), s = void 0 === s ? s : Sn(ft(s), 0), a = void 0 === a ? a :
          ft(a), c -= i ? i.length : 0, e & En) {
          var h = r,
            u = i;
          r = i = void 0
        }
        var d = l ? void 0 : re(t),
          p = [t, e, n, r, i, h, u, o, s, a];
        if (d && vn(p, d), t = p[0], e = p[1], n = p[2], r = p[3], i = p[4], !(a = p[9] = void 0 === p[9] ? l ? 0 :
            t.length : Sn(p[9] - c, 0)) && e & (xn | wn) && (e &= ~(xn | wn)), e && e != bn) f = e == xn || e ==
          wn ? sn(t, e, a) : e != An && e != (bn | An) || i.length ? on.apply(void 0, p) : ln(t, e, n, r);
        else var f = Ut(t, e, n);
        return Fe((d ? zt : be)(f, p), t, e)
      },
      kn = 128;
    var On = function(t, e, n) {
      return e = n ? void 0 : e, e = t && null == e ? t.length : e, Mn(t, kn, void 0, void 0, void 0, void 0, e)
    };
    var Pn = function(t, e, n) {
      "__proto__" == e && Me ? Me(t, e, {
        configurable: !0,
        enumerable: !0,
        value: n,
        writable: !0
      }) : t[e] = n
    };
    var Dn = function(t, e) {
        return t === e || t != t && e != e
      },
      Tn = Object.prototype.hasOwnProperty;
    var _n = function(t, e, n) {
      var r = t[e];
      Tn.call(t, e) && Dn(r, n) && (void 0 !== n || e in t) || Pn(t, e, n)
    };
    var jn = function(t, e, n, r) {
        var i = !n;
        n || (n = {});
        for (var o = -1, s = e.length; ++o < s;) {
          var a = e[o],
            l = r ? r(n[a], t[a], a, n, t) : void 0;
          void 0 === l && (l = t[a]), i ? Pn(n, a, l) : _n(n, a, l)
        }
        return n
      },
      Ln = Math.max;
    var Nn = function(t, e, n) {
      return e = Ln(void 0 === e ? t.length - 1 : e, 0),
        function() {
          for (var r = arguments, i = -1, o = Ln(r.length - e, 0), s = Array(o); ++i < o;) s[i] = r[e + i];
          i = -1;
          for (var a = Array(e + 1); ++i < e;) a[i] = r[i];
          return a[e] = n(s), qt(t, this, a)
        }
    };
    var Fn = function(t, e) {
        return ke(Nn(t, e, vt), t + "")
      },
      $n = 9007199254740991;
    var Bn = function(t) {
      return "number" == typeof t && t > -1 && t % 1 == 0 && t <= $n
    };
    var In = function(t) {
      return null != t && Bn(t.length) && !At(t)
    };
    var zn = function(t, e, n) {
      if (!rt(n)) return !1;
      var r = typeof e;
      return !!("number" == r ? In(n) && We(e, n.length) : "string" == r && e in n) && Dn(n[e], t)
    };
    var Rn = function(t) {
        return Fn(function(e, n) {
          var r = -1,
            i = n.length,
            o = i > 1 ? n[i - 1] : void 0,
            s = i > 2 ? n[2] : void 0;
          for (o = t.length > 3 && "function" == typeof o ? (i--, o) : void 0, s && zn(n[0], n[1], s) && (o =
              i < 3 ? void 0 : o, i = 1), e = Object(e); ++r < i;) {
            var a = n[r];
            a && t(e, a, r, o)
          }
          return e
        })
      },
      Vn = Object.prototype;
    var Hn = function(t) {
      var e = t && t.constructor;
      return t === ("function" == typeof e && e.prototype || Vn)
    };
    var Gn = function(t, e) {
        for (var n = -1, r = Array(t); ++n < t;) r[n] = e(n);
        return r
      },
      Un = "[object Arguments]";
    var qn = function(t) {
        return G(t) && H(t) == Un
      },
      Wn = Object.prototype,
      Xn = Wn.hasOwnProperty,
      Yn = Wn.propertyIsEnumerable,
      Jn = qn(function() {
        return arguments
      }()) ? qn : function(t) {
        return G(t) && Xn.call(t, "callee") && !Yn.call(t, "callee")
      },
      Zn = n("FvOO"),
      Kn = {};
    Kn["[object Float32Array]"] = Kn["[object Float64Array]"] = Kn["[object Int8Array]"] = Kn[
      "[object Int16Array]"] = Kn["[object Int32Array]"] = Kn["[object Uint8Array]"] = Kn[
      "[object Uint8ClampedArray]"] = Kn["[object Uint16Array]"] = Kn["[object Uint32Array]"] = !0, Kn[
      "[object Arguments]"] = Kn["[object Array]"] = Kn["[object ArrayBuffer]"] = Kn["[object Boolean]"] = Kn[
      "[object DataView]"] = Kn["[object Date]"] = Kn["[object Error]"] = Kn["[object Function]"] = Kn[
      "[object Map]"] = Kn["[object Number]"] = Kn["[object Object]"] = Kn["[object RegExp]"] = Kn[
      "[object Set]"] = Kn["[object String]"] = Kn["[object WeakMap]"] = !1;
    var Qn = function(t) {
      return G(t) && Bn(t.length) && !!Kn[H(t)]
    };
    var tr = function(t) {
        return function(e) {
          return t(e)
        }
      },
      er = n("6PaC"),
      nr = er.a && er.a.isTypedArray,
      rr = nr ? tr(nr) : Qn,
      ir = Object.prototype.hasOwnProperty;
    var or = function(t, e) {
      var n = J(t),
        r = !n && Jn(t),
        i = !n && !r && Object(Zn.a)(t),
        o = !n && !r && !i && rr(t),
        s = n || r || i || o,
        a = s ? Gn(t.length, String) : [],
        l = a.length;
      for (var c in t) !e && !ir.call(t, c) || s && ("length" == c || i && ("offset" == c || "parent" == c) ||
        o && ("buffer" == c || "byteLength" == c || "byteOffset" == c) || We(c, l)) || a.push(c);
      return a
    };
    var sr = function(t, e) {
        return function(n) {
          return t(e(n))
        }
      },
      ar = sr(Object.keys, Object),
      lr = Object.prototype.hasOwnProperty;
    var cr = function(t) {
      if (!Hn(t)) return ar(t);
      var e = [];
      for (var n in Object(t)) lr.call(t, n) && "constructor" != n && e.push(n);
      return e
    };
    var hr = function(t) {
        return In(t) ? or(t) : cr(t)
      },
      ur = Object.prototype.hasOwnProperty,
      dr = Rn(function(t, e) {
        if (Hn(e) || In(e)) jn(e, hr(e), t);
        else
          for (var n in e) ur.call(e, n) && _n(t, n, e[n])
      });
    var pr = function(t) {
        var e = [];
        if (null != t)
          for (var n in Object(t)) e.push(n);
        return e
      },
      fr = Object.prototype.hasOwnProperty;
    var gr = function(t) {
      if (!rt(t)) return pr(t);
      var e = Hn(t),
        n = [];
      for (var r in t)("constructor" != r || !e && fr.call(t, r)) && n.push(r);
      return n
    };
    var mr = function(t) {
        return In(t) ? or(t, !0) : gr(t)
      },
      vr = Rn(function(t, e) {
        jn(e, mr(e), t)
      }),
      yr = Rn(function(t, e, n, r) {
        jn(e, mr(e), t, r)
      }),
      br = Rn(function(t, e, n, r) {
        jn(e, hr(e), t, r)
      }),
      Cr = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      xr = /^\w*$/;
    var wr = function(t, e) {
        if (J(t)) return !1;
        var n = typeof t;
        return !("number" != n && "symbol" != n && "boolean" != n && null != t && !q(t)) || xr.test(t) || !Cr.test(
          t) || null != e && t in Object(e)
      },
      Ar = $t(Object, "create");
    var Er = function() {
      this.__data__ = Ar ? Ar(null) : {}, this.size = 0
    };
    var Sr = function(t) {
        var e = this.has(t) && delete this.__data__[t];
        return this.size -= e ? 1 : 0, e
      },
      Mr = "__lodash_hash_undefined__",
      kr = Object.prototype.hasOwnProperty;
    var Or = function(t) {
        var e = this.__data__;
        if (Ar) {
          var n = e[t];
          return n === Mr ? void 0 : n
        }
        return kr.call(e, t) ? e[t] : void 0
      },
      Pr = Object.prototype.hasOwnProperty;
    var Dr = function(t) {
        var e = this.__data__;
        return Ar ? void 0 !== e[t] : Pr.call(e, t)
      },
      Tr = "__lodash_hash_undefined__";
    var _r = function(t, e) {
      var n = this.__data__;
      return this.size += this.has(t) ? 0 : 1, n[t] = Ar && void 0 === e ? Tr : e, this
    };

    function jr(t) {
      var e = -1,
        n = null == t ? 0 : t.length;
      for (this.clear(); ++e < n;) {
        var r = t[e];
        this.set(r[0], r[1])
      }
    }
    jr.prototype.clear = Er, jr.prototype.delete = Sr, jr.prototype.get = Or, jr.prototype.has = Dr, jr.prototype
      .set = _r;
    var Lr = jr;
    var Nr = function() {
      this.__data__ = [], this.size = 0
    };
    var Fr = function(t, e) {
        for (var n = t.length; n--;)
          if (Dn(t[n][0], e)) return n;
        return -1
      },
      $r = Array.prototype.splice;
    var Br = function(t) {
      var e = this.__data__,
        n = Fr(e, t);
      return !(n < 0 || (n == e.length - 1 ? e.pop() : $r.call(e, n, 1), --this.size, 0))
    };
    var Ir = function(t) {
      var e = this.__data__,
        n = Fr(e, t);
      return n < 0 ? void 0 : e[n][1]
    };
    var zr = function(t) {
      return Fr(this.__data__, t) > -1
    };
    var Rr = function(t, e) {
      var n = this.__data__,
        r = Fr(n, t);
      return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this
    };

    function Vr(t) {
      var e = -1,
        n = null == t ? 0 : t.length;
      for (this.clear(); ++e < n;) {
        var r = t[e];
        this.set(r[0], r[1])
      }
    }
    Vr.prototype.clear = Nr, Vr.prototype.delete = Br, Vr.prototype.get = Ir, Vr.prototype.has = zr, Vr.prototype
      .set = Rr;
    var Hr = Vr,
      Gr = $t(T.a, "Map");
    var Ur = function() {
      this.size = 0, this.__data__ = {
        hash: new Lr,
        map: new(Gr || Hr),
        string: new Lr
      }
    };
    var qr = function(t) {
      var e = typeof t;
      return "string" == e || "number" == e || "symbol" == e || "boolean" == e ? "__proto__" !== t : null ===
        t
    };
    var Wr = function(t, e) {
      var n = t.__data__;
      return qr(e) ? n["string" == typeof e ? "string" : "hash"] : n.map
    };
    var Xr = function(t) {
      var e = Wr(this, t).delete(t);
      return this.size -= e ? 1 : 0, e
    };
    var Yr = function(t) {
      return Wr(this, t).get(t)
    };
    var Jr = function(t) {
      return Wr(this, t).has(t)
    };
    var Zr = function(t, e) {
      var n = Wr(this, t),
        r = n.size;
      return n.set(t, e), this.size += n.size == r ? 0 : 1, this
    };

    function Kr(t) {
      var e = -1,
        n = null == t ? 0 : t.length;
      for (this.clear(); ++e < n;) {
        var r = t[e];
        this.set(r[0], r[1])
      }
    }
    Kr.prototype.clear = Ur, Kr.prototype.delete = Xr, Kr.prototype.get = Yr, Kr.prototype.has = Jr, Kr.prototype
      .set = Zr;
    var Qr = Kr,
      ti = "Expected a function";

    function ei(t, e) {
      if ("function" != typeof t || null != e && "function" != typeof e) throw new TypeError(ti);
      var n = function() {
        var r = arguments,
          i = e ? e.apply(this, r) : r[0],
          o = n.cache;
        if (o.has(i)) return o.get(i);
        var s = t.apply(this, r);
        return n.cache = o.set(i, s) || o, s
      };
      return n.cache = new(ei.Cache || Qr), n
    }
    ei.Cache = Qr;
    var ni = ei,
      ri = 500;
    var ii = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
      oi = /\\(\\)?/g,
      si = function(t) {
        var e = ni(t, function(t) {
            return n.size === ri && n.clear(), t
          }),
          n = e.cache;
        return e
      }(function(t) {
        var e = [];
        return 46 === t.charCodeAt(0) && e.push(""), t.replace(ii, function(t, n, r, i) {
          e.push(r ? i.replace(oi, "$1") : n || t)
        }), e
      });
    var ai = function(t) {
      return null == t ? "" : tt(t)
    };
    var li = function(t, e) {
        return J(t) ? t : wr(t, e) ? [t] : si(ai(t))
      },
      ci = 1 / 0;
    var hi = function(t) {
      if ("string" == typeof t || q(t)) return t;
      var e = t + "";
      return "0" == e && 1 / t == -ci ? "-0" : e
    };
    var ui = function(t, e) {
      for (var n = 0, r = (e = li(e, t)).length; null != t && n < r;) t = t[hi(e[n++])];
      return n && n == r ? t : void 0
    };
    var di = function(t, e, n) {
      var r = null == t ? void 0 : ui(t, e);
      return void 0 === r ? n : r
    };
    var pi = function(t, e) {
      for (var n = -1, r = e.length, i = Array(r), o = null == t; ++n < r;) i[n] = o ? void 0 : di(t, e[n]);
      return i
    };
    var fi = function(t, e) {
        for (var n = -1, r = e.length, i = t.length; ++n < r;) t[i + n] = e[n];
        return t
      },
      gi = _ ? _.isConcatSpreadable : void 0;
    var mi = function(t) {
      return J(t) || Jn(t) || !!(gi && t && t[gi])
    };
    var vi = function t(e, n, r, i, o) {
      var s = -1,
        a = e.length;
      for (r || (r = mi), o || (o = []); ++s < a;) {
        var l = e[s];
        n > 0 && r(l) ? n > 1 ? t(l, n - 1, r, i, o) : fi(o, l) : i || (o[o.length] = l)
      }
      return o
    };
    var yi = function(t) {
      return null != t && t.length ? vi(t, 1) : []
    };
    var bi = function(t) {
        return ke(Nn(t, void 0, yi), t + "")
      },
      Ci = bi(pi),
      xi = sr(Object.getPrototypeOf, Object),
      wi = "[object Object]",
      Ai = Function.prototype,
      Ei = Object.prototype,
      Si = Ai.toString,
      Mi = Ei.hasOwnProperty,
      ki = Si.call(Object);
    var Oi = function(t) {
        if (!G(t) || H(t) != wi) return !1;
        var e = xi(t);
        if (null === e) return !0;
        var n = Mi.call(e, "constructor") && e.constructor;
        return "function" == typeof n && n instanceof n && Si.call(n) == ki
      },
      Pi = "[object DOMException]",
      Di = "[object Error]";
    var Ti = function(t) {
        if (!G(t)) return !1;
        var e = H(t);
        return e == Di || e == Pi || "string" == typeof t.message && "string" == typeof t.name && !Oi(t)
      },
      _i = Fn(function(t, e) {
        try {
          return qt(t, void 0, e)
        } catch (t) {
          return Ti(t) ? t : new Error(t)
        }
      }),
      ji = "Expected a function";
    var Li = function(t, e) {
        var n;
        if ("function" != typeof e) throw new TypeError(ji);
        return t = ft(t),
          function() {
            return --t > 0 && (n = e.apply(this, arguments)), t <= 1 && (e = void 0), n
          }
      },
      Ni = Fn(function(t, e, n) {
        var r = 1;
        if (n.length) {
          var i = Ze(n, Ge(Ni));
          r |= 32
        }
        return Mn(t, r, e, n, i)
      });
    Ni.placeholder = {};
    var Fi = Ni,
      $i = bi(function(t, e) {
        return Oe(e, function(e) {
          e = hi(e), Pn(t, e, Fi(t[e], t))
        }), t
      }),
      Bi = Fn(function(t, e, n) {
        var r = 3;
        if (n.length) {
          var i = Ze(n, Ge(Bi));
          r |= 32
        }
        return Mn(e, r, t, n, i)
      });
    Bi.placeholder = {};
    var Ii = Bi;
    var zi = function(t, e, n) {
      var r = -1,
        i = t.length;
      e < 0 && (e = -e > i ? 0 : i + e), (n = n > i ? i : n) < 0 && (n += i), i = e > n ? 0 : n - e >>> 0, e >>>=
        0;
      for (var o = Array(i); ++r < i;) o[r] = t[r + e];
      return o
    };
    var Ri = function(t, e, n) {
        var r = t.length;
        return n = void 0 === n ? r : n, !e && n >= r ? t : zi(t, e, n)
      },
      Vi = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");
    var Hi = function(t) {
      return Vi.test(t)
    };
    var Gi = function(t) {
        return t.split("")
      },
      Ui = "[\\ud800-\\udfff]",
      qi = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]",
      Wi = "\\ud83c[\\udffb-\\udfff]",
      Xi = "[^\\ud800-\\udfff]",
      Yi = "(?:\\ud83c[\\udde6-\\uddff]){2}",
      Ji = "[\\ud800-\\udbff][\\udc00-\\udfff]",
      Zi = "(?:" + qi + "|" + Wi + ")" + "?",
      Ki = "[\\ufe0e\\ufe0f]?" + Zi + ("(?:\\u200d(?:" + [Xi, Yi, Ji].join("|") + ")[\\ufe0e\\ufe0f]?" + Zi +
        ")*"),
      Qi = "(?:" + [Xi + qi + "?", qi, Yi, Ji, Ui].join("|") + ")",
      to = RegExp(Wi + "(?=" + Wi + ")|" + Qi + Ki, "g");
    var eo = function(t) {
      return t.match(to) || []
    };
    var no = function(t) {
      return Hi(t) ? eo(t) : Gi(t)
    };
    var ro = function(t) {
        return function(e) {
          e = ai(e);
          var n = Hi(e) ? no(e) : void 0,
            r = n ? n[0] : e.charAt(0),
            i = n ? Ri(n, 1).join("") : e.slice(1);
          return r[t]() + i
        }
      },
      io = ro("toUpperCase");
    var oo = function(t) {
      return io(ai(t).toLowerCase())
    };
    var so = function(t, e, n, r) {
      var i = -1,
        o = null == t ? 0 : t.length;
      for (r && o && (n = t[++i]); ++i < o;) n = e(n, t[i], i, t);
      return n
    };
    var ao = function(t) {
        return function(e) {
          return null == t ? void 0 : t[e]
        }
      },
      lo = ao({
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss",
        "Ā": "A",
        "Ă": "A",
        "Ą": "A",
        "ā": "a",
        "ă": "a",
        "ą": "a",
        "Ć": "C",
        "Ĉ": "C",
        "Ċ": "C",
        "Č": "C",
        "ć": "c",
        "ĉ": "c",
        "ċ": "c",
        "č": "c",
        "Ď": "D",
        "Đ": "D",
        "ď": "d",
        "đ": "d",
        "Ē": "E",
        "Ĕ": "E",
        "Ė": "E",
        "Ę": "E",
        "Ě": "E",
        "ē": "e",
        "ĕ": "e",
        "ė": "e",
        "ę": "e",
        "ě": "e",
        "Ĝ": "G",
        "Ğ": "G",
        "Ġ": "G",
        "Ģ": "G",
        "ĝ": "g",
        "ğ": "g",
        "ġ": "g",
        "ģ": "g",
        "Ĥ": "H",
        "Ħ": "H",
        "ĥ": "h",
        "ħ": "h",
        "Ĩ": "I",
        "Ī": "I",
        "Ĭ": "I",
        "Į": "I",
        "İ": "I",
        "ĩ": "i",
        "ī": "i",
        "ĭ": "i",
        "į": "i",
        "ı": "i",
        "Ĵ": "J",
        "ĵ": "j",
        "Ķ": "K",
        "ķ": "k",
        "ĸ": "k",
        "Ĺ": "L",
        "Ļ": "L",
        "Ľ": "L",
        "Ŀ": "L",
        "Ł": "L",
        "ĺ": "l",
        "ļ": "l",
        "ľ": "l",
        "ŀ": "l",
        "ł": "l",
        "Ń": "N",
        "Ņ": "N",
        "Ň": "N",
        "Ŋ": "N",
        "ń": "n",
        "ņ": "n",
        "ň": "n",
        "ŋ": "n",
        "Ō": "O",
        "Ŏ": "O",
        "Ő": "O",
        "ō": "o",
        "ŏ": "o",
        "ő": "o",
        "Ŕ": "R",
        "Ŗ": "R",
        "Ř": "R",
        "ŕ": "r",
        "ŗ": "r",
        "ř": "r",
        "Ś": "S",
        "Ŝ": "S",
        "Ş": "S",
        "Š": "S",
        "ś": "s",
        "ŝ": "s",
        "ş": "s",
        "š": "s",
        "Ţ": "T",
        "Ť": "T",
        "Ŧ": "T",
        "ţ": "t",
        "ť": "t",
        "ŧ": "t",
        "Ũ": "U",
        "Ū": "U",
        "Ŭ": "U",
        "Ů": "U",
        "Ű": "U",
        "Ų": "U",
        "ũ": "u",
        "ū": "u",
        "ŭ": "u",
        "ů": "u",
        "ű": "u",
        "ų": "u",
        "Ŵ": "W",
        "ŵ": "w",
        "Ŷ": "Y",
        "ŷ": "y",
        "Ÿ": "Y",
        "Ź": "Z",
        "Ż": "Z",
        "Ž": "Z",
        "ź": "z",
        "ż": "z",
        "ž": "z",
        "Ĳ": "IJ",
        "ĳ": "ij",
        "Œ": "Oe",
        "œ": "oe",
        "ŉ": "'n",
        "ſ": "s"
      }),
      co = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
      ho = RegExp("[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]", "g");
    var uo = function(t) {
        return (t = ai(t)) && t.replace(co, lo).replace(ho, "")
      },
      po = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var fo = function(t) {
        return t.match(po) || []
      },
      go = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var mo = function(t) {
        return go.test(t)
      },
      vo =
      "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
      yo = "[" + vo + "]",
      bo = "\\d+",
      Co = "[\\u2700-\\u27bf]",
      xo = "[a-z\\xdf-\\xf6\\xf8-\\xff]",
      wo = "[^\\ud800-\\udfff" + vo + bo + "\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde]",
      Ao = "(?:\\ud83c[\\udde6-\\uddff]){2}",
      Eo = "[\\ud800-\\udbff][\\udc00-\\udfff]",
      So = "[A-Z\\xc0-\\xd6\\xd8-\\xde]",
      Mo = "(?:" + xo + "|" + wo + ")",
      ko = "(?:" + So + "|" + wo + ")",
      Oo = "(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?",
      Po = "[\\ufe0e\\ufe0f]?" + Oo + ("(?:\\u200d(?:" + ["[^\\ud800-\\udfff]", Ao, Eo].join("|") +
        ")[\\ufe0e\\ufe0f]?" + Oo + ")*"),
      Do = "(?:" + [Co, Ao, Eo].join("|") + ")" + Po,
      To = RegExp([So + "?" + xo + "+(?:['’](?:d|ll|m|re|s|t|ve))?(?=" + [yo, So, "$"].join("|") + ")", ko +
        "+(?:['’](?:D|LL|M|RE|S|T|VE))?(?=" + [yo, So + Mo, "$"].join("|") + ")", So + "?" + Mo +
        "+(?:['’](?:d|ll|m|re|s|t|ve))?", So + "+(?:['’](?:D|LL|M|RE|S|T|VE))?",
        "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
        bo, Do
      ].join("|"), "g");
    var _o = function(t) {
      return t.match(To) || []
    };
    var jo = function(t, e, n) {
        return t = ai(t), void 0 === (e = n ? void 0 : e) ? mo(t) ? _o(t) : fo(t) : t.match(e) || []
      },
      Lo = RegExp("['’]", "g");
    var No = function(t) {
        return function(e) {
          return so(jo(uo(e).replace(Lo, "")), t, "")
        }
      },
      Fo = No(function(t, e, n) {
        return e = e.toLowerCase(), t + (n ? oo(e) : e)
      });
    var $o = function() {
        if (!arguments.length) return [];
        var t = arguments[0];
        return J(t) ? t : [t]
      },
      Bo = T.a.isFinite,
      Io = Math.min;
    var zo = function(t) {
        var e = Math[t];
        return function(t, n) {
          if (t = ht(t), (n = null == n ? 0 : Io(ft(n), 292)) && Bo(t)) {
            var r = (ai(t) + "e").split("e"),
              i = e(r[0] + "e" + (+r[1] + n));
            return +((r = (ai(i) + "e").split("e"))[0] + "e" + (+r[1] - n))
          }
          return e(t)
        }
      },
      Ro = zo("ceil");
    var Vo = function(t) {
        var e = pe(t);
        return e.__chain__ = !0, e
      },
      Ho = Math.ceil,
      Go = Math.max;
    var Uo = function(t, e, n) {
      e = (n ? zn(t, e, n) : void 0 === e) ? 1 : Go(ft(e), 0);
      var r = null == t ? 0 : t.length;
      if (!r || e < 1) return [];
      for (var i = 0, o = 0, s = Array(Ho(r / e)); i < r;) s[o++] = zi(t, i, i += e);
      return s
    };
    var qo = function(t, e, n) {
      return t == t && (void 0 !== n && (t = t <= n ? t : n), void 0 !== e && (t = t >= e ? t : e)), t
    };
    var Wo = function(t, e, n) {
      return void 0 === n && (n = e, e = void 0), void 0 !== n && (n = (n = ht(n)) == n ? n : 0), void 0 !== e &&
        (e = (e = ht(e)) == e ? e : 0), qo(ht(t), e, n)
    };
    var Xo = function() {
      this.__data__ = new Hr, this.size = 0
    };
    var Yo = function(t) {
      var e = this.__data__,
        n = e.delete(t);
      return this.size = e.size, n
    };
    var Jo = function(t) {
      return this.__data__.get(t)
    };
    var Zo = function(t) {
        return this.__data__.has(t)
      },
      Ko = 200;
    var Qo = function(t, e) {
      var n = this.__data__;
      if (n instanceof Hr) {
        var r = n.__data__;
        if (!Gr || r.length < Ko - 1) return r.push([t, e]), this.size = ++n.size, this;
        n = this.__data__ = new Qr(r)
      }
      return n.set(t, e), this.size = n.size, this
    };

    function ts(t) {
      var e = this.__data__ = new Hr(t);
      this.size = e.size
    }
    ts.prototype.clear = Xo, ts.prototype.delete = Yo, ts.prototype.get = Jo, ts.prototype.has = Zo, ts.prototype
      .set = Qo;
    var es = ts;
    var ns = function(t, e) {
      return t && jn(e, hr(e), t)
    };
    var rs = function(t, e) {
        return t && jn(e, mr(e), t)
      },
      is = n("gzeU");
    var os = function(t, e) {
      for (var n = -1, r = null == t ? 0 : t.length, i = 0, o = []; ++n < r;) {
        var s = t[n];
        e(s, n, t) && (o[i++] = s)
      }
      return o
    };
    var ss = function() {
        return []
      },
      as = Object.prototype.propertyIsEnumerable,
      ls = Object.getOwnPropertySymbols,
      cs = ls ? function(t) {
        return null == t ? [] : (t = Object(t), os(ls(t), function(e) {
          return as.call(t, e)
        }))
      } : ss;
    var hs = function(t, e) {
        return jn(t, cs(t), e)
      },
      us = Object.getOwnPropertySymbols ? function(t) {
        for (var e = []; t;) fi(e, cs(t)), t = xi(t);
        return e
      } : ss;
    var ds = function(t, e) {
      return jn(t, us(t), e)
    };
    var ps = function(t, e, n) {
      var r = e(t);
      return J(t) ? r : fi(r, n(t))
    };
    var fs = function(t) {
      return ps(t, hr, cs)
    };
    var gs = function(t) {
        return ps(t, mr, us)
      },
      ms = $t(T.a, "DataView"),
      vs = $t(T.a, "Promise"),
      ys = $t(T.a, "Set"),
      bs = Ot(ms),
      Cs = Ot(Gr),
      xs = Ot(vs),
      ws = Ot(ys),
      As = Ot(Bt),
      Es = H;
    (ms && "[object DataView]" != Es(new ms(new ArrayBuffer(1))) || Gr && "[object Map]" != Es(new Gr) || vs &&
      "[object Promise]" != Es(vs.resolve()) || ys && "[object Set]" != Es(new ys) || Bt && "[object WeakMap]" !=
      Es(new Bt)) && (Es = function(t) {
      var e = H(t),
        n = "[object Object]" == e ? t.constructor : void 0,
        r = n ? Ot(n) : "";
      if (r) switch (r) {
        case bs:
          return "[object DataView]";
        case Cs:
          return "[object Map]";
        case xs:
          return "[object Promise]";
        case ws:
          return "[object Set]";
        case As:
          return "[object WeakMap]"
      }
      return e
    });
    var Ss = Es,
      Ms = Object.prototype.hasOwnProperty;
    var ks = function(t) {
        var e = t.length,
          n = new t.constructor(e);
        return e && "string" == typeof t[0] && Ms.call(t, "index") && (n.index = t.index, n.input = t.input), n
      },
      Os = T.a.Uint8Array;
    var Ps = function(t) {
      var e = new t.constructor(t.byteLength);
      return new Os(e).set(new Os(t)), e
    };
    var Ds = function(t, e) {
        var n = e ? Ps(t.buffer) : t.buffer;
        return new t.constructor(n, t.byteOffset, t.byteLength)
      },
      Ts = /\w*$/;
    var _s = function(t) {
        var e = new t.constructor(t.source, Ts.exec(t));
        return e.lastIndex = t.lastIndex, e
      },
      js = _ ? _.prototype : void 0,
      Ls = js ? js.valueOf : void 0;
    var Ns = function(t) {
      return Ls ? Object(Ls.call(t)) : {}
    };
    var Fs = function(t, e) {
        var n = e ? Ps(t.buffer) : t.buffer;
        return new t.constructor(n, t.byteOffset, t.length)
      },
      $s = "[object Boolean]",
      Bs = "[object Date]",
      Is = "[object Map]",
      zs = "[object Number]",
      Rs = "[object RegExp]",
      Vs = "[object Set]",
      Hs = "[object String]",
      Gs = "[object Symbol]",
      Us = "[object ArrayBuffer]",
      qs = "[object DataView]",
      Ws = "[object Float32Array]",
      Xs = "[object Float64Array]",
      Ys = "[object Int8Array]",
      Js = "[object Int16Array]",
      Zs = "[object Int32Array]",
      Ks = "[object Uint8Array]",
      Qs = "[object Uint8ClampedArray]",
      ta = "[object Uint16Array]",
      ea = "[object Uint32Array]";
    var na = function(t, e, n) {
      var r = t.constructor;
      switch (e) {
        case Us:
          return Ps(t);
        case $s:
        case Bs:
          return new r(+t);
        case qs:
          return Ds(t, n);
        case Ws:
        case Xs:
        case Ys:
        case Js:
        case Zs:
        case Ks:
        case Qs:
        case ta:
        case ea:
          return Fs(t, n);
        case Is:
          return new r;
        case zs:
        case Hs:
          return new r(t);
        case Rs:
          return _s(t);
        case Vs:
          return new r;
        case Gs:
          return Ns(t)
      }
    };
    var ra = function(t) {
        return "function" != typeof t.constructor || Hn(t) ? {} : Vt(xi(t))
      },
      ia = "[object Map]";
    var oa = function(t) {
        return G(t) && Ss(t) == ia
      },
      sa = er.a && er.a.isMap,
      aa = sa ? tr(sa) : oa,
      la = "[object Set]";
    var ca = function(t) {
        return G(t) && Ss(t) == la
      },
      ha = er.a && er.a.isSet,
      ua = ha ? tr(ha) : ca,
      da = 1,
      pa = 2,
      fa = 4,
      ga = "[object Arguments]",
      ma = "[object Function]",
      va = "[object GeneratorFunction]",
      ya = "[object Object]",
      ba = {};
    ba[ga] = ba["[object Array]"] = ba["[object ArrayBuffer]"] = ba["[object DataView]"] = ba["[object Boolean]"] =
      ba["[object Date]"] = ba["[object Float32Array]"] = ba["[object Float64Array]"] = ba["[object Int8Array]"] =
      ba["[object Int16Array]"] = ba["[object Int32Array]"] = ba["[object Map]"] = ba["[object Number]"] = ba[ya] =
      ba["[object RegExp]"] = ba["[object Set]"] = ba["[object String]"] = ba["[object Symbol]"] = ba[
        "[object Uint8Array]"] = ba["[object Uint8ClampedArray]"] = ba["[object Uint16Array]"] = ba[
        "[object Uint32Array]"] = !0, ba["[object Error]"] = ba[ma] = ba["[object WeakMap]"] = !1;
    var Ca = function t(e, n, r, i, o, s) {
        var a, l = n & da,
          c = n & pa,
          h = n & fa;
        if (r && (a = o ? r(e, i, o, s) : r(e)), void 0 !== a) return a;
        if (!rt(e)) return e;
        var u = J(e);
        if (u) {
          if (a = ks(e), !l) return ce(e, a)
        } else {
          var d = Ss(e),
            p = d == ma || d == va;
          if (Object(Zn.a)(e)) return Object(is.a)(e, l);
          if (d == ya || d == ga || p && !o) {
            if (a = c || p ? {} : ra(e), !l) return c ? ds(e, rs(a, e)) : hs(e, ns(a, e))
          } else {
            if (!ba[d]) return o ? e : {};
            a = na(e, d, l)
          }
        }
        s || (s = new es);
        var f = s.get(e);
        if (f) return f;
        s.set(e, a), ua(e) ? e.forEach(function(i) {
          a.add(t(i, n, r, i, e, s))
        }) : aa(e) && e.forEach(function(i, o) {
          a.set(o, t(i, n, r, o, e, s))
        });
        var g = h ? c ? gs : fs : c ? keysIn : hr,
          m = u ? void 0 : g(e);
        return Oe(m || e, function(i, o) {
          m && (i = e[o = i]), _n(a, o, t(i, n, r, o, e, s))
        }), a
      },
      xa = 4;
    var wa = function(t) {
        return Ca(t, xa)
      },
      Aa = 1,
      Ea = 4;
    var Sa = function(t) {
        return Ca(t, Aa | Ea)
      },
      Ma = 1,
      ka = 4;
    var Oa = function(t, e) {
        return Ca(t, Ma | ka, e = "function" == typeof e ? e : void 0)
      },
      Pa = 4;
    var Da = function(t, e) {
      return Ca(t, Pa, e = "function" == typeof e ? e : void 0)
    };
    var Ta = function() {
      return new le(this.value(), this.__chain__)
    };
    var _a = function(t) {
      for (var e = -1, n = null == t ? 0 : t.length, r = 0, i = []; ++e < n;) {
        var o = t[e];
        o && (i[r++] = o)
      }
      return i
    };
    var ja = function() {
        var t = arguments.length;
        if (!t) return [];
        for (var e = Array(t - 1), n = arguments[0], r = t; r--;) e[r - 1] = arguments[r];
        return fi(J(n) ? ce(n) : [n], vi(e, 1))
      },
      La = "__lodash_hash_undefined__";
    var Na = function(t) {
      return this.__data__.set(t, La), this
    };
    var Fa = function(t) {
      return this.__data__.has(t)
    };

    function $a(t) {
      var e = -1,
        n = null == t ? 0 : t.length;
      for (this.__data__ = new Qr; ++e < n;) this.add(t[e])
    }
    $a.prototype.add = $a.prototype.push = Na, $a.prototype.has = Fa;
    var Ba = $a;
    var Ia = function(t, e) {
      for (var n = -1, r = null == t ? 0 : t.length; ++n < r;)
        if (e(t[n], n, t)) return !0;
      return !1
    };
    var za = function(t, e) {
        return t.has(e)
      },
      Ra = 1,
      Va = 2;
    var Ha = function(t, e, n, r, i, o) {
      var s = n & Ra,
        a = t.length,
        l = e.length;
      if (a != l && !(s && l > a)) return !1;
      var c = o.get(t);
      if (c && o.get(e)) return c == e;
      var h = -1,
        u = !0,
        d = n & Va ? new Ba : void 0;
      for (o.set(t, e), o.set(e, t); ++h < a;) {
        var p = t[h],
          f = e[h];
        if (r) var g = s ? r(f, p, h, e, t, o) : r(p, f, h, t, e, o);
        if (void 0 !== g) {
          if (g) continue;
          u = !1;
          break
        }
        if (d) {
          if (!Ia(e, function(t, e) {
              if (!za(d, e) && (p === t || i(p, t, n, r, o))) return d.push(e)
            })) {
            u = !1;
            break
          }
        } else if (p !== f && !i(p, f, n, r, o)) {
          u = !1;
          break
        }
      }
      return o.delete(t), o.delete(e), u
    };
    var Ga = function(t) {
      var e = -1,
        n = Array(t.size);
      return t.forEach(function(t, r) {
        n[++e] = [r, t]
      }), n
    };
    var Ua = function(t) {
        var e = -1,
          n = Array(t.size);
        return t.forEach(function(t) {
          n[++e] = t
        }), n
      },
      qa = 1,
      Wa = 2,
      Xa = "[object Boolean]",
      Ya = "[object Date]",
      Ja = "[object Error]",
      Za = "[object Map]",
      Ka = "[object Number]",
      Qa = "[object RegExp]",
      tl = "[object Set]",
      el = "[object String]",
      nl = "[object Symbol]",
      rl = "[object ArrayBuffer]",
      il = "[object DataView]",
      ol = _ ? _.prototype : void 0,
      sl = ol ? ol.valueOf : void 0;
    var al = function(t, e, n, r, i, o, s) {
        switch (n) {
          case il:
            if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) return !1;
            t = t.buffer, e = e.buffer;
          case rl:
            return !(t.byteLength != e.byteLength || !o(new Os(t), new Os(e)));
          case Xa:
          case Ya:
          case Ka:
            return Dn(+t, +e);
          case Ja:
            return t.name == e.name && t.message == e.message;
          case Qa:
          case el:
            return t == e + "";
          case Za:
            var a = Ga;
          case tl:
            var l = r & qa;
            if (a || (a = Ua), t.size != e.size && !l) return !1;
            var c = s.get(t);
            if (c) return c == e;
            r |= Wa, s.set(t, e);
            var h = Ha(a(t), a(e), r, i, o, s);
            return s.delete(t), h;
          case nl:
            if (sl) return sl.call(t) == sl.call(e)
        }
        return !1
      },
      ll = 1,
      cl = Object.prototype.hasOwnProperty;
    var hl = function(t, e, n, r, i, o) {
        var s = n & ll,
          a = fs(t),
          l = a.length;
        if (l != fs(e).length && !s) return !1;
        for (var c = l; c--;) {
          var h = a[c];
          if (!(s ? h in e : cl.call(e, h))) return !1
        }
        var u = o.get(t);
        if (u && o.get(e)) return u == e;
        var d = !0;
        o.set(t, e), o.set(e, t);
        for (var p = s; ++c < l;) {
          var f = t[h = a[c]],
            g = e[h];
          if (r) var m = s ? r(g, f, h, e, t, o) : r(f, g, h, t, e, o);
          if (!(void 0 === m ? f === g || i(f, g, n, r, o) : m)) {
            d = !1;
            break
          }
          p || (p = "constructor" == h)
        }
        if (d && !p) {
          var v = t.constructor,
            y = e.constructor;
          v != y && "constructor" in t && "constructor" in e && !("function" == typeof v && v instanceof v &&
            "function" == typeof y && y instanceof y) && (d = !1)
        }
        return o.delete(t), o.delete(e), d
      },
      ul = 1,
      dl = "[object Arguments]",
      pl = "[object Array]",
      fl = "[object Object]",
      gl = Object.prototype.hasOwnProperty;
    var ml = function(t, e, n, r, i, o) {
      var s = J(t),
        a = J(e),
        l = s ? pl : Ss(t),
        c = a ? pl : Ss(e),
        h = (l = l == dl ? fl : l) == fl,
        u = (c = c == dl ? fl : c) == fl,
        d = l == c;
      if (d && Object(Zn.a)(t)) {
        if (!Object(Zn.a)(e)) return !1;
        s = !0, h = !1
      }
      if (d && !h) return o || (o = new es), s || rr(t) ? Ha(t, e, n, r, i, o) : al(t, e, l, n, r, i, o);
      if (!(n & ul)) {
        var p = h && gl.call(t, "__wrapped__"),
          f = u && gl.call(e, "__wrapped__");
        if (p || f) {
          var g = p ? t.value() : t,
            m = f ? e.value() : e;
          return o || (o = new es), i(g, m, n, r, o)
        }
      }
      return !!d && (o || (o = new es), hl(t, e, n, r, i, o))
    };
    var vl = function t(e, n, r, i, o) {
        return e === n || (null == e || null == n || !G(e) && !G(n) ? e != e && n != n : ml(e, n, r, i, t, o))
      },
      yl = 1,
      bl = 2;
    var Cl = function(t, e, n, r) {
      var i = n.length,
        o = i,
        s = !r;
      if (null == t) return !o;
      for (t = Object(t); i--;) {
        var a = n[i];
        if (s && a[2] ? a[1] !== t[a[0]] : !(a[0] in t)) return !1
      }
      for (; ++i < o;) {
        var l = (a = n[i])[0],
          c = t[l],
          h = a[1];
        if (s && a[2]) {
          if (void 0 === c && !(l in t)) return !1
        } else {
          var u = new es;
          if (r) var d = r(c, h, l, t, e, u);
          if (!(void 0 === d ? vl(h, c, yl | bl, r, u) : d)) return !1
        }
      }
      return !0
    };
    var xl = function(t) {
      return t == t && !rt(t)
    };
    var wl = function(t) {
      for (var e = hr(t), n = e.length; n--;) {
        var r = e[n],
          i = t[r];
        e[n] = [r, i, xl(i)]
      }
      return e
    };
    var Al = function(t, e) {
      return function(n) {
        return null != n && n[t] === e && (void 0 !== e || t in Object(n))
      }
    };
    var El = function(t) {
      var e = wl(t);
      return 1 == e.length && e[0][2] ? Al(e[0][0], e[0][1]) : function(n) {
        return n === t || Cl(n, t, e)
      }
    };
    var Sl = function(t, e) {
      return null != t && e in Object(t)
    };
    var Ml = function(t, e, n) {
      for (var r = -1, i = (e = li(e, t)).length, o = !1; ++r < i;) {
        var s = hi(e[r]);
        if (!(o = null != t && n(t, s))) break;
        t = t[s]
      }
      return o || ++r != i ? o : !!(i = null == t ? 0 : t.length) && Bn(i) && We(s, i) && (J(t) || Jn(t))
    };
    var kl = function(t, e) {
        return null != t && Ml(t, e, Sl)
      },
      Ol = 1,
      Pl = 2;
    var Dl = function(t, e) {
      return wr(t) && xl(e) ? Al(hi(t), e) : function(n) {
        var r = di(n, t);
        return void 0 === r && r === e ? kl(n, t) : vl(e, r, Ol | Pl)
      }
    };
    var Tl = function(t) {
      return function(e) {
        return null == e ? void 0 : e[t]
      }
    };
    var _l = function(t) {
      return function(e) {
        return ui(e, t)
      }
    };
    var jl = function(t) {
      return wr(t) ? Tl(hi(t)) : _l(t)
    };
    var Ll = function(t) {
        return "function" == typeof t ? t : null == t ? vt : "object" == typeof t ? J(t) ? Dl(t[0], t[1]) : El(t) :
          jl(t)
      },
      Nl = "Expected a function";
    var Fl = function(t) {
      var e = null == t ? 0 : t.length,
        n = Ll;
      return t = e ? Y(t, function(t) {
        if ("function" != typeof t[1]) throw new TypeError(Nl);
        return [n(t[0]), t[1]]
      }) : [], Fn(function(n) {
        for (var r = -1; ++r < e;) {
          var i = t[r];
          if (qt(i[0], this, n)) return qt(i[1], this, n)
        }
      })
    };
    var $l = function(t, e, n) {
      var r = n.length;
      if (null == t) return !r;
      for (t = Object(t); r--;) {
        var i = n[r],
          o = e[i],
          s = t[i];
        if (void 0 === s && !(i in t) || !o(s)) return !1
      }
      return !0
    };
    var Bl = function(t) {
        var e = hr(t);
        return function(n) {
          return $l(n, t, e)
        }
      },
      Il = 1;
    var zl = function(t) {
      return Bl(Ca(t, Il))
    };
    var Rl = function(t, e) {
      return null == e || $l(t, e, hr(e))
    };
    var Vl = function(t, e, n, r) {
      for (var i = -1, o = null == t ? 0 : t.length; ++i < o;) {
        var s = t[i];
        e(r, s, n(s), t)
      }
      return r
    };
    var Hl = function(t) {
        return function(e, n, r) {
          for (var i = -1, o = Object(e), s = r(e), a = s.length; a--;) {
            var l = s[t ? a : ++i];
            if (!1 === n(o[l], l, o)) break
          }
          return e
        }
      },
      Gl = Hl();
    var Ul = function(t, e) {
      return t && Gl(t, e, hr)
    };
    var ql = function(t, e) {
        return function(n, r) {
          if (null == n) return n;
          if (!In(n)) return t(n, r);
          for (var i = n.length, o = e ? i : -1, s = Object(n);
            (e ? o-- : ++o < i) && !1 !== r(s[o], o, s););
          return n
        }
      },
      Wl = ql(Ul);
    var Xl = function(t, e, n, r) {
      return Wl(t, function(t, i, o) {
        e(r, t, n(t), o)
      }), r
    };
    var Yl = function(t, e) {
        return function(n, r) {
          var i = J(n) ? Vl : Xl,
            o = e ? e() : {};
          return i(n, t, Ll(r, 2), o)
        }
      },
      Jl = Object.prototype.hasOwnProperty,
      Zl = Yl(function(t, e, n) {
        Jl.call(t, n) ? ++t[n] : Pn(t, n, 1)
      });
    var Kl = function(t, e) {
        var n = Vt(t);
        return null == e ? n : ns(n, e)
      },
      Ql = 8;

    function tc(t, e, n) {
      var r = Mn(t, Ql, void 0, void 0, void 0, void 0, void 0, e = n ? void 0 : e);
      return r.placeholder = tc.placeholder, r
    }
    tc.placeholder = {};
    var ec = tc,
      nc = 16;

    function rc(t, e, n) {
      var r = Mn(t, nc, void 0, void 0, void 0, void 0, void 0, e = n ? void 0 : e);
      return r.placeholder = rc.placeholder, r
    }
    rc.placeholder = {};
    var ic = rc,
      oc = function() {
        return T.a.Date.now()
      },
      sc = "Expected a function",
      ac = Math.max,
      lc = Math.min;
    var cc = function(t, e, n) {
      var r, i, o, s, a, l, c = 0,
        h = !1,
        u = !1,
        d = !0;
      if ("function" != typeof t) throw new TypeError(sc);

      function p(e) {
        var n = r,
          o = i;
        return r = i = void 0, c = e, s = t.apply(o, n)
      }

      function f(t) {
        var n = t - l;
        return void 0 === l || n >= e || n < 0 || u && t - c >= o
      }

      function g() {
        var t = oc();
        if (f(t)) return m(t);
        a = setTimeout(g, function(t) {
          var n = e - (t - l);
          return u ? lc(n, o - (t - c)) : n
        }(t))
      }

      function m(t) {
        return a = void 0, d && r ? p(t) : (r = i = void 0, s)
      }

      function v() {
        var t = oc(),
          n = f(t);
        if (r = arguments, i = this, l = t, n) {
          if (void 0 === a) return function(t) {
            return c = t, a = setTimeout(g, e), h ? p(t) : s
          }(l);
          if (u) return clearTimeout(a), a = setTimeout(g, e), p(l)
        }
        return void 0 === a && (a = setTimeout(g, e)), s
      }
      return e = ht(e) || 0, rt(n) && (h = !!n.leading, o = (u = "maxWait" in n) ? ac(ht(n.maxWait) || 0, e) :
        o, d = "trailing" in n ? !!n.trailing : d), v.cancel = function() {
        void 0 !== a && clearTimeout(a), c = 0, r = l = i = a = void 0
      }, v.flush = function() {
        return void 0 === a ? s : m(oc())
      }, v
    };
    var hc = function(t, e) {
        return null == t || t != t ? e : t
      },
      uc = Object.prototype,
      dc = uc.hasOwnProperty,
      pc = Fn(function(t, e) {
        t = Object(t);
        var n = -1,
          r = e.length,
          i = r > 2 ? e[2] : void 0;
        for (i && zn(e[0], e[1], i) && (r = 1); ++n < r;)
          for (var o = e[n], s = mr(o), a = -1, l = s.length; ++a < l;) {
            var c = s[a],
              h = t[c];
            (void 0 === h || Dn(h, uc[c]) && !dc.call(t, c)) && (t[c] = o[c])
          }
        return t
      });
    var fc = function(t, e, n) {
      (void 0 === n || Dn(t[e], n)) && (void 0 !== n || e in t) || Pn(t, e, n)
    };
    var gc = function(t) {
      return G(t) && In(t)
    };
    var mc = function(t, e) {
      if (("constructor" !== e || "function" != typeof t[e]) && "__proto__" != e) return t[e]
    };
    var vc = function(t) {
      return jn(t, mr(t))
    };
    var yc = function(t, e, n, r, i, o, s) {
      var a = mc(t, n),
        l = mc(e, n),
        c = s.get(l);
      if (c) fc(t, n, c);
      else {
        var h = o ? o(a, l, n + "", t, e, s) : void 0,
          u = void 0 === h;
        if (u) {
          var d = J(l),
            p = !d && Object(Zn.a)(l),
            f = !d && !p && rr(l);
          h = l, d || p || f ? J(a) ? h = a : gc(a) ? h = ce(a) : p ? (u = !1, h = Object(is.a)(l, !0)) : f ? (
            u = !1, h = Fs(l, !0)) : h = [] : Oi(l) || Jn(l) ? (h = a, Jn(a) ? h = vc(a) : rt(a) && !At(a) ||
            (h = ra(l))) : u = !1
        }
        u && (s.set(l, h), i(h, l, r, o, s), s.delete(l)), fc(t, n, h)
      }
    };
    var bc = function t(e, n, r, i, o) {
      e !== n && Gl(n, function(s, a) {
        if (o || (o = new es), rt(s)) yc(e, n, a, r, t, i, o);
        else {
          var l = i ? i(mc(e, a), s, a + "", e, n, o) : void 0;
          void 0 === l && (l = s), fc(e, a, l)
        }
      }, mr)
    };
    var Cc = function t(e, n, r, i, o, s) {
        return rt(e) && rt(n) && (s.set(n, e), bc(e, n, void 0, t, s), s.delete(n)), e
      },
      xc = Rn(function(t, e, n, r) {
        bc(t, e, n, r)
      }),
      wc = Fn(function(t) {
        return t.push(void 0, Cc), qt(xc, void 0, t)
      }),
      Ac = "Expected a function";
    var Ec = function(t, e, n) {
        if ("function" != typeof t) throw new TypeError(Ac);
        return setTimeout(function() {
          t.apply(void 0, n)
        }, e)
      },
      Sc = Fn(function(t, e) {
        return Ec(t, 1, e)
      }),
      Mc = Fn(function(t, e, n) {
        return Ec(t, ht(e) || 0, n)
      });
    var kc = function(t, e, n) {
        for (var r = -1, i = null == t ? 0 : t.length; ++r < i;)
          if (n(e, t[r])) return !0;
        return !1
      },
      Oc = 200;
    var Pc = function(t, e, n, r) {
        var i = -1,
          o = je,
          s = !0,
          a = t.length,
          l = [],
          c = e.length;
        if (!a) return l;
        n && (e = Y(e, tr(n))), r ? (o = kc, s = !1) : e.length >= Oc && (o = za, s = !1, e = new Ba(e));
        t: for (; ++i < a;) {
          var h = t[i],
            u = null == n ? h : n(h);
          if (h = r || 0 !== h ? h : 0, s && u == u) {
            for (var d = c; d--;)
              if (e[d] === u) continue t;
            l.push(h)
          } else o(e, u, r) || l.push(h)
        }
        return l
      },
      Dc = Fn(function(t, e) {
        return gc(t) ? Pc(t, vi(e, 1, gc, !0)) : []
      });
    var Tc = function(t) {
        var e = null == t ? 0 : t.length;
        return e ? t[e - 1] : void 0
      },
      _c = Fn(function(t, e) {
        var n = Tc(e);
        return gc(n) && (n = void 0), gc(t) ? Pc(t, vi(e, 1, gc, !0), Ll(n, 2)) : []
      }),
      jc = Fn(function(t, e) {
        var n = Tc(e);
        return gc(n) && (n = void 0), gc(t) ? Pc(t, vi(e, 1, gc, !0), void 0, n) : []
      }),
      Lc = et(function(t, e) {
        return t / e
      }, 1);
    var Nc = function(t, e, n) {
      var r = null == t ? 0 : t.length;
      return r ? (e = n || void 0 === e ? 1 : ft(e), zi(t, e < 0 ? 0 : e, r)) : []
    };
    var Fc = function(t, e, n) {
      var r = null == t ? 0 : t.length;
      return r ? (e = n || void 0 === e ? 1 : ft(e), zi(t, 0, (e = r - e) < 0 ? 0 : e)) : []
    };
    var $c = function(t, e, n, r) {
      for (var i = t.length, o = r ? i : -1;
        (r ? o-- : ++o < i) && e(t[o], o, t););
      return n ? zi(t, r ? 0 : o, r ? o + 1 : i) : zi(t, r ? o + 1 : 0, r ? i : o)
    };
    var Bc = function(t, e) {
      return t && t.length ? $c(t, Ll(e, 3), !0, !0) : []
    };
    var Ic = function(t, e) {
      return t && t.length ? $c(t, Ll(e, 3), !0) : []
    };
    var zc = function(t) {
      return "function" == typeof t ? t : vt
    };
    var Rc = function(t, e) {
      return (J(t) ? Oe : Wl)(t, zc(e))
    };
    var Vc = function(t, e) {
        for (var n = null == t ? 0 : t.length; n-- && !1 !== e(t[n], n, t););
        return t
      },
      Hc = Hl(!0);
    var Gc = function(t, e) {
        return t && Hc(t, e, hr)
      },
      Uc = ql(Gc, !0);
    var qc = function(t, e) {
      return (J(t) ? Vc : Uc)(t, zc(e))
    };
    var Wc = function(t, e, n) {
      t = ai(t), e = tt(e);
      var r = t.length,
        i = n = void 0 === n ? r : qo(ft(n), 0, r);
      return (n -= e.length) >= 0 && t.slice(n, i) == e
    };
    var Xc = function(t, e) {
      return Y(e, function(e) {
        return [e, t[e]]
      })
    };
    var Yc = function(t) {
        var e = -1,
          n = Array(t.size);
        return t.forEach(function(t) {
          n[++e] = [t, t]
        }), n
      },
      Jc = "[object Map]",
      Zc = "[object Set]";
    var Kc = function(t) {
        return function(e) {
          var n = Ss(e);
          return n == Jc ? Ga(e) : n == Zc ? Yc(e) : Xc(e, t(e))
        }
      },
      Qc = Kc(hr),
      th = Kc(mr),
      eh = ao({
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      }),
      nh = /[&<>"']/g,
      rh = RegExp(nh.source);
    var ih = function(t) {
        return (t = ai(t)) && rh.test(t) ? t.replace(nh, eh) : t
      },
      oh = /[\\^$.*+?()[\]{}|]/g,
      sh = RegExp(oh.source);
    var ah = function(t) {
      return (t = ai(t)) && sh.test(t) ? t.replace(oh, "\\$&") : t
    };
    var lh = function(t, e) {
      for (var n = -1, r = null == t ? 0 : t.length; ++n < r;)
        if (!e(t[n], n, t)) return !1;
      return !0
    };
    var ch = function(t, e) {
      var n = !0;
      return Wl(t, function(t, r, i) {
        return n = !!e(t, r, i)
      }), n
    };
    var hh = function(t, e, n) {
        var r = J(t) ? lh : ch;
        return n && zn(t, e, n) && (e = void 0), r(t, Ll(e, 3))
      },
      uh = 4294967295;
    var dh = function(t) {
      return t ? qo(ft(t), 0, uh) : 0
    };
    var ph = function(t, e, n, r) {
      var i = t.length;
      for ((n = ft(n)) < 0 && (n = -n > i ? 0 : i + n), (r = void 0 === r || r > i ? i : ft(r)) < 0 && (r += i),
        r = n > r ? 0 : dh(r); n < r;) t[n++] = e;
      return t
    };
    var fh = function(t, e, n, r) {
      var i = null == t ? 0 : t.length;
      return i ? (n && "number" != typeof n && zn(t, e, n) && (n = 0, r = i), ph(t, e, n, r)) : []
    };
    var gh = function(t, e) {
      var n = [];
      return Wl(t, function(t, r, i) {
        e(t, r, i) && n.push(t)
      }), n
    };
    var mh = function(t, e) {
      return (J(t) ? os : gh)(t, Ll(e, 3))
    };
    var vh = function(t) {
        return function(e, n, r) {
          var i = Object(e);
          if (!In(e)) {
            var o = Ll(n, 3);
            e = hr(e), n = function(t) {
              return o(i[t], t, i)
            }
          }
          var s = t(e, n, r);
          return s > -1 ? i[o ? e[s] : s] : void 0
        }
      },
      yh = Math.max;
    var bh = function(t, e, n) {
        var r = null == t ? 0 : t.length;
        if (!r) return -1;
        var i = null == n ? 0 : ft(n);
        return i < 0 && (i = yh(r + i, 0)), Pe(t, Ll(e, 3), i)
      },
      Ch = vh(bh);
    var xh = function(t, e, n) {
      var r;
      return n(t, function(t, n, i) {
        if (e(t, n, i)) return r = n, !1
      }), r
    };
    var wh = function(t, e) {
        return xh(t, Ll(e, 3), Ul)
      },
      Ah = Math.max,
      Eh = Math.min;
    var Sh = function(t, e, n) {
        var r = null == t ? 0 : t.length;
        if (!r) return -1;
        var i = r - 1;
        return void 0 !== n && (i = ft(n), i = n < 0 ? Ah(r + i, 0) : Eh(i, r - 1)), Pe(t, Ll(e, 3), i, !0)
      },
      Mh = vh(Sh);
    var kh = function(t, e) {
      return xh(t, Ll(e, 3), Gc)
    };
    var Oh = function(t) {
      return t && t.length ? t[0] : void 0
    };
    var Ph = function(t, e) {
      var n = -1,
        r = In(t) ? Array(t.length) : [];
      return Wl(t, function(t, i, o) {
        r[++n] = e(t, i, o)
      }), r
    };
    var Dh = function(t, e) {
      return (J(t) ? Y : Ph)(t, Ll(e, 3))
    };
    var Th = function(t, e) {
        return vi(Dh(t, e), 1)
      },
      _h = 1 / 0;
    var jh = function(t, e) {
      return vi(Dh(t, e), _h)
    };
    var Lh = function(t, e, n) {
        return n = void 0 === n ? 1 : ft(n), vi(Dh(t, e), n)
      },
      Nh = 1 / 0;
    var Fh = function(t) {
      return null != t && t.length ? vi(t, Nh) : []
    };
    var $h = function(t, e) {
        return null != t && t.length ? (e = void 0 === e ? 1 : ft(e), vi(t, e)) : []
      },
      Bh = 512;
    var Ih = function(t) {
        return Mn(t, Bh)
      },
      zh = zo("floor"),
      Rh = "Expected a function",
      Vh = 8,
      Hh = 32,
      Gh = 128,
      Uh = 256;
    var qh = function(t) {
        return bi(function(e) {
          var n = e.length,
            r = n,
            i = le.prototype.thru;
          for (t && e.reverse(); r--;) {
            var o = e[r];
            if ("function" != typeof o) throw new TypeError(Rh);
            if (i && !s && "wrapper" == se(o)) var s = new le([], !0)
          }
          for (r = s ? r : n; ++r < n;) {
            o = e[r];
            var a = se(o),
              l = "wrapper" == a ? re(o) : void 0;
            s = l && fe(l[0]) && l[1] == (Gh | Vh | Hh | Uh) && !l[4].length && 1 == l[9] ? s[se(l[0])].apply(
              s, l[3]) : 1 == o.length && fe(o) ? s[a]() : s.thru(o)
          }
          return function() {
            var t = arguments,
              r = t[0];
            if (s && 1 == t.length && J(r)) return s.plant(r).value();
            for (var i = 0, o = n ? e[i].apply(this, t) : r; ++i < n;) o = e[i].call(this, o);
            return o
          }
        })
      },
      Wh = qh(),
      Xh = qh(!0);
    var Yh = function(t, e) {
      return null == t ? t : Gl(t, zc(e), mr)
    };
    var Jh = function(t, e) {
      return null == t ? t : Hc(t, zc(e), mr)
    };
    var Zh = function(t, e) {
      return t && Ul(t, zc(e))
    };
    var Kh = function(t, e) {
      return t && Gc(t, zc(e))
    };
    var Qh = function(t) {
      for (var e = -1, n = null == t ? 0 : t.length, r = {}; ++e < n;) {
        var i = t[e];
        r[i[0]] = i[1]
      }
      return r
    };
    var tu = function(t, e) {
      return os(e, function(e) {
        return At(t[e])
      })
    };
    var eu = function(t) {
      return null == t ? [] : tu(t, hr(t))
    };
    var nu = function(t) {
        return null == t ? [] : tu(t, mr(t))
      },
      ru = Object.prototype.hasOwnProperty,
      iu = Yl(function(t, e, n) {
        ru.call(t, n) ? t[n].push(e) : Pn(t, n, [e])
      });
    var ou = function(t, e) {
      return t > e
    };
    var su = function(t) {
        return function(e, n) {
          return "string" == typeof e && "string" == typeof n || (e = ht(e), n = ht(n)), t(e, n)
        }
      },
      au = su(ou),
      lu = su(function(t, e) {
        return t >= e
      }),
      cu = Object.prototype.hasOwnProperty;
    var hu = function(t, e) {
      return null != t && cu.call(t, e)
    };
    var uu = function(t, e) {
        return null != t && Ml(t, e, hu)
      },
      du = Math.max,
      pu = Math.min;
    var fu = function(t, e, n) {
      return t >= pu(e, n) && t < du(e, n)
    };
    var gu = function(t, e, n) {
        return e = pt(e), void 0 === n ? (n = e, e = 0) : n = pt(n), t = ht(t), fu(t, e, n)
      },
      mu = "[object String]";
    var vu = function(t) {
      return "string" == typeof t || !J(t) && G(t) && H(t) == mu
    };
    var yu = function(t, e) {
      return Y(e, function(e) {
        return t[e]
      })
    };
    var bu = function(t) {
        return null == t ? [] : yu(t, hr(t))
      },
      Cu = Math.max;
    var xu = function(t, e, n, r) {
        t = In(t) ? t : bu(t), n = n && !r ? ft(n) : 0;
        var i = t.length;
        return n < 0 && (n = Cu(i + n, 0)), vu(t) ? n <= i && t.indexOf(e, n) > -1 : !!i && _e(t, e, n) > -1
      },
      wu = Math.max;
    var Au = function(t, e, n) {
      var r = null == t ? 0 : t.length;
      if (!r) return -1;
      var i = null == n ? 0 : ft(n);
      return i < 0 && (i = wu(r + i, 0)), _e(t, e, i)
    };
    var Eu = function(t) {
        return null != t && t.length ? zi(t, 0, -1) : []
      },
      Su = Math.min;
    var Mu = function(t, e, n) {
      for (var r = n ? kc : je, i = t[0].length, o = t.length, s = o, a = Array(o), l = 1 / 0, c = []; s--;) {
        var h = t[s];
        s && e && (h = Y(h, tr(e))), l = Su(h.length, l), a[s] = !n && (e || i >= 120 && h.length >= 120) ? new Ba(
          s && h) : void 0
      }
      h = t[0];
      var u = -1,
        d = a[0];
      t: for (; ++u < i && c.length < l;) {
        var p = h[u],
          f = e ? e(p) : p;
        if (p = n || 0 !== p ? p : 0, !(d ? za(d, f) : r(c, f, n))) {
          for (s = o; --s;) {
            var g = a[s];
            if (!(g ? za(g, f) : r(t[s], f, n))) continue t
          }
          d && d.push(f), c.push(p)
        }
      }
      return c
    };
    var ku = function(t) {
        return gc(t) ? t : []
      },
      Ou = Fn(function(t) {
        var e = Y(t, ku);
        return e.length && e[0] === t[0] ? Mu(e) : []
      }),
      Pu = Fn(function(t) {
        var e = Tc(t),
          n = Y(t, ku);
        return e === Tc(n) ? e = void 0 : n.pop(), n.length && n[0] === t[0] ? Mu(n, Ll(e, 2)) : []
      }),
      Du = Fn(function(t) {
        var e = Tc(t),
          n = Y(t, ku);
        return (e = "function" == typeof e ? e : void 0) && n.pop(), n.length && n[0] === t[0] ? Mu(n, void 0,
          e) : []
      });
    var Tu = function(t, e, n, r) {
      return Ul(t, function(t, i, o) {
        e(r, n(t), i, o)
      }), r
    };
    var _u = function(t, e) {
        return function(n, r) {
          return Tu(n, t, e(r), {})
        }
      },
      ju = Object.prototype.toString,
      Lu = _u(function(t, e, n) {
        null != e && "function" != typeof e.toString && (e = ju.call(e)), t[e] = n
      }, Se(vt)),
      Nu = Object.prototype,
      Fu = Nu.hasOwnProperty,
      $u = Nu.toString,
      Bu = _u(function(t, e, n) {
        null != e && "function" != typeof e.toString && (e = $u.call(e)), Fu.call(t, e) ? t[e].push(n) : t[e] = [
          n
        ]
      }, Ll);
    var Iu = function(t, e) {
      return e.length < 2 ? t : ui(t, zi(e, 0, -1))
    };
    var zu = function(t, e, n) {
        e = li(e, t);
        var r = null == (t = Iu(t, e)) ? t : t[hi(Tc(e))];
        return null == r ? void 0 : qt(r, t, n)
      },
      Ru = Fn(zu),
      Vu = Fn(function(t, e, n) {
        var r = -1,
          i = "function" == typeof e,
          o = In(t) ? Array(t.length) : [];
        return Wl(t, function(t) {
          o[++r] = i ? qt(e, t, n) : zu(t, e, n)
        }), o
      }),
      Hu = "[object ArrayBuffer]";
    var Gu = function(t) {
        return G(t) && H(t) == Hu
      },
      Uu = er.a && er.a.isArrayBuffer,
      qu = Uu ? tr(Uu) : Gu,
      Wu = "[object Boolean]";
    var Xu = function(t) {
        return !0 === t || !1 === t || G(t) && H(t) == Wu
      },
      Yu = "[object Date]";
    var Ju = function(t) {
        return G(t) && H(t) == Yu
      },
      Zu = er.a && er.a.isDate,
      Ku = Zu ? tr(Zu) : Ju;
    var Qu = function(t) {
        return G(t) && 1 === t.nodeType && !Oi(t)
      },
      td = "[object Map]",
      ed = "[object Set]",
      nd = Object.prototype.hasOwnProperty;
    var rd = function(t) {
      if (null == t) return !0;
      if (In(t) && (J(t) || "string" == typeof t || "function" == typeof t.splice || Object(Zn.a)(t) || rr(t) ||
          Jn(t))) return !t.length;
      var e = Ss(t);
      if (e == td || e == ed) return !t.size;
      if (Hn(t)) return !cr(t).length;
      for (var n in t)
        if (nd.call(t, n)) return !1;
      return !0
    };
    var id = function(t, e) {
      return vl(t, e)
    };
    var od = function(t, e, n) {
        var r = (n = "function" == typeof n ? n : void 0) ? n(t, e) : void 0;
        return void 0 === r ? vl(t, e, void 0, n) : !!r
      },
      sd = T.a.isFinite;
    var ad = function(t) {
      return "number" == typeof t && sd(t)
    };
    var ld = function(t) {
      return "number" == typeof t && t == ft(t)
    };
    var cd = function(t, e) {
      return t === e || Cl(t, e, wl(e))
    };
    var hd = function(t, e, n) {
        return n = "function" == typeof n ? n : void 0, Cl(t, e, wl(e), n)
      },
      ud = "[object Number]";
    var dd = function(t) {
      return "number" == typeof t || G(t) && H(t) == ud
    };
    var pd = function(t) {
        return dd(t) && t != +t
      },
      fd = n("YXvJ"),
      gd = Et ? At : fd.a,
      md = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.";
    var vd = function(t) {
      if (gd(t)) throw new Error(md);
      return Nt(t)
    };
    var yd = function(t) {
      return null == t
    };
    var bd = function(t) {
        return null === t
      },
      Cd = "[object RegExp]";
    var xd = function(t) {
        return G(t) && H(t) == Cd
      },
      wd = er.a && er.a.isRegExp,
      Ad = wd ? tr(wd) : xd,
      Ed = 9007199254740991;
    var Sd = function(t) {
      return ld(t) && t >= -Ed && t <= Ed
    };
    var Md = function(t) {
        return void 0 === t
      },
      kd = "[object WeakMap]";
    var Od = function(t) {
        return G(t) && Ss(t) == kd
      },
      Pd = "[object WeakSet]";
    var Dd = function(t) {
        return G(t) && H(t) == Pd
      },
      Td = 1;
    var _d = function(t) {
        return Ll("function" == typeof t ? t : Ca(t, Td))
      },
      jd = Array.prototype.join;
    var Ld = function(t, e) {
        return null == t ? "" : jd.call(t, e)
      },
      Nd = No(function(t, e, n) {
        return t + (n ? "-" : "") + e.toLowerCase()
      }),
      Fd = Yl(function(t, e, n) {
        Pn(t, n, e)
      });
    var $d = function(t, e, n) {
        for (var r = n + 1; r--;)
          if (t[r] === e) return r;
        return r
      },
      Bd = Math.max,
      Id = Math.min;
    var zd = function(t, e, n) {
        var r = null == t ? 0 : t.length;
        if (!r) return -1;
        var i = r;
        return void 0 !== n && (i = (i = ft(n)) < 0 ? Bd(r + i, 0) : Id(i, r - 1)), e == e ? $d(t, e, i) : Pe(t,
          De, i, !0)
      },
      Rd = No(function(t, e, n) {
        return t + (n ? " " : "") + e.toLowerCase()
      }),
      Vd = ro("toLowerCase");
    var Hd = function(t, e) {
        return t < e
      },
      Gd = su(Hd),
      Ud = su(function(t, e) {
        return t <= e
      });
    var qd = function(t, e) {
      var n = {};
      return e = Ll(e, 3), Ul(t, function(t, r, i) {
        Pn(n, e(t, r, i), t)
      }), n
    };
    var Wd = function(t, e) {
        var n = {};
        return e = Ll(e, 3), Ul(t, function(t, r, i) {
          Pn(n, r, e(t, r, i))
        }), n
      },
      Xd = 1;
    var Yd = function(t) {
        return El(Ca(t, Xd))
      },
      Jd = 1;
    var Zd = function(t, e) {
      return Dl(t, Ca(e, Jd))
    };
    var Kd = function(t, e, n) {
      for (var r = -1, i = t.length; ++r < i;) {
        var o = t[r],
          s = e(o);
        if (null != s && (void 0 === a ? s == s && !q(s) : n(s, a))) var a = s,
          l = o
      }
      return l
    };
    var Qd = function(t) {
      return t && t.length ? Kd(t, vt, ou) : void 0
    };
    var tp = function(t, e) {
      return t && t.length ? Kd(t, Ll(e, 2), ou) : void 0
    };
    var ep = function(t, e) {
        for (var n, r = -1, i = t.length; ++r < i;) {
          var o = e(t[r]);
          void 0 !== o && (n = void 0 === n ? o : n + o)
        }
        return n
      },
      np = NaN;
    var rp = function(t, e) {
      var n = null == t ? 0 : t.length;
      return n ? ep(t, e) / n : np
    };
    var ip = function(t) {
      return rp(t, vt)
    };
    var op = function(t, e) {
        return rp(t, Ll(e, 2))
      },
      sp = Rn(function(t, e, n) {
        bc(t, e, n)
      }),
      ap = Fn(function(t, e) {
        return function(n) {
          return zu(n, t, e)
        }
      }),
      lp = Fn(function(t, e) {
        return function(n) {
          return zu(t, n, e)
        }
      });
    var cp = function(t) {
      return t && t.length ? Kd(t, vt, Hd) : void 0
    };
    var hp = function(t, e) {
      return t && t.length ? Kd(t, Ll(e, 2), Hd) : void 0
    };
    var up = function(t, e, n) {
        var r = hr(e),
          i = tu(e, r),
          o = !(rt(n) && "chain" in n && !n.chain),
          s = At(t);
        return Oe(i, function(n) {
          var r = e[n];
          t[n] = r, s && (t.prototype[n] = function() {
            var e = this.__chain__;
            if (o || e) {
              var n = t(this.__wrapped__);
              return (n.__actions__ = ce(this.__actions__)).push({
                func: r,
                args: arguments,
                thisArg: t
              }), n.__chain__ = e, n
            }
            return r.apply(t, fi([this.value()], arguments))
          })
        }), t
      },
      dp = et(function(t, e) {
        return t * e
      }, 1),
      pp = "Expected a function";
    var fp = function(t) {
      if ("function" != typeof t) throw new TypeError(pp);
      return function() {
        var e = arguments;
        switch (e.length) {
          case 0:
            return !t.call(this);
          case 1:
            return !t.call(this, e[0]);
          case 2:
            return !t.call(this, e[0], e[1]);
          case 3:
            return !t.call(this, e[0], e[1], e[2])
        }
        return !t.apply(this, e)
      }
    };
    var gp = function(t) {
        for (var e, n = []; !(e = t.next()).done;) n.push(e.value);
        return n
      },
      mp = "[object Map]",
      vp = "[object Set]",
      yp = _ ? _.iterator : void 0;
    var bp = function(t) {
      if (!t) return [];
      if (In(t)) return vu(t) ? no(t) : ce(t);
      if (yp && t[yp]) return gp(t[yp]());
      var e = Ss(t);
      return (e == mp ? Ga : e == vp ? Ua : bu)(t)
    };
    var Cp = function() {
      void 0 === this.__values__ && (this.__values__ = bp(this.value()));
      var t = this.__index__ >= this.__values__.length;
      return {
        done: t,
        value: t ? void 0 : this.__values__[this.__index__++]
      }
    };
    var xp = function(t, e) {
      var n = t.length;
      if (n) return We(e += e < 0 ? n : 0, n) ? t[e] : void 0
    };
    var wp = function(t, e) {
      return t && t.length ? xp(t, ft(e)) : void 0
    };
    var Ap = function(t) {
      return t = ft(t), Fn(function(e) {
        return xp(e, t)
      })
    };
    var Ep = function(t, e) {
      return e = li(e, t), null == (t = Iu(t, e)) || delete t[hi(Tc(e))]
    };
    var Sp = function(t) {
        return Oi(t) ? void 0 : t
      },
      Mp = bi(function(t, e) {
        var n = {};
        if (null == t) return n;
        var r = !1;
        e = Y(e, function(e) {
          return e = li(e, t), r || (r = e.length > 1), e
        }), jn(t, gs(t), n), r && (n = Ca(n, 7, Sp));
        for (var i = e.length; i--;) Ep(n, e[i]);
        return n
      });
    var kp = function(t, e, n, r) {
      if (!rt(t)) return t;
      for (var i = -1, o = (e = li(e, t)).length, s = o - 1, a = t; null != a && ++i < o;) {
        var l = hi(e[i]),
          c = n;
        if (i != s) {
          var h = a[l];
          void 0 === (c = r ? r(h, l, a) : void 0) && (c = rt(h) ? h : We(e[i + 1]) ? [] : {})
        }
        _n(a, l, c), a = a[l]
      }
      return t
    };
    var Op = function(t, e, n) {
      for (var r = -1, i = e.length, o = {}; ++r < i;) {
        var s = e[r],
          a = ui(t, s);
        n(a, s) && kp(o, li(s, t), a)
      }
      return o
    };
    var Pp = function(t, e) {
      if (null == t) return {};
      var n = Y(gs(t), function(t) {
        return [t]
      });
      return e = Ll(e), Op(t, n, function(t, n) {
        return e(t, n[0])
      })
    };
    var Dp = function(t, e) {
      return Pp(t, fp(Ll(e)))
    };
    var Tp = function(t) {
      return Li(2, t)
    };
    var _p = function(t, e) {
      var n = t.length;
      for (t.sort(e); n--;) t[n] = t[n].value;
      return t
    };
    var jp = function(t, e) {
      if (t !== e) {
        var n = void 0 !== t,
          r = null === t,
          i = t == t,
          o = q(t),
          s = void 0 !== e,
          a = null === e,
          l = e == e,
          c = q(e);
        if (!a && !c && !o && t > e || o && s && l && !a && !c || r && s && l || !n && l || !i) return 1;
        if (!r && !o && !c && t < e || c && n && i && !r && !o || a && n && i || !s && i || !l) return -1
      }
      return 0
    };
    var Lp = function(t, e, n) {
      for (var r = -1, i = t.criteria, o = e.criteria, s = i.length, a = n.length; ++r < s;) {
        var l = jp(i[r], o[r]);
        if (l) return r >= a ? l : l * ("desc" == n[r] ? -1 : 1)
      }
      return t.index - e.index
    };
    var Np = function(t, e, n) {
      var r = -1;
      e = Y(e.length ? e : [vt], tr(Ll));
      var i = Ph(t, function(t, n, i) {
        return {
          criteria: Y(e, function(e) {
            return e(t)
          }),
          index: ++r,
          value: t
        }
      });
      return _p(i, function(t, e) {
        return Lp(t, e, n)
      })
    };
    var Fp = function(t, e, n, r) {
      return null == t ? [] : (J(e) || (e = null == e ? [] : [e]), J(n = r ? void 0 : n) || (n = null == n ? [] :
        [n]), Np(t, e, n))
    };
    var $p = function(t) {
        return bi(function(e) {
          return e = Y(e, tr(Ll)), Fn(function(n) {
            var r = this;
            return t(e, function(t) {
              return qt(t, r, n)
            })
          })
        })
      },
      Bp = $p(Y),
      Ip = Fn,
      zp = Math.min,
      Rp = Ip(function(t, e) {
        var n = (e = 1 == e.length && J(e[0]) ? Y(e[0], tr(Ll)) : Y(vi(e, 1), tr(Ll))).length;
        return Fn(function(r) {
          for (var i = -1, o = zp(r.length, n); ++i < o;) r[i] = e[i].call(this, r[i]);
          return qt(t, this, r)
        })
      }),
      Vp = $p(lh),
      Hp = $p(Ia),
      Gp = 9007199254740991,
      Up = Math.floor;
    var qp = function(t, e) {
        var n = "";
        if (!t || e < 1 || e > Gp) return n;
        do {
          e % 2 && (n += t), (e = Up(e / 2)) && (t += t)
        } while (e);
        return n
      },
      Wp = Tl("length"),
      Xp = "[\\ud800-\\udfff]",
      Yp = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]",
      Jp = "[^\\ud800-\\udfff]",
      Zp = "(?:\\ud83c[\\udde6-\\uddff]){2}",
      Kp = "[\\ud800-\\udbff][\\udc00-\\udfff]",
      Qp = "(?:" + Yp + "|\\ud83c[\\udffb-\\udfff])" + "?",
      tf = "[\\ufe0e\\ufe0f]?" + Qp + ("(?:\\u200d(?:" + [Jp, Zp, Kp].join("|") + ")[\\ufe0e\\ufe0f]?" + Qp +
        ")*"),
      ef = "(?:" + [Jp + Yp + "?", Yp, Zp, Kp, Xp].join("|") + ")",
      nf = RegExp("\\ud83c[\\udffb-\\udfff](?=\\ud83c[\\udffb-\\udfff])|" + ef + tf, "g");
    var rf = function(t) {
      for (var e = nf.lastIndex = 0; nf.test(t);) ++e;
      return e
    };
    var of = function(t) {
      return Hi(t) ? rf(t) : Wp(t)
    }, sf = Math.ceil;
    var af = function(t, e) {
        var n = (e = void 0 === e ? " " : tt(e)).length;
        if (n < 2) return n ? qp(e, t) : e;
        var r = qp(e, sf(t / of (e)));
        return Hi(e) ? Ri(no(r), 0, t).join("") : r.slice(0, t)
      },
      lf = Math.ceil,
      cf = Math.floor;
    var hf = function(t, e, n) {
      t = ai(t);
      var r = (e = ft(e)) ? of (t) : 0;
      if (!e || r >= e) return t;
      var i = (e - r) / 2;
      return af(cf(i), n) + t + af(lf(i), n)
    };
    var uf = function(t, e, n) {
      t = ai(t);
      var r = (e = ft(e)) ? of (t) : 0;
      return e && r < e ? t + af(e - r, n) : t
    };
    var df = function(t, e, n) {
        t = ai(t);
        var r = (e = ft(e)) ? of (t) : 0;
        return e && r < e ? af(e - r, n) + t : t
      },
      pf = /^\s+/,
      ff = T.a.parseInt;
    var gf = function(t, e, n) {
        return n || null == e ? e = 0 : e && (e = +e), ff(ai(t).replace(pf, ""), e || 0)
      },
      mf = Fn(function(t, e) {
        var n = Ze(e, Ge(mf));
        return Mn(t, 32, void 0, e, n)
      });
    mf.placeholder = {};
    var vf = mf,
      yf = Fn(function(t, e) {
        var n = Ze(e, Ge(yf));
        return Mn(t, 64, void 0, e, n)
      });
    yf.placeholder = {};
    var bf = yf,
      Cf = Yl(function(t, e, n) {
        t[n ? 0 : 1].push(e)
      }, function() {
        return [
          [],
          []
        ]
      });
    var xf = function(t, e) {
        return Op(t, e, function(e, n) {
          return kl(t, n)
        })
      },
      wf = bi(function(t, e) {
        return null == t ? {} : xf(t, e)
      });
    var Af = function(t) {
      for (var e, n = this; n instanceof Kt;) {
        var r = he(n);
        r.__index__ = 0, r.__values__ = void 0, e ? i.__wrapped__ = r : e = r;
        var i = r;
        n = n.__wrapped__
      }
      return i.__wrapped__ = t, e
    };
    var Ef = function(t) {
      return function(e) {
        return null == t ? void 0 : ui(t, e)
      }
    };
    var Sf = function(t, e, n, r) {
        for (var i = n - 1, o = t.length; ++i < o;)
          if (r(t[i], e)) return i;
        return -1
      },
      Mf = Array.prototype.splice;
    var kf = function(t, e, n, r) {
      var i = r ? Sf : _e,
        o = -1,
        s = e.length,
        a = t;
      for (t === e && (e = ce(e)), n && (a = Y(t, tr(n))); ++o < s;)
        for (var l = 0, c = e[o], h = n ? n(c) : c;
          (l = i(a, h, l, r)) > -1;) a !== t && Mf.call(a, l, 1), Mf.call(t, l, 1);
      return t
    };
    var Of = function(t, e) {
        return t && t.length && e && e.length ? kf(t, e) : t
      },
      Pf = Fn(Of);
    var Df = function(t, e, n) {
      return t && t.length && e && e.length ? kf(t, e, Ll(n, 2)) : t
    };
    var Tf = function(t, e, n) {
        return t && t.length && e && e.length ? kf(t, e, void 0, n) : t
      },
      _f = Array.prototype.splice;
    var jf = function(t, e) {
        for (var n = t ? e.length : 0, r = n - 1; n--;) {
          var i = e[n];
          if (n == r || i !== o) {
            var o = i;
            We(i) ? _f.call(t, i, 1) : Ep(t, i)
          }
        }
        return t
      },
      Lf = bi(function(t, e) {
        var n = null == t ? 0 : t.length,
          r = pi(t, e);
        return jf(t, Y(e, function(t) {
          return We(t, n) ? +t : t
        }).sort(jp)), r
      }),
      Nf = Math.floor,
      Ff = Math.random;
    var $f = function(t, e) {
        return t + Nf(Ff() * (e - t + 1))
      },
      Bf = parseFloat,
      If = Math.min,
      zf = Math.random;
    var Rf = function(t, e, n) {
        if (n && "boolean" != typeof n && zn(t, e, n) && (e = n = void 0), void 0 === n && ("boolean" == typeof e ?
            (n = e, e = void 0) : "boolean" == typeof t && (n = t, t = void 0)), void 0 === t && void 0 === e ? (
            t = 0, e = 1) : (t = pt(t), void 0 === e ? (e = t, t = 0) : e = pt(e)), t > e) {
          var r = t;
          t = e, e = r
        }
        if (n || t % 1 || e % 1) {
          var i = zf();
          return If(t + i * (e - t + Bf("1e-" + ((i + "").length - 1))), e)
        }
        return $f(t, e)
      },
      Vf = Math.ceil,
      Hf = Math.max;
    var Gf = function(t, e, n, r) {
      for (var i = -1, o = Hf(Vf((e - t) / (n || 1)), 0), s = Array(o); o--;) s[r ? o : ++i] = t, t += n;
      return s
    };
    var Uf = function(t) {
        return function(e, n, r) {
          return r && "number" != typeof r && zn(e, n, r) && (n = r = void 0), e = pt(e), void 0 === n ? (n = e,
            e = 0) : n = pt(n), r = void 0 === r ? e < n ? 1 : -1 : pt(r), Gf(e, n, r, t)
        }
      },
      qf = Uf(),
      Wf = Uf(!0),
      Xf = bi(function(t, e) {
        return Mn(t, 256, void 0, void 0, void 0, e)
      });
    var Yf = function(t, e, n, r, i) {
      return i(t, function(t, i, o) {
        n = r ? (r = !1, t) : e(n, t, i, o)
      }), n
    };
    var Jf = function(t, e, n) {
      var r = J(t) ? so : Yf,
        i = arguments.length < 3;
      return r(t, Ll(e, 4), n, i, Wl)
    };
    var Zf = function(t, e, n, r) {
      var i = null == t ? 0 : t.length;
      for (r && i && (n = t[--i]); i--;) n = e(n, t[i], i, t);
      return n
    };
    var Kf = function(t, e, n) {
      var r = J(t) ? Zf : Yf,
        i = arguments.length < 3;
      return r(t, Ll(e, 4), n, i, Uc)
    };
    var Qf = function(t, e) {
      return (J(t) ? os : gh)(t, fp(Ll(e, 3)))
    };
    var tg = function(t, e) {
      var n = [];
      if (!t || !t.length) return n;
      var r = -1,
        i = [],
        o = t.length;
      for (e = Ll(e, 3); ++r < o;) {
        var s = t[r];
        e(s, r, t) && (n.push(s), i.push(r))
      }
      return jf(t, i), n
    };
    var eg = function(t, e, n) {
      return e = (n ? zn(t, e, n) : void 0 === e) ? 1 : ft(e), qp(ai(t), e)
    };
    var ng = function() {
        var t = arguments,
          e = ai(t[0]);
        return t.length < 3 ? e : e.replace(t[1], t[2])
      },
      rg = "Expected a function";
    var ig = function(t, e) {
      if ("function" != typeof t) throw new TypeError(rg);
      return e = void 0 === e ? e : ft(e), Fn(t, e)
    };
    var og = function(t, e, n) {
        var r = -1,
          i = (e = li(e, t)).length;
        for (i || (i = 1, t = void 0); ++r < i;) {
          var o = null == t ? void 0 : t[hi(e[r])];
          void 0 === o && (r = i, o = n), t = At(o) ? o.call(t) : o
        }
        return t
      },
      sg = Array.prototype.reverse;
    var ag = function(t) {
        return null == t ? t : sg.call(t)
      },
      lg = zo("round");
    var cg = function(t) {
      var e = t.length;
      return e ? t[$f(0, e - 1)] : void 0
    };
    var hg = function(t) {
      return cg(bu(t))
    };
    var ug = function(t) {
      return (J(t) ? cg : hg)(t)
    };
    var dg = function(t, e) {
      var n = -1,
        r = t.length,
        i = r - 1;
      for (e = void 0 === e ? r : e; ++n < e;) {
        var o = $f(n, i),
          s = t[o];
        t[o] = t[n], t[n] = s
      }
      return t.length = e, t
    };
    var pg = function(t, e) {
      return dg(ce(t), qo(e, 0, t.length))
    };
    var fg = function(t, e) {
      var n = bu(t);
      return dg(n, qo(e, 0, n.length))
    };
    var gg = function(t, e, n) {
      return e = (n ? zn(t, e, n) : void 0 === e) ? 1 : ft(e), (J(t) ? pg : fg)(t, e)
    };
    var mg = function(t, e, n) {
      return null == t ? t : kp(t, e, n)
    };
    var vg = function(t, e, n, r) {
      return r = "function" == typeof r ? r : void 0, null == t ? t : kp(t, e, n, r)
    };
    var yg = function(t) {
      return dg(ce(t))
    };
    var bg = function(t) {
      return dg(bu(t))
    };
    var Cg = function(t) {
        return (J(t) ? yg : bg)(t)
      },
      xg = "[object Map]",
      wg = "[object Set]";
    var Ag = function(t) {
      if (null == t) return 0;
      if (In(t)) return vu(t) ? of (t) : t.length;
      var e = Ss(t);
      return e == xg || e == wg ? t.size : cr(t).length
    };
    var Eg = function(t, e, n) {
        var r = null == t ? 0 : t.length;
        return r ? (n && "number" != typeof n && zn(t, e, n) ? (e = 0, n = r) : (e = null == e ? 0 : ft(e), n =
          void 0 === n ? r : ft(n)), zi(t, e, n)) : []
      },
      Sg = No(function(t, e, n) {
        return t + (n ? "_" : "") + e.toLowerCase()
      });
    var Mg = function(t, e) {
      var n;
      return Wl(t, function(t, r, i) {
        return !(n = e(t, r, i))
      }), !!n
    };
    var kg = function(t, e, n) {
        var r = J(t) ? Ia : Mg;
        return n && zn(t, e, n) && (e = void 0), r(t, Ll(e, 3))
      },
      Og = Fn(function(t, e) {
        if (null == t) return [];
        var n = e.length;
        return n > 1 && zn(t, e[0], e[1]) ? e = [] : n > 2 && zn(e[0], e[1], e[2]) && (e = [e[0]]), Np(t, vi(e,
          1), [])
      }),
      Pg = 4294967294,
      Dg = Math.floor,
      Tg = Math.min;
    var _g = function(t, e, n, r) {
        e = n(e);
        for (var i = 0, o = null == t ? 0 : t.length, s = e != e, a = null === e, l = q(e), c = void 0 === e; i <
          o;) {
          var h = Dg((i + o) / 2),
            u = n(t[h]),
            d = void 0 !== u,
            p = null === u,
            f = u == u,
            g = q(u);
          if (s) var m = r || f;
          else m = c ? f && (r || d) : a ? f && d && (r || !p) : l ? f && d && !p && (r || !g) : !p && !g && (r ?
            u <= e : u < e);
          m ? i = h + 1 : o = h
        }
        return Tg(o, Pg)
      },
      jg = 2147483647;
    var Lg = function(t, e, n) {
      var r = 0,
        i = null == t ? r : t.length;
      if ("number" == typeof e && e == e && i <= jg) {
        for (; r < i;) {
          var o = r + i >>> 1,
            s = t[o];
          null !== s && !q(s) && (n ? s <= e : s < e) ? r = o + 1 : i = o
        }
        return i
      }
      return _g(t, e, vt, n)
    };
    var Ng = function(t, e) {
      return Lg(t, e)
    };
    var Fg = function(t, e, n) {
      return _g(t, e, Ll(n, 2))
    };
    var $g = function(t, e) {
      var n = null == t ? 0 : t.length;
      if (n) {
        var r = Lg(t, e);
        if (r < n && Dn(t[r], e)) return r
      }
      return -1
    };
    var Bg = function(t, e) {
      return Lg(t, e, !0)
    };
    var Ig = function(t, e, n) {
      return _g(t, e, Ll(n, 2), !0)
    };
    var zg = function(t, e) {
      if (null != t && t.length) {
        var n = Lg(t, e, !0) - 1;
        if (Dn(t[n], e)) return n
      }
      return -1
    };
    var Rg = function(t, e) {
      for (var n = -1, r = t.length, i = 0, o = []; ++n < r;) {
        var s = t[n],
          a = e ? e(s) : s;
        if (!n || !Dn(a, l)) {
          var l = a;
          o[i++] = 0 === s ? 0 : s
        }
      }
      return o
    };
    var Vg = function(t) {
      return t && t.length ? Rg(t) : []
    };
    var Hg = function(t, e) {
        return t && t.length ? Rg(t, Ll(e, 2)) : []
      },
      Gg = 4294967295;
    var Ug = function(t, e, n) {
        return n && "number" != typeof n && zn(t, e, n) && (e = n = void 0), (n = void 0 === n ? Gg : n >>> 0) ?
          (t = ai(t)) && ("string" == typeof e || null != e && !Ad(e)) && !(e = tt(e)) && Hi(t) ? Ri(no(t), 0, n) :
          t.split(e, n) : []
      },
      qg = "Expected a function",
      Wg = Math.max;
    var Xg = function(t, e) {
        if ("function" != typeof t) throw new TypeError(qg);
        return e = null == e ? 0 : Wg(ft(e), 0), Fn(function(n) {
          var r = n[e],
            i = Ri(n, 0, e);
          return r && fi(i, r), qt(t, this, i)
        })
      },
      Yg = No(function(t, e, n) {
        return t + (n ? " " : "") + io(e)
      });
    var Jg = function(t, e, n) {
      return t = ai(t), n = null == n ? 0 : qo(ft(n), 0, t.length), e = tt(e), t.slice(n, n + e.length) == e
    };
    var Zg = function() {
      return {}
    };
    var Kg = function() {
      return ""
    };
    var Qg = function() {
        return !0
      },
      tm = et(function(t, e) {
        return t - e
      }, 0);
    var em = function(t) {
      return t && t.length ? ep(t, vt) : 0
    };
    var nm = function(t, e) {
      return t && t.length ? ep(t, Ll(e, 2)) : 0
    };
    var rm = function(t) {
      var e = null == t ? 0 : t.length;
      return e ? zi(t, 1, e) : []
    };
    var im = function(t, e, n) {
      return t && t.length ? (e = n || void 0 === e ? 1 : ft(e), zi(t, 0, e < 0 ? 0 : e)) : []
    };
    var om = function(t, e, n) {
      var r = null == t ? 0 : t.length;
      return r ? (e = n || void 0 === e ? 1 : ft(e), zi(t, (e = r - e) < 0 ? 0 : e, r)) : []
    };
    var sm = function(t, e) {
      return t && t.length ? $c(t, Ll(e, 3), !1, !0) : []
    };
    var am = function(t, e) {
      return t && t.length ? $c(t, Ll(e, 3)) : []
    };
    var lm = function(t, e) {
        return e(t), t
      },
      cm = Object.prototype,
      hm = cm.hasOwnProperty;
    var um = function(t, e, n, r) {
        return void 0 === t || Dn(t, cm[n]) && !hm.call(r, n) ? e : t
      },
      dm = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
    var pm = function(t) {
        return "\\" + dm[t]
      },
      fm = /<%=([\s\S]+?)%>/g,
      gm = {
        escape: /<%-([\s\S]+?)%>/g,
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: fm,
        variable: "",
        imports: {
          _: {
            escape: ih
          }
        }
      },
      mm = /\b__p \+= '';/g,
      vm = /\b(__p \+=) '' \+/g,
      ym = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
      bm = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
      Cm = /($^)/,
      xm = /['\n\r\u2028\u2029\\]/g,
      wm = Object.prototype.hasOwnProperty;
    var Am = function(t, e, n) {
        var r = gm.imports._.templateSettings || gm;
        n && zn(t, e, n) && (e = void 0), t = ai(t), e = yr({}, e, r, um);
        var i, o, s = yr({}, e.imports, r.imports, um),
          a = hr(s),
          l = yu(s, a),
          c = 0,
          h = e.interpolate || Cm,
          u = "__p += '",
          d = RegExp((e.escape || Cm).source + "|" + h.source + "|" + (h === fm ? bm : Cm).source + "|" + (e.evaluate ||
            Cm).source + "|$", "g"),
          p = wm.call(e, "sourceURL") ? "//# sourceURL=" + (e.sourceURL + "").replace(/[\r\n]/g, " ") + "\n" : "";
        t.replace(d, function(e, n, r, s, a, l) {
          return r || (r = s), u += t.slice(c, l).replace(xm, pm), n && (i = !0, u += "' +\n__e(" + n +
            ") +\n'"), a && (o = !0, u += "';\n" + a + ";\n__p += '"), r && (u += "' +\n((__t = (" + r +
            ")) == null ? '' : __t) +\n'"), c = l + e.length, e
        }), u += "';\n";
        var f = wm.call(e, "variable") && e.variable;
        f || (u = "with (obj) {\n" + u + "\n}\n"), u = (o ? u.replace(mm, "") : u).replace(vm, "$1").replace(ym,
            "$1;"), u = "function(" + (f || "obj") + ") {\n" + (f ? "" : "obj || (obj = {});\n") +
          "var __t, __p = ''" + (i ? ", __e = _.escape" : "") + (o ?
            ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + u +
          "return __p\n}";
        var g = _i(function() {
          return Function(a, p + "return " + u).apply(void 0, l)
        });
        if (g.source = u, Ti(g)) throw g;
        return g
      },
      Em = "Expected a function";
    var Sm = function(t, e, n) {
      var r = !0,
        i = !0;
      if ("function" != typeof t) throw new TypeError(Em);
      return rt(n) && (r = "leading" in n ? !!n.leading : r, i = "trailing" in n ? !!n.trailing : i), cc(t, e, {
        leading: r,
        maxWait: e,
        trailing: i
      })
    };
    var Mm = function(t, e) {
        return e(t)
      },
      km = 9007199254740991,
      Om = 4294967295,
      Pm = Math.min;
    var Dm = function(t, e) {
      if ((t = ft(t)) < 1 || t > km) return [];
      var n = Om,
        r = Pm(t, Om);
      e = zc(e), t -= Om;
      for (var i = Gn(r, e); ++n < t;) e(n);
      return i
    };
    var Tm = function() {
      return this
    };
    var _m = function(t, e) {
      var n = t;
      return n instanceof ee && (n = n.value()), so(e, function(t, e) {
        return e.func.apply(e.thisArg, fi([t], e.args))
      }, n)
    };
    var jm = function() {
      return _m(this.__wrapped__, this.__actions__)
    };
    var Lm = function(t) {
      return ai(t).toLowerCase()
    };
    var Nm = function(t) {
        return J(t) ? Y(t, hi) : q(t) ? [t] : ce(si(ai(t)))
      },
      Fm = 9007199254740991;
    var $m = function(t) {
      return t ? qo(ft(t), -Fm, Fm) : 0 === t ? t : 0
    };
    var Bm = function(t) {
      return ai(t).toUpperCase()
    };
    var Im = function(t, e, n) {
      var r = J(t),
        i = r || Object(Zn.a)(t) || rr(t);
      if (e = Ll(e, 4), null == n) {
        var o = t && t.constructor;
        n = i ? r ? new o : [] : rt(t) && At(o) ? Vt(xi(t)) : {}
      }
      return (i ? Oe : Ul)(t, function(t, r, i) {
        return e(n, t, r, i)
      }), n
    };
    var zm = function(t, e) {
      for (var n = t.length; n-- && _e(e, t[n], 0) > -1;);
      return n
    };
    var Rm = function(t, e) {
        for (var n = -1, r = t.length; ++n < r && _e(e, t[n], 0) > -1;);
        return n
      },
      Vm = /^\s+|\s+$/g;
    var Hm = function(t, e, n) {
        if ((t = ai(t)) && (n || void 0 === e)) return t.replace(Vm, "");
        if (!t || !(e = tt(e))) return t;
        var r = no(t),
          i = no(e),
          o = Rm(r, i),
          s = zm(r, i) + 1;
        return Ri(r, o, s).join("")
      },
      Gm = /\s+$/;
    var Um = function(t, e, n) {
        if ((t = ai(t)) && (n || void 0 === e)) return t.replace(Gm, "");
        if (!t || !(e = tt(e))) return t;
        var r = no(t),
          i = zm(r, no(e)) + 1;
        return Ri(r, 0, i).join("")
      },
      qm = /^\s+/;
    var Wm = function(t, e, n) {
        if ((t = ai(t)) && (n || void 0 === e)) return t.replace(qm, "");
        if (!t || !(e = tt(e))) return t;
        var r = no(t),
          i = Rm(r, no(e));
        return Ri(r, i).join("")
      },
      Xm = 30,
      Ym = "...",
      Jm = /\w*$/;
    var Zm = function(t, e) {
      var n = Xm,
        r = Ym;
      if (rt(e)) {
        var i = "separator" in e ? e.separator : i;
        n = "length" in e ? ft(e.length) : n, r = "omission" in e ? tt(e.omission) : r
      }
      var o = (t = ai(t)).length;
      if (Hi(t)) {
        var s = no(t);
        o = s.length
      }
      if (n >= o) return t;
      var a = n - of (r);
      if (a < 1) return r;
      var l = s ? Ri(s, 0, a).join("") : t.slice(0, a);
      if (void 0 === i) return l + r;
      if (s && (a += l.length - a), Ad(i)) {
        if (t.slice(a).search(i)) {
          var c, h = l;
          for (i.global || (i = RegExp(i.source, ai(Jm.exec(i)) + "g")), i.lastIndex = 0; c = i.exec(h);) var u =
            c.index;
          l = l.slice(0, void 0 === u ? a : u)
        }
      } else if (t.indexOf(tt(i), a) != a) {
        var d = l.lastIndexOf(i);
        d > -1 && (l = l.slice(0, d))
      }
      return l + r
    };
    var Km = function(t) {
        return On(t, 1)
      },
      Qm = ao({
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      }),
      tv = /&(?:amp|lt|gt|quot|#39);/g,
      ev = RegExp(tv.source);
    var nv = function(t) {
        return (t = ai(t)) && ev.test(t) ? t.replace(tv, Qm) : t
      },
      rv = ys && 1 / Ua(new ys([, -0]))[1] == 1 / 0 ? function(t) {
        return new ys(t)
      } : ne,
      iv = 200;
    var ov = function(t, e, n) {
        var r = -1,
          i = je,
          o = t.length,
          s = !0,
          a = [],
          l = a;
        if (n) s = !1, i = kc;
        else if (o >= iv) {
          var c = e ? null : rv(t);
          if (c) return Ua(c);
          s = !1, i = za, l = new Ba
        } else l = e ? [] : a;
        t: for (; ++r < o;) {
          var h = t[r],
            u = e ? e(h) : h;
          if (h = n || 0 !== h ? h : 0, s && u == u) {
            for (var d = l.length; d--;)
              if (l[d] === u) continue t;
            e && l.push(u), a.push(h)
          } else i(l, u, n) || (l !== a && l.push(u), a.push(h))
        }
        return a
      },
      sv = Fn(function(t) {
        return ov(vi(t, 1, gc, !0))
      }),
      av = Fn(function(t) {
        var e = Tc(t);
        return gc(e) && (e = void 0), ov(vi(t, 1, gc, !0), Ll(e, 2))
      }),
      lv = Fn(function(t) {
        var e = Tc(t);
        return e = "function" == typeof e ? e : void 0, ov(vi(t, 1, gc, !0), void 0, e)
      });
    var cv = function(t) {
      return t && t.length ? ov(t) : []
    };
    var hv = function(t, e) {
      return t && t.length ? ov(t, Ll(e, 2)) : []
    };
    var uv = function(t, e) {
        return e = "function" == typeof e ? e : void 0, t && t.length ? ov(t, void 0, e) : []
      },
      dv = 0;
    var pv = function(t) {
      var e = ++dv;
      return ai(t) + e
    };
    var fv = function(t, e) {
        return null == t || Ep(t, e)
      },
      gv = Math.max;
    var mv = function(t) {
      if (!t || !t.length) return [];
      var e = 0;
      return t = os(t, function(t) {
        if (gc(t)) return e = gv(t.length, e), !0
      }), Gn(e, function(e) {
        return Y(t, Tl(e))
      })
    };
    var vv = function(t, e) {
      if (!t || !t.length) return [];
      var n = mv(t);
      return null == e ? n : Y(n, function(t) {
        return qt(e, void 0, t)
      })
    };
    var yv = function(t, e, n, r) {
      return kp(t, e, n(ui(t, e)), r)
    };
    var bv = function(t, e, n) {
      return null == t ? t : yv(t, e, zc(n))
    };
    var Cv = function(t, e, n, r) {
        return r = "function" == typeof r ? r : void 0, null == t ? t : yv(t, e, zc(n), r)
      },
      xv = No(function(t, e, n) {
        return t + (n ? " " : "") + e.toUpperCase()
      });
    var wv = function(t) {
        return null == t ? [] : yu(t, mr(t))
      },
      Av = Fn(function(t, e) {
        return gc(t) ? Pc(t, e) : []
      });
    var Ev = function(t, e) {
        return vf(zc(e), t)
      },
      Sv = bi(function(t) {
        var e = t.length,
          n = e ? t[0] : 0,
          r = this.__wrapped__,
          i = function(e) {
            return pi(e, t)
          };
        return !(e > 1 || this.__actions__.length) && r instanceof ee && We(n) ? ((r = r.slice(n, +n + (e ? 1 :
          0))).__actions__.push({
          func: Mm,
          args: [i],
          thisArg: void 0
        }), new le(r, this.__chain__).thru(function(t) {
          return e && !t.length && t.push(void 0), t
        })) : this.thru(i)
      });
    var Mv = function() {
      return Vo(this)
    };
    var kv = function() {
      var t = this.__wrapped__;
      if (t instanceof ee) {
        var e = t;
        return this.__actions__.length && (e = new ee(this)), (e = e.reverse()).__actions__.push({
          func: Mm,
          args: [ag],
          thisArg: void 0
        }), new le(e, this.__chain__)
      }
      return this.thru(ag)
    };
    var Ov = function(t, e, n) {
        var r = t.length;
        if (r < 2) return r ? ov(t[0]) : [];
        for (var i = -1, o = Array(r); ++i < r;)
          for (var s = t[i], a = -1; ++a < r;) a != i && (o[i] = Pc(o[i] || s, t[a], e, n));
        return ov(vi(o, 1), e, n)
      },
      Pv = Fn(function(t) {
        return Ov(os(t, gc))
      }),
      Dv = Fn(function(t) {
        var e = Tc(t);
        return gc(e) && (e = void 0), Ov(os(t, gc), Ll(e, 2))
      }),
      Tv = Fn(function(t) {
        var e = Tc(t);
        return e = "function" == typeof e ? e : void 0, Ov(os(t, gc), void 0, e)
      }),
      _v = Fn(mv);
    var jv = function(t, e, n) {
      for (var r = -1, i = t.length, o = e.length, s = {}; ++r < i;) {
        var a = r < o ? e[r] : void 0;
        n(s, t[r], a)
      }
      return s
    };
    var Lv = function(t, e) {
      return jv(t || [], e || [], _n)
    };
    var Nv = function(t, e) {
        return jv(t || [], e || [], kp)
      },
      Fv = Fn(function(t) {
        var e = t.length,
          n = e > 1 ? t[e - 1] : void 0;
        return n = "function" == typeof n ? (t.pop(), n) : void 0, vv(t, n)
      }),
      $v = {
        chunk: Uo,
        compact: _a,
        concat: ja,
        difference: Dc,
        differenceBy: _c,
        differenceWith: jc,
        drop: Nc,
        dropRight: Fc,
        dropRightWhile: Bc,
        dropWhile: Ic,
        fill: fh,
        findIndex: bh,
        findLastIndex: Sh,
        first: Oh,
        flatten: yi,
        flattenDeep: Fh,
        flattenDepth: $h,
        fromPairs: Qh,
        head: Oh,
        indexOf: Au,
        initial: Eu,
        intersection: Ou,
        intersectionBy: Pu,
        intersectionWith: Du,
        join: Ld,
        last: Tc,
        lastIndexOf: zd,
        nth: wp,
        pull: Pf,
        pullAll: Of,
        pullAllBy: Df,
        pullAllWith: Tf,
        pullAt: Lf,
        remove: tg,
        reverse: ag,
        slice: Eg,
        sortedIndex: Ng,
        sortedIndexBy: Fg,
        sortedIndexOf: $g,
        sortedLastIndex: Bg,
        sortedLastIndexBy: Ig,
        sortedLastIndexOf: zg,
        sortedUniq: Vg,
        sortedUniqBy: Hg,
        tail: rm,
        take: im,
        takeRight: om,
        takeRightWhile: sm,
        takeWhile: am,
        union: sv,
        unionBy: av,
        unionWith: lv,
        uniq: cv,
        uniqBy: hv,
        uniqWith: uv,
        unzip: mv,
        unzipWith: vv,
        without: Av,
        xor: Pv,
        xorBy: Dv,
        xorWith: Tv,
        zip: _v,
        zipObject: Lv,
        zipObjectDeep: Nv,
        zipWith: Fv
      },
      Bv = {
        countBy: Zl,
        each: Rc,
        eachRight: qc,
        every: hh,
        filter: mh,
        find: Ch,
        findLast: Mh,
        flatMap: Th,
        flatMapDeep: jh,
        flatMapDepth: Lh,
        forEach: Rc,
        forEachRight: qc,
        groupBy: iu,
        includes: xu,
        invokeMap: Vu,
        keyBy: Fd,
        map: Dh,
        orderBy: Fp,
        partition: Cf,
        reduce: Jf,
        reduceRight: Kf,
        reject: Qf,
        sample: ug,
        sampleSize: gg,
        shuffle: Cg,
        size: Ag,
        some: kg,
        sortBy: Og
      },
      Iv = {
        now: oc
      },
      zv = {
        after: mt,
        ary: On,
        before: Li,
        bind: Fi,
        bindKey: Ii,
        curry: ec,
        curryRight: ic,
        debounce: cc,
        defer: Sc,
        delay: Mc,
        flip: Ih,
        memoize: ni,
        negate: fp,
        once: Tp,
        overArgs: Rp,
        partial: vf,
        partialRight: bf,
        rearg: Xf,
        rest: ig,
        spread: Xg,
        throttle: Sm,
        unary: Km,
        wrap: Ev
      },
      Rv = {
        castArray: $o,
        clone: wa,
        cloneDeep: Sa,
        cloneDeepWith: Oa,
        cloneWith: Da,
        conformsTo: Rl,
        eq: Dn,
        gt: au,
        gte: lu,
        isArguments: Jn,
        isArray: J,
        isArrayBuffer: qu,
        isArrayLike: In,
        isArrayLikeObject: gc,
        isBoolean: Xu,
        isBuffer: Zn.a,
        isDate: Ku,
        isElement: Qu,
        isEmpty: rd,
        isEqual: id,
        isEqualWith: od,
        isError: Ti,
        isFinite: ad,
        isFunction: At,
        isInteger: ld,
        isLength: Bn,
        isMap: aa,
        isMatch: cd,
        isMatchWith: hd,
        isNaN: pd,
        isNative: vd,
        isNil: yd,
        isNull: bd,
        isNumber: dd,
        isObject: rt,
        isObjectLike: G,
        isPlainObject: Oi,
        isRegExp: Ad,
        isSafeInteger: Sd,
        isSet: ua,
        isString: vu,
        isSymbol: q,
        isTypedArray: rr,
        isUndefined: Md,
        isWeakMap: Od,
        isWeakSet: Dd,
        lt: Gd,
        lte: Ud,
        toArray: bp,
        toFinite: pt,
        toInteger: ft,
        toLength: dh,
        toNumber: ht,
        toPlainObject: vc,
        toSafeInteger: $m,
        toString: ai
      },
      Vv = {
        add: nt,
        ceil: Ro,
        divide: Lc,
        floor: zh,
        max: Qd,
        maxBy: tp,
        mean: ip,
        meanBy: op,
        min: cp,
        minBy: hp,
        multiply: dp,
        round: lg,
        subtract: tm,
        sum: em,
        sumBy: nm
      },
      Hv = {
        clamp: Wo,
        inRange: gu,
        random: Rf
      },
      Gv = {
        assign: dr,
        assignIn: vr,
        assignInWith: yr,
        assignWith: br,
        at: Ci,
        create: Kl,
        defaults: pc,
        defaultsDeep: wc,
        entries: Qc,
        entriesIn: th,
        extend: vr,
        extendWith: yr,
        findKey: wh,
        findLastKey: kh,
        forIn: Yh,
        forInRight: Jh,
        forOwn: Zh,
        forOwnRight: Kh,
        functions: eu,
        functionsIn: nu,
        get: di,
        has: uu,
        hasIn: kl,
        invert: Lu,
        invertBy: Bu,
        invoke: Ru,
        keys: hr,
        keysIn: mr,
        mapKeys: qd,
        mapValues: Wd,
        merge: sp,
        mergeWith: xc,
        omit: Mp,
        omitBy: Dp,
        pick: wf,
        pickBy: Pp,
        result: og,
        set: mg,
        setWith: vg,
        toPairs: Qc,
        toPairsIn: th,
        transform: Im,
        unset: fv,
        update: bv,
        updateWith: Cv,
        values: bu,
        valuesIn: wv
      },
      Uv = {
        at: Sv,
        chain: Vo,
        commit: Ta,
        lodash: pe,
        next: Cp,
        plant: Af,
        reverse: kv,
        tap: lm,
        thru: Mm,
        toIterator: Tm,
        toJSON: jm,
        value: jm,
        valueOf: jm,
        wrapperChain: Mv
      },
      qv = {
        camelCase: Fo,
        capitalize: oo,
        deburr: uo,
        endsWith: Wc,
        escape: ih,
        escapeRegExp: ah,
        kebabCase: Nd,
        lowerCase: Rd,
        lowerFirst: Vd,
        pad: hf,
        padEnd: uf,
        padStart: df,
        parseInt: gf,
        repeat: eg,
        replace: ng,
        snakeCase: Sg,
        split: Ug,
        startCase: Yg,
        startsWith: Jg,
        template: Am,
        templateSettings: gm,
        toLower: Lm,
        toUpper: Bm,
        trim: Hm,
        trimEnd: Um,
        trimStart: Wm,
        truncate: Zm,
        unescape: nv,
        upperCase: xv,
        upperFirst: io,
        words: jo
      },
      Wv = {
        attempt: _i,
        bindAll: $i,
        cond: Fl,
        conforms: zl,
        constant: Se,
        defaultTo: hc,
        flow: Wh,
        flowRight: Xh,
        identity: vt,
        iteratee: _d,
        matches: Yd,
        matchesProperty: Zd,
        method: ap,
        methodOf: lp,
        mixin: up,
        noop: ne,
        nthArg: Ap,
        over: Bp,
        overEvery: Vp,
        overSome: Hp,
        property: jl,
        propertyOf: Ef,
        range: qf,
        rangeRight: Wf,
        stubArray: ss,
        stubFalse: fd.a,
        stubObject: Zg,
        stubString: Kg,
        stubTrue: Qg,
        times: Dm,
        toPath: Nm,
        uniqueId: pv
      };
    var Xv = function() {
      var t = new ee(this.__wrapped__);
      return t.__actions__ = ce(this.__actions__), t.__dir__ = this.__dir__, t.__filtered__ = this.__filtered__,
        t.__iteratees__ = ce(this.__iteratees__), t.__takeCount__ = this.__takeCount__, t.__views__ = ce(this.__views__),
        t
    };
    var Yv = function() {
        if (this.__filtered__) {
          var t = new ee(this);
          t.__dir__ = -1, t.__filtered__ = !0
        } else(t = this.clone()).__dir__ *= -1;
        return t
      },
      Jv = Math.max,
      Zv = Math.min;
    var Kv = function(t, e, n) {
        for (var r = -1, i = n.length; ++r < i;) {
          var o = n[r],
            s = o.size;
          switch (o.type) {
            case "drop":
              t += s;
              break;
            case "dropRight":
              e -= s;
              break;
            case "take":
              e = Zv(e, t + s);
              break;
            case "takeRight":
              t = Jv(t, e - s)
          }
        }
        return {
          start: t,
          end: e
        }
      },
      Qv = 1,
      ty = 2,
      ey = Math.min;
    var ny, ry, iy = function() {
        var t = this.__wrapped__.value(),
          e = this.__dir__,
          n = J(t),
          r = e < 0,
          i = n ? t.length : 0,
          o = Kv(0, i, this.__views__),
          s = o.start,
          a = o.end,
          l = a - s,
          c = r ? a : s - 1,
          h = this.__iteratees__,
          u = h.length,
          d = 0,
          p = ey(l, this.__takeCount__);
        if (!n || !r && i == l && p == l) return _m(t, this.__actions__);
        var f = [];
        t: for (; l-- && d < p;) {
          for (var g = -1, m = t[c += e]; ++g < u;) {
            var v = h[g],
              y = v.iteratee,
              b = v.type,
              C = y(m);
            if (b == ty) m = C;
            else if (!C) {
              if (b == Qv) continue t;
              break t
            }
          }
          f[d++] = m
        }
        return f
      },
      oy = Array.prototype,
      sy = Object.prototype.hasOwnProperty,
      ay = _ ? _.iterator : void 0,
      ly = Math.max,
      cy = Math.min,
      hy = (ny = up, function(t, e, n) {
        if (null == n) {
          var r = rt(e),
            i = r && hr(e),
            o = i && i.length && tu(e, i);
          (o ? o.length : r) || (n = e, e = t, t = this)
        }
        return ny(t, e, n)
      });
    /**
     * @license
     * Lodash (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="es" -o ./`
     * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */
    pe.after = zv.after, pe.ary = zv.ary, pe.assign = Gv.assign, pe.assignIn = Gv.assignIn, pe.assignInWith = Gv.assignInWith,
      pe.assignWith = Gv.assignWith, pe.at = Gv.at, pe.before = zv.before, pe.bind = zv.bind, pe.bindAll = Wv.bindAll,
      pe.bindKey = zv.bindKey, pe.castArray = Rv.castArray, pe.chain = Uv.chain, pe.chunk = $v.chunk, pe.compact =
      $v.compact, pe.concat = $v.concat, pe.cond = Wv.cond, pe.conforms = Wv.conforms, pe.constant = Wv.constant,
      pe.countBy = Bv.countBy, pe.create = Gv.create, pe.curry = zv.curry, pe.curryRight = zv.curryRight, pe.debounce =
      zv.debounce, pe.defaults = Gv.defaults, pe.defaultsDeep = Gv.defaultsDeep, pe.defer = zv.defer, pe.delay =
      zv.delay, pe.difference = $v.difference, pe.differenceBy = $v.differenceBy, pe.differenceWith = $v.differenceWith,
      pe.drop = $v.drop, pe.dropRight = $v.dropRight, pe.dropRightWhile = $v.dropRightWhile, pe.dropWhile = $v.dropWhile,
      pe.fill = $v.fill, pe.filter = Bv.filter, pe.flatMap = Bv.flatMap, pe.flatMapDeep = Bv.flatMapDeep, pe.flatMapDepth =
      Bv.flatMapDepth, pe.flatten = $v.flatten, pe.flattenDeep = $v.flattenDeep, pe.flattenDepth = $v.flattenDepth,
      pe.flip = zv.flip, pe.flow = Wv.flow, pe.flowRight = Wv.flowRight, pe.fromPairs = $v.fromPairs, pe.functions =
      Gv.functions, pe.functionsIn = Gv.functionsIn, pe.groupBy = Bv.groupBy, pe.initial = $v.initial, pe.intersection =
      $v.intersection, pe.intersectionBy = $v.intersectionBy, pe.intersectionWith = $v.intersectionWith, pe.invert =
      Gv.invert, pe.invertBy = Gv.invertBy, pe.invokeMap = Bv.invokeMap, pe.iteratee = Wv.iteratee, pe.keyBy = Bv
      .keyBy, pe.keys = hr, pe.keysIn = Gv.keysIn, pe.map = Bv.map, pe.mapKeys = Gv.mapKeys, pe.mapValues = Gv.mapValues,
      pe.matches = Wv.matches, pe.matchesProperty = Wv.matchesProperty, pe.memoize = zv.memoize, pe.merge = Gv.merge,
      pe.mergeWith = Gv.mergeWith, pe.method = Wv.method, pe.methodOf = Wv.methodOf, pe.mixin = hy, pe.negate =
      fp, pe.nthArg = Wv.nthArg, pe.omit = Gv.omit, pe.omitBy = Gv.omitBy, pe.once = zv.once, pe.orderBy = Bv.orderBy,
      pe.over = Wv.over, pe.overArgs = zv.overArgs, pe.overEvery = Wv.overEvery, pe.overSome = Wv.overSome, pe.partial =
      zv.partial, pe.partialRight = zv.partialRight, pe.partition = Bv.partition, pe.pick = Gv.pick, pe.pickBy =
      Gv.pickBy, pe.property = Wv.property, pe.propertyOf = Wv.propertyOf, pe.pull = $v.pull, pe.pullAll = $v.pullAll,
      pe.pullAllBy = $v.pullAllBy, pe.pullAllWith = $v.pullAllWith, pe.pullAt = $v.pullAt, pe.range = Wv.range,
      pe.rangeRight = Wv.rangeRight, pe.rearg = zv.rearg, pe.reject = Bv.reject, pe.remove = $v.remove, pe.rest =
      zv.rest, pe.reverse = $v.reverse, pe.sampleSize = Bv.sampleSize, pe.set = Gv.set, pe.setWith = Gv.setWith,
      pe.shuffle = Bv.shuffle, pe.slice = $v.slice, pe.sortBy = Bv.sortBy, pe.sortedUniq = $v.sortedUniq, pe.sortedUniqBy =
      $v.sortedUniqBy, pe.split = qv.split, pe.spread = zv.spread, pe.tail = $v.tail, pe.take = $v.take, pe.takeRight =
      $v.takeRight, pe.takeRightWhile = $v.takeRightWhile, pe.takeWhile = $v.takeWhile, pe.tap = Uv.tap, pe.throttle =
      zv.throttle, pe.thru = Mm, pe.toArray = Rv.toArray, pe.toPairs = Gv.toPairs, pe.toPairsIn = Gv.toPairsIn,
      pe.toPath = Wv.toPath, pe.toPlainObject = Rv.toPlainObject, pe.transform = Gv.transform, pe.unary = zv.unary,
      pe.union = $v.union, pe.unionBy = $v.unionBy, pe.unionWith = $v.unionWith, pe.uniq = $v.uniq, pe.uniqBy =
      $v.uniqBy, pe.uniqWith = $v.uniqWith, pe.unset = Gv.unset, pe.unzip = $v.unzip, pe.unzipWith = $v.unzipWith,
      pe.update = Gv.update, pe.updateWith = Gv.updateWith, pe.values = Gv.values, pe.valuesIn = Gv.valuesIn, pe.without =
      $v.without, pe.words = qv.words, pe.wrap = zv.wrap, pe.xor = $v.xor, pe.xorBy = $v.xorBy, pe.xorWith = $v.xorWith,
      pe.zip = $v.zip, pe.zipObject = $v.zipObject, pe.zipObjectDeep = $v.zipObjectDeep, pe.zipWith = $v.zipWith,
      pe.entries = Gv.toPairs, pe.entriesIn = Gv.toPairsIn, pe.extend = Gv.assignIn, pe.extendWith = Gv.assignInWith,
      hy(pe, pe), pe.add = Vv.add, pe.attempt = Wv.attempt, pe.camelCase = qv.camelCase, pe.capitalize = qv.capitalize,
      pe.ceil = Vv.ceil, pe.clamp = Hv.clamp, pe.clone = Rv.clone, pe.cloneDeep = Rv.cloneDeep, pe.cloneDeepWith =
      Rv.cloneDeepWith, pe.cloneWith = Rv.cloneWith, pe.conformsTo = Rv.conformsTo, pe.deburr = qv.deburr, pe.defaultTo =
      Wv.defaultTo, pe.divide = Vv.divide, pe.endsWith = qv.endsWith, pe.eq = Rv.eq, pe.escape = qv.escape, pe.escapeRegExp =
      qv.escapeRegExp, pe.every = Bv.every, pe.find = Bv.find, pe.findIndex = $v.findIndex, pe.findKey = Gv.findKey,
      pe.findLast = Bv.findLast, pe.findLastIndex = $v.findLastIndex, pe.findLastKey = Gv.findLastKey, pe.floor =
      Vv.floor, pe.forEach = Bv.forEach, pe.forEachRight = Bv.forEachRight, pe.forIn = Gv.forIn, pe.forInRight =
      Gv.forInRight, pe.forOwn = Gv.forOwn, pe.forOwnRight = Gv.forOwnRight, pe.get = Gv.get, pe.gt = Rv.gt, pe.gte =
      Rv.gte, pe.has = Gv.has, pe.hasIn = Gv.hasIn, pe.head = $v.head, pe.identity = vt, pe.includes = Bv.includes,
      pe.indexOf = $v.indexOf, pe.inRange = Hv.inRange, pe.invoke = Gv.invoke, pe.isArguments = Rv.isArguments,
      pe.isArray = J, pe.isArrayBuffer = Rv.isArrayBuffer, pe.isArrayLike = Rv.isArrayLike, pe.isArrayLikeObject =
      Rv.isArrayLikeObject, pe.isBoolean = Rv.isBoolean, pe.isBuffer = Rv.isBuffer, pe.isDate = Rv.isDate, pe.isElement =
      Rv.isElement, pe.isEmpty = Rv.isEmpty, pe.isEqual = Rv.isEqual, pe.isEqualWith = Rv.isEqualWith, pe.isError =
      Rv.isError, pe.isFinite = Rv.isFinite, pe.isFunction = Rv.isFunction, pe.isInteger = Rv.isInteger, pe.isLength =
      Rv.isLength, pe.isMap = Rv.isMap, pe.isMatch = Rv.isMatch, pe.isMatchWith = Rv.isMatchWith, pe.isNaN = Rv.isNaN,
      pe.isNative = Rv.isNative, pe.isNil = Rv.isNil, pe.isNull = Rv.isNull, pe.isNumber = Rv.isNumber, pe.isObject =
      rt, pe.isObjectLike = Rv.isObjectLike, pe.isPlainObject = Rv.isPlainObject, pe.isRegExp = Rv.isRegExp, pe.isSafeInteger =
      Rv.isSafeInteger, pe.isSet = Rv.isSet, pe.isString = Rv.isString, pe.isSymbol = Rv.isSymbol, pe.isTypedArray =
      Rv.isTypedArray, pe.isUndefined = Rv.isUndefined, pe.isWeakMap = Rv.isWeakMap, pe.isWeakSet = Rv.isWeakSet,
      pe.join = $v.join, pe.kebabCase = qv.kebabCase, pe.last = Tc, pe.lastIndexOf = $v.lastIndexOf, pe.lowerCase =
      qv.lowerCase, pe.lowerFirst = qv.lowerFirst, pe.lt = Rv.lt, pe.lte = Rv.lte, pe.max = Vv.max, pe.maxBy = Vv
      .maxBy, pe.mean = Vv.mean, pe.meanBy = Vv.meanBy, pe.min = Vv.min, pe.minBy = Vv.minBy, pe.stubArray = Wv.stubArray,
      pe.stubFalse = Wv.stubFalse, pe.stubObject = Wv.stubObject, pe.stubString = Wv.stubString, pe.stubTrue = Wv
      .stubTrue, pe.multiply = Vv.multiply, pe.nth = $v.nth, pe.noop = Wv.noop, pe.now = Iv.now, pe.pad = qv.pad,
      pe.padEnd = qv.padEnd, pe.padStart = qv.padStart, pe.parseInt = qv.parseInt, pe.random = Hv.random, pe.reduce =
      Bv.reduce, pe.reduceRight = Bv.reduceRight, pe.repeat = qv.repeat, pe.replace = qv.replace, pe.result = Gv.result,
      pe.round = Vv.round, pe.sample = Bv.sample, pe.size = Bv.size, pe.snakeCase = qv.snakeCase, pe.some = Bv.some,
      pe.sortedIndex = $v.sortedIndex, pe.sortedIndexBy = $v.sortedIndexBy, pe.sortedIndexOf = $v.sortedIndexOf,
      pe.sortedLastIndex = $v.sortedLastIndex, pe.sortedLastIndexBy = $v.sortedLastIndexBy, pe.sortedLastIndexOf =
      $v.sortedLastIndexOf, pe.startCase = qv.startCase, pe.startsWith = qv.startsWith, pe.subtract = Vv.subtract,
      pe.sum = Vv.sum, pe.sumBy = Vv.sumBy, pe.template = qv.template, pe.times = Wv.times, pe.toFinite = Rv.toFinite,
      pe.toInteger = ft, pe.toLength = Rv.toLength, pe.toLower = qv.toLower, pe.toNumber = Rv.toNumber, pe.toSafeInteger =
      Rv.toSafeInteger, pe.toString = Rv.toString, pe.toUpper = qv.toUpper, pe.trim = qv.trim, pe.trimEnd = qv.trimEnd,
      pe.trimStart = qv.trimStart, pe.truncate = qv.truncate, pe.unescape = qv.unescape, pe.uniqueId = Wv.uniqueId,
      pe.upperCase = qv.upperCase, pe.upperFirst = qv.upperFirst, pe.each = Bv.forEach, pe.eachRight = Bv.forEachRight,
      pe.first = $v.head, hy(pe, (ry = {}, Ul(pe, function(t, e) {
        sy.call(pe.prototype, e) || (ry[e] = t)
      }), ry), {
        chain: !1
      }), pe.VERSION = "4.17.15", (pe.templateSettings = qv.templateSettings).imports._ = pe, Oe(["bind",
        "bindKey", "curry", "curryRight", "partial", "partialRight"
      ], function(t) {
        pe[t].placeholder = pe
      }), Oe(["drop", "take"], function(t, e) {
        ee.prototype[t] = function(n) {
          n = void 0 === n ? 1 : ly(ft(n), 0);
          var r = this.__filtered__ && !e ? new ee(this) : this.clone();
          return r.__filtered__ ? r.__takeCount__ = cy(n, r.__takeCount__) : r.__views__.push({
            size: cy(n, 4294967295),
            type: t + (r.__dir__ < 0 ? "Right" : "")
          }), r
        }, ee.prototype[t + "Right"] = function(e) {
          return this.reverse()[t](e).reverse()
        }
      }), Oe(["filter", "map", "takeWhile"], function(t, e) {
        var n = e + 1,
          r = 1 == n || 3 == n;
        ee.prototype[t] = function(t) {
          var e = this.clone();
          return e.__iteratees__.push({
            iteratee: Ll(t, 3),
            type: n
          }), e.__filtered__ = e.__filtered__ || r, e
        }
      }), Oe(["head", "last"], function(t, e) {
        var n = "take" + (e ? "Right" : "");
        ee.prototype[t] = function() {
          return this[n](1).value()[0]
        }
      }), Oe(["initial", "tail"], function(t, e) {
        var n = "drop" + (e ? "" : "Right");
        ee.prototype[t] = function() {
          return this.__filtered__ ? new ee(this) : this[n](1)
        }
      }), ee.prototype.compact = function() {
        return this.filter(vt)
      }, ee.prototype.find = function(t) {
        return this.filter(t).head()
      }, ee.prototype.findLast = function(t) {
        return this.reverse().find(t)
      }, ee.prototype.invokeMap = Fn(function(t, e) {
        return "function" == typeof t ? new ee(this) : this.map(function(n) {
          return zu(n, t, e)
        })
      }), ee.prototype.reject = function(t) {
        return this.filter(fp(Ll(t)))
      }, ee.prototype.slice = function(t, e) {
        t = ft(t);
        var n = this;
        return n.__filtered__ && (t > 0 || e < 0) ? new ee(n) : (t < 0 ? n = n.takeRight(-t) : t && (n = n.drop(t)),
          void 0 !== e && (n = (e = ft(e)) < 0 ? n.dropRight(-e) : n.take(e - t)), n)
      }, ee.prototype.takeRightWhile = function(t) {
        return this.reverse().takeWhile(t).reverse()
      }, ee.prototype.toArray = function() {
        return this.take(4294967295)
      }, Ul(ee.prototype, function(t, e) {
        var n = /^(?:filter|find|map|reject)|While$/.test(e),
          r = /^(?:head|last)$/.test(e),
          i = pe[r ? "take" + ("last" == e ? "Right" : "") : e],
          o = r || /^find/.test(e);
        i && (pe.prototype[e] = function() {
          var e = this.__wrapped__,
            s = r ? [1] : arguments,
            a = e instanceof ee,
            l = s[0],
            c = a || J(e),
            h = function(t) {
              var e = i.apply(pe, fi([t], s));
              return r && u ? e[0] : e
            };
          c && n && "function" == typeof l && 1 != l.length && (a = c = !1);
          var u = this.__chain__,
            d = !!this.__actions__.length,
            p = o && !u,
            f = a && !d;
          if (!o && c) {
            e = f ? e : new ee(this);
            var g = t.apply(e, s);
            return g.__actions__.push({
              func: Mm,
              args: [h],
              thisArg: void 0
            }), new le(g, u)
          }
          return p && f ? t.apply(this, s) : (g = this.thru(h), p ? r ? g.value()[0] : g.value() : g)
        })
      }), Oe(["pop", "push", "shift", "sort", "splice", "unshift"], function(t) {
        var e = oy[t],
          n = /^(?:push|sort|unshift)$/.test(t) ? "tap" : "thru",
          r = /^(?:pop|shift)$/.test(t);
        pe.prototype[t] = function() {
          var t = arguments;
          if (r && !this.__chain__) {
            var i = this.value();
            return e.apply(J(i) ? i : [], t)
          }
          return this[n](function(n) {
            return e.apply(J(n) ? n : [], t)
          })
        }
      }), Ul(ee.prototype, function(t, e) {
        var n = pe[e];
        if (n) {
          var r = n.name + "";
          sy.call(ie, r) || (ie[r] = []), ie[r].push({
            name: e,
            func: n
          })
        }
      }), ie[on(void 0, 2).name] = [{
        name: "wrapper",
        func: void 0
      }], ee.prototype.clone = Xv, ee.prototype.reverse = Yv, ee.prototype.value = iy, pe.prototype.at = Uv.at,
      pe.prototype.chain = Uv.wrapperChain, pe.prototype.commit = Uv.commit, pe.prototype.next = Uv.next, pe.prototype
      .plant = Uv.plant, pe.prototype.reverse = Uv.reverse, pe.prototype.toJSON = pe.prototype.valueOf = pe.prototype
      .value = Uv.value, pe.prototype.first = pe.prototype.head, ay && (pe.prototype[ay] = Uv.toIterator);
    /**
     * @license
     * Lodash (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="es" -o ./`
     * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */
    const uy = t => t && t === t.window,
      dy = t => !Array.isArray(t) && t - parseFloat(t) + 1 >= 0;

    function py(t, ...e) {
      e.forEach(e => {
        Object.getOwnPropertyNames(e.prototype).forEach(n => {
          "constructor" !== n && Object.defineProperty(t.prototype, n, Object.getOwnPropertyDescriptor(e.prototype,
            n))
        })
      })
    }
    const fy = Object.setPrototypeOf || {
      __proto__: []
    }
    instanceof Array && function(t, e) {
      t.__proto__ = e
    } || function(t, e) {
      for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
    };

    function gy(t, e) {
      function n() {
        this.constructor = t
      }
      fy(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
    }
    const my = /^\s*class\s+/.test(`${class{}}`) || /^\s*class\s*\{/.test(`${class{}}`);

    function vy(t, e) {
      const n = new Function("base",
        `\n      return ${my}\n        ? class ${t} extends base { }\n        : function ${t}() { return base.apply(this, arguments) }\n    `
      )(e);
      return my || gy(n, e), n
    }

    function yy(t, e) {
      return null != t ? t : e
    }

    function by(t, e, n) {
      const r = null != t ? t[e] : null;
      return void 0 !== n ? yy(r, n) : r
    }

    function Cy(t, e, n) {
      let r = null != t ? t[e] : null;
      return null == r ? n : (r = +r, isNaN(r) || !isFinite(r) ? n : r)
    }

    function xy(t, e, n) {
      const r = null != t ? t[e] : null;
      return null == r ? n : !!r
    }

    function wy(t, e, n = "/") {
      let r;
      const i = Array.isArray(e) ? e : e.split(n);
      if (i.length)
        for (r = t; i.length;) {
          const t = i.shift();
          if (!(Object(r) === r && t && t in r)) return;
          r = r[t]
        }
      return r
    }

    function Ay(t, e, n, r = "/") {
      const i = Array.isArray(e) ? e : e.split(r),
        o = i.pop();
      if (o) {
        let e = t;
        i.forEach(t => {
          null == e[t] && (e[t] = {}), e = e[t]
        }), e[o] = n
      }
      return t
    }

    function Ey(t, e, n = "/") {
      const r = Array.isArray(e) ? e.slice() : e.split(n),
        i = r.pop();
      if (i)
        if (r.length > 0) {
          const e = wy(t, r);
          e && delete e[i]
        } else delete t[i];
      return t
    }

    function Sy(t, e = "/", n) {
      const r = {};
      Object.keys(t).forEach(i => {
        const o = t[i];
        let s = "object" == typeof o || Array.isArray(o);
        if (s && n && n(o) && (s = !1), s) {
          const t = Sy(o, e, n);
          Object.keys(t).forEach(n => {
            r[i + e + n] = t[n]
          })
        } else r[i] = o
      });
      for (const e in t) t.hasOwnProperty(e);
      return r
    }

    function My(t) {
      let e = null;
      try {
        e = window.eval(t)
      } catch (t) {}
      return e
    }

    function ky(t) {
      return Yg(Fo(t)).replace(/ /g, "")
    }

    function Oy(t) {
      return xv(t).replace(/ /g, "_")
    }

    function Py(t) {
      return Rd(t).replace(/ /g, ".")
    }

    function Dy(t) {
      return Rd(t).replace(/ /g, "/")
    }

    function Ty(t) {
      return io(Rd(t))
    }

    function _y(t) {
      return Yg(Fo(t))
    }

    function jy(t) {
      let e = 2166136261,
        n = !1,
        r = t;
      for (let t = 0, i = r.length; t < i; t += 1) {
        let i = r.charCodeAt(t);
        i > 127 && !n && (i = (r = unescape(encodeURIComponent(r))).charCodeAt(t), n = !0), e ^= i, e += (e << 1) +
          (e << 4) + (e << 7) + (e << 8) + (e << 24)
      }
      return e >>> 0
    }

    function Ly() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, t => {
        const e = 16 * Math.random() | 0;
        return ("x" === t ? e : 3 & e | 8).toString(16)
      })
    }

    function Ny(t, e = {}) {
      const n = P.a.parseHTML(t, null, !1);
      return n.forEach(t => {
        const e = t;
        if (e) {
          const t = e.attributes;
          if (t)
            for (let n = 0, r = t.length; n < r; n += 1) {
              const r = t.item(n);
              if (r) {
                const t = r.value.toLowerCase(),
                  n = r.name.toLowerCase();
                (n.startsWith("on") || t.startsWith("javascript:") || t.startsWith("data:") || t.startsWith(
                  "vbscript:")) && e.removeAttribute(n)
              }
            }
        }
      }), e.raw ? n : P()("<div/>").append(n).html()
    }

    function Fy(t, e, n) {
      const r = Math.min(2, Math.floor(.34 * t.length));
      let i, o = Math.floor(.4 * t.length) + 1,
        s = !1;
      const a = t.toLowerCase();
      for (const l of e) {
        const e = n(l);
        if (void 0 !== e && Math.abs(e.length - a.length) <= r) {
          const n = e.toLowerCase();
          if (n === a) {
            if (e === t) continue;
            return l
          }
          if (s) continue;
          if (e.length < 3) continue;
          const r = $y(a, n, o - 1);
          if (void 0 === r) continue;
          r < 3 ? (s = !0, i = l) : (o = r, i = l)
        }
      }
      return i
    }

    function $y(t, e, n) {
      let r = new Array(e.length + 1),
        i = new Array(e.length + 1);
      const o = n + 1;
      for (let t = 0; t <= e.length; t += 1) r[t] = t;
      for (let s = 1; s <= t.length; s += 1) {
        const a = t.charCodeAt(s - 1),
          l = s > n ? s - n : 1,
          c = e.length > n + s ? n + s : e.length;
        i[0] = s;
        let h = s;
        for (let t = 1; t < l; t += 1) i[t] = o;
        for (let t = l; t <= c; t += 1) {
          const n = a === e.charCodeAt(t - 1) ? r[t - 1] : Math.min(r[t] + 1, i[t - 1] + 1, r[t - 1] + 2);
          i[t] = n, h = Math.min(h, n)
        }
        for (let t = c + 1; t <= e.length; t += 1) i[t] = o;
        if (h > n) return;
        const u = r;
        r = i, i = u
      }
      const s = r[e.length];
      return s > n ? void 0 : s
    }

    function By(t, e) {
      return (t % e + e) % e
    }

    function Iy(t, e) {
      if (null == e) e = null == t ? 1 : t, t = 0;
      else if (e < t) {
        const n = t;
        t = e, e = n
      }
      return Math.floor(Math.random() * (e - t + 1) + t)
    }

    function zy(t) {
      return "string" == typeof t && "%" === t.slice(-1)
    }

    function Ry(t, e) {
      if (null == t) return 0;
      let n;
      if ("string" == typeof t) {
        if (n = parseFloat(t), zy(t) && (n /= 100, isFinite(n))) return n * e
      } else n = t;
      return isFinite(n) ? n > 0 && n < 1 ? n * e : n : 0
    }

    function Vy(t, e) {
      const n = parseFloat(t);
      if (Number.isNaN(n)) return null;
      let r;
      if (null == e) r = "[A-Za-z]*";
      else if (Array.isArray(e)) {
        if (0 === e.length) return null;
        r = e.join("|")
      } else "string" == typeof e && (r = e);
      const i = function(e) {
        const n = new RegExp(`(?:\\d+(?:\\.\\d+)*)(${e})$`).exec(t);
        return n ? n[1] : null
      }(r);
      return null === i ? null : {
        unit: i,
        value: n
      }
    }

    function Hy(t) {
      if ("object" == typeof t) {
        let e = 0,
          n = 0,
          r = 0,
          i = 0;
        return null != t.vertical && isFinite(t.vertical) && (n = i = t.vertical), null != t.horizontal &&
          isFinite(t.horizontal) && (r = e = t.horizontal), null != t.left && isFinite(t.left) && (e = t.left),
          null != t.top && isFinite(t.top) && (n = t.top), null != t.right && isFinite(t.right) && (r = t.right),
          null != t.bottom && isFinite(t.bottom) && (i = t.bottom), {
            top: n,
            right: r,
            bottom: i,
            left: e
          }
      }
      let e = 0;
      return null != t && isFinite(t) && (e = t), {
        top: e,
        right: e,
        bottom: e,
        left: e
      }
    }

    function Gy(t, e, n) {
      if (n) switch (n.length) {
        case 0:
          return t.call(e);
        case 1:
          return t.call(e, n[0]);
        case 2:
          return t.call(e, n[0], n[1]);
        case 3:
          return t.call(e, n[0], n[1], n[2]);
        case 4:
          return t.call(e, n[0], n[1], n[2], n[3]);
        case 5:
          return t.call(e, n[0], n[1], n[2], n[3], n[4]);
        case 6:
          return t.call(e, n[0], n[1], n[2], n[3], n[4], n[5]);
        default:
          return t.apply(e, n)
      }
      return t.call(e)
    }

    function Uy(t, e, ...n) {
      return Gy(t, e, n)
    }

    function qy(t, e, n) {
      const r = [],
        i = {};
      return (...o) => {
        let s = !1;
        const a = o.join("␀");
        return a in i ? (s = !0, function(t, e) {
          for (let n = 0, r = t.length; n < r; n += 1)
            if (t[n] === e) return t.push(t.splice(n, 1)[0])
        }(r, a)) : (r.length >= 1e3 && delete i[r.shift()], r.push(a), i[a] = Gy(t, e || null, o)), n ? n(i[a],
          s) : i[a]
      }
    }

    function Wy(t) {
      return "object" == typeof t && t.then && "function" == typeof t.then
    }

    function Xy(t) {
      return null != t && (t instanceof Promise || Wy(t))
    }

    function Yy(...t) {
      const e = [];
      if (t.forEach(t => {
          Array.isArray(t) ? e.push(...t) : e.push(t)
        }), e.some(t => Xy(t))) {
        const t = e.map(t => Xy(t) ? t : Promise.resolve(!1 !== t));
        return Promise.all(t).then(t => t.reduce((t, e) => !1 !== e && t, !0))
      }
      return e.every(t => !1 !== t)
    }

    function Jy(...t) {
      const e = Yy(t);
      return "boolean" == typeof e ? Promise.resolve(e) : e
    }
    const Zy = /[\t\r\n\f]/g,
      Ky = /\S+/g,
      Qy = t => ` ${t} `;

    function tb(t) {
      return t && t.getAttribute && t.getAttribute("class") || ""
    }

    function eb(t, e) {
      if (null == t || null == e) return !1;
      const n = Qy(tb(t)),
        r = Qy(e);
      return 1 === t.nodeType && n.replace(Zy, " ").includes(r)
    }

    function nb(t, e) {
      if (null != t && null != e) {
        if ("function" == typeof e) return nb(t, e(tb(t)));
        if ("string" == typeof e && 1 === t.nodeType) {
          const n = e.match(Ky) || [],
            r = Qy(tb(t)).replace(Zy, " ");
          let i = n.reduce((t, e) => t.indexOf(Qy(e)) < 0 ? `${t}${e} ` : t, r);
          r !== (i = i.trim()) && t.setAttribute("class", i)
        }
      }
    }

    function rb(t, e) {
      if (null != t) {
        if ("function" == typeof e) return rb(t, e(tb(t)));
        if ((!e || "string" == typeof e) && 1 === t.nodeType) {
          const n = (e || "").match(Ky) || [],
            r = Qy(tb(t)).replace(Zy, " ");
          let i = n.reduce((t, e) => {
            const n = Qy(e);
            return t.indexOf(n) > -1 ? t.replace(n, " ") : t
          }, r);
          r !== (i = e ? i.trim() : "") && t.setAttribute("class", i)
        }
      }
    }

    function ib(t, e, n) {
      if (null != t && null != e)
        if (null == n || "string" != typeof e) {
          if ("function" == typeof e) return ib(t, e(tb(t), n), n);
          if ("string" == typeof e) {
            (e.match(Ky) || []).forEach(e => {
              eb(t, e) ? rb(t, e) : nb(t, e)
            })
          }
        } else n ? nb(t, e) : rb(t, e)
    }
    let ob = 0;

    function sb() {
      return `v${ob+=1}`
    }

    function ab(t) {
      return null != t.id && "" !== t.id || (t.id = sb()), t.id
    }

    function lb(t) {
      return null != t && ("function" == typeof t.getScreenCTM && t instanceof SVGElement)
    }
    const cb = {
        svg: "http://www.w3.org/2000/svg",
        xmlns: "http://www.w3.org/2000/xmlns/",
        xml: "http://www.w3.org/XML/1998/namespace",
        xlink: "http://www.w3.org/1999/xlink",
        xhtml: "http://www.w3.org/1999/xhtml"
      },
      hb = "1.1";

    function ub(t, e = document) {
      return e.createElement(t)
    }

    function db(t, e = cb.xhtml, n = document) {
      return n.createElementNS(e, t)
    }

    function pb(t, e = document) {
      return db(t, cb.svg, e)
    }

    function fb(t) {
      if (t) {
        const e = `<svg xmlns="${cb.svg}" xmlns:xlink="${cb.xlink}" version="${hb}">${t}</svg>`,
          {
            documentElement: n
          } = gb(e, {
            async: !1
          });
        return n
      }
      const e = document.createElementNS(cb.svg, "svg");
      return e.setAttributeNS(cb.xmlns, "xmlns:xlink", cb.xlink), e.setAttribute("version", hb), e
    }

    function gb(t, e = {}) {
      let n;
      try {
        const r = new DOMParser;
        if (null != e.async) {
          r.async = e.async
        }
        n = r.parseFromString(t, "text/xml")
      } catch (t) {
        n = void 0
      }
      if (!n || n.getElementsByTagName("parsererror").length) throw new Error(`Invalid XML: ${t}`);
      return n
    }

    function mb(t, e = !0) {
      const n = t.nodeName;
      return e ? n.toLowerCase() : n.toUpperCase()
    }

    function vb(t) {
      let e = 0,
        n = t.previousSibling;
      for (; n;) 1 === n.nodeType && (e += 1), n = n.previousSibling;
      return e
    }

    function yb(t, e) {
      return t.querySelectorAll(e)
    }

    function bb(t, e) {
      return t.querySelector(e)
    }

    function Cb(t, e, n) {
      const r = t.ownerSVGElement;
      let i = t.parentNode;
      for (; i && i !== n && i !== r;) {
        if (eb(i, e)) return i;
        i = i.parentNode
      }
      return null
    }

    function xb(t, e) {
      const n = e && e.parentNode;
      return t === n || !!(n && 1 === n.nodeType && 16 & t.compareDocumentPosition(n))
    }

    function wb(t) {
      t.parentNode && t.parentNode.removeChild(t)
    }

    function Ab(t) {
      for (; t.firstChild;) t.removeChild(t.firstChild)
    }

    function Eb(t, e) {
      (Array.isArray(e) ? e : [e]).forEach(e => {
        null != e && t.appendChild(e)
      })
    }

    function Sb(t, e) {
      const n = t.firstChild;
      return n ? Mb(n, e) : Eb(t, e)
    }

    function Mb(t, e) {
      const n = t.parentNode;
      if (n) {
        (Array.isArray(e) ? e : [e]).forEach(e => {
          null != e && n.insertBefore(e, t)
        })
      }
    }

    function kb(t, e) {
      null != e && e.appendChild(t)
    }

    function Ob(t) {
      try {
        return t instanceof HTMLElement
      } catch (e) {
        return "object" == typeof t && 1 === t.nodeType && "object" == typeof t.style && "object" == typeof t.ownerDocument
      }
    }

    function Pb(t, e) {
      return t.getAttribute(e)
    }

    function Db(t, e) {
      const n = Lb(e);
      n.ns ? t.hasAttributeNS(n.ns, n.local) && t.removeAttributeNS(n.ns, n.local) : t.hasAttribute(e) && t.removeAttribute(
        e)
    }

    function Tb(t, e, n) {
      if (null == n) return Db(t, e);
      const r = Lb(e);
      r.ns && "string" == typeof n ? t.setAttributeNS(r.ns, e, n) : "id" === e ? t.id = `${n}` : t.setAttribute(e,
        `${n}`)
    }

    function _b(t, e) {
      Object.keys(e).forEach(n => {
        Tb(t, n, e[n])
      })
    }

    function jb(t, e, n) {
      if (null == e) {
        const e = t.attributes,
          n = {};
        for (let t = 0; t < e.length; t += 1) n[e[t].name] = e[t].value;
        return n
      }
      if ("string" == typeof e && void 0 === n) return t.getAttribute(e);
      "object" == typeof e ? _b(t, e) : Tb(t, e, n)
    }

    function Lb(t) {
      if (-1 !== t.indexOf(":")) {
        const e = t.split(":");
        return {
          ns: cb[e[0]],
          local: e[1]
        }
      }
      return {
        ns: null,
        local: t
      }
    }

    function Nb(t) {
      const e = {};
      return t.split(";").forEach(t => {
        const n = t.trim();
        if (n) {
          const t = n.split("=");
          t.length && (e[t[0].trim()] = t[1] ? t[1].trim() : "")
        }
      }), e
    }

    function Fb(t, e) {
      return Object.keys(e).forEach(n => {
        if ("class" === n) t[n] = t[n] ? `${t[n]} ${e[n]}` : e[n];
        else if ("style" === n) {
          const r = "object" == typeof t[n],
            i = "object" == typeof e[n];
          let o, s;
          r && i ? (o = t[n], s = e[n]) : r ? (o = t[n], s = Nb(e[n])) : i ? (o = Nb(t[n]), s = e[n]) : (o =
            Nb(t[n]), s = Nb(e[n])), t[n] = Fb(o, s)
        } else t[n] = e[n]
      }), t
    }

    function $b(t, e, n = {}) {
      const r = n.offset || 0,
        i = [],
        s = [];
      let a, l, c = null;
      for (let h = 0; h < t.length; h += 1) {
        a = s[h] = t[h];
        for (let i = 0, o = e.length; i < o; i += 1) {
          const o = e[i],
            l = o.start + r,
            c = o.end + r;
          h >= l && h < c && ("string" == typeof a ? a = s[h] = {
            t: t[h],
            attrs: o.attrs
          } : a.attrs = Fb(Fb({}, a.attrs), o.attrs), n.includeAnnotationIndices && (null == a.annotations &&
            (a.annotations = []), a.annotations.push(i)))
        }(l = s[h - 1]) ? o.isObject(a) && o.isObject(l) ? (c = c, JSON.stringify(a.attrs) === JSON.stringify(l.attrs) ?
          c.t += a.t : (i.push(c), c = a)) : o.isObject(a) ? (c = c, i.push(c), c = a) : o.isObject(l) ? (c = c,
          i.push(c), c = a) : c = (c || "") + a: c = a
      }
      return null != c && i.push(c), i
    }

    function Bb(t, e) {
      return t ? t.filter(t => t.start < e && e <= t.end) : []
    }

    function Ib(t, e, n) {
      return t ? t.filter(t => e >= t.start && e < t.end || n > t.start && n <= t.end || t.start >= e && t.end <
        n) : []
    }

    function zb(t, e, n) {
      return t && t.forEach(t => {
        t.start < e && t.end >= e ? t.end += n : t.start >= e && (t.start += n, t.end += n)
      }), t
    }

    function Rb(t) {
      return t.replace(/ /g, " ")
    }
    var Vb, Hb;
    ! function(t) {
      function e(t) {
        return null === t || void 0 === t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t
      }

      function n(t) {
        return Array.isArray(t)
      }

      function r(t, i) {
        if (t === i) return !0;
        if (e(t) || e(i)) return !1;
        const o = n(t),
          s = n(i);
        return o === s && (o && s ? function(t, e) {
          if (t === e) return !0;
          if (t.length !== e.length) return !1;
          for (let n = 0, i = t.length; n < i; n += 1)
            if (!r(t[n], e[n])) return !1;
          return !0
        }(t, i) : function(t, e) {
          if (t === e) return !0;
          for (const n in t)
            if (!(n in e)) return !1;
          for (const n in e)
            if (!(n in t)) return !1;
          for (const n in t)
            if (!r(t[n], e[n])) return !1;
          return !0
        }(t, i))
      }

      function i(t) {
        return e(t) ? t : n(t) ? function(t) {
          const e = new Array(t.length);
          for (let n = 0, r = t.length; n < r; n += 1) e[n] = i(t[n]);
          return e
        }(t) : function(t) {
          const e = {};
          for (const n in t) e[n] = i(t[n]);
          return e
        }(t)
      }
      t.emptyObject = Object.freeze({}), t.emptyArray = Object.freeze([]), t.isPrimitive = e, t.isArray = n, t.isObject =
        function(t) {
          return !e(t) && !n(t)
        }, t.deepEqual = r, t.deepCopy = i
    }(Vb || (Vb = {}));
    class Gb {
      constructor(t, e, n, r) {
        return null == t ? this.set(255, 255, 255, 1) : "number" == typeof t ? this.set(t, e, n, r) : "string" ==
          typeof t ? Gb.fromString(t) || this : Array.isArray(t) ? this.set(t) : void this.set(t.r, t.g, t.b,
            null == t.a ? 1 : t.a)
      }
      blend(t, e, n) {
        this.set(t.r + (e.r - t.r) * n, t.g + (e.g - t.g) * n, t.b + (e.b - t.b) * n, t.a + (e.a - t.a) * n)
      }
      lighten(t) {
        const e = Gb.lighten(this.toArray(), t);
        this.r = e[0], this.g = e[1], this.b = e[2], this.a = e[3]
      }
      darken(t) {
        this.lighten(-t)
      }
      set(t, e, n, r) {
        const i = Array.isArray(t) ? t[0] : t,
          o = Array.isArray(t) ? t[1] : e,
          s = Array.isArray(t) ? t[2] : n,
          l = Array.isArray(t) ? t[3] : r;
        return this.r = Math.round(a.clamp(i, 0, 255)), this.g = Math.round(a.clamp(o, 0, 255)), this.b = Math.round(
          a.clamp(s, 0, 255)), this.a = null == l ? 1 : a.clamp(l, 0, 1), this
      }
      toHex() {
        return `#${["r","g","b"].map(t=>{const e=this[t].toString(16);return e.length<2?`0${e}`:e}).join("")}`
      }
      toRGBA() {
        return this.toArray()
      }
      toHSLA() {
        return Gb.rgba2hsla(this.r, this.g, this.b, this.a)
      }
      toCSS(t) {
        const e = `${this.r},${this.g},${this.b},`;
        return t ? `rgb(${e})` : `rgba(${e},${this.a})`
      }
      toGrey() {
        return Gb.makeGrey(Math.round((this.r + this.g + this.b) / 3), this.a)
      }
      toArray() {
        return [this.r, this.g, this.b, this.a]
      }
      toString() {
        return this.toCSS()
      }
    }! function(t) {
      function e(e) {
        return new t([...l(e), 1])
      }

      function n(e) {
        const n = e.toLowerCase().match(/^rgba?\(([\s\.,0-9]+)\)/);
        if (n) {
          const e = n[1].split(/\s*,\s*/).map(t => parseInt(t, 10));
          return new t(e)
        }
        return null
      }

      function r(t, e, n) {
        n < 0 && ++n, n > 1 && --n;
        const r = 6 * n;
        return r < 1 ? t + (e - t) * r : 2 * n < 1 ? e : 3 * n < 2 ? t + (e - t) * (2 / 3 - n) * 6 : t
      }

      function i(e) {
        const n = e.toLowerCase().match(/^hsla?\(([\s\.,0-9]+)\)/);
        if (n) {
          const e = n[2].split(/\s*,\s*/),
            r = (parseFloat(e[0]) % 360 + 360) % 360 / 360,
            i = parseFloat(e[1]) / 100,
            s = parseFloat(e[2]) / 100,
            a = null == e[3] ? 1 : parseInt(e[3], 10);
          return new t(o(r, i, s, a))
        }
        return null
      }

      function o(t, e, n, i) {
        const o = Array.isArray(t) ? t[0] : t,
          s = Array.isArray(t) ? t[1] : e,
          a = Array.isArray(t) ? t[2] : n,
          l = Array.isArray(t) ? t[3] : i,
          c = a <= .5 ? a * (s + 1) : a + s - a * s,
          h = 2 * a - c;
        return [256 * r(h, c, o + 1 / 3), 256 * r(h, c, o), 256 * r(h, c, o - 1 / 3), null == l ? 1 : l]
      }

      function s(e) {
        return new t(Math.round(256 * Math.random()), Math.round(256 * Math.random()), Math.round(256 * Math.random()),
          e ? void 0 : parseFloat(Math.random().toFixed(2)))
      }

      function l(t) {
        const e = 0 === t.indexOf("#") ? t : `#${t}`;
        let n = Number(`0x${e.substr(1)}`);
        if (4 !== e.length && 7 !== e.length || isNaN(n)) throw new Error("Invalid hex color.");
        const r = 4 === e.length ? 4 : 8,
          i = (1 << r) - 1,
          o = ["b", "g", "r"].map(() => {
            const t = n & i;
            return n >>= r, 4 === r ? 17 * t : t
          });
        return [o[2], o[1], o[0]]
      }

      function c(t, e, n) {
        const r = t => t.length < 2 ? `0${t}` : t;
        return `${r(t.toString(16))}${r(e.toString(16))}${r(n.toString(16))}`
      }

      function h(t, e) {
        if ("string" == typeof t) {
          const n = "#" === t[0],
            r = parseInt(n ? t.substr(1) : t, 16),
            i = a.clamp((r >> 16) + e, 0, 255),
            o = a.clamp((r >> 8 & 255) + e, 0, 255),
            s = a.clamp((255 & r) + e, 0, 255);
          return `${n?"#":""}${(s|o<<8|i<<16).toString(16)}`
        }
        const n = l(h(c(t[0], t[1], t[2]), e));
        return [n[0], n[1], n[2], t[3]]
      }
      t.fromArray = function(e) {
        return new t(e)
      }, t.fromHex = e, t.fromRGBA = n, t.fromHSLA = i, t.fromString = function(r) {
        if (r.startsWith("#")) return e(r);
        if (r.startsWith("rgb")) return n(r);
        const o = t.named[r];
        return o ? e(o) : i(r)
      }, t.makeGrey = function(e, n) {
        return t.fromArray([e, e, e, n])
      }, t.rgba2hsla = function(t, e, n, r) {
        const i = Array.isArray(t) ? t[0] : t,
          o = Array.isArray(t) ? t[1] : e,
          s = Array.isArray(t) ? t[2] : n,
          a = Array.isArray(t) ? t[3] : r,
          l = Math.max(i, o, s),
          c = Math.min(i, o, s),
          h = (l + c) / 2;
        let u = 0,
          d = 0;
        if (c !== l) {
          const t = l - c;
          switch (d = h > .5 ? t / (2 - l - c) : t / (l + c), l) {
            case i:
              u = (o - s) / t + (o < s ? 6 : 0);
              break;
            case o:
              u = (s - i) / t + 2;
              break;
            case s:
              u = (i - o) / t + 4
          }
          u /= 6
        }
        return [u, d, h, null == a ? 1 : a]
      }, t.hsla2rgba = o, t.random = s, t.randomHex = function() {
        let t = "#";
        for (let e = 0; e < 6; e += 1) t += "0123456789ABCDEF" [Math.floor(16 * Math.random())];
        return t
      }, t.randomRGBA = function(t) {
        return s(t).toString()
      }, t.invert = function(t, e) {
        if ("string" == typeof t) {
          const n = "#" === t[0],
            [r, i, o] = l(t);
          return e ? .299 * r + .587 * i + .114 * o > 186 ? "#000000" : "#ffffff" :
            `${n?"#":""}${c(255-r,255-i,255-o)}`
        }
        const n = t[0],
          r = t[1],
          i = t[2],
          o = t[3];
        return e ? .299 * n + .587 * r + .114 * i > 186 ? [0, 0, 0, o] : [255, 255, 255, o] : [255 - n, 255 - r,
          255 - i, o
        ]
      }, t.lighten = function(t, e) {
        return h(t, e)
      }, t.darken = function(t, e) {
        return h(t, -e)
      }
    }(Gb || (Gb = {})), (Gb || (Gb = {})).named = {
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000000",
        blanchedalmond: "#ffebcd",
        blue: "#0000ff",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        burntsienna: "#ea7e5d",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        gold: "#ffd700",
        goldenrod: "#daa520",
        gray: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        lavender: "#e6e6fa",
        lavenderblush: "#fff0f5",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgreen: "#90ee90",
        lightgrey: "#d3d3d3",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#ff00ff",
        maroon: "#800000",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370db",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#db7093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        rebeccapurple: "#663399",
        red: "#ff0000",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#ffffff",
        whitesmoke: "#f5f5f5",
        yellow: "#ffff00",
        yellowgreen: "#9acd32"
      },
      function(t) {
        function e(t) {
          return "data:" === t.substr(0, "data:".length)
        }

        function n(t) {
          let e = t.replace(/\s/g, "");
          const n = (e = decodeURIComponent(e)).indexOf(","),
            r = e.slice(0, n),
            i = r.split(":")[1].split(";")[0],
            o = e.slice(n + 1);
          let s;
          s = r.indexOf("base64") >= 0 ? atob(o) : unescape(encodeURIComponent(o));
          const a = new Uint8Array(s.length);
          for (let t = 0; t < s.length; t += 1) a[t] = s.charCodeAt(t);
          return new Blob([a], {
            type: i
          })
        }

        function r(t, e) {
          if (window.navigator.msSaveBlob) window.navigator.msSaveBlob(t, e);
          else {
            const n = window.URL.createObjectURL(t),
              r = document.createElement("a");
            r.href = n, r.download = e, document.body.appendChild(r), r.click(), document.body.removeChild(r),
              window.URL.revokeObjectURL(n)
          }
        }

        function i(t) {
          const e = parseFloat(t);
          return isNaN(e) ? null : e
        }
        t.isDataUrl = e, t.imageToDataUri = function(t, n) {
          if (!t || e(t)) return void setTimeout(() => n(null, t));
          const r = () => {
              n(new Error(`Failed to load image: ${t}`))
            },
            i = window.FileReader ? t => {
              if (200 === t.status) {
                const e = new FileReader;
                e.onload = (t => {
                  const e = t.target.result;
                  n(null, e)
                }), e.onerror = r, e.readAsDataURL(t.response)
              } else r()
            } : e => {
              if (200 === e.status) {
                let r = t.split(".").pop() || "png";
                "svg" === r && (r = "svg+xml");
                const i = `data:image/${r};base64,`,
                  o = new Uint8Array(e.response),
                  s = i + btoa((t => {
                    const e = [];
                    for (let n = 0; n < t.length; n += 32768) e.push(String.fromCharCode.apply(null, t.subarray(
                      n, n + 32768)));
                    return e.join("")
                  })(o));
                n(null, s)
              } else r()
            },
            o = new XMLHttpRequest;
          o.responseType = window.FileReader ? "blob" : "arraybuffer", o.open("GET", t, !0), o.addEventListener(
            "error", r), o.addEventListener("load", () => i(o)), o.send()
        }, t.dataUriToBlob = n, t.downloadBlob = r, t.downloadDataUri = function(t, e) {
          r(n(t), e)
        }, t.svgToDataUrl = function(t, e = {}) {
          let n = null;
          const r = e => (null == n && (n = function(t) {
              const e = t.match(/<svg[^>]*viewBox\s*=\s*(["']?)(.+?)\1[^>]*>/i);
              return e && e[2] ? e[2].replace(/\s+/, " ").split(" ") : null
            }(t)), null != n ? i(n[e]) : null),
            o = e => {
              const n = t.match(e);
              return n && n[2] ? i(n[2]) : null
            };
          let s = e.width;
          if (null == s && (s = o(/<svg[^>]*width\s*=\s*(["']?)(.+?)\1[^>]*>/i)), null == s && (s = r(2)), null ==
            s) throw new Error("Can not parse width from svg string");
          let a = e.height;
          if (null == a && (a = o(/<svg[^>]*height\s*=\s*(["']?)(.+?)\1[^>]*>/i)), null == a && (a = r(3)),
            null == a) throw new Error("Can not parse height from svg string");
          return `data:image/svg+xml,${encodeURIComponent(t).replace(/'/g,"%27").replace(/"/g,"%22")}`
        }
      }(Hb || (Hb = {}));
    const Ub = function() {
        let t;
        const e = window;
        if (null != e && null != (t = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame ||
            e.oRequestAnimationFrame || e.msRequestAnimationFrame) && (t = t.bind(e)), null == t) {
          let e = 0;
          t = (t => {
            const n = (new Date).getTime(),
              r = Math.max(0, 16 - (n - e)),
              i = setTimeout(() => {
                t(n + r)
              }, r);
            return e = n + r, i
          })
        }
        return t
      }(),
      qb = function() {
        let t;
        const e = window;
        return null != e && (t = e.cancelAnimationFrame || e.webkitCancelAnimationFrame || e.webkitCancelRequestAnimationFrame ||
          e.msCancelAnimationFrame || e.msCancelRequestAnimationFrame || e.oCancelAnimationFrame || e.oCancelRequestAnimationFrame ||
          e.mozCancelAnimationFrame || e.mozCancelRequestAnimationFrame) && (t = t.bind(e)), null == t && (t =
          clearTimeout), t
      }(),
      Wb = /-(.)/g;
    const Xb = {},
      Yb = ["Webkit", "ms", "Moz", "O"],
      Jb = document ? document.createElement("div").style : {};

    function Zb(t) {
      const e = t.replace(Wb, (t, e) => e.toUpperCase());
      if (null == Xb[e]) {
        const t = e.charAt(0).toUpperCase() + e.slice(1);
        Xb[e] = e in Jb ? e : function(t) {
          for (let e = 0; e < Yb.length; e += 1) {
            const n = Yb[e] + t;
            if (n in Jb) return n
          }
          return null
        }(t)
      }
      return Xb[e]
    }

    function Kb(t, e, n) {
      const r = Zb(e);
      null != r && (t[r] = n), t[e] = n
    }

    function Qb(t, e) {
      const n = t.ownerDocument && t.ownerDocument.defaultView && t.ownerDocument.defaultView.opener ? t.ownerDocument
        .defaultView.getComputedStyle(t, null) : window.getComputedStyle(t, null);
      return n && e ? n.getPropertyValue(e) || n[e] : n
    }

    function tC(t) {
      const e = Qb(t);
      return null != e && ("scroll" === e.overflow || "auto" === e.overflow)
    }
    const eC = function() {
      const t = document;
      return t.selection ? function() {
        t.selection.empty()
      } : window.getSelection ? function() {
        const t = window.getSelection();
        t && (t.empty ? t.empty() : t.removeAllRanges && t.removeAllRanges())
      } : function() {}
    }();
    var nC;

    function rC(t, e) {
      const n = Math.pow(10, e || 0);
      return Math.round(t * n) / n
    }

    function iC(t, e) {
      let n, r;
      if (null == e ? (r = null == t ? 1 : t, n = 0) : (r = e, n = null == t ? 0 : t), r < n) {
        const t = n;
        n = r, r = t
      }
      return Math.floor(Math.random() * (r - n + 1) + n)
    }

    function oC(t, e, n) {
      return isNaN(t) ? NaN : isNaN(e) || isNaN(n) ? 0 : e < n ? t < e ? e : t > n ? n : t : t < n ? n : t > e ?
        e : t
    }

    function sC(t, e) {
      return e * Math.round(t / e)
    }

    function aC(t, e) {
      return null != e && null != t && e.x >= t.x && e.x <= t.x + t.width && e.y >= t.y && e.y <= t.y + t.height
    }

    function lC(t, e) {
      const n = t.x - e.x,
        r = t.y - e.y;
      return n * n + r * r
    }! function(t) {
      t.toDeg = function(t) {
        return 180 * t / Math.PI % 360
      }, t.toRad = function(t, e = !1) {
        return (e ? t : t % 360) * Math.PI / 180
      }, t.normalize = function(t) {
        return t % 360 + (t < 0 ? 360 : 0)
      }
    }(nC || (nC = {}));
    class cC {
      valueOf() {
        return this.toJSON()
      }
      toString() {
        return JSON.stringify(this.toJSON())
      }
    }
    class hC extends cC {
      constructor(t, e) {
        super(), this.x = null == t ? 0 : t, this.y = null == e ? 0 : e
      }
      round(t = 0) {
        return this.x = rC(this.x, t), this.y = rC(this.y, t), this
      }
      add(t, e) {
        const n = hC.create(t, e);
        return this.x += n.x, this.y += n.y, this
      }
      update(t, e) {
        const n = hC.create(t, e);
        return this.x = n.x, this.y = n.y, this
      }
      translate(t, e) {
        const n = hC.create(t, e);
        return this.x += n.x, this.y += n.y, this
      }
      rotate(t, e) {
        const n = hC.rotate(this, t, e);
        return this.x = n.x, this.y = n.y, this
      }
      scale(t, e, n = new hC) {
        const r = hC.create(n);
        return this.x = r.x + t * (this.x - r.x), this.y = r.y + e * (this.y - r.y), this
      }
      closest(t) {
        if (1 === t.length) return hC.create(t[0]);
        let e = null,
          n = 1 / 0;
        return t.forEach(t => {
          const r = this.squaredDistance(t);
          r < n && (e = t, n = r)
        }), e ? hC.create(e) : null
      }
      distance(t) {
        return Math.sqrt(this.squaredDistance(t))
      }
      squaredDistance(t) {
        const e = hC.create(t),
          n = this.x - e.x,
          r = this.y - e.y;
        return n * n + r * r
      }
      manhattanDistance(t) {
        const e = hC.create(t);
        return Math.abs(e.x - this.x) + Math.abs(e.y - this.y)
      }
      magnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y) || .01
      }
      theta(t = new hC) {
        const e = hC.create(t),
          n = -(e.y - this.y),
          r = e.x - this.x;
        let i = Math.atan2(n, r);
        return i < 0 && (i = 2 * Math.PI + i), 180 * i / Math.PI
      }
      angleBetween(t, e) {
        if (this.equals(t) || this.equals(e)) return NaN;
        let n = this.theta(e) - this.theta(t);
        return n < 0 && (n += 360), n
      }
      vectorAngle(t) {
        return new hC(0, 0).angleBetween(this, t)
      }
      toPolar(t) {
        return this.update(hC.toPolar(this, t)), this
      }
      changeInAngle(t, e, n) {
        return this.clone().translate(-t, -e).theta(n) - this.theta(n)
      }
      adhereToRect(t) {
        return aC(t, this) || (this.x = Math.min(Math.max(this.x, t.x), t.x + t.width), this.y = Math.min(Math.max(
          this.y, t.y), t.y + t.height)), this
      }
      bearing(t) {
        const e = hC.create(t),
          n = nC.toRad(this.y),
          r = nC.toRad(e.y),
          i = this.x,
          o = e.x,
          s = nC.toRad(o - i),
          a = Math.sin(s) * Math.cos(r),
          l = Math.cos(n) * Math.sin(r) - Math.sin(n) * Math.cos(r) * Math.cos(s);
        let c = nC.toDeg(Math.atan2(a, l)) - 22.5;
        return c < 0 && (c += 360), ["NE", "E", "SE", "S", "SW", "W", "NW", "N"][c /= 45]
      }
      cross(t, e) {
        if (null != t && null != e) {
          const n = hC.create(t),
            r = hC.create(e);
          return (r.x - this.x) * (n.y - this.y) - (r.y - this.y) * (n.x - this.x)
        }
        return NaN
      }
      dot(t) {
        const e = hC.create(t);
        return this.x * e.x + this.y * e.y
      }
      diff(t, e) {
        if ("number" == typeof t) return new hC(this.x - t, this.y - e);
        const n = hC.create(t);
        return new hC(this.x - n.x, this.y - n.y)
      }
      lerp(t, e) {
        const n = this.x,
          r = this.y,
          i = hC.create(t);
        return new hC((1 - e) * n + e * i.x, (1 - e) * r + e * i.y)
      }
      normalize(t = 1) {
        const e = t / this.magnitude();
        return this.scale(e, e)
      }
      move(t, e) {
        const n = hC.create(t),
          r = nC.toRad(n.theta(this));
        return this.translate(Math.cos(r) * e, -Math.sin(r) * e)
      }
      reflection(t) {
        const e = hC.create(t);
        return e.move(this, this.distance(e))
      }
      snapToGrid(t, e) {
        return this.x = sC(this.x, t), this.y = sC(this.y, null == e ? t : e), this
      }
      equals(t) {
        const e = hC.create(t);
        return null != e && e.x === this.x && e.y === this.y
      }
      clone() {
        return hC.clone(this)
      }
      toJSON() {
        return hC.toJSON(this)
      }
      serialize() {
        return `${this.x} ${this.y}`
      }
    }! function(t) {
      t.isPointLike = function(t) {
        return null != t && "object" == typeof t && "number" == typeof t.x && "number" == typeof t.y
      }, t.isPointData = function(t) {
        return null != t && Array.isArray(t) && 2 === t.length && "number" == typeof t[0] && "number" == typeof t[
          1]
      }
    }(hC || (hC = {})),
    function(t) {
      function e(e) {
        return e instanceof t ? new t(e.x, e.y) : Array.isArray(e) ? new t(e[0], e[1]) : new t(e.x, e.y)
      }

      function n(t, e) {
        return t === e || null != t && null != e && (t.x === e.x && t.y === e.y)
      }

      function r(n, r, i, o = new t) {
        const s = e(n),
          a = e(o),
          l = s.x - a.x,
          c = s.y - a.y,
          h = c * r + l * i;
        return new t(l * r - c * i + a.x, h + a.y)
      }
      t.create = function(n, r) {
        return null == n || "number" == typeof n ? new t(n, r) : e(n)
      }, t.clone = e, t.toJSON = function(e) {
        return e instanceof t ? {
          x: e.x,
          y: e.y
        } : Array.isArray(e) ? {
          x: e[0],
          y: e[1]
        } : {
          x: e.x,
          y: e.y
        }
      }, t.fromPolar = function(n, r, i = new t) {
        let o = Math.abs(n * Math.cos(r)),
          s = Math.abs(n * Math.sin(r));
        const a = e(i),
          l = nC.normalize(nC.toDeg(r));
        return l < 90 ? s = -s : l < 180 ? (o = -o, s = -s) : l < 270 && (o = -o), new t(a.x + o, a.y + s)
      }, t.toPolar = function(n, r = new t) {
        const i = e(n),
          o = e(r),
          s = i.x - o.x,
          a = i.y - o.y;
        return new t(Math.sqrt(s * s + a * a), nC.toRad(o.theta(i)))
      }, t.equals = n, t.equalPoints = function(t, e) {
        if (null == t && null != e || null != t && null == e || null != t && null != e && t.length !== e.length)
          return !1;
        if (null != t && null != e)
          for (let r = 0, i = t.length; r < i; r += 1)
            if (t[r] === e[r] || null != t[r] && !n(t[r], e[r])) return !1;
        return !0
      }, t.random = function(e, n, r, i) {
        return new t(iC(e, n), iC(r, i))
      }, t.rotate = function(t, e, n) {
        const i = nC.toRad(nC.normalize(-e)),
          o = Math.sin(i);
        return r(t, Math.cos(i), o, n)
      }, t.rotateEx = r
    }(hC || (hC = {}));
    class uC extends cC {
      constructor(t, e, n, r) {
        super(), this.x = null == t ? 0 : t, this.y = null == e ? 0 : e, this.width = null == n ? 0 : n, this.height =
          null == r ? 0 : r
      }
      get origin() {
        return new hC(this.x, this.y)
      }
      get topLeft() {
        return new hC(this.x, this.y)
      }
      get topCenter() {
        return new hC(this.x + this.width / 2, this.y)
      }
      get topRight() {
        return new hC(this.x + this.width, this.y)
      }
      get center() {
        return new hC(this.x + this.width / 2, this.y + this.height / 2)
      }
      get bottomLeft() {
        return new hC(this.x, this.y + this.height)
      }
      get bottomCenter() {
        return new hC(this.x + this.width / 2, this.y + this.height)
      }
      get bottomRight() {
        return new hC(this.x + this.width, this.y + this.height)
      }
      get corner() {
        return new hC(this.x + this.width, this.y + this.height)
      }
      get rightMiddle() {
        return new hC(this.x + this.width, this.y + this.height / 2)
      }
      get leftMiddle() {
        return new hC(this.x, this.y + this.height / 2)
      }
      get topLine() {
        return new dC(this.topLeft, this.topRight)
      }
      get rightLine() {
        return new dC(this.topRight, this.bottomRight)
      }
      get bottomLine() {
        return new dC(this.bottomLeft, this.bottomRight)
      }
      get leftLine() {
        return new dC(this.topLeft, this.bottomLeft)
      }
      getOrigin() {
        return this.origin
      }
      getTopLeft() {
        return this.topLeft
      }
      getTopCenter() {
        return this.topCenter
      }
      getTopRight() {
        return this.topRight
      }
      getCenter() {
        return this.center
      }
      getCenterX() {
        return this.x + this.width / 2
      }
      getCenterY() {
        return this.y + this.height / 2
      }
      getBottomLeft() {
        return this.bottomLeft
      }
      getBottomCenter() {
        return this.bottomCenter
      }
      getBottomRight() {
        return this.bottomRight
      }
      getCorner() {
        return this.corner
      }
      getRightMiddle() {
        return this.rightMiddle
      }
      getLeftMiddle() {
        return this.leftMiddle
      }
      getTopLine() {
        return this.topLine
      }
      getRightLine() {
        return this.rightLine
      }
      getBottomLine() {
        return this.bottomLine
      }
      getLeftLine() {
        return this.leftLine
      }
      bbox(t) {
        if (!t) return this.clone();
        const e = nC.toRad(t),
          n = Math.abs(Math.sin(e)),
          r = Math.abs(Math.cos(e)),
          i = this.width * r + this.height * n,
          o = this.width * n + this.height * r;
        return new uC(this.x + (this.width - i) / 2, this.y + (this.height - o) / 2, i, o)
      }
      round(t = 0) {
        return this.x = rC(this.x, t), this.y = rC(this.y, t), this.width = rC(this.width, t), this.height = rC(
          this.height, t), this
      }
      add(t, e, n, r) {
        const i = uC.create(t, e, n, r),
          o = Math.min(this.x, i.x),
          s = Math.min(this.y, i.y),
          a = Math.max(this.x + this.width, i.x + i.width),
          l = Math.max(this.y + this.height, i.y + i.height);
        return this.x = o, this.y = s, this.width = a - o, this.height = l - s, this
      }
      update(t, e, n, r) {
        const i = uC.create(t, e, n, r);
        return this.x = i.x, this.y = i.y, this.width = i.width, this.height = i.height, this
      }
      inflate(t, e) {
        const n = t,
          r = null != e ? e : t;
        return this.x -= n, this.y -= r, this.width += 2 * n, this.height += 2 * r, this
      }
      snapToGrid(t, e) {
        const n = this.origin.snapToGrid(t, e),
          r = this.corner.snapToGrid(t, e);
        return this.x = n.x, this.y = n.y, this.width = r.x - n.x, this.height = r.y - n.y, this
      }
      translate(t, e) {
        const n = hC.create(t, e);
        return this.x += n.x, this.y += n.y, this
      }
      moveAndExpand(t) {
        const e = uC.clone(t);
        return this.x += e.x || 0, this.y += e.y || 0, this.width += e.width || 0, this.height += e.height || 0,
          this
      }
      scale(t, e, n = new hC) {
        const r = this.origin.scale(t, e, n);
        return this.x = r.x, this.y = r.y, this.width *= t, this.height *= e, this
      }
      rotate(t, e = this.getCenter()) {
        if (0 !== t) {
          const n = nC.toRad(t),
            r = Math.cos(n),
            i = Math.sin(n);
          let o = this.getOrigin(),
            s = this.getTopRight(),
            a = this.getBottomRight(),
            l = this.getBottomLeft();
          o = hC.rotateEx(o, r, i, e), s = hC.rotateEx(s, r, i, e), a = hC.rotateEx(a, r, i, e), l = hC.rotateEx(
            l, r, i, e);
          const c = new uC(o.x, o.y, 0, 0);
          c.add(s.x, s.y, 0, 0), c.add(a.x, a.y, 0, 0), c.add(l.x, l.y, 0, 0), this.update(c)
        }
        return this
      }
      rotate90() {
        const t = (this.width - this.height) / 2;
        this.x += t, this.y -= t;
        const e = this.width;
        return this.width = this.height, this.height = e, this
      }
      maxRectScaleToFit(t, e = this.center) {
        const n = uC.clone(t),
          r = e.x,
          i = e.y;
        let o, s, a, l, c, h, u, d;
        o = s = a = l = c = h = u = d = 1 / 0;
        const p = n.topLeft;
        p.x < r && (o = (this.x - r) / (p.x - r)), p.y < i && (c = (this.y - i) / (p.y - i));
        const f = n.bottomRight;
        f.x > r && (s = (this.x + this.width - r) / (f.x - r)), f.y > i && (h = (this.y + this.height - i) / (f
          .y - i));
        const g = n.topRight;
        g.x > r && (a = (this.x + this.width - r) / (g.x - r)), g.y < i && (u = (this.y - i) / (g.y - i));
        const m = n.bottomLeft;
        return m.x < r && (l = (this.x - r) / (m.x - r)), m.y > i && (d = (this.y + this.height - i) / (m.y - i)), {
          sx: Math.min(o, s, a, l),
          sy: Math.min(c, h, u, d)
        }
      }
      maxRectUniformScaleToFit(t, e = this.center) {
        const n = this.maxRectScaleToFit(t, e);
        return Math.min(n.sx, n.sy)
      }
      containsPoint(t, e) {
        return aC(this, hC.create(t, e))
      }
      containsRect(t, e, n, r) {
        const i = uC.create(t, e, n, r),
          o = this.x,
          s = this.y,
          a = this.width,
          l = this.height,
          c = i.x,
          h = i.y,
          u = i.width,
          d = i.height;
        return c >= o && h >= s && c + u <= o + a && h + d <= s + l
      }
      intersectionWithLine(t) {
        const e = [],
          n = [];
        return [this.topLine, this.rightLine, this.bottomLine, this.leftLine].forEach(r => {
          const i = t.intersectionWithLine(r);
          null !== i && n.indexOf(i.toString()) < 0 && (e.push(i), n.push(i.toString()))
        }), e.length > 0 ? e : null
      }
      intersectionWithLineFromCenterToPoint(t, e) {
        const n = hC.clone(t),
          r = this.center;
        let i;
        e && n.rotate(e, r);
        const o = [this.topLine, this.rightLine, this.bottomLine, this.leftLine],
          s = new dC(r, t);
        for (let t = o.length - 1; t >= 0; t -= 1) {
          const e = o[t].intersectionWithLine(s);
          if (null !== e) {
            i = e;
            break
          }
        }
        return i && e && i.rotate(-e, r), i
      }
      normalize() {
        let t = this.x,
          e = this.y,
          n = this.width,
          r = this.height;
        return this.width < 0 && (t = this.x + this.width, n = -this.width), this.height < 0 && (e = this.y +
          this.height, r = -this.height), this.x = t, this.y = e, this.width = n, this.height = r, this
      }
      intersect(t, e, n, r) {
        const i = uC.create(t, e, n, r);
        if (!this.isIntersectWith(i)) return null;
        const o = this.origin,
          s = this.corner,
          a = i.origin,
          l = i.corner,
          c = Math.max(o.x, a.x),
          h = Math.max(o.y, a.y);
        return new uC(c, h, Math.min(s.x, l.x) - c, Math.min(s.y, l.y) - h)
      }
      isIntersectWith(t, e, n, r) {
        const i = uC.create(t, e, n, r),
          o = this.origin,
          s = this.corner,
          a = i.origin,
          l = i.corner;
        return !(l.x <= o.x || l.y <= o.y || a.x >= s.x || a.y >= s.y)
      }
      union(t) {
        const e = uC.clone(t),
          n = this.origin,
          r = this.corner,
          i = e.origin,
          o = e.corner,
          s = Math.min(n.x, i.x),
          a = Math.min(n.y, i.y),
          l = Math.max(r.x, o.x),
          c = Math.max(r.y, o.y);
        return new uC(s, a, l - s, c - a)
      }
      sideNearestToPoint(t) {
        const e = hC.clone(t),
          n = e.x - this.x,
          r = this.x + this.width - e.x,
          i = e.y - this.y,
          o = this.y + this.height - e.y;
        let s = n,
          a = "left";
        return r < s && (s = r, a = "right"), i < s && (s = i, a = "top"), o < s && (a = "bottom"), a
      }
      pointNearestToPoint(t) {
        const e = hC.clone(t);
        if (this.containsPoint(e)) {
          switch (this.sideNearestToPoint(e)) {
            case "right":
              return new hC(this.x + this.width, e.y);
            case "left":
              return new hC(this.x, e.y);
            case "bottom":
              return new hC(e.x, this.y + this.height);
            case "top":
              return new hC(e.x, this.y)
          }
        }
        return e.adhereToRect(this)
      }
      equals(t) {
        return null != t && t.x === this.x && t.y === this.y && t.width === this.width && t.height === this.height
      }
      clone() {
        return new uC(this.x, this.y, this.width, this.height)
      }
      toJSON() {
        return {
          x: this.x,
          y: this.y,
          width: this.width,
          height: this.height
        }
      }
      serialize() {
        return `${this.x} ${this.y} ${this.width} ${this.height}`
      }
    }! function(t) {
      function e(e) {
        return e instanceof t ? e.clone() : Array.isArray(e) ? new t(e[0], e[1], e[2], e[3]) : new t(e.x, e.y, e.width,
          e.height)
      }
      t.create = function(n, r, i, o) {
        return null == n || "number" == typeof n ? new t(n, r, i, o) : e(n)
      }, t.clone = e, t.fromSize = function(e) {
        return new t(0, 0, e.width, e.height)
      }, t.fromPositionAndSize = function(e, n) {
        return new t(e.x, e.y, n.width, n.height)
      }, t.fromEllipse = function(e) {
        return new t(e.x - e.a, e.y - e.b, 2 * e.a, 2 * e.b)
      }, t.isRectangleLike = function(t) {
        return null != t && "object" == typeof t && "number" == typeof t.x && "number" == typeof t.y &&
          "number" == typeof t.width && "number" == typeof t.height
      }
    }(uC || (uC = {}));
    class dC extends cC {
      constructor(t, e, n, r) {
        super(), "number" == typeof t && "number" == typeof e ? (this.start = new hC(t, e), this.end = new hC(n,
          r)) : (this.start = hC.create(t), this.end = hC.create(e))
      }
      get center() {
        return new hC((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2)
      }
      getCenter() {
        return this.center
      }
      round(t = 0) {
        return this.start.round(t), this.end.round(t), this
      }
      translate(t, e) {
        return "number" == typeof t ? (this.start.translate(t, e), this.end.translate(t, e)) : (this.start.translate(
          t), this.end.translate(t)), this
      }
      rotate(t, e) {
        return this.start.rotate(t, e), this.end.rotate(t, e), this
      }
      scale(t, e, n) {
        return this.start.scale(t, e, n), this.end.scale(t, e, n), this
      }
      length() {
        return Math.sqrt(this.squaredLength())
      }
      squaredLength() {
        const t = this.start.x - this.end.x,
          e = this.start.y - this.end.y;
        return t * t + e * e
      }
      setLength(t) {
        const e = this.length();
        if (!e) return this;
        const n = t / e;
        return this.scale(n, n, this.start)
      }
      vector() {
        return new hC(this.end.x - this.start.x, this.end.y - this.start.y)
      }
      angle() {
        const t = new hC(this.start.x + 1, this.start.y);
        return this.start.angleBetween(this.end, t)
      }
      bbox() {
        const t = Math.min(this.start.x, this.end.x),
          e = Math.min(this.start.y, this.end.y),
          n = Math.max(this.start.x, this.end.x),
          r = Math.max(this.start.y, this.end.y);
        return new uC(t, e, n - t, r - e)
      }
      bearing() {
        return this.start.bearing(this.end)
      }
      closestPoint(t) {
        return this.pointAt(this.closestPointNormalizedLength(t))
      }
      closestPointLength(t) {
        return this.closestPointNormalizedLength(t) * this.length()
      }
      closestPointTangent(t) {
        return this.tangentAt(this.closestPointNormalizedLength(t))
      }
      closestPointNormalizedLength(t) {
        const e = this.vector().dot(new dC(this.start, t).vector()),
          n = Math.min(1, Math.max(0, e / this.squaredLength()));
        return n != n ? 0 : n
      }
      pointAt(t) {
        const e = this.start,
          n = this.end;
        return t <= 0 ? e.clone() : t >= 1 ? n.clone() : e.lerp(n, t)
      }
      pointAtLength(t) {
        const e = this.start,
          n = this.end;
        let r = !0;
        t < 0 && (r = !1, t = -t);
        const i = this.length();
        if (t >= i) return r ? n.clone() : e.clone();
        const o = (r ? t : i - t) / i;
        return this.pointAt(o)
      }
      divideAt(t) {
        const e = this.pointAt(t);
        return [new dC(this.start, e), new dC(e, this.end)]
      }
      divideAtLength(t) {
        const e = this.pointAtLength(t);
        return [new dC(this.start, e), new dC(e, this.end)]
      }
      containsPoint(t) {
        const e = this.start,
          n = this.end;
        if (0 !== e.cross(t, n)) return !1;
        const r = this.length();
        return !(new dC(e, t).length() > r) && !(new dC(t, n).length() > r)
      }
      intersect(t, e) {
        const n = t.intersectionWithLine(this, e);
        return n ? Array.isArray(n) ? n : [n] : null
      }
      intersectionWithLine(t) {
        const e = new hC(this.end.x - this.start.x, this.end.y - this.start.y),
          n = new hC(t.end.x - t.start.x, t.end.y - t.start.y),
          r = e.x * n.y - e.y * n.x,
          i = new hC(t.start.x - this.start.x, t.start.y - this.start.y),
          o = i.x * n.y - i.y * n.x,
          s = i.x * e.y - i.y * e.x;
        if (0 === r || o * r < 0 || s * r < 0) return null;
        if (r > 0) {
          if (o > r || s > r) return null
        } else if (o < r || s < r) return null;
        return new hC(this.start.x + o * e.x / r, this.start.y + o * e.y / r)
      }
      isDifferentiable() {
        return !this.start.equals(this.end)
      }
      pointOffset(t) {
        const e = hC.clone(t),
          n = this.start,
          r = this.end;
        return ((r.x - n.x) * (e.y - n.y) - (r.y - n.y) * (e.x - n.x)) / this.length()
      }
      pointSquaredDistance(t, e) {
        const n = hC.create(t, e);
        return this.closestPoint(n).squaredDistance(n)
      }
      pointDistance(t, e) {
        const n = hC.create(t, e);
        return this.closestPoint(n).distance(n)
      }
      tangentAt(t) {
        if (!this.isDifferentiable()) return null;
        const e = this.start,
          n = this.end,
          r = this.pointAt(t),
          i = new dC(e, n);
        return i.translate(r.x - e.x, r.y - e.y), i
      }
      tangentAtLength(t) {
        if (!this.isDifferentiable()) return null;
        const e = this.start,
          n = this.end,
          r = this.pointAtLength(t),
          i = new dC(e, n);
        return i.translate(r.x - e.x, r.y - e.y), i
      }
      relativeCcw(t, e) {
        const n = hC.create(t, e);
        let r = n.x - this.start.x,
          i = n.y - this.start.y;
        const o = this.end.x - this.start.x,
          s = this.end.y - this.start.y;
        let a = r * s - i * o;
        return 0 === a && (a = r * o + i * s) > 0 && (a = (r -= o) * o + (i -= s) * s) < 0 && (a = 0), a < 0 ?
          -1 : a > 0 ? 1 : 0
      }
      equals(t) {
        return null != t && this.start.x === t.start.x && this.start.y === t.start.y && this.end.x === t.end.x &&
          this.end.y === t.end.y
      }
      clone() {
        return new dC(this.start, this.end)
      }
      toJSON() {
        return {
          start: this.start.toJSON(),
          end: this.end.toJSON()
        }
      }
      serialize() {
        return [this.start.serialize(), this.end.serialize()].join(" ")
      }
    }
    class pC extends cC {
      constructor(t, e, n, r) {
        super(), this.x = null == t ? 0 : t, this.y = null == e ? 0 : e, this.a = null == n ? 0 : n, this.b =
          null == r ? 0 : r
      }
      get center() {
        return new hC(this.x, this.y)
      }
      bbox() {
        return uC.fromEllipse(this)
      }
      getCenter() {
        return this.center
      }
      inflate(t, e) {
        const n = t,
          r = null != e ? e : t;
        return this.a += 2 * n, this.b += 2 * r, this
      }
      containsPoint(t) {
        return this.normalizedDistance(t) <= 1
      }
      normalizedDistance(t) {
        const e = hC.clone(t),
          n = e.x - this.x,
          r = e.y - this.y,
          i = this.a,
          o = this.b;
        return n * n / (i * i) + r * r / (o * o)
      }
      intersectionWithLine(t) {
        const e = [],
          n = this.a,
          r = this.b,
          i = t.start,
          o = t.end,
          s = t.vector(),
          a = i.diff(new hC(this.x, this.y)),
          l = new hC(s.x / (n * n), s.y / (r * r)),
          c = new hC(a.x / (n * n), a.y / (r * r)),
          h = s.dot(l),
          u = s.dot(c),
          d = u * u - h * (a.dot(c) - 1);
        if (d < 0) return null;
        if (d > 0) {
          const t = Math.sqrt(d),
            n = (-u - t) / h,
            r = (-u + t) / h;
          if ((n < 0 || 1 < n) && (r < 0 || 1 < r)) return null;
          0 <= n && n <= 1 && e.push(i.lerp(o, n)), 0 <= r && r <= 1 && e.push(i.lerp(o, r))
        } else {
          const t = -u / h;
          if (!(0 <= t && t <= 1)) return null;
          e.push(i.lerp(o, t))
        }
        return e
      }
      intersectionWithLineFromCenterToPoint(t, e = 0) {
        const n = hC.clone(t);
        e && n.rotate(e, this.getCenter());
        const r = n.x - this.x,
          i = n.y - this.y;
        let o;
        if (0 === r) return o = this.bbox().pointNearestToPoint(t), e ? o.rotate(-e, this.getCenter()) : o;
        const s = i / r,
          a = s * s,
          l = this.a * this.a,
          c = this.b * this.b;
        let h = Math.sqrt(1 / (1 / l + a / c));
        const u = s * (h = r < 0 ? -h : h);
        return o = new hC(this.x + h, this.y + u), e ? o.rotate(-e, this.getCenter()) : o
      }
      tangentTheta(t) {
        const e = hC.clone(t),
          n = e.x,
          r = e.y,
          i = this.a,
          o = this.b,
          s = this.bbox().center,
          a = s.x,
          l = s.y,
          c = n > s.x + i / 2,
          h = n < s.x - i / 2;
        let u, d;
        return c || h ? u = i * i / (n - a) - i * i * (r - l) * ((d = n > s.x ? r - 30 : r + 30) - l) / (o * o *
          (n - a)) + a : d = o * o / (r - l) - o * o * (n - a) * ((u = r > s.y ? n + 30 : n - 30) - a) / (i *
          i * (r - l)) + l, new hC(u, d).theta(e)
      }
      scale(t, e) {
        return this.a *= t, this.b *= e, this
      }
      translate(t, e) {
        const n = hC.create(t, e);
        return this.x += n.x, this.y += n.y, this
      }
      equals(t) {
        return null != t && t.x === this.x && t.y === this.y && t.a === this.a && t.b === this.b
      }
      clone() {
        return new pC(this.x, this.y, this.a, this.b)
      }
      toJSON() {
        return {
          x: this.x,
          y: this.y,
          a: this.a,
          b: this.b
        }
      }
      serialize() {
        return `${this.x} ${this.y} ${this.a} ${this.b}`
      }
    }! function(t) {
      function e(e) {
        return e instanceof t ? e.clone() : Array.isArray(e) ? new t(e[0], e[1], e[2], e[3]) : new t(e.x, e.y, e.a,
          e.b)
      }
      t.create = function(n, r, i, o) {
        return null == n || "number" == typeof n ? new t(n, r, i, o) : e(n)
      }, t.parse = e, t.fromRect = function(e) {
        const n = e.center;
        return new t(n.x, n.y, e.width / 2, e.height / 2)
      }
    }(pC || (pC = {}));
    class fC extends cC {
      constructor(t) {
        if (super(), null != t) {
          if ("string" == typeof t) return fC.parse(t);
          this.points = t.map(t => hC.create(t))
        } else this.points = []
      }
      get start() {
        return 0 === this.points.length ? null : this.points[0]
      }
      get end() {
        return 0 === this.points.length ? null : this.points[this.points.length - 1]
      }
      scale(t, e, n = new hC) {
        return this.points.forEach(r => r.scale(t, e, n)), this
      }
      translate(t, e) {
        const n = hC.create(t, e);
        return this.points.forEach(t => t.translate(n.x, n.y)), this
      }
      bbox() {
        if (0 === this.points.length) return new uC;
        let t = 1 / 0,
          e = -1 / 0,
          n = 1 / 0,
          r = -1 / 0;
        const i = this.points;
        for (let o = 0, s = i.length; o < s; o += 1) {
          const s = i[o],
            a = s.x,
            l = s.y;
          a < t && (t = a), a > e && (e = a), l < n && (n = l), l > r && (r = l)
        }
        return new uC(t, n, e - t, r - n)
      }
      closestPoint(t) {
        const e = this.closestPointLength(t);
        return this.pointAtLength(e)
      }
      closestPointLength(t) {
        const e = this.points,
          n = e.length;
        if (0 === n || 1 === n) return 0;
        let r = 0,
          i = 0,
          o = 1 / 0;
        for (let s = 0, a = n - 1; s < a; s += 1) {
          const n = new dC(e[s], e[s + 1]),
            a = n.length(),
            l = n.closestPointNormalizedLength(t),
            c = n.pointAt(l).squaredDistance(t);
          c < o && (o = c, i = r + l * a), r += a
        }
        return i
      }
      closestPointNormalizedLength(t) {
        const e = this.closestPointLength(t);
        if (0 === e) return 0;
        const n = this.length();
        return 0 === n ? 0 : e / n
      }
      closestPointTangent(t) {
        const e = this.closestPointLength(t);
        return this.tangentAtLength(e)
      }
      containsPoint(t) {
        if (0 === this.points.length) return !1;
        const e = hC.clone(t),
          n = e.x,
          r = e.y,
          i = this.points,
          o = i.length;
        let s = o - 1,
          a = 0;
        for (let l = 0; l < o; l += 1) {
          const o = i[s],
            c = i[l];
          if (e.equals(o)) return !0;
          const h = new dC(o, c);
          if (h.containsPoint(t)) return !0;
          if (r <= o.y && r > c.y || r > o.y && r <= c.y) {
            const e = o.x - n > c.x - n ? o.x - n : c.x - n;
            if (e >= 0) {
              const i = new hC(n + e, r),
                o = new dC(t, i);
              h.intersectionWithLine(o) && (a += 1)
            }
          }
          s = l
        }
        return a % 2 == 1
      }
      intersectionWithLine(t) {
        const e = [];
        for (let n = 0, r = this.points.length - 1; n < r; n += 1) {
          const r = this.points[n],
            i = this.points[n + 1],
            o = t.intersectionWithLine(new dC(r, i));
          o && e.push(o)
        }
        return e.length > 0 ? e : null
      }
      isDifferentiable() {
        for (let t = 0, e = this.points.length - 1; t < e; t += 1) {
          const e = this.points[t],
            n = this.points[t + 1];
          if (new dC(e, n).isDifferentiable()) return !0
        }
        return !1
      }
      length() {
        let t = 0;
        for (let e = 0, n = this.points.length - 1; e < n; e += 1) {
          const n = this.points[e],
            r = this.points[e + 1];
          t += n.distance(r)
        }
        return t
      }
      pointAt(t) {
        const e = this.points,
          n = e.length;
        if (0 === n) return null;
        if (1 === n) return e[0].clone();
        if (t <= 0) return e[0].clone();
        if (t >= 1) return e[n - 1].clone();
        const r = this.length() * t;
        return this.pointAtLength(r)
      }
      pointAtLength(t) {
        const e = this.points,
          n = e.length;
        if (0 === n) return null;
        if (1 === n) return e[0].clone();
        let r = !0;
        t < 0 && (r = !1, t = -t);
        let i = 0;
        for (let o = 0, s = n - 1; o < s; o += 1) {
          const n = r ? o : s - 1 - o,
            a = e[n],
            l = e[n + 1],
            c = new dC(a, l),
            h = a.distance(l);
          if (t <= i + h) return c.pointAtLength((r ? 1 : -1) * (t - i));
          i += h
        }
        return (r ? e[n - 1] : e[0]).clone()
      }
      tangentAt(t) {
        const e = this.points.length;
        if (0 === e || 1 === e) return null;
        t < 0 && (t = 0), t > 1 && (t = 1);
        const n = this.length() * t;
        return this.tangentAtLength(n)
      }
      tangentAtLength(t) {
        const e = this.points,
          n = e.length;
        if (0 === n || 1 === n) return null;
        let r, i = !0;
        t < 0 && (i = !1, t = -t);
        let o = 0;
        for (let s = 0, a = n - 1; s < a; s += 1) {
          const n = i ? s : a - 1 - s,
            l = e[n],
            c = e[n + 1],
            h = new dC(l, c),
            u = l.distance(c);
          if (h.isDifferentiable()) {
            if (t <= o + u) return h.tangentAtLength((i ? 1 : -1) * (t - o));
            r = h
          }
          o += u
        }
        if (r) {
          const t = i ? 1 : 0;
          return r.tangentAt(t)
        }
        return null
      }
      simplify(t = {}) {
        const e = this.points;
        if (e.length < 3) return this;
        const n = t.threshold || 0;
        let r = 0;
        for (; e[r + 2];) {
          const t = r + 1,
            i = r + 2,
            o = e[r],
            s = e[t],
            a = e[i];
          new dC(o, a).closestPoint(s).distance(s) <= n ? e.splice(t, 1) : r += 1
        }
        return this
      }
      toHull() {
        const t = this.points,
          e = t.length;
        if (0 === e) return new fC;
        let n = t[0];
        for (let r = 1; r < e; r += 1) t[r].y < n.y ? n = t[r] : t[r].y === n.y && t[r].x > n.x && (n = t[r]);
        const r = [];
        for (let i = 0; i < e; i += 1) {
          let e = n.theta(t[i]);
          0 === e && (e = 360), r.push([t[i], i, e])
        }
        if (r.sort((t, e) => {
            let n = t[2] - e[2];
            return 0 === n && (n = e[1] - t[1]), n
          }), r.length > 2) {
          const t = r[r.length - 1];
          r.unshift(t)
        }
        const i = {},
          o = [],
          s = t => `${t[0].toString()}@${t[1]}`;
        for (; 0 !== r.length;) {
          const t = r.pop(),
            e = t[0];
          if (i[s(t)]) continue;
          let n = !1;
          for (; !n;)
            if (o.length < 2) o.push(t), n = !0;
            else {
              const a = o.pop(),
                l = a[0],
                c = o.pop(),
                h = c[0],
                u = h.cross(l, e);
              if (u < 0) o.push(c), o.push(a), o.push(t), n = !0;
              else if (0 === u) {
                const t = 1e-10,
                  n = l.angleBetween(h, e);
                Math.abs(n - 180) < t ? (i[s(a)] = l, o.push(c)) : l.equals(e) || h.equals(l) ? (i[s(a)] = l, o
                  .push(c)) : Math.abs((n + 1) % 360 - 1) < t && (o.push(c), r.push(a))
              } else i[s(a)] = l, o.push(c)
            }
        }
        let a;
        o.length > 2 && o.pop();
        let l = -1;
        for (let t = 0, e = o.length; t < e; t += 1) {
          const e = o[t][1];
          (void 0 === a || e < a) && (a = e, l = t)
        }
        let c = [];
        if (l > 0) {
          const t = o.slice(l),
            e = o.slice(0, l);
          c = t.concat(e)
        } else c = o;
        const h = [];
        for (let t = 0, e = c.length; t < e; t += 1) h.push(c[t][0]);
        return new fC(h)
      }
      equals(t) {
        return null != t && (t.points.length === this.points.length && t.points.every((t, e) => t.equals(this.points[
          e])))
      }
      clone() {
        return new fC(this.points.map(t => t.clone()))
      }
      toJSON() {
        return this.points.map(t => t.toJSON())
      }
      serialize() {
        return this.points.map(t => `${t.x}, ${t.y}`).join(" ")
      }
    }! function(t) {
      t.parse = function(e) {
        const n = e.trim();
        if ("" === n) return new t;
        const r = [],
          i = n.split(/\s*,\s*|\s+/);
        for (let t = 0, e = i.length; t < e; t += 2) r.push({
          x: +i[t],
          y: +i[t + 1]
        });
        return new t(r)
      }
    }(fC || (fC = {}));
    class gC extends cC {
      constructor(t, e, n, r) {
        super(), this.PRECISION = 3, this.start = hC.create(t), this.controlPoint1 = hC.create(e), this.controlPoint2 =
          hC.create(n), this.end = hC.create(r)
      }
      bbox() {
        const t = this.start,
          e = this.controlPoint1,
          n = this.controlPoint2,
          r = this.end,
          i = t.x,
          o = t.y,
          s = e.x,
          a = e.y,
          l = n.x,
          c = n.y,
          h = r.x,
          u = r.y,
          d = [],
          p = [],
          f = [
            [],
            []
          ];
        let g, m, v, y, b, C, x, w, A, E, S;
        for (let t = 0; t < 2; t += 1)
          if (0 === t ? (m = 6 * i - 12 * s + 6 * l, g = -3 * i + 9 * s - 9 * l + 3 * h, v = 3 * s - 3 * i) : (
              m = 6 * o - 12 * a + 6 * c, g = -3 * o + 9 * a - 9 * c + 3 * u, v = 3 * a - 3 * o), Math.abs(g) <
            1e-12) {
            if (Math.abs(m) < 1e-12) continue;
            0 < (y = -v / m) && y < 1 && p.push(y)
          } else x = m * m - 4 * v * g, w = Math.sqrt(x), x < 0 || (0 < (b = (-m + w) / (2 * g)) && b < 1 && p.push(
            b), 0 < (C = (-m - w) / (2 * g)) && C < 1 && p.push(C));
        let M = p.length;
        const k = M;
        for (; M;) A = (S = 1 - (y = p[M -= 1])) * S * S * i + 3 * S * S * y * s + 3 * S * y * y * l + y * y *
          y * h, f[0][M] = A, E = S * S * S * o + 3 * S * S * y * a + 3 * S * y * y * c + y * y * y * u, f[1][M] =
          E, d[M] = {
            X: A,
            Y: E
          };
        p[k] = 0, p[k + 1] = 1, d[k] = {
            X: i,
            Y: o
          }, d[k + 1] = {
            X: h,
            Y: u
          }, f[0][k] = i, f[1][k] = o, f[0][k + 1] = h, f[1][k + 1] = u, p.length = k + 2, f[0].length = k + 2,
          f[1].length = k + 2, d.length = k + 2;
        const O = Math.min.apply(null, f[0]),
          P = Math.min.apply(null, f[1]),
          D = Math.max.apply(null, f[0]),
          T = Math.max.apply(null, f[1]);
        return new uC(O, P, D - O, T - P)
      }
      closestPoint(t, e = {}) {
        return this.pointAtT(this.closestPointT(t, e))
      }
      closestPointLength(t, e = {}) {
        const n = this.getOptions(e);
        return this.lengthAtT(this.closestPointT(t, n), n)
      }
      closestPointNormalizedLength(t, e = {}) {
        const n = this.getOptions(e),
          r = this.closestPointLength(t, n);
        if (!r) return 0;
        const i = this.length(n);
        return 0 === i ? 0 : r / i
      }
      closestPointT(t, e = {}) {
        const n = this.getPrecision(e),
          r = this.getDivisions(e),
          i = Math.pow(10, -n);
        let o = null,
          s = 0,
          a = 0,
          l = 0,
          c = 0,
          h = 0,
          u = null;
        const d = r.length;
        let p = d > 0 ? 1 / d : 0;
        for (r.forEach((e, n) => {
            const r = e.start.distance(t),
              i = e.end.distance(t),
              d = r + i;
            (null == u || d < u) && (o = e, s = n * p, a = (n + 1) * p, l = r, c = i, u = d, h = e.endpointDistance())
          });;) {
          const e = l ? Math.abs(l - c) / l : 0,
            n = null != c ? Math.abs(l - c) / c : 0;
          if (e < i || n < i || (!l || l < h * i || (!c || c < h * i))) return l <= c ? s : a;
          const r = o.divide(.5);
          p /= 2;
          const u = r[0].start.distance(t),
            d = r[0].end.distance(t),
            f = u + d,
            g = r[1].start.distance(t),
            m = r[1].end.distance(t);
          f <= g + m ? (o = r[0], a -= p, l = u, c = d) : (o = r[1], s += p, l = g, c = m)
        }
      }
      closestPointTangent(t, e = {}) {
        return this.tangentAtT(this.closestPointT(t, e))
      }
      containsPoint(t, e = {}) {
        return this.toPolyline(e).containsPoint(t)
      }
      divideAt(t, e = {}) {
        if (t <= 0) return this.divideAtT(0);
        if (t >= 1) return this.divideAtT(1);
        const n = this.tAt(t, e);
        return this.divideAtT(n)
      }
      divideAtLength(t, e = {}) {
        const n = this.tAtLength(t, e);
        return this.divideAtT(n)
      }
      divide(t) {
        return this.divideAtT(t)
      }
      divideAtT(t) {
        const e = this.start,
          n = this.controlPoint1,
          r = this.controlPoint2,
          i = this.end;
        if (t <= 0) return [new gC(e, e, e, e), new gC(e, n, r, i)];
        if (t >= 1) return [new gC(e, n, r, i), new gC(i, i, i, i)];
        const o = this.getSkeletonPoints(t),
          s = o.startControlPoint1,
          a = o.startControlPoint2,
          l = o.divider,
          c = o.dividerControlPoint1,
          h = o.dividerControlPoint2;
        return [new gC(e, s, a, l), new gC(l, c, h, i)]
      }
      endpointDistance() {
        return this.start.distance(this.end)
      }
      getSkeletonPoints(t) {
        const e = this.start,
          n = this.controlPoint1,
          r = this.controlPoint2,
          i = this.end;
        if (t <= 0) return {
          startControlPoint1: e.clone(),
          startControlPoint2: e.clone(),
          divider: e.clone(),
          dividerControlPoint1: n.clone(),
          dividerControlPoint2: r.clone()
        };
        if (t >= 1) return {
          startControlPoint1: n.clone(),
          startControlPoint2: r.clone(),
          divider: i.clone(),
          dividerControlPoint1: i.clone(),
          dividerControlPoint2: i.clone()
        };
        const o = new dC(e, n).pointAt(t),
          s = new dC(n, r).pointAt(t),
          a = new dC(r, i).pointAt(t),
          l = new dC(o, s).pointAt(t),
          c = new dC(s, a).pointAt(t);
        return {
          startControlPoint1: o,
          startControlPoint2: l,
          divider: new dC(l, c).pointAt(t),
          dividerControlPoint1: c,
          dividerControlPoint2: a
        }
      }
      getSubdivisions(t = {}) {
        const e = this.getPrecision(t);
        let n = [new gC(this.start, this.controlPoint1, this.controlPoint2, this.end)];
        if (0 === e) return n;
        let r = this.endpointDistance();
        const i = Math.pow(10, -e);
        let o = 0;
        for (;;) {
          o += 1;
          const t = [];
          n.forEach(e => {
            const n = e.divide(.5);
            t.push(n[0], n[1])
          });
          const e = t.reduce((t, e) => t + e.endpointDistance(), 0);
          if (o > 1 && (0 !== e ? (e - r) / e : 0) < i) return t;
          n = t, r = e
        }
      }
      length(t = {}) {
        return this.getDivisions(t).reduce((t, e) => t + e.endpointDistance(), 0)
      }
      lengthAtT(t, e = {}) {
        if (t <= 0) return 0;
        const n = void 0 === e.precision ? this.PRECISION : e.precision;
        return this.divide(t)[0].length({
          precision: n
        })
      }
      pointAt(t, e = {}) {
        if (t <= 0) return this.start.clone();
        if (t >= 1) return this.end.clone();
        const n = this.tAt(t, e);
        return this.pointAtT(n)
      }
      pointAtLength(t, e = {}) {
        const n = this.tAtLength(t, e);
        return this.pointAtT(n)
      }
      pointAtT(t) {
        return t <= 0 ? this.start.clone() : t >= 1 ? this.end.clone() : this.getSkeletonPoints(t).divider
      }
      isDifferentiable() {
        const t = this.start,
          e = this.controlPoint1,
          n = this.controlPoint2,
          r = this.end;
        return !(t.equals(e) && e.equals(n) && n.equals(r))
      }
      tangentAt(t, e = {}) {
        if (!this.isDifferentiable()) return null;
        t < 0 ? t = 0 : t > 1 && (t = 1);
        const n = this.tAt(t, e);
        return this.tangentAtT(n)
      }
      tangentAtLength(t, e = {}) {
        if (!this.isDifferentiable()) return null;
        const n = this.tAtLength(t, e);
        return this.tangentAtT(n)
      }
      tangentAtT(t) {
        if (!this.isDifferentiable()) return null;
        t < 0 && (t = 0), t > 1 && (t = 1);
        const e = this.getSkeletonPoints(t),
          n = e.startControlPoint2,
          r = e.dividerControlPoint1,
          i = e.divider,
          o = new dC(n, r);
        return o.translate(i.x - n.x, i.y - n.y), o
      }
      getPrecision(t = {}) {
        return null == t.precision ? this.PRECISION : t.precision
      }
      getDivisions(t = {}) {
        if (null != t.subdivisions) return t.subdivisions;
        const e = this.getPrecision(t);
        return this.getSubdivisions({
          precision: e
        })
      }
      getOptions(t = {}) {
        return {
          precision: this.getPrecision(t),
          subdivisions: this.getDivisions(t)
        }
      }
      tAt(t, e = {}) {
        if (t <= 0) return 0;
        if (t >= 1) return 1;
        const n = this.getOptions(e),
          r = this.length(n) * t;
        return this.tAtLength(r, n)
      }
      tAtLength(t, e = {}) {
        let n = !0;
        t < 0 && (n = !1, t = -t);
        const r = this.getPrecision(e),
          i = this.getDivisions(e),
          o = {
            precision: r,
            subdivisions: i
          };
        let s, a, l = null,
          c = 0,
          h = 0,
          u = 0;
        const d = i.length;
        let p = d > 0 ? 1 / d : 0;
        for (let e = 0; e < d; e += 1) {
          const r = n ? e : d - 1 - e,
            o = i[e],
            f = o.endpointDistance();
          if (t <= u + f) {
            l = o, s = r * p, a = (r + 1) * p, c = n ? t - u : f + u - t, h = n ? f + u - t : t - u;
            break
          }
          u += f
        }
        if (null == l) return n ? 1 : 0;
        const f = this.length(o),
          g = Math.pow(10, -r);
        for (;;) {
          let t, e, n;
          if ((t = 0 !== f ? c / f : 0) < g) return s;
          if ((t = 0 !== f ? h / f : 0) < g) return a;
          const r = l.divide(.5);
          p /= 2;
          const i = r[0].endpointDistance(),
            o = r[1].endpointDistance();
          c <= i ? (l = r[0], a -= p, n = i - (e = c)) : (l = r[1], s += p, n = o - (e = c - i)), c = e, h = n
        }
      }
      toPoints(t = {}) {
        const e = this.getDivisions(t),
          n = [e[0].start.clone()];
        return e.forEach(t => n.push(t.end.clone())), n
      }
      toPolyline(t = {}) {
        return new fC(this.toPoints(t))
      }
      scale(t, e, n) {
        return this.start.scale(t, e, n), this.controlPoint1.scale(t, e, n), this.controlPoint2.scale(t, e, n),
          this.end.scale(t, e, n), this
      }
      translate(t, e) {
        return "number" == typeof t ? (this.start.translate(t, e), this.controlPoint1.translate(t, e), this.controlPoint2
          .translate(t, e), this.end.translate(t, e)) : (this.start.translate(t), this.controlPoint1.translate(
          t), this.controlPoint2.translate(t), this.end.translate(t)), this
      }
      equals(t) {
        return null != t && this.start.equals(t.start) && this.controlPoint1.equals(t.controlPoint1) && this.controlPoint2
          .equals(t.controlPoint2) && this.end.equals(t.end)
      }
      clone() {
        return new gC(this.start, this.controlPoint1, this.controlPoint2, this.end)
      }
      toJSON() {
        return {
          start: this.start.toJSON(),
          controlPoint1: this.controlPoint1.toJSON(),
          controlPoint2: this.controlPoint2.toJSON(),
          end: this.end.toJSON()
        }
      }
      serialize() {
        return [this.start.serialize(), this.controlPoint1.serialize(), this.controlPoint2.serialize(), this.end
          .serialize()
        ].join(" ")
      }
    }! function(t) {
      function e(t) {
        const e = t.length,
          n = [],
          r = [];
        let i = 2;
        n[0] = t[0] / i;
        for (let o = 1; o < e; o += 1) r[o] = 1 / i, i = (o < e - 1 ? 4 : 3.5) - r[o], n[o] = (t[o] - n[o - 1]) /
          i;
        for (let t = 1; t < e; t += 1) n[e - t - 1] -= r[e - t] * n[e - t];
        return n
      }
      t.throughPoints = function(n) {
        if (null == n || Array.isArray(n) && n.length < 2) throw new Error("At least 2 points are required");
        const r = function(t) {
            const n = t.map(t => hC.clone(t)),
              r = [],
              i = [],
              o = n.length - 1;
            if (1 === o) return r[0] = new hC((2 * n[0].x + n[1].x) / 3, (2 * n[0].y + n[1].y) / 3), i[0] = new hC(
              2 * r[0].x - n[0].x, 2 * r[0].y - n[0].y), [r, i];
            const s = [];
            for (let t = 1; t < o - 1; t += 1) s[t] = 4 * n[t].x + 2 * n[t + 1].x;
            s[0] = n[0].x + 2 * n[1].x, s[o - 1] = (8 * n[o - 1].x + n[o].x) / 2;
            const a = e(s);
            for (let t = 1; t < o - 1; t += 1) s[t] = 4 * n[t].y + 2 * n[t + 1].y;
            s[0] = n[0].y + 2 * n[1].y, s[o - 1] = (8 * n[o - 1].y + n[o].y) / 2;
            const l = e(s);
            for (let t = 0; t < o; t += 1) r.push(new hC(a[t], l[t])), t < o - 1 ? i.push(new hC(2 * n[t + 1].x -
              a[t + 1], 2 * n[t + 1].y - l[t + 1])) : i.push(new hC((n[o].x + a[o - 1]) / 2, (n[o].y + l[o -
              1]) / 2));
            return [r, i]
          }(n),
          i = [];
        for (let e = 0, o = r[0].length; e < o; e += 1) {
          const o = new hC(r[0][e].x, r[0][e].y),
            s = new hC(r[1][e].x, r[1][e].y);
          i.push(new t(n[e], o, s, n[e + 1]))
        }
        return i
      }
    }(gC || (gC = {}));
    class mC extends cC {
      constructor() {
        super(...arguments), this.isVisible = !0, this.isSegment = !0, this.isSubpathStart = !1
      }
      get end() {
        return this.endPoint
      }
      get start() {
        if (null == this.previousSegment) throw new Error(
          "Missing previous segment. (This segment cannot be the first segment of a path, or segment has not yet been added to a path.)"
        );
        return this.previousSegment.end
      }
      closestPointT(t, e) {
        if (this.closestPointNormalizedLength) return this.closestPointNormalizedLength(t);
        throw new Error("Neither `closestPointT` nor `closestPointNormalizedLength` method is implemented.")
      }
      lengthAtT(t, e) {
        if (t <= 0) return 0;
        const n = this.length();
        return t >= 1 ? n : n * t
      }
      divideAtT(t) {
        if (this.divideAt) return this.divideAt(t);
        throw new Error("Neither `divideAtT` nor `divideAt` method is implemented.")
      }
      pointAtT(t) {
        if (this.pointAt) return this.pointAt(t);
        throw new Error("Neither `pointAtT` nor `pointAt` method is implemented.")
      }
      tangentAtT(t) {
        if (this.tangentAt) return this.tangentAt(t);
        throw new Error("Neither `tangentAtT` nor `tangentAt` method is implemented.")
      }
    }
    class vC extends mC {
      constructor(t, e) {
        super(), this.endPoint = t instanceof dC ? t.end.clone() : hC.create(t, e)
      }
      get type() {
        return "L"
      }
      get line() {
        return new dC(this.start, this.end)
      }
      bbox() {
        return this.line.bbox()
      }
      closestPoint(t) {
        return this.line.closestPoint(t)
      }
      closestPointLength(t) {
        return this.line.closestPointLength(t)
      }
      closestPointNormalizedLength(t) {
        return this.line.closestPointNormalizedLength(t)
      }
      closestPointTangent(t) {
        return this.line.closestPointTangent(t)
      }
      length() {
        return this.line.length()
      }
      divideAt(t) {
        const e = this.line.divideAt(t);
        return [new vC(e[0]), new vC(e[1])]
      }
      divideAtLength(t) {
        const e = this.line.divideAtLength(t);
        return [new vC(e[0]), new vC(e[1])]
      }
      getSubdivisions() {
        return []
      }
      pointAt(t) {
        return this.line.pointAt(t)
      }
      pointAtLength(t) {
        return this.line.pointAtLength(t)
      }
      tangentAt(t) {
        return this.line.tangentAt(t)
      }
      tangentAtLength(t) {
        return this.line.tangentAtLength(t)
      }
      isDifferentiable() {
        return null != this.previousSegment && !this.start.equals(this.end)
      }
      clone() {
        return new vC(this.end)
      }
      scale(t, e, n) {
        return this.end.scale(t, e, n), this
      }
      translate(t, e) {
        return "number" == typeof t ? this.end.translate(t, e) : this.end.translate(t), this
      }
      equals(t) {
        return this.type === t.type && this.start.equals(t.start) && this.end.equals(t.end)
      }
      toJSON() {
        return {
          type: this.type,
          start: this.start.toJSON(),
          end: this.end.toJSON()
        }
      }
      serialize() {
        const t = this.end;
        return `${this.type} ${t.x} ${t.y}`
      }
    }! function(t) {
      t.create = function(...e) {
        const n = e.length,
          r = e[0];
        if (r instanceof dC) return new t(r);
        if (hC.isPointLike(r)) return 1 === n ? new t(r) : e.map(e => new t(e));
        if (2 === n) return new t(+e[0], +e[1]);
        const i = [];
        for (let r = 0; r < n; r += 2) {
          const n = +e[r],
            o = +e[r + 1];
          i.push(new t(n, o))
        }
        return i
      }
    }(vC || (vC = {}));
    class yC extends mC {
      get end() {
        if (!this.subpathStartSegment) throw new Error(
          "Missing subpath start segment. (This segment needs a subpath start segment (e.g. MoveTo), or segment has not yet been added to a path.)"
        );
        return this.subpathStartSegment.end
      }
      get type() {
        return "Z"
      }
      get line() {
        return new dC(this.start, this.end)
      }
      bbox() {
        return this.line.bbox()
      }
      closestPoint(t) {
        return this.line.closestPoint(t)
      }
      closestPointLength(t) {
        return this.line.closestPointLength(t)
      }
      closestPointNormalizedLength(t) {
        return this.line.closestPointNormalizedLength(t)
      }
      closestPointTangent(t) {
        return this.line.closestPointTangent(t)
      }
      length() {
        return this.line.length()
      }
      divideAt(t) {
        const e = this.line.divideAt(t);
        return [e[1].isDifferentiable() ? new vC(e[0]) : this.clone(), new vC(e[1])]
      }
      divideAtLength(t) {
        const e = this.line.divideAtLength(t);
        return [e[1].isDifferentiable() ? new vC(e[0]) : this.clone(), new vC(e[1])]
      }
      getSubdivisions() {
        return []
      }
      pointAt(t) {
        return this.line.pointAt(t)
      }
      pointAtLength(t) {
        return this.line.pointAtLength(t)
      }
      tangentAt(t) {
        return this.line.tangentAt(t)
      }
      tangentAtLength(t) {
        return this.line.tangentAtLength(t)
      }
      isDifferentiable() {
        return !(!this.previousSegment || !this.subpathStartSegment) && !this.start.equals(this.end)
      }
      scale() {
        return this
      }
      translate() {
        return this
      }
      equals(t) {
        return this.type === t.type && this.start.equals(t.start) && this.end.equals(t.end)
      }
      clone() {
        return new yC
      }
      toJSON() {
        return {
          type: this.type,
          start: this.start.toJSON(),
          end: this.end.toJSON()
        }
      }
      serialize() {
        return this.type
      }
    }! function(t) {
      t.create = function() {
        return new t
      }
    }(yC || (yC = {}));
    class bC extends mC {
      constructor(t, e) {
        super(), this.isVisible = !1, this.isSubpathStart = !0, this.endPoint = t instanceof dC || t instanceof gC ?
          t.end.clone() : hC.create(t, e)
      }
      get start() {
        throw new Error("Illegal access. Moveto segments should not need a start property.")
      }
      get type() {
        return "M"
      }
      bbox() {
        return null
      }
      closestPoint() {
        return this.end.clone()
      }
      closestPointLength() {
        return 0
      }
      closestPointNormalizedLength() {
        return 0
      }
      closestPointT() {
        return 1
      }
      closestPointTangent() {
        return null
      }
      length() {
        return 0
      }
      lengthAtT() {
        return 0
      }
      divideAt() {
        return [this.clone(), this.clone()]
      }
      divideAtLength() {
        return [this.clone(), this.clone()]
      }
      getSubdivisions() {
        return []
      }
      pointAt() {
        return this.end.clone()
      }
      pointAtLength() {
        return this.end.clone()
      }
      pointAtT() {
        return this.end.clone()
      }
      tangentAt() {
        return null
      }
      tangentAtLength() {
        return null
      }
      tangentAtT() {
        return null
      }
      isDifferentiable() {
        return !1
      }
      scale(t, e, n) {
        return this.end.scale(t, e, n), this
      }
      translate(t, e) {
        return "number" == typeof t ? this.end.translate(t, e) : this.end.translate(t), this
      }
      clone() {
        return new bC(this.end)
      }
      equals(t) {
        return this.type === t.type && this.end.equals(t.end)
      }
      toJSON() {
        return {
          type: this.type,
          end: this.end.toJSON()
        }
      }
      serialize() {
        const t = this.end;
        return `${this.type} ${t.x} ${t.y}`
      }
    }! function(t) {
      t.create = function(...e) {
        const n = e.length,
          r = e[0];
        if (r instanceof dC) return new t(r);
        if (r instanceof gC) return new t(r);
        if (hC.isPointLike(r)) {
          if (1 === n) return new t(r);
          const i = [];
          for (let r = 0; r < n; r += 1) 0 === r ? i.push(new t(e[r])) : i.push(new vC(e[r]));
          return i
        }
        if (2 === n) return new t(+e[0], +e[1]);
        const i = [];
        for (let r = 0; r < n; r += 2) {
          const n = +e[r],
            o = +e[r + 1];
          0 === r ? i.push(new t(n, o)) : i.push(new vC(n, o))
        }
        return i
      }
    }(bC || (bC = {}));
    class CC extends mC {
      constructor(t, e, n, r, i, o) {
        super(), t instanceof gC ? (this.controlPoint1 = t.controlPoint1.clone(), this.controlPoint2 = t.controlPoint2
          .clone(), this.endPoint = t.end.clone()) : "number" == typeof t ? (this.controlPoint1 = new hC(t, e),
          this.controlPoint2 = new hC(n, r), this.endPoint = new hC(i, o)) : (this.controlPoint1 = hC.create(
          t), this.controlPoint2 = hC.create(e), this.endPoint = hC.create(n))
      }
      get end() {
        return this.endPoint
      }
      get type() {
        return "C"
      }
      get curve() {
        return new gC(this.start, this.controlPoint1, this.controlPoint2, this.end)
      }
      bbox() {
        return this.curve.bbox()
      }
      closestPoint(t) {
        return this.curve.closestPoint(t)
      }
      closestPointLength(t) {
        return this.curve.closestPointLength(t)
      }
      closestPointNormalizedLength(t) {
        return this.curve.closestPointNormalizedLength(t)
      }
      closestPointTangent(t) {
        return this.curve.closestPointTangent(t)
      }
      length() {
        return this.curve.length()
      }
      divideAt(t, e = {}) {
        const n = this.curve.divideAt(t, e);
        return [new CC(n[0]), new CC(n[1])]
      }
      divideAtLength(t, e = {}) {
        const n = this.curve.divideAtLength(t, e);
        return [new CC(n[0]), new CC(n[1])]
      }
      divideAtT(t) {
        const e = this.curve.divideAtT(t);
        return [new CC(e[0]), new CC(e[1])]
      }
      getSubdivisions() {
        return []
      }
      pointAt(t) {
        return this.curve.pointAt(t)
      }
      pointAtLength(t) {
        return this.curve.pointAtLength(t)
      }
      tangentAt(t) {
        return this.curve.tangentAt(t)
      }
      tangentAtLength(t) {
        return this.curve.tangentAtLength(t)
      }
      isDifferentiable() {
        if (!this.previousSegment) return !1;
        const t = this.start,
          e = this.controlPoint1,
          n = this.controlPoint2,
          r = this.end;
        return !(t.equals(e) && e.equals(n) && n.equals(r))
      }
      scale(t, e, n) {
        return this.controlPoint1.scale(t, e, n), this.controlPoint2.scale(t, e, n), this.end.scale(t, e, n),
          this
      }
      translate(t, e) {
        return "number" == typeof t ? (this.controlPoint1.translate(t, e), this.controlPoint2.translate(t, e),
          this.end.translate(t, e)) : (this.controlPoint1.translate(t), this.controlPoint2.translate(t), this
          .end.translate(t)), this
      }
      equals(t) {
        return this.start.equals(t.start) && this.end.equals(t.end) && this.controlPoint1.equals(t.controlPoint1) &&
          this.controlPoint2.equals(t.controlPoint2)
      }
      clone() {
        return new CC(this.controlPoint1, this.controlPoint2, this.end)
      }
      toJSON() {
        return {
          type: this.type,
          start: this.start.toJSON(),
          controlPoint1: this.controlPoint1.toJSON(),
          controlPoint2: this.controlPoint2.toJSON(),
          end: this.end.toJSON()
        }
      }
      serialize() {
        const t = this.controlPoint1,
          e = this.controlPoint2,
          n = this.end;
        return [this.type, t.x, t.y, e.x, e.y, n.x, n.y].join(" ")
      }
    }! function(t) {
      t.create = function(...e) {
        const n = e.length,
          r = e[0];
        if (r instanceof gC) return new t(r);
        if (hC.isPointLike(r)) {
          if (3 === n) return new t(e[0], e[1], e[2]);
          const r = [];
          for (let i = 0; i < n; i += 3) r.push(new t(e[i], e[i + 1], e[i + 2]));
          return r
        }
        if (6 === n) return new t(e[0], e[1], e[2], e[3], e[4], e[5]);
        const i = [];
        for (let r = 0; r < n; r += 6) i.push(new t(e[r], e[r + 1], e[r + 2], e[r + 3], e[r + 4], e[r + 5]));
        return i
      }
    }(CC || (CC = {}));
    const xC = "\t\n\v\f\r   ᠎             　\u2028\u2029",
      wC = new RegExp("([a-z])[" + xC + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + xC + "]*,?[" + xC + "]*)+)",
        "ig"),
      AC = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + xC + "]*,?[" + xC + "]*", "ig");

    function EC(t, e, n) {
      return {
        x: t * Math.cos(n) - e * Math.sin(n),
        y: t * Math.sin(n) + e * Math.cos(n)
      }
    }

    function SC(t, e, n, r, i, o) {
      return [1 / 3 * t + 2 / 3 * n, 1 / 3 * e + 2 / 3 * r, 1 / 3 * i + 2 / 3 * n, 1 / 3 * o + 2 / 3 * r, i, o]
    }

    function MC(t) {
      const e = function(t) {
        if (!t) return null;
        const e = {
            a: 7,
            c: 6,
            h: 1,
            l: 2,
            m: 2,
            q: 4,
            s: 4,
            t: 2,
            v: 1,
            z: 0
          },
          n = [];
        return t.replace(wC, (t, r, i) => {
          const o = [];
          let s = r.toLowerCase();
          i.replace(AC, (t, e) => (e && o.push(+e), t)), "m" === s && o.length > 2 && (n.push([r, ...o.splice(
            0, 2)]), s = "l", r = "m" === r ? "l" : "L");
          const a = e[s];
          for (; o.length >= a && (n.push([r, ...o.splice(0, a)]), a););
          return t
        }), n
      }(t);
      if (!e || !e.length) return [
        ["M", 0, 0]
      ];
      const n = [];
      let r = 0,
        i = 0,
        o = 0,
        s = 0;
      for (let t = 0, a = e.length; t < a; t += 1) {
        const a = [];
        n.push(a);
        const l = e[t],
          c = l[0];
        if (c !== c.toUpperCase()) {
          let t, e;
          switch (a[0] = c.toUpperCase(), a[0]) {
            case "A":
              a[1] = l[1], a[2] = l[2], a[3] = l[3], a[4] = l[4], a[5] = l[5], a[6] = +l[6] + r, a[7] = +l[7] + i;
              break;
            case "V":
              a[1] = +l[1] + i;
              break;
            case "H":
              a[1] = +l[1] + r;
              break;
            case "M":
              for (o = +l[1] + r, s = +l[2] + i, e = 1, t = l.length; e < t; e += 1) a[e] = +l[e] + (e % 2 ? r :
                i);
              break;
            default:
              for (e = 1, t = l.length; e < t; e += 1) a[e] = +l[e] + (e % 2 ? r : i)
          }
        } else
          for (let t = 0, e = l.length; t < e; t += 1) a[t] = l[t];
        switch (a[0]) {
          case "Z":
            r = +o, i = +s;
            break;
          case "H":
            r = a[1];
            break;
          case "V":
            i = a[1];
            break;
          case "M":
            o = a[a.length - 2], s = a[a.length - 1], r = a[a.length - 2], i = a[a.length - 1];
            break;
          default:
            r = a[a.length - 2], i = a[a.length - 1]
        }
      }
      return n
    }

    function kC(t) {
      const e = MC(t),
        n = {
          x: 0,
          y: 0,
          bx: 0,
          by: 0,
          X: 0,
          Y: 0,
          qx: null,
          qy: null
        };

      function r(t, e, n) {
        let r, i;
        if (!t) return ["C", e.x, e.y, e.x, e.y, e.x, e.y];
        switch (t[0] in {
          T: 1,
          Q: 1
        } || (e.qx = null, e.qy = null), t[0]) {
          case "M":
            e.X = t[1], e.Y = t[2];
            break;
          case "A":
            return 0 === parseFloat(t[1]) || 0 === parseFloat(t[2]) ? ["L", t[6], t[7]] : ["C"].concat(function t(
              e, n, r, i, o, s, a, l, c, h) {
              const u = 120 * Math.PI / 180,
                d = Math.PI / 180 * (+o || 0);
              let p, f, g, m, v, y = [];
              if (h) f = h[0], g = h[1], m = h[2], v = h[3];
              else {
                e = (p = EC(e, n, -d)).x, n = p.y;
                const t = (e - (l = (p = EC(l, c, -d)).x)) / 2,
                  o = (n - (c = p.y)) / 2;
                let h = t * t / (r * r) + o * o / (i * i);
                h > 1 && (r *= h = Math.sqrt(h), i *= h);
                const u = r * r,
                  y = i * i,
                  b = (s === a ? -1 : 1) * Math.sqrt(Math.abs((u * y - u * o * o - y * t * t) / (u * o * o +
                    y * t * t)));
                m = b * r * o / i + (e + l) / 2, v = b * -i * t / r + (n + c) / 2, f = Math.asin(+((n - v) /
                    i).toFixed(9)), g = Math.asin(+((c - v) / i).toFixed(9)), f = e < m ? Math.PI - f : f, g =
                  l < m ? Math.PI - g : g, f < 0 && (f = 2 * Math.PI + f), g < 0 && (g = 2 * Math.PI + g), a &&
                  f > g && (f -= 2 * Math.PI), !a && g > f && (g -= 2 * Math.PI)
              }
              let b = g - f;
              if (Math.abs(b) > u) {
                const e = g,
                  n = l,
                  s = c;
                g = f + u * (a && g > f ? 1 : -1), y = t(l = m + r * Math.cos(g), c = v + i * Math.sin(g), r,
                  i, o, 0, a, n, s, [g, e, m, v])
              }
              b = g - f;
              const C = Math.cos(f),
                x = Math.sin(f),
                w = Math.cos(g),
                A = Math.sin(g),
                E = Math.tan(b / 4),
                S = 4 / 3 * (r * E),
                M = 4 / 3 * (i * E),
                k = [e, n],
                O = [e + S * x, n - M * C],
                P = [l + S * A, c - M * w],
                D = [l, c];
              if (O[0] = 2 * k[0] - O[0], O[1] = 2 * k[1] - O[1], h) return [O, P, D].concat(y); {
                const t = [],
                  e = (y = [O, P, D].concat(y).join().split(",")).length;
                for (let n = 0; n < e; n += 1) t[n] = n % 2 ? EC(+y[n - 1], +y[n], d).y : EC(+y[n], +y[n + 1],
                  d).x;
                return t
              }
            }.apply(0, [e.x, e.y].concat(t.slice(1))));
          case "S":
            return "C" === n || "S" === n ? (r = 2 * e.x - e.bx, i = 2 * e.y - e.by) : (r = e.x, i = e.y), ["C",
              r, i
            ].concat(t.slice(1));
          case "T":
            return "Q" === n || "T" === n ? (e.qx = 2 * e.x - e.qx, e.qy = 2 * e.y - e.qy) : (e.qx = e.x, e.qy =
              e.y), ["C"].concat(SC(e.x, e.y, e.qx, e.qy, t[1], t[2]));
          case "Q":
            return e.qx = t[1], e.qy = t[2], ["C"].concat(SC(e.x, e.y, t[1], t[2], t[3], t[4]));
          case "H":
            return ["L"].concat(t[1], e.y);
          case "V":
            return ["L"].concat(e.x, t[1])
        }
        return t
      }

      function i(t, n) {
        if (t[n].length > 7) {
          t[n].shift();
          const r = t[n];
          for (; r.length;) o[n] = "A", n += 1, t.splice(n, 0, ["C"].concat(r.splice(0, 6)));
          t.splice(n, 1), a = e.length
        }
      }
      const o = [];
      let s = "",
        a = e.length;
      for (let t = 0; t < a; t += 1) {
        let a = "";
        e[t] && (a = e[t][0]), "C" !== a && (o[t] = a, t > 0 && (s = o[t - 1])), e[t] = r(e[t], n, s), "A" !== o[
          t] && "C" === a && (o[t] = "C"), i(e, t);
        const l = e[t],
          c = l.length;
        n.x = l[c - 2], n.y = l[c - 1], n.bx = parseFloat(l[c - 4]) || n.x, n.by = parseFloat(l[c - 3]) || n.y
      }
      return e[0][0] && "M" === e[0][0] || e.unshift(["M", 0, 0]), e
    }

    function OC(t) {
      return kC(t).join(",").split(",").join(" ")
    }
    class PC extends cC {
      constructor(t) {
        if (super(), this.PRECISION = 3, this.segments = [], Array.isArray(t))
          if (t[0] instanceof dC || t[0] instanceof gC) {
            let e = null;
            t.forEach((t, n) => {
              0 === n && this.appendSegment(PC.createSegment("M", t.start)), null == e || e.end.equals(t.start) ||
                this.appendSegment(PC.createSegment("M", t.start)), t instanceof dC ? this.appendSegment(PC
                  .createSegment("L", t.end)) : t instanceof gC && this.appendSegment(PC.createSegment("C",
                  t.controlPoint1, t.controlPoint2, t.end)), e = t
            })
          } else {
            t.forEach(t => {
              t.isSegment && this.appendSegment(t)
            })
          }
        else null != t && (t instanceof dC ? (this.appendSegment(PC.createSegment("M", t.start)), this.appendSegment(
            PC.createSegment("L", t.end))) : t instanceof gC ? (this.appendSegment(PC.createSegment("M", t.start)),
            this.appendSegment(PC.createSegment("C", t.controlPoint1, t.controlPoint2, t.end))) : t instanceof fC ?
          t.points && t.points.length && t.points.forEach((t, e) => {
            const n = 0 === e ? PC.createSegment("M", t) : PC.createSegment("L", t);
            this.appendSegment(n)
          }) : t.isSegment && this.appendSegment(t))
      }
      get start() {
        const t = this.segments,
          e = t.length;
        if (0 === e) return null;
        for (let n = 0; n < e; n += 1) {
          const e = t[n];
          if (e.isVisible) return e.start
        }
        return t[e - 1].end
      }
      get end() {
        const t = this.segments,
          e = t.length;
        if (0 === e) return null;
        for (let n = e - 1; n >= 0; n -= 1) {
          const e = t[n];
          if (e.isVisible) return e.end
        }
        return t[e - 1].end
      }
      moveTo(...t) {
        return this.appendSegment(bC.create.call(null, ...t))
      }
      lineTo(...t) {
        return this.appendSegment(vC.create.call(null, ...t))
      }
      curveTo(...t) {
        return this.appendSegment(CC.create.call(null, ...t))
      }
      close() {
        return this.appendSegment(yC.create())
      }
      bbox() {
        const t = this.segments,
          e = t.length;
        if (0 === e) return null;
        let n;
        for (let r = 0; r < e; r += 1) {
          const e = t[r];
          if (e.isVisible) {
            const t = e.bbox();
            null != t && (n = n ? n.union(t) : t)
          }
        }
        if (null != n) return n;
        const r = t[e - 1];
        return new uC(r.end.x, r.end.y, 0, 0)
      }
      appendSegment(t) {
        const e = this.segments.length;
        let n, r = 0 !== e ? this.segments[e - 1] : null;
        if (Array.isArray(t))
          for (let e = 0, i = t.length; e < i; e += 1) {
            const i = t[e];
            n = this.prepareSegment(i, r, null), this.segments.push(n), r = n
          } else null != t && t.isSegment && (n = this.prepareSegment(t, r, null), this.segments.push(n));
        return this
      }
      insertSegment(t, e) {
        const n = this.segments.length;
        if (t < 0 && (t = n + t + 1), t > n || t < 0) throw new Error("Index out of range.");
        let r, i = null,
          o = null;
        if (0 !== n && (t >= 1 ? o = (i = this.segments[t - 1]).nextSegment : (i = null, o = this.segments[0])),
          Array.isArray(e))
          for (let n = 0, s = e.length; n < s; n += 1) {
            const s = e[n];
            r = this.prepareSegment(s, i, o), this.segments.splice(t + n, 0, r), i = r
          } else r = this.prepareSegment(e, i, o), this.segments.splice(t, 0, r);
        return this
      }
      removeSegment(t) {
        const e = this.fixIndex(t),
          n = this.segments.splice(e, 1)[0],
          r = n.previousSegment,
          i = n.nextSegment;
        return r && (r.nextSegment = i), i && (i.previousSegment = r), n.isSubpathStart && i && this.updateSubpathStartSegment(
          i), n
      }
      replaceSegment(t, e) {
        const n = this.fixIndex(t);
        let r;
        const i = this.segments[n];
        let o = i.previousSegment;
        const s = i.nextSegment;
        let a = i.isSubpathStart;
        if (Array.isArray(e)) {
          this.segments.splice(t, 1);
          for (let n = 0, i = e.length; n < i; n += 1) {
            const i = e[n];
            r = this.prepareSegment(i, o, s), this.segments.splice(t + n, 0, r), o = r, a && r.isSubpathStart &&
              (a = !1)
          }
        } else r = this.prepareSegment(e, o, s), this.segments.splice(n, 1, r), a && r.isSubpathStart && (a = !
          1);
        a && s && this.updateSubpathStartSegment(s)
      }
      getSegment(t) {
        const e = this.fixIndex(t);
        return this.segments[e]
      }
      fixIndex(t) {
        const e = this.segments.length;
        if (0 === e) throw new Error("Path has no segments.");
        let n = t;
        for (; n < 0;) n = e + n;
        if (n >= e || n < 0) throw new Error("Index out of range.");
        return n
      }
      segmentAt(t, e = {}) {
        const n = this.segmentIndexAt(t, e);
        return n ? this.getSegment(n) : null
      }
      segmentAtLength(t, e = {}) {
        const n = this.segmentIndexAtLength(t, e);
        return n ? this.getSegment(n) : null
      }
      segmentIndexAt(t, e = {}) {
        if (0 === this.segments.length) return null;
        const n = oC(t, 0, 1),
          r = this.getOptions(e),
          i = this.length(r) * n;
        return this.segmentIndexAtLength(i, r)
      }
      segmentIndexAtLength(t, e = {}) {
        const n = this.segments.length;
        if (0 === n) return null;
        let r = !0;
        t < 0 && (r = !1, t = -t);
        const i = this.getPrecision(e),
          o = this.getSubdivisions(e);
        let s = 0,
          a = null;
        for (let e = 0; e < n; e += 1) {
          const l = r ? e : n - 1 - e,
            c = this.segments[l],
            h = o[l],
            u = c.length({
              precision: i,
              subdivisions: h
            });
          if (c.isVisible) {
            if (t <= s + u) return l;
            a = l
          }
          s += u
        }
        return a
      }
      getSegmentSubdivisions(t = {}) {
        const e = this.getPrecision(t),
          n = [];
        for (let t = 0, r = this.segments.length; t < r; t += 1) {
          const r = this.segments[t].getSubdivisions({
            precision: e
          });
          n.push(r)
        }
        return n
      }
      updateSubpathStartSegment(t) {
        let e = t.previousSegment,
          n = t;
        for (; n && !n.isSubpathStart;) n.subpathStartSegment = null != e ? e.subpathStartSegment : null, e = n,
          n = n.nextSegment
      }
      prepareSegment(t, e, n) {
        t.previousSegment = e, t.nextSegment = n, null != e && (e.nextSegment = t), null != n && (n.previousSegment =
          t);
        let r = t;
        return t.isSubpathStart && (t.subpathStartSegment = t, r = n), null != r && this.updateSubpathStartSegment(
          r), t
      }
      closestPoint(t, e = {}) {
        const n = this.closestPointT(t, e);
        return n ? this.pointAtT(n) : null
      }
      closestPointLength(t, e = {}) {
        const n = this.getOptions(e),
          r = this.closestPointT(t, n);
        return r ? this.lengthAtT(r, n) : 0
      }
      closestPointNormalizedLength(t, e = {}) {
        const n = this.getOptions(e),
          r = this.closestPointLength(t, n);
        if (0 === r) return 0;
        const i = this.length(n);
        return 0 === i ? 0 : r / i
      }
      closestPointT(t, e = {}) {
        if (0 === this.segments.length) return null;
        const n = this.getPrecision(e),
          r = this.getSubdivisions(e);
        let i, o = 1 / 0;
        for (let e = 0, s = this.segments.length; e < s; e += 1) {
          const s = this.segments[e],
            a = r[e];
          if (s.isVisible) {
            const r = s.closestPointT(t, {
                precision: n,
                subdivisions: a
              }),
              l = lC(s.pointAtT(r), t);
            l < o && (i = {
              segmentIndex: e,
              value: r
            }, o = l)
          }
        }
        return i || {
          segmentIndex: this.segments.length - 1,
          value: 1
        }
      }
      closestPointTangent(t, e = {}) {
        if (0 === this.segments.length) return null;
        const n = this.getPrecision(e),
          r = this.getSubdivisions(e);
        let i, o = 1 / 0;
        for (let e = 0, s = this.segments.length; e < s; e += 1) {
          const s = this.segments[e],
            a = r[e];
          if (s.isDifferentiable()) {
            const e = s.closestPointT(t, {
                precision: n,
                subdivisions: a
              }),
              r = lC(s.pointAtT(e), t);
            r < o && (i = s.tangentAtT(e), o = r)
          }
        }
        return i || null
      }
      containsPoint(t, e = {}) {
        const n = this.toPolylines(e);
        if (!n) return !1;
        let r = 0;
        for (let e = 0, i = n.length; e < i; e += 1) {
          n[e].containsPoint(t) && (r += 1)
        }
        return r % 2 == 1
      }
      pointAt(t, e = {}) {
        if (0 === this.segments.length) return null;
        if (t <= 0) return this.start.clone();
        if (t >= 1) return this.end.clone();
        const n = this.getOptions(e),
          r = this.length(n) * t;
        return this.pointAtLength(r, n)
      }
      pointAtLength(t, e = {}) {
        if (0 === this.segments.length) return null;
        if (0 === t) return this.start.clone();
        let n = !0;
        t < 0 && (n = !1, t = -t);
        const r = this.getPrecision(e),
          i = this.getSubdivisions(e);
        let o, s = 0;
        for (let e = 0, a = this.segments.length; e < a; e += 1) {
          const l = n ? e : a - 1 - e,
            c = this.segments[l],
            h = i[l],
            u = c.length({
              precision: r,
              subdivisions: h
            });
          if (c.isVisible) {
            if (t <= s + u) return c.pointAtLength((n ? 1 : -1) * (t - s), {
              precision: r,
              subdivisions: h
            });
            o = c
          }
          s += u
        }
        if (o) return n ? o.end : o.start;
        return this.segments[this.segments.length - 1].end.clone()
      }
      pointAtT(t) {
        const e = this.segments,
          n = e.length;
        if (0 === n) return null;
        const r = t.segmentIndex;
        if (r < 0) return e[0].pointAtT(0);
        if (r >= n) return e[n - 1].pointAtT(1);
        const i = oC(t.value, 0, 1);
        return e[r].pointAtT(i)
      }
      divideAt(t, e = {}) {
        if (0 === this.segments.length) return null;
        const n = oC(t, 0, 1),
          r = this.getOptions(e),
          i = this.length(r) * n;
        return this.divideAtLength(i, r)
      }
      divideAtLength(t, e = {}) {
        if (0 === this.segments.length) return null;
        let n = !0;
        t < 0 && (n = !1, t = -t);
        const r = this.getPrecision(e),
          i = this.getSubdivisions(e);
        let o, s, a, l, c, h = 0;
        for (let e = 0, c = this.segments.length; e < c; e += 1) {
          const u = n ? e : c - 1 - e,
            d = this.getSegment(u),
            p = {
              precision: r,
              subdivisions: i[u]
            },
            f = d.length(p);
          if (d.isDifferentiable() && (a = d, l = u, t <= h + f)) {
            s = u, o = d.divideAtLength((n ? 1 : -1) * (t - h), p);
            break
          }
          h += f
        }
        if (!a) return null;
        o || (s = l, c = n ? 1 : 0, o = a.divideAtT(c));
        const u = this.clone(),
          d = s;
        u.replaceSegment(d, o);
        const p = d;
        let f = d + 1,
          g = d + 2;
        o[0].isDifferentiable() || (u.removeSegment(p), f -= 1, g -= 1);
        const m = u.getSegment(f).start;
        u.insertSegment(f, PC.createSegment("M", m)), g += 1, o[1].isDifferentiable() || (u.removeSegment(g - 1),
          g -= 1);
        const v = g - p - 1;
        for (let t = g, e = u.segments.length; t < e; t += 1) {
          const e = this.getSegment(t - v),
            n = u.getSegment(t);
          if ("Z" === n.type && !e.subpathStartSegment.end.equals(n.subpathStartSegment.end)) {
            const n = PC.createSegment("L", e.end);
            u.replaceSegment(t, n)
          }
        }
        return [new PC(u.segments.slice(0, f)), new PC(u.segments.slice(f))]
      }
      intersectionWithLine(t, e = {}) {
        const n = this.toPolylines(e);
        if (null == n) return null;
        let r = null;
        for (let e = 0, i = n.length; e < i; e += 1) {
          const i = n[e],
            o = t.intersect(i);
          o && (null == r && (r = []), Array.isArray(o) ? r.push(...o) : r.push(o))
        }
        return r
      }
      isDifferentiable() {
        for (let t = 0, e = this.segments.length; t < e; t += 1) {
          if (this.segments[t].isDifferentiable()) return !0
        }
        return !1
      }
      isValid() {
        const t = this.segments;
        return 0 === t.length || "M" === t[0].type
      }
      length(t = {}) {
        if (0 === this.segments.length) return 0;
        const e = this.getSubdivisions(t);
        let n = 0;
        for (let t = 0, r = this.segments.length; t < r; t += 1) {
          const r = this.segments[t],
            i = e[t];
          n += r.length({
            subdivisions: i
          })
        }
        return n
      }
      lengthAtT(t, e = {}) {
        const n = this.segments.length;
        if (0 === n) return 0;
        let r = t.segmentIndex;
        if (r < 0) return 0;
        let i = oC(t.value, 0, 1);
        r >= n && (r = n - 1, i = 1);
        const o = this.getPrecision(e),
          s = this.getSubdivisions(e);
        let a = 0;
        for (let t = 0; t < r; t += 1) {
          const e = this.segments[t],
            n = s[t];
          a += e.length({
            precision: o,
            subdivisions: n
          })
        }
        const l = this.segments[r],
          c = s[r];
        return a += l.lengthAtT(i, {
          precision: o,
          subdivisions: c
        })
      }
      tangentAt(t, e = {}) {
        if (0 === this.segments.length) return null;
        const n = oC(t, 0, 1),
          r = this.getOptions(e),
          i = this.length(r) * n;
        return this.tangentAtLength(i, r)
      }
      tangentAtLength(t, e = {}) {
        if (0 === this.segments.length) return null;
        let n = !0;
        t < 0 && (n = !1, t = -t);
        const r = this.getPrecision(e),
          i = this.getSubdivisions(e);
        let o, s = 0;
        for (let e = 0, a = this.segments.length; e < a; e += 1) {
          const l = n ? e : a - 1 - e,
            c = this.segments[l],
            h = i[l],
            u = c.length({
              precision: r,
              subdivisions: h
            });
          if (c.isDifferentiable()) {
            if (t <= s + u) return c.tangentAtLength((n ? 1 : -1) * (t - s), {
              precision: r,
              subdivisions: h
            });
            o = c
          }
          s += u
        }
        if (o) {
          const t = n ? 1 : 0;
          return o.tangentAtT(t)
        }
        return null
      }
      tangentAtT(t) {
        const e = this.segments.length;
        if (0 === e) return null;
        const n = t.segmentIndex;
        if (n < 0) return this.segments[0].tangentAtT(0);
        if (n >= e) return this.segments[e - 1].tangentAtT(1);
        const r = oC(t.value, 0, 1);
        return this.segments[n].tangentAtT(r)
      }
      getPrecision(t = {}) {
        return null == t.precision ? this.PRECISION : t.precision
      }
      getSubdivisions(t = {}) {
        if (null == t.segmentSubdivisions) {
          const e = this.getPrecision(t);
          return this.getSegmentSubdivisions({
            precision: e
          })
        }
        return t.segmentSubdivisions
      }
      getOptions(t = {}) {
        return {
          precision: this.getPrecision(t),
          segmentSubdivisions: this.getSubdivisions(t)
        }
      }
      toPoints(t = {}) {
        const e = this.segments,
          n = e.length;
        if (0 === n) return null;
        const r = this.getSubdivisions(t),
          i = [];
        let o = [];
        for (let t = 0; t < n; t += 1) {
          const n = e[t];
          if (n.isVisible) {
            const e = r[t];
            e.length > 0 ? e.forEach(t => o.push(t.start)) : o.push(n.start)
          } else o.length > 0 && (o.push(e[t - 1].end), i.push(o), o = [])
        }
        return o.length > 0 && (o.push(this.end), i.push(o)), i
      }
      toPolylines(t = {}) {
        const e = this.toPoints(t);
        return e ? e.map(t => new fC(t)) : null
      }
      scale(t, e, n) {
        return this.segments.forEach(r => r.scale(t, e, n)), this
      }
      translate(t, e) {
        return "number" == typeof t ? this.segments.forEach(n => n.translate(t, e)) : this.segments.forEach(e =>
          e.translate(t)), this
      }
      clone() {
        const t = new PC;
        return this.segments.forEach(e => t.appendSegment(e.clone())), t
      }
      equals(t) {
        if (null == t) return !1;
        const e = this.segments,
          n = t.segments,
          r = e.length;
        if (n.length !== r) return !1;
        for (let t = 0; t < r; t += 1) {
          const r = e[t],
            i = n[t];
          if (r.type !== i.type || !r.equals(i)) return !1
        }
        return !0
      }
      toJSON() {
        return this.segments.map(t => t.toJSON())
      }
      serialize() {
        if (!this.isValid()) throw new Error("Invalid path segments.");
        return this.segments.map(t => t.serialize()).join(" ")
      }
    }! function(t) {
      const e = new RegExp("^[\\s\\dLMCZz,.]*$");

      function n(t, ...e) {
        if ("M" === t) return bC.create.call(null, ...e);
        if ("L" === t) return vC.create.call(null, ...e);
        if ("C" === t) return CC.create.call(null, ...e);
        if ("z" === t || "Z" === t) return yC.create();
        throw new Error(`Invalid path segment type "${t}"`)
      }
      t.isSupported = function(t) {
        return "string" == typeof t && e.test(t)
      }, t.normalize = OC, t.parse = function(e) {
        if (!e) return new t;
        const r = new t,
          i = e.match(
            /(?:[a-zA-Z] *)(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)? *,? *)|(?:-?\.\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\d|-|\.)/g
          );
        if (null != i)
          for (let t = 0, e = i.length; t < e; t += 1) {
            const e = /(?:[a-zA-Z])|(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)?))|(?:(?:-?\.\d+))/g,
              o = i[t].match(e);
            if (null != o) {
              const t = o[0],
                e = o.slice(1).map(t => +t),
                i = n.call(null, t, ...e);
              r.appendSegment(i)
            }
          }
        return r
      }, t.createSegment = n
    }(PC || (PC = {}));
    class DC {
      constructor(t, e, n) {
        if (!t) throw new TypeError("Invalid element to create vectorizer");
        let r;
        if (DC.isVector(t)) r = t.node;
        else if ("string" == typeof t)
          if ("svg" === t.toLowerCase()) r = fb();
          else if ("<" === t[0]) {
          const e = fb(t);
          r = document.importNode(e.firstChild, !0)
        } else r = document.createElementNS(cb.svg, t);
        else r = t;
        this.node = r, e && this.setAttributes(e), n && this.append(n)
      }
      get id() {
        return this.node.id
      }
      set id(t) {
        this.node.id = t
      }
      getTransformToElement(t) {
        const e = DC.toHTMLElement(t);
        return yx(this.node, e)
      }
      transform(t, e) {
        return null == t ? Ex(this.node) : (Ex(this.node, t, e), this)
      }
      translate(t, e = 0, n = {}) {
        return null == t ? Sx(this.node) : (Sx(this.node, t, e, n), this)
      }
      rotate(t, e, n, r = {}) {
        return null == t ? Mx(this.node) : (Mx(this.node, t, e, n, r), this)
      }
      scale(t, e) {
        return null == t ? kx(this.node) : (kx(this.node, t, e), this)
      }
      removeAttribute(t) {
        return Db(this.node, t), this
      }
      getAttribute(t) {
        return Pb(this.node, t)
      }
      setAttribute(t, e) {
        return Tb(this.node, t, e), this
      }
      setAttributes(t) {
        return _b(this.node, t), this
      }
      attr(t, e) {
        return null == t ? jb(this.node) : "string" == typeof t && void 0 === e ? jb(this.node, t) : ("object" ==
          typeof t ? jb(this.node, t) : jb(this.node, t, e), this)
      }
      svg() {
        return this.node instanceof SVGSVGElement ? this : DC.createVector(this.node.ownerSVGElement)
      }
      defs() {
        const t = this.svg() || this,
          e = t.node.getElementsByTagName("defs")[0];
        return e ? DC.createVector(e) : DC.createVector("defs").appendTo(t)
      }
      text(t, e = {}) {
        return LC(this.node, t, e), this
      }
      tagName() {
        return mb(this.node)
      }
      clone() {
        return DC.createVector(this.node.cloneNode(!0))
      }
      remove() {
        return wb(this.node), this
      }
      empty() {
        return Ab(this.node), this
      }
      append(t) {
        return Eb(this.node, DC.toHTMLElements(t)), this
      }
      prepend(t) {
        return Sb(this.node, DC.toHTMLElements(t)), this
      }
      before(t) {
        return Mb(this.node, DC.toHTMLElements(t)), this
      }
      appendTo(t) {
        return kb(this.node, DC.toHTMLElement(t)), this
      }
      findOne(t) {
        const e = bb(this.node, t);
        return e ? DC.createVector(e) : void 0
      }
      find(t) {
        const e = [],
          n = yb(this.node, t);
        if (n)
          for (let t = 0, r = n.length; t < r; t += 1) e.push(DC.createVector(n[t]));
        return e
      }
      findParentByClass(t, e) {
        const n = Cb(this.node, t, e);
        return n ? DC.createVector(n) : null
      }
      contains(t) {
        return xb(this.node, t instanceof DC ? t.node : t)
      }
      children() {
        const t = this.node.childNodes,
          e = [];
        for (let n = 0; n < t.length; n += 1) {
          1 === t[n].nodeType && e.push(DC.createVector(t[n]))
        }
        return e
      }
      index() {
        return vb(this.node)
      }
      hasClass(t) {
        return eb(this.node, t)
      }
      addClass(t) {
        return nb(this.node, t), this
      }
      removeClass(t) {
        return rb(this.node, t), this
      }
      toggleClass(t, e) {
        return ib(this.node, t, e), this
      }
      toLocalPoint(t, e) {
        return bx(this.node, t, e)
      }
      toGeometryShape() {
        return Cx(this.node)
      }
      translateCenterToPoint(t) {
        const e = this.getBBox({
          target: this.svg()
        }).getCenter();
        return this.translate(t.x - e.x, t.y - e.y), this
      }
      translateAndAutoOrient(t, e, n) {
        return Ox(this.node, t, e, n), this
      }
      animateAlongPath(t, e) {
        return wx(this.node, t, e), this
      }
      normalizePath() {
        return "path" === this.tagName() && this.attr("d", PC.normalize(this.attr("d"))), this
      }
      bbox(t, e) {
        return mx(this.node, t, e)
      }
      getBBox(t = {}) {
        return vx(this.node, {
          recursive: t.recursive,
          target: DC.toHTMLElement(t.target)
        })
      }
      sample(t = 1) {
        return this.node instanceof SVGPathElement ? BC(this.node, t) : []
      }
      convertToPath() {
        return DC.createVector(XC(this.node))
      }
      convertToPathData() {
        return YC(this.node)
      }
    }

    function TC(t, e, n) {
      const r = n.eol,
        i = n.baseSize,
        o = n.lineHeight;
      let s, a = 0;
      const l = {},
        c = e.length - 1;
      for (let o = 0; o <= c; o += 1) {
        let l = e[o],
          h = null;
        if ("object" == typeof l) {
          const t = l.attrs,
            e = DC.createVector("tspan", t);
          s = e.node;
          let u = l.t;
          r && o === c && (u += r), s.textContent = u;
          const d = t.class;
          d && e.addClass(d), n.includeAnnotationIndices && e.attr("annotations", l.annotations.join(",")), void 0 ===
            (h = parseFloat(t["font-size"])) && (h = i), h && h > a && (a = h)
        } else r && o === c && (l += r), s = document.createTextNode(l || " "), i && i > a && (a = i);
        t.appendChild(s)
      }
      return a && (l.maxFontSize = a), o ? l.lineHeight = o : a && (l.lineHeight = 1.2 * a), l
    }! function(t) {
      function e(e) {
        return e instanceof t
      }

      function n(e, n, r) {
        return new t(e, n, r)
      }

      function r(t) {
        return null != t ? e(t) ? t.node : t.nodeName && t || t[0] : null
      }
      t.isVector = e, t.createVector = n, t.createVectors = function(t) {
        if ("<" === t[0]) {
          const e = fb(t),
            r = [];
          for (let t = 0, i = e.childNodes.length; t < i; t += 1) {
            const i = e.childNodes[t];
            r.push(n(document.importNode(i, !0)))
          }
          return r
        }
        return [n(t)]
      }, t.toHTMLElement = r, t.toHTMLElements = function(t) {
        return Array.isArray(t) ? t.map(t => r(t)) : [r(t)]
      }
    }(DC || (DC = {}));
    const _C = /em$/;

    function jC(t, e) {
      const n = parseFloat(t);
      return _C.test(t) ? n * e : n
    }

    function LC(t, e, n = {}) {
      e = c.sanitize(e);
      const r = n.eol;
      let i = n.textPath;
      const o = n.textVerticalAnchor,
        s = "middle" === o || "bottom" === o || "top" === o;
      let a = n.x;
      void 0 === a && (a = t.getAttribute("x") || 0);
      const l = n.includeAnnotationIndices;
      let h = n.annotations;
      h && !Array.isArray(h) && (h = [h]);
      const u = n.lineHeight,
        d = "auto" === u,
        p = d ? "1.5em" : u || "1em";
      Ab(t), jb(t, {
        "xml:space": "preserve",
        display: e || n.displayEmpty ? null : "none"
      });
      let f, g, m = parseFloat(jb(t, "font-size"));
      m || (m = 16, (s || h) && jb(t, "font-size", `${m}`)), i ? ("string" == typeof i && (i = {
        d: i
      }), f = function(t, e) {
        const n = DC.createVector(e),
          r = DC.createVector("textPath"),
          i = t.d;
        if (i && void 0 === t["xlink:href"]) {
          const t = DC.createVector("path").attr("d", i).appendTo(n.defs());
          r.attr("xlink:href", `#${t.id}`)
        }
        return "object" == typeof t && r.attr(t), r.node
      }(i, t)) : f = document.createDocumentFragment();
      let v, y = 0;
      const b = e.split("\n"),
        C = [],
        x = b.length - 1;
      for (let t = 0; t <= x; t += 1) {
        g = p;
        let e = "v-line";
        const n = pb("tspan");
        let o, s = b[t];
        if (s)
          if (h) {
            const e = (o = TC(n, c.annotate(s, h, {
              offset: -y,
              includeAnnotationIndices: l
            }), {
              eol: t !== x && r,
              baseSize: m,
              lineHeight: d ? null : p,
              includeAnnotationIndices: l
            })).lineHeight;
            e && d && 0 !== t && (g = e), 0 === t && (v = .8 * o.maxFontSize)
          } else r && t !== x && (s += r), n.textContent = s;
        else {
          n.textContent = "-", e += " v-empty-line";
          const t = n.style;
          t.fillOpacity = 0, t.strokeOpacity = 0, h && (o = {})
        }
        o && C.push(o), t > 0 && n.setAttribute("dy", g), (t > 0 || i) && n.setAttribute("x", a), n.className.baseVal =
          e, f.appendChild(n), y += s.length + 1
      }
      if (s)
        if (h) g = function(t, e, n, r) {
          if (!Array.isArray(e)) return 0;
          const i = e.length;
          if (!i) return 0;
          let o = e[0];
          const s = jC(o.maxFontSize, n) || n;
          let a = 0;
          const l = jC(r, n);
          for (let t = 1; t < i; t += 1) a += jC((o = e[t]).lineHeight, n) || l;
          const c = jC(o.maxFontSize, n) || n;
          let h;
          switch (t) {
            case "middle":
              h = s / 2 - .15 * c - a / 2;
              break;
            case "bottom":
              h = -.25 * c - a;
              break;
            default:
            case "top":
              h = .8 * s
          }
          return h
        }(o, C, m, p);
        else if ("top" === o) g = "0.8em";
      else {
        let t;
        switch (x > 0 ? (t = parseFloat(p) || 1, t *= x, _C.test(p) || (t /= m)) : t = 0, o) {
          case "middle":
            g = `${.3-t/2}em`;
            break;
          case "bottom":
            g = `${-t-.3}em`
        }
      } else 0 === o ? g = "0em" : o ? g = o : (g = 0, null == t.getAttribute("y") && t.setAttribute("y",
        `${v||"0.8em"}`));
      f.firstChild.setAttribute("dy", g), t.appendChild(f)
    }

    function NC(t, e, n = {}, r = {}) {
      const i = e.width,
        o = e.height,
        s = r.svgDocument || pb("svg"),
        l = pb("tspan"),
        c = pb("text");
      jb(c, n), Eb(c, l);
      const h = document.createTextNode("");
      c.style.opacity = "0", c.style.display = "block", l.style.display = "block", l.appendChild(h), s.appendChild(
        c), r.svgDocument || document.body.appendChild(s);
      const u = r.eol || "\n",
        d = r.separator || " ",
        p = r.hyphen ? new RegExp(r.hyphen) : /[^\w\d]/,
        f = t.split(d),
        g = [];
      let m, v, y, b = [];
      for (let t = 0, e = 0, s = f.length; t < s; t += 1) {
        const C = f[t];
        if (C)
          if (u && C.indexOf(u) >= 0)
            if (C.length > 1) {
              const e = C.split(u);
              for (let t = 0, n = e.length - 1; t < n; t += 1) e.splice(2 * t + 1, 0, u);
              f.splice(t, 1, ...e.filter(t => "" !== t)), t -= 1, s = f.length
            } else b[e += 1] = "";
        else {
          if (h.data = b[e] ? `${b[e]} ${C}` : C, l.getComputedTextLength() <= i) b[e] = h.data, (m || v) && (g[e] = !
            0, e += 1, m = 0, v = 0);
          else {
            if (!b[e] || m) {
              const n = !!m;
              if (m = C.length - 1, n || !m) {
                if (!m) {
                  if (!b[e]) {
                    b = [];
                    break
                  }
                  f.splice(t, 2, C + f[t + 1]), s -= 1, g[e] = !0, e += 1, t -= 1;
                  continue
                }
                f[t] = C.substring(0, m), f[t + 1] = C.substring(m) + f[t + 1]
              } else {
                if (v) f.splice(t, 2, f[t] + f[t + 1]), v = 0;
                else {
                  const e = C.search(p);
                  e > -1 && e !== C.length - 1 && 0 !== e && (v = e + 1, m = 0), f.splice(t, 1, C.substring(0, v ||
                    m), C.substring(v || m)), s += 1
                }
                e && !g[e - 1] && (e -= 1)
              }
              t -= 1;
              continue
            }
            e += 1, t -= 1
          }
          if (void 0 !== o) {
            if (void 0 === y) {
              let t;
              y = (t = "auto" === n.lineHeight ? {
                value: 1.5,
                unit: "em"
              } : a.parseCssNumeric(n.lineHeight, ["em"]) || {
                value: 1,
                unit: "em"
              }).value, "em" === t.unit && (y *= c.getBBox().height)
            }
            if (y * b.length > o) {
              const t = Math.floor(o / y) - 1;
              b.splice(t + 1);
              let e = r.ellipsis;
              if (!e || t < 0) break;
              "string" != typeof e && (e = "…");
              const n = b[t];
              if (!n) break;
              let s, a, c, u = n.length;
              do {
                if (a = n[u], s = n.substring(0, u), a ? a.match(d) && (s += a) : s += c = "string" == typeof d ?
                  d : " ", s += e, h.data = s, l.getComputedTextLength() <= i) {
                  b[t] = s;
                  break
                }
                u -= 1
              } while (u >= 0);
              break
            }
          }
        }
      }
      return r.svgDocument ? s.removeChild(c) : document.body.removeChild(s), b.join(u)
    }
    const FC = .551784;

    function $C(t, e, n = NaN) {
      const r = t.getAttribute(e);
      if (null == r) return n;
      const i = parseFloat(r);
      return isNaN(i) ? n : i
    }

    function BC(t, e = 1) {
      const n = t.getTotalLength(),
        r = [];
      let i, o = 0;
      for (; o < n;) i = t.getPointAtLength(o), r.push({
        distance: o,
        x: i.x,
        y: i.y
      }), o += e;
      return r
    }

    function IC(t) {
      return ["M", $C(t, "x1"), $C(t, "y1"), "L", $C(t, "x2"), $C(t, "y2")].join(" ")
    }

    function zC(t) {
      const e = HC(t);
      return 0 === e.length ? null : `${VC(e)} Z`
    }

    function RC(t) {
      const e = HC(t);
      return 0 === e.length ? null : VC(e)
    }

    function VC(t) {
      return `M ${t.map(t=>`${t.x} ${t.y}`).join(" L")}`
    }

    function HC(t) {
      const e = [],
        n = t.points;
      if (n)
        for (let t = 0, r = n.numberOfItems; t < r; t += 1) e.push(n.getItem(t));
      return e
    }

    function GC(t) {
      const e = $C(t, "cx", 0),
        n = $C(t, "cy", 0),
        r = $C(t, "r"),
        i = r * FC;
      return ["M", e, n - r, "C", e + i, n - r, e + r, n - i, e + r, n, "C", e + r, n + i, e + i, n + r, e, n + r,
        "C", e - i, n + r, e - r, n + i, e - r, n, "C", e - r, n - i, e - i, n - r, e, n - r, "Z"
      ].join(" ")
    }

    function UC(t) {
      const e = $C(t, "cx", 0),
        n = $C(t, "cy", 0),
        r = $C(t, "rx"),
        i = $C(t, "ry") || r,
        o = r * FC,
        s = i * FC;
      return ["M", e, n - i, "C", e + o, n - i, e + r, n - s, e + r, n, "C", e + r, n + s, e + o, n + i, e, n + i,
        "C", e - o, n + i, e - r, n + s, e - r, n, "C", e - r, n - s, e - o, n - i, e, n - i, "Z"
      ].join(" ")
    }

    function qC(t) {
      return WC({
        x: $C(t, "x", 0),
        y: $C(t, "y", 0),
        width: $C(t, "width", 0),
        height: $C(t, "height", 0),
        rx: $C(t, "rx", 0),
        ry: $C(t, "ry", 0)
      })
    }

    function WC(t) {
      let e;
      const n = t.x,
        r = t.y,
        i = t.width,
        o = t.height,
        s = Math.min(t.rx || t["top-rx"] || 0, i / 2),
        a = Math.min(t.rx || t["bottom-rx"] || 0, i / 2),
        l = Math.min(t.ry || t["top-ry"] || 0, o / 2),
        c = Math.min(t.ry || t["bottom-ry"] || 0, o / 2);
      return (e = s || a || l || c ? ["M", n, r + l, "v", o - l - c, "a", a, c, 0, 0, 0, a, c, "h", i - 2 * a,
        "a", a, c, 0, 0, 0, a, -c, "v", -(o - c - l), "a", s, l, 0, 0, 0, -s, -l, "h", -(i - 2 * s), "a", s,
        l, 0, 0, 0, -s, l, "Z"
      ] : ["M", n, r, "H", n + i, "V", r + o, "H", n, "V", r, "Z"]).join(" ")
    }

    function XC(t) {
      const e = pb("path");
      jb(e, jb(t));
      const n = YC(t);
      return n && e.setAttribute("d", n), e
    }

    function YC(t) {
      const e = t.tagName.toLowerCase();
      switch (e) {
        case "path":
          return t.getAttribute("d");
        case "line":
          return IC(t);
        case "polygon":
          return zC(t);
        case "polyline":
          return RC(t);
        case "ellipse":
          return UC(t);
        case "circle":
          return GC(t);
        case "rect":
          return qC(t)
      }
      throw new Error(`"${e}" cannot be converted to svg path element.`)
    }

    function JC(t, e, n, r) {
      const i = 2 * Math.PI - 1e-6,
        o = t,
        s = e;
      let a = n,
        l = r;
      if (l < a) {
        const t = a;
        a = l, l = t
      }
      const c = l - a,
        h = c < Math.PI ? "0" : "1",
        u = Math.cos(a),
        d = Math.sin(a),
        p = Math.cos(l),
        f = Math.sin(l);
      return c >= i ? o ? "M0," + s + "A" + s + "," + s + " 0 1,1 0," + -s + "A" + s + "," + s + " 0 1,1 0," + s +
        "M0," + o + "A" + o + "," + o + " 0 1,0 0," + -o + "A" + o + "," + o + " 0 1,0 0," + o + "Z" : "M0," + s +
        "A" + s + "," + s + " 0 1,1 0," + -s + "A" + s + "," + s + " 0 1,1 0," + s + "Z" : o ? "M" + s * u + "," +
        s * d + "A" + s + "," + s + " 0 " + h + ",1 " + s * p + "," + s * f + "L" + o * p + "," + o * f + "A" + o +
        "," + o + " 0 " + h + ",0 " + o * u + "," + o * d + "Z" : "M" + s * u + "," + s * d + "A" + s + "," + s +
        " 0 " + h + ",1 " + s * p + "," + s * f + "L0,0Z"
    }
    const ZC = pb("svg"),
      KC = /(\w+)\(([^,)]+),?([^)]+)?\)/gi,
      QC = /[ ,]+/,
      tx = /^(\w+)\((.*)\)/;

    function ex(t, e) {
      const n = ZC.createSVGPoint();
      return n.x = t, n.y = e, n
    }

    function nx(t) {
      const e = ZC.createSVGMatrix();
      if (null != t) {
        const n = t,
          r = e;
        for (const t in n) r[t] = n[t]
      }
      return e
    }

    function rx(t) {
      return null != t ? (t instanceof DOMMatrix || (t = nx(t)), ZC.createSVGTransformFromMatrix(t)) : ZC.createSVGTransform()
    }

    function ix(t) {
      let e = nx();
      const n = null != t && t.match(KC);
      if (!n) return e;
      for (let t = 0, r = n.length; t < r; t += 1) {
        const r = n[t].match(tx);
        if (r) {
          let t, n, i, o, s, a = nx();
          const l = r[2].split(QC);
          switch (r[1].toLowerCase()) {
            case "scale":
              t = parseFloat(l[0]), n = void 0 === l[1] ? t : parseFloat(l[1]), a = a.scaleNonUniform(t, n);
              break;
            case "translate":
              i = parseFloat(l[0]), o = parseFloat(l[1]), a = a.translate(i, o);
              break;
            case "rotate":
              s = parseFloat(l[0]), i = parseFloat(l[1]) || 0, o = parseFloat(l[2]) || 0, a = 0 !== i || 0 !== o ?
                a.translate(i, o).rotate(s).translate(-i, -o) : a.rotate(s);
              break;
            case "skewx":
              s = parseFloat(l[0]), a = a.skewX(s);
              break;
            case "skewy":
              s = parseFloat(l[0]), a = a.skewY(s);
              break;
            case "matrix":
              a.a = parseFloat(l[0]), a.b = parseFloat(l[1]), a.c = parseFloat(l[2]), a.d = parseFloat(l[3]), a.e =
                parseFloat(l[4]), a.f = parseFloat(l[5]);
              break;
            default:
              continue
          }
          e = e.multiply(a)
        }
      }
      return e
    }

    function ox(t) {
      const e = t || {};
      return `matrix(${null!=e.a?e.a:1},${null!=e.b?e.b:0},${null!=e.c?e.c:0},${null!=e.d?e.d:1},${null!=e.e?e.e:0},${null!=e.f?e.f:0})`
    }

    function sx(t) {
      let e, n, r;
      if (t) {
        const i = QC;
        if (t.trim().indexOf("matrix") >= 0) {
          const i = lx(ix(t));
          e = [i.translateX, i.translateY], n = [i.rotation], r = [i.scaleX, i.scaleY];
          const o = [];
          0 === e[0] && 0 === e[1] || o.push(`translate(${e.join(",")})`), 1 === r[0] && 1 === r[1] || o.push(
            `scale(${r.join(",")})`), 0 !== n[0] && o.push(`rotate(${n[0]})`), t = o.join(" ")
        } else {
          const o = t.match(/translate\((.*?)\)/);
          o && (e = o[1].split(i));
          const s = t.match(/rotate\((.*?)\)/);
          s && (n = s[1].split(i));
          const a = t.match(/scale\((.*?)\)/);
          a && (r = a[1].split(i))
        }
      }
      const i = r && r[0] ? parseFloat(r[0]) : 1;
      return {
        raw: t || "",
        translation: {
          tx: e && e[0] ? parseInt(e[0], 10) : 0,
          ty: e && e[1] ? parseInt(e[1], 10) : 0
        },
        rotation: {
          angle: n && n[0] ? parseInt(n[0], 10) : 0,
          cx: n && n[1] ? parseInt(n[1], 10) : void 0,
          cy: n && n[2] ? parseInt(n[2], 10) : void 0
        },
        scale: {
          sx: i,
          sy: r && r[1] ? parseFloat(r[1]) : i
        }
      }
    }

    function ax(t, e) {
      return {
        x: e.x * t.a + e.y * t.c + 0,
        y: e.x * t.b + e.y * t.d + 0
      }
    }

    function lx(t) {
      const e = ax(t, {
          x: 0,
          y: 1
        }),
        n = ax(t, {
          x: 1,
          y: 0
        }),
        r = 180 / Math.PI * Math.atan2(e.y, e.x) - 90;
      return {
        skewX: r,
        skewY: 180 / Math.PI * Math.atan2(n.y, n.x),
        translateX: t.e,
        translateY: t.f,
        scaleX: Math.sqrt(t.a * t.a + t.b * t.b),
        scaleY: Math.sqrt(t.c * t.c + t.d * t.d),
        rotation: r
      }
    }

    function cx(t) {
      let e, n, r, i;
      return t ? (e = null == t.a ? 1 : t.a, i = null == t.d ? 1 : t.d, n = t.b, r = t.c) : e = i = 1, {
        sx: n ? Math.sqrt(e * e + n * n) : e,
        sy: r ? Math.sqrt(r * r + i * i) : i
      }
    }

    function hx(t) {
      let e = {
        x: 0,
        y: 1
      };
      return t && (e = ax(t, e)), {
        angle: nC.normalize(nC.toDeg(Math.atan2(e.y, e.x)) - 90)
      }
    }

    function ux(t) {
      return {
        tx: t && t.e || 0,
        ty: t && t.f || 0
      }
    }

    function dx(t, e) {
      const n = ex(t.x, t.y).matrixTransform(e);
      return new hC(n.x, n.y)
    }

    function px(t, e) {
      return new dC(dx(t.start, e), dx(t.end, e))
    }

    function fx(t, e) {
      let n = t instanceof fC ? t.points : t;
      return Array.isArray(n) || (n = []), new fC(n.map(t => dx(t, e)))
    }

    function gx(t, e) {
      const n = ZC.createSVGPoint();
      n.x = t.x, n.y = t.y;
      const r = n.matrixTransform(e);
      n.x = t.x + t.width, n.y = t.y;
      const i = n.matrixTransform(e);
      n.x = t.x + t.width, n.y = t.y + t.height;
      const o = n.matrixTransform(e);
      n.x = t.x, n.y = t.y + t.height;
      const s = n.matrixTransform(e),
        a = Math.min(r.x, i.x, o.x, s.x),
        l = Math.max(r.x, i.x, o.x, s.x),
        c = Math.min(r.y, i.y, o.y, s.y),
        h = Math.max(r.y, i.y, o.y, s.y);
      return new uC(a, c, l - a, h - c)
    }

    function mx(t, e, n) {
      let r;
      const i = t.ownerSVGElement;
      if (!i) return new uC(0, 0, 0, 0);
      try {
        r = t.getBBox()
      } catch (e) {
        r = {
          x: t.clientLeft,
          y: t.clientTop,
          width: t.clientWidth,
          height: t.clientHeight
        }
      }
      return e ? uC.create(r) : gx(r, yx(t, n || i))
    }

    function vx(t, e = {}) {
      let n;
      if (!t.ownerSVGElement || !lb(t)) {
        if (Ob(t)) {
          const {
            left: e,
            top: n,
            width: r,
            height: i
          } = Ax(t);
          return new uC(e, n, r, i)
        }
        return new uC(0, 0, 0, 0)
      }
      let r = e.target;
      if (!e.recursive) {
        try {
          n = t.getBBox()
        } catch (e) {
          n = {
            x: t.clientLeft,
            y: t.clientTop,
            width: t.clientWidth,
            height: t.clientHeight
          }
        }
        if (!r) return uC.create(n);
        return gx(n, yx(t, r))
      } {
        const e = t.childNodes,
          i = e.length;
        if (0 === i) return vx(t, {
          target: r
        });
        r || (r = t);
        for (let t = 0; t < i; t += 1) {
          const i = e[t];
          let o;
          o = 0 === i.childNodes.length ? vx(i, {
            target: r
          }) : vx(i, {
            target: r,
            recursive: !0
          }), n = n ? n.union(o) : o
        }
        return n
      }
    }

    function yx(t, e) {
      if (lb(e) && lb(t)) {
        const n = e.getScreenCTM(),
          r = t.getScreenCTM();
        if (n && r) return n.inverse().multiply(r)
      }
      return nx()
    }

    function bx(t, e, n) {
      const r = t instanceof SVGSVGElement ? t : t.ownerSVGElement,
        i = r.createSVGPoint();
      i.x = e, i.y = n;
      try {
        const e = r.getScreenCTM(),
          n = i.matrixTransform(e.inverse()),
          o = yx(t, r).inverse();
        return n.matrixTransform(o)
      } catch (t) {
        return i
      }
    }

    function Cx(t) {
      const e = e => {
        const n = t.getAttribute(e),
          r = n ? parseFloat(n) : 0;
        return isNaN(r) ? 0 : r
      };
      switch (t instanceof SVGElement && t.nodeName.toLowerCase()) {
        case "rect":
          return new uC(e("x"), e("y"), e("width"), e("height"));
        case "circle":
          return new pC(e("cx"), e("cy"), e("r"), e("r"));
        case "ellipse":
          return new pC(e("cx"), e("cy"), e("rx"), e("ry"));
        case "polyline":
          {
            const e = HC(t);
            return new fC(e)
          }
        case "polygon":
          {
            const e = HC(t);
            return e.length > 1 && e.push(e[0]),
            new fC(e)
          }
        case "path":
          {
            let e = t.getAttribute("d");
            return PC.isSupported(e) || (e = PC.normalize(e)),
            PC.parse(e)
          }
        case "line":
          return new dC(e("x1"), e("y1"), e("x2"), e("y2"))
      }
      return vx(t)
    }

    function xx(t, e, n) {
      const r = t instanceof SVGSVGElement ? t : t.ownerSVGElement,
        i = vx(n = n || r),
        o = i.getCenter();
      if (!i.intersectionWithLineFromCenterToPoint(e)) return;
      let s;
      const a = t.tagName.toLowerCase();
      if ("rect" === a) {
        const i = new uC(parseFloat(t.getAttribute("x") || "0"), parseFloat(t.getAttribute("y") || "0"),
            parseFloat(t.getAttribute("width") || "0"), parseFloat(t.getAttribute("height") || "0")),
          a = yx(t, n),
          l = lx(a),
          c = r.createSVGTransform();
        c.setRotate(-l.rotation, o.x, o.y);
        const h = gx(i, c.matrix.multiply(a));
        s = uC.create(h).intersectionWithLineFromCenterToPoint(e, l.rotation)
      } else if ("path" === a || "polygon" === a || "polyline" === a || "circle" === a || "ellipse" === a) {
        const r = "path" === a ? t : XC(t),
          i = sample(r);
        let l = 1 / 0,
          c = [];
        for (let r = 0, s = i.length; r < s; r += 1) {
          const s = i[r];
          let a = ex(s.x, s.y);
          a = a.matrixTransform(yx(t, n));
          const h = hC.create(a),
            u = h.distance(o),
            d = 1.1 * h.distance(e),
            p = u + d;
          p < l ? (l = p, c = [{
            sample: s,
            refDistance: d
          }]) : p < l + 1 && c.push({
            sample: s,
            refDistance: d
          })
        }
        c.sort((t, e) => t.refDistance - e.refDistance), c[0] && (s = hC.create(c[0].sample))
      }
      return s
    }

    function wx(t, e, n) {
      const r = ab(n),
        i = pb("animateMotion"),
        o = pb("mpath");
      jb(i, e), jb(o, {
        "xlink:href": `#${r}`
      }), i.appendChild(o), t.appendChild(i);
      try {
        i.beginElement()
      } catch (t) {
        if ("fake" === document.documentElement.getAttribute("smiling")) {
          const t = i;
          t.animators = [];
          const e = window,
            n = t.getAttribute("id");
          n && (e.id2anim[n] = t);
          const r = e.getTargets(t);
          for (let n = 0, i = r.length; n < i; n += 1) {
            const i = r[n],
              o = new e.Animator(t, i, n);
            e.animators.push(o), t.animators[n] = o, o.register()
          }
        }
      }
    }

    function Ax(t) {
      let e = 0,
        n = 0,
        r = 0,
        i = 0;
      if (t) {
        let o = t;
        for (; o;) e += o.offsetLeft, n += o.offsetTop, (o = o.offsetParent) && (e += parseInt(Qb(o, "borderLeft"),
          10), n += parseInt(Qb(o, "borderTop"), 10));
        r = t.offsetWidth, i = t.offsetHeight
      }
      return {
        left: e,
        top: n,
        width: r,
        height: i
      }
    }

    function Ex(t, e, n = {}) {
      if (null == e) return ix(jb(t, "transform"));
      if (n.absolute) return void t.setAttribute("transform", ox(e));
      const r = t.transform,
        i = rx(e);
      r.baseVal.appendItem(i)
    }

    function Sx(t, e, n = 0, r = {}) {
      let i = jb(t, "transform");
      const o = sx(i);
      if (null == e) return o.translation;
      i = (i = o.raw).replace(/translate\([^)]*\)/g, "").trim();
      const s = `translate(${r.absolute?e:o.translation.tx+e},${r.absolute?n:o.translation.ty+n})`;
      t.setAttribute("transform", `${s} ${i}`.trim())
    }

    function Mx(t, e, n, r, i = {}) {
      let o = jb(t, "transform");
      const s = sx(o);
      if (null == e) return s.rotation;
      o = (o = s.raw).replace(/rotate\([^)]*\)/g, "").trim(), e %= 360;
      const a = `rotate(${i.absolute?e:s.rotation.angle+e}${null!=n&&null!=r?`,${n},${r}`:""})`;
      t.setAttribute("transform", `${o} ${a}`.trim())
    }

    function kx(t, e, n) {
      let r = jb(t, "transform");
      const i = sx(r);
      if (null == e) return i.scale;
      n = null == n ? e : n, r = (r = i.raw).replace(/scale\([^)]*\)/g, "").trim();
      const o = `scale(${e},${n})`;
      t.setAttribute("transform", `${r} ${o}`.trim())
    }

    function Ox(t, e, n, r) {
      const i = hC.create(e),
        o = hC.create(n);
      if (!r) {
        r = t instanceof SVGSVGElement ? t : t.ownerSVGElement
      }
      const s = kx(t);
      t.setAttribute("transform", "");
      const a = vx(t, {
          target: r
        }).scale(s.sx, s.sy),
        l = rx();
      l.setTranslate(-a.x - a.width / 2, -a.y - a.height / 2);
      const c = rx(),
        h = i.angleBetween(o, i.clone().translate(1, 0));
      h && c.setRotate(h, 0, 0);
      const u = rx(),
        d = i.clone().move(o, a.width / 2);
      u.setTranslate(2 * i.x - d.x, 2 * i.y - d.y);
      const p = yx(t, r),
        f = rx();
      f.setMatrix(u.matrix.multiply(c.matrix.multiply(l.matrix.multiply(p.scale(s.sx, s.sy))))), t.setAttribute(
        "transform", ox(f.matrix))
    }
    const Px = DC.isVector,
      Dx = DC.createVector,
      Tx = DC.createVectors,
      _x = DC.toHTMLElement,
      jx = DC.toHTMLElements;
    let Lx;
    const Nx = {
      px: t => t,
      mm: t => Lx * t,
      cm: t => Lx * t * 10,
      in: t => Lx * t * 25.4,
      pt: t => Lx * (25.4 * t / 72),
      pc: t => Lx * (25.4 * t / 6)
    };
    var Fx, $x;
    ! function(t) {
      function e(t, e, n) {
        const r = P()("<div/>").css({
            display: "inline-block",
            position: "absolute",
            left: -15e3,
            top: -15e3,
            width: t + (n || ""),
            height: e + (n || "")
          }).appendTo(document.body),
          i = {
            width: r.width() || 0,
            height: r.height() || 0
          };
        return r.remove(), i
      }
      t.measure = e, t.toPx = function(t, n) {
        null == Lx && (Lx = e("1", "1", "mm").width);
        const r = n ? Nx[n] : null;
        return r ? r(t) : t
      }
    }(Fx || (Fx = {}));
    class Bx {
      constructor() {
        this.listeners = {}
      }
      on(t, e, n) {
        if (null == e) return this;
        return this.listeners[t] || (this.listeners[t] = []), this.listeners[t].push(e, n), this
      }
      once(t, e, n) {
        const r = (...i) => (this.off(t, r), $x.call([e, n], i));
        return this.on(t, r, this)
      }
      off(t, e, n) {
        if (!(t || e || n)) return this.listeners = {}, this;
        const r = this.listeners;
        return (t ? [t] : Object.keys(r)).forEach(t => {
          const i = r[t];
          if (i)
            if (e || n)
              for (let t = i.length - 2; t >= 0; t -= 2) e && i[t] !== e || n && i[t + 1] !== n || i.splice(
                t, 2);
            else delete r[t]
        }), this
      }
      trigger(t, ...e) {
        let n = !0;
        if ("*" !== t) {
          const r = this.listeners[t];
          null != r && (n = $x.call(r, e))
        }
        const r = this.listeners["*"];
        return null != r ? l.toAsyncBoolean([n, $x.call(r, [t, ...e])]) : n
      }
      emit(t, ...e) {
        return this.trigger(t, ...e)
      }
    }! function(t) {
      ($x || ($x = {})).call = function(t, e) {
        const n = [];
        for (let r = 0; r < t.length; r += 2) {
          const i = t[r],
            o = t[r + 1],
            s = Array.isArray(e) ? e : [e],
            a = l.apply(i, o, s);
          n.push(a)
        }
        return l.toAsyncBoolean(n)
      }
    }();
    class Ix {
      get disposed() {
        return !0 === this._disposed
      }
      dispose() {
        this._disposed = !0
      }
    }! function(t) {
      t.dispose = function() {
        return (t, e, n) => {
          const r = n.value,
            i = t.__proto__;
          n.value = function() {
            this.disposed || (r.call(this), i.dispose.call(this))
          }
        }
      }
    }(Ix || (Ix = {}));
    class zx {
      constructor(t) {
        this.callback = t
      }
      get disposed() {
        return !this.callback
      }
      dispose() {
        if (!this.callback) return;
        const t = this.callback;
        this.callback = null, t()
      }
    }
    class Rx {
      constructor() {
        this.isDisposed = !1, this.items = new Set
      }
      get disposed() {
        return this.isDisposed
      }
      dispose() {
        this.isDisposed || (this.isDisposed = !0, this.items.forEach(t => {
          t.dispose()
        }), this.items.clear())
      }
      contains(t) {
        return this.items.has(t)
      }
      add(t) {
        this.items.add(t)
      }
      remove(t) {
        this.items.delete(t)
      }
      clear() {
        this.items.clear()
      }
    }! function(t) {
      t.from = function(e) {
        const n = new t;
        return e.forEach(t => {
          n.add(t)
        }), n
      }
    }(Rx || (Rx = {}));
    class Vx extends Bx {}(Vx || (Vx = {})).dispose = Ix.dispose, o.applyMixins(Vx, Ix);
    class Hx extends Vx {
      get disabled() {
        return !0 === this._disabled
      }
      enable() {
        delete this._disabled
      }
      disable() {
        this._disabled = !0
      }
    }
    var Gx, Ux, qx, Wx = this && this.__decorate || function(t, e, n, r) {
      var i, o = arguments.length,
        s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r);
      else
        for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) ||
          s);
      return o > 3 && s && Object.defineProperty(e, n, s), s
    };
    class Xx extends Ix {
      constructor() {
        super(), this.clear()
      }
      clear() {
        this.map = new WeakMap, this.arr = []
      }
      has(t) {
        return this.map.has(t)
      }
      get(t) {
        return this.map.get(t)
      }
      set(t, e) {
        this.map.set(t, e), this.arr.push(t)
      }
      delete(t) {
        const e = this.arr.indexOf(t);
        e >= 0 && this.arr.splice(e, 1);
        const n = this.map.get(t);
        return this.map.delete(t), n
      }
      each(t) {
        this.arr.forEach(e => {
          const n = this.map.get(e);
          t(n, e)
        })
      }
      dispose() {
        this.clear()
      }
    }
    Wx([Ix.dispose()], Xx.prototype, "dispose", null);
    class Yx {
      constructor(t = {}) {
        this.comparator = t.comparator || Yx.defaultComparator, this.index = {}, this.data = t.data || [], this
          .heapify()
      }
      isEmpty() {
        return 0 === this.data.length
      }
      insert(t, e, n) {
        const r = {
            priority: t,
            value: e
          },
          i = this.data.length - 1;
        return n && (r.id = n, this.index[n] = i), this.data.push(r), this.bubbleUp(i), this
      }
      peek() {
        return this.data[0] ? this.data[0].value : null
      }
      peekPriority() {
        return this.data[0] ? this.data[0].priority : null
      }
      updatePriority(t, e) {
        const n = this.index[t];
        if (void 0 === n) throw new Error(`Node with id '${t}' was not found in the heap.`);
        const r = this.data,
          i = r[n].priority,
          o = this.comparator(e, i);
        o < 0 ? (r[n].priority = e, this.bubbleUp(n)) : o > 0 && (r[n].priority = e, this.bubbleDown(n))
      }
      remove() {
        const t = this.data,
          e = t[0],
          n = t.pop();
        return delete this.index[t.length], t.length > 0 && (t[0] = n, n.id && (this.index[n.id] = 0), this.bubbleDown(
          0)), e ? e.value : null
      }
      heapify() {
        for (let t = 0; t < this.data.length; t += 1) this.bubbleUp(t)
      }
      bubbleUp(t) {
        const e = this.data;
        let n, r, i = t;
        for (; i > 0 && (r = i - 1 >>> 1, this.comparator(e[i].priority, e[r].priority) < 0);) {
          n = e[r], e[r] = e[i];
          let t = e[i].id;
          null != t && (this.index[t] = r), e[i] = n, null != (t = e[i].id) && (this.index[t] = i), i = r
        }
      }
      bubbleDown(t) {
        const e = this.data,
          n = e.length - 1;
        let r = t;
        for (;;) {
          const t = 1 + (r << 1),
            i = t + 1;
          let o = r;
          if (t <= n && this.comparator(e[t].priority, e[o].priority) < 0 && (o = t), i <= n && this.comparator(
              e[i].priority, e[o].priority) < 0 && (o = i), o === r) break; {
            const t = e[o];
            e[o] = e[r];
            let n = e[r].id;
            null != n && (this.index[n] = o), e[r] = t, null != (n = e[r].id) && (this.index[n] = r), r = o
          }
        }
      }
    }! function(t) {
      t.defaultComparator = ((t, e) => t - e)
    }(Yx || (Yx = {})),
    function(t) {
      (Gx || (Gx = {})).run = function(t, e, n = ((t, e) => 1)) {
        const r = {},
          i = {},
          o = {},
          s = new Yx;
        r[e] = 0;
        for (const n in t) n !== e && (r[n] = 1 / 0), s.insert(r[n], n, n);
        for (; !s.isEmpty();) {
          const e = s.remove();
          o[e] = !0;
          const a = t[e] || [];
          for (let t = 0; t < a.length; t += 1) {
            const l = a[t];
            if (!o[l]) {
              const t = r[e] + n(e, l);
              t < r[l] && (r[l] = t, i[l] = e, s.updatePriority(l, t))
            }
          }
        }
        return i
      }
    }(),
    function(t) {
      t.linear = (t => t), t.quad = (t => t * t), t.cubic = (t => t * t * t), t.inout = (t => {
        if (t <= 0) return 0;
        if (t >= 1) return 1;
        const e = t * t,
          n = e * t;
        return 4 * (t < .5 ? n : 3 * (t - e) + n - .75)
      }), t.exponential = (t => Math.pow(2, 10 * (t - 1))), t.bounce = (t => {
        for (let e = 0, n = 1;; e += n, n /= 2)
          if (t >= (7 - 4 * e) / 11) {
            const r = (11 - 6 * e - 11 * t) / 4;
            return -r * r + n * n
          }
      })
    }(Ux || (Ux = {})),
    function(t) {
      t.decorators = {
        reverse: t => e => 1 - t(1 - e),
        reflect: t => e => .5 * (e < .5 ? t(2 * e) : 2 - t(2 - 2 * e)),
        clamp: (t, e = 0, n = 1) => r => {
          const i = t(r);
          return i < e ? e : i > n ? n : i
        },
        back: (t = 1.70158) => e => e * e * ((t + 1) * e - t),
        elastic: (t = 1.5) => e => Math.pow(2, 10 * (e - 1)) * Math.cos(20 * Math.PI * t / 3 * e)
      }
    }(Ux || (Ux = {})),
    function(t) {
      function e(t) {
        const e = t / 1;
        if (e < 1 / 2.75) return 7.5625 * e * e;
        if (e < 2 / 2.75) {
          const t = e - 1.5 / 2.75;
          return 7.5625 * t * t + .75
        }
        if (e < 2.5 / 2.75) {
          const t = e - 2.25 / 2.75;
          return 7.5625 * t * t + .9375
        } {
          const t = e - 2.625 / 2.75;
          return 7.5625 * t * t + .984375
        }
      }

      function n(t) {
        return 1 - e(1 - t)
      }
      t.easeInSine = function(t) {
        return -1 * Math.cos(t * (Math.PI / 2)) + 1
      }, t.easeOutSine = function(t) {
        return Math.sin(t * (Math.PI / 2))
      }, t.easeInOutSine = function(t) {
        return -.5 * (Math.cos(Math.PI * t) - 1)
      }, t.easeInQuad = function(t) {
        return t * t
      }, t.easeOutQuad = function(t) {
        return t * (2 - t)
      }, t.easeInOutQuad = function(t) {
        return t < .5 ? 2 * t * t : (4 - 2 * t) * t - 1
      }, t.easeInCubic = function(t) {
        return t * t * t
      }, t.easeOutCubic = function(t) {
        const e = t - 1;
        return e * e * e + 1
      }, t.easeInOutCubic = function(t) {
        return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1
      }, t.easeInQuart = function(t) {
        return t * t * t * t
      }, t.easeOutQuart = function(t) {
        const e = t - 1;
        return 1 - e * e * e * e
      }, t.easeInOutQuart = function(t) {
        const e = t - 1;
        return t < .5 ? 8 * t * t * t * t : 1 - 8 * e * e * e * e
      }, t.easeInQuint = function(t) {
        return t * t * t * t * t
      }, t.easeOutQuint = function(t) {
        const e = t - 1;
        return 1 + e * e * e * e * e
      }, t.easeInOutQuint = function(t) {
        const e = t - 1;
        return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * e * e * e * e * e
      }, t.easeInExpo = function(t) {
        return 0 === t ? 0 : Math.pow(2, 10 * (t - 1))
      }, t.easeOutExpo = function(t) {
        return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
      }, t.easeInOutExpo = function(t) {
        if (0 === t || 1 === t) return t;
        const e = 2 * t,
          n = e - 1;
        return e < 1 ? .5 * Math.pow(2, 10 * n) : .5 * (2 - Math.pow(2, -10 * n))
      }, t.easeInCirc = function(t) {
        const e = t / 1;
        return -1 * (Math.sqrt(1 - e * t) - 1)
      }, t.easeOutCirc = function(t) {
        const e = t - 1;
        return Math.sqrt(1 - e * e)
      }, t.easeInOutCirc = function(t) {
        const e = 2 * t,
          n = e - 2;
        return e < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - n * n) + 1)
      }, t.easeInBack = function(t, e = 1.70158) {
        return t * t * ((e + 1) * t - e)
      }, t.easeOutBack = function(t, e = 1.70158) {
        const n = t / 1 - 1;
        return n * n * ((e + 1) * n + e) + 1
      }, t.easeInOutBack = function(t, e = 1.70158) {
        const n = 2 * t,
          r = n - 2,
          i = 1.525 * e;
        return n < 1 ? .5 * n * n * ((i + 1) * n - i) : .5 * (r * r * ((i + 1) * r + i) + 2)
      }, t.easeInElastic = function(t, e = .7) {
        if (0 === t || 1 === t) return t;
        const n = t / 1 - 1,
          r = 1 - e,
          i = r / (2 * Math.PI) * Math.asin(1);
        return -Math.pow(2, 10 * n) * Math.sin((n - i) * (2 * Math.PI) / r)
      }, t.easeOutElastic = function(t, e = .7) {
        const n = 1 - e,
          r = 2 * t;
        if (0 === t || 1 === t) return t;
        const i = n / (2 * Math.PI) * Math.asin(1);
        return Math.pow(2, -10 * r) * Math.sin((r - i) * (2 * Math.PI) / n) + 1
      }, t.easeInOutElastic = function(t, e = .65) {
        const n = 1 - e;
        if (0 === t || 1 === t) return t;
        const r = 2 * t,
          i = r - 1,
          o = n / (2 * Math.PI) * Math.asin(1);
        return r < 1 ? Math.pow(2, 10 * i) * Math.sin((i - o) * (2 * Math.PI) / n) * -.5 : Math.pow(2, -10 * i) *
          Math.sin((i - o) * (2 * Math.PI) / n) * .5 + 1
      }, t.easeOutBounce = e, t.easeInBounce = n, t.easeInOutBounce = function(t) {
        return t < .5 ? .5 * n(2 * t) : .5 * e(2 * t - 1) + .5
      }
    }(Ux || (Ux = {})),
    function(t) {
      t.number = ((t, e) => {
        const n = e - t;
        return e => t + n * e
      }), t.object = ((t, e) => {
        const n = Object.keys(t);
        return r => {
          const i = {};
          for (let o = n.length - 1; - 1 !== o; o -= 1) {
            const s = n[o];
            i[s] = t[s] + (e[s] - t[s]) * r
          }
          return i
        }
      }), t.unit = ((t, e) => {
        const n = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/,
          r = n.exec(t),
          i = n.exec(e),
          o = i ? i[1] : "",
          s = r ? +r[1] : 0,
          a = i ? +i[1] : 0,
          l = o.indexOf("."),
          c = l > 0 ? o[1].length - l - 1 : 0,
          h = a - s,
          u = r ? r[2] : "";
        return t => (s + h * t).toFixed(c) + u
      }), t.color = ((t, e) => {
        const n = parseInt(t.slice(1), 16),
          r = parseInt(e.slice(1), 16),
          i = 255 & n,
          o = (255 & r) - i,
          s = 65280 & n,
          a = (65280 & r) - s,
          l = 16711680 & n,
          c = (16711680 & r) - l;
        return t => {
          return `#${(1<<24|i+o*t&255|s+a*t&65280|l+c*t&16711680).toString(16).slice(1)}`
        }
      })
    }(qx || (qx = {}));
    const Jx = {
      prefixCls: "x6",
      autoInsertCSS: !0,
      useCSSSelector: !0,
      trackable: !0,
      trackInfo: {},
      track(t) {
        Jx.trackable = t
      }
    };
    var Zx;
    ! function(t) {
      const e = `${Jx.prefixCls}.storage`;

      function n(t, e, n) {
        t && l.defer(() => {
          t(e, n)
        })
      }

      function r(t, e) {
        localStorage.setItem(t, JSON.stringify(e))
      }

      function i(t) {
        const e = localStorage.getItem(t);
        return e ? JSON.parse(e) : null
      }

      function o(t) {
        const e = i(c(t));
        return e ? (null == e.keys && (e.keys = []), e) : {
          keys: []
        }
      }

      function a(t, n) {
        return `${e}.${t}.docs.${n}`
      }

      function c(t) {
        return `${e}.${t}.index`
      }
      t.insert = function(t, e, i) {
        const l = e.id || s.uniqueId("doc-"),
          h = o(t);
        h.keys.push(l), r(a(t, l), e), r(c(t), h), n(i, null, Object.assign(Object.assign({}, e), {
          id: l
        }))
      }, t.find = function(t, e, r) {
        const s = o(t),
          l = [];
        if (null == e) s.keys.forEach(e => {
          const o = i(a(t, e));
          o ? l.push(o) : n(r, new Error(`No document found for an ID '${e}' from index.`))
        }), n(r, null, l);
        else if (e.id) {
          const o = i(a(t, e.id));
          n(r, null, o ? [o] : [])
        } else n(r, null, [])
      }, t.remove = function(t, e, i) {
        const s = o(t);
        if (null == e) s.keys.forEach(e => {
          localStorage.removeItem(a(t, e))
        }), localStorage.removeItem(c(t)), n(i, null);
        else if (e.id) {
          const o = s.keys.indexOf(e.id);
          o >= 0 && s.keys.splice(o, 1), localStorage.removeItem(a(t, e.id)), r(c(t), s), n(i, null)
        }
      }
    }(Zx || (Zx = {}));
    class Kx {
      constructor(t) {
        this.options = Object.assign({}, t), this.data = this.options.data || {}, this.register = this.register
          .bind(this), this.unregister = this.unregister.bind(this)
      }
      get names() {
        return Object.keys(this.data)
      }
      register(t, e, n = !1) {
        if ("object" == typeof t) return void Object.keys(t).forEach(n => {
          this.register(n, t[n], e)
        });
        !this.exist(t) || n || D.a.isApplyingHMR() || this.onDuplicated(t);
        const r = this.options.process,
          i = r ? l.call(r, this, t, e) : e;
        return this.data[t] = i, i
      }
      unregister(t) {
        const e = t ? this.data[t] : null;
        return delete this.data[t], e
      }
      get(t) {
        return t ? this.data[t] : null
      }
      exist(t) {
        return !!t && null != this.data[t]
      }
      onDuplicated(t) {
        try {
          throw this.options.onConflict && l.call(this.options.onConflict, this, t), new Error(
            `${s.upperFirst(this.options.type)} with name '${t}' already registered.`)
        } catch (t) {
          throw t
        }
      }
      onNotFound(t, e) {
        throw new Error(this.getSpellingSuggestion(t, e))
      }
      getSpellingSuggestion(t, e) {
        const n = this.getSpellingSuggestionForName(t),
          r = e ? `${e} ${s.lowerFirst(this.options.type)}` : this.options.type;
        return `${s.upperFirst(r)} with name '${t}' does not exist.` + (n ? ` Did you mean '${n}'?` : "")
      }
      getSpellingSuggestionForName(t) {
        return s.getSpellingSuggestion(t, Object.keys(this.data), t => t)
      }
    }! function(t) {
      t.create = function(e) {
        return new t(e)
      }
    }(Kx || (Kx = {}));
    const Qx = {
        xlinkHref: "xlink:href",
        xlinkShow: "xlink:show",
        xlinkRole: "xlink:role",
        xlinkType: "xlink:type",
        xlinkArcrole: "xlink:arcrole",
        xlinkTitle: "xlink:title",
        xlinkActuate: "xlink:actuate",
        xmlSpace: "xml:space",
        xmlBase: "xml:base",
        xmlLang: "xml:lang",
        preserveAspectRatio: "preserveAspectRatio",
        requiredExtension: "requiredExtension",
        requiredFeatures: "requiredFeatures",
        systemLanguage: "systemLanguage",
        externalResourcesRequired: "externalResourceRequired"
      },
      tw = {},
      ew = {
        position: Ew("x", "width", "origin")
      },
      nw = {
        position: Ew("y", "height", "origin")
      },
      rw = {
        position: Ew("x", "width", "corner")
      },
      iw = {
        position: Ew("y", "height", "corner")
      },
      ow = {
        set: Sw("width", "width")
      },
      sw = {
        set: Sw("height", "height")
      },
      aw = {
        set: Sw("rx", "width")
      },
      lw = {
        set: Sw("ry", "height")
      },
      cw = {
        set: (t => {
          const e = Sw("r", "width"),
            n = Sw("r", "height");
          return function(t, r) {
            const i = r.refBBox,
              o = i.height > i.width ? e : n;
            return l.call(o, this, t, r)
          }
        })()
      },
      hw = {
        set(t, {
          refBBox: e
        }) {
          let n = parseFloat(t);
          const r = a.isPercentage(t);
          r && (n /= 100);
          const i = Math.sqrt(e.height * e.height + e.width * e.width);
          let o;
          return isFinite(n) && (o = r || n >= 0 && n <= 1 ? n * i : Math.max(n + i, 0)), {
            r: o
          }
        }
      },
      uw = {
        set: Sw("cx", "width")
      },
      dw = {
        set: Sw("cy", "height")
      },
      pw = {
        set: kw({
          resetOffset: !0
        })
      },
      fw = {
        set: kw({
          resetOffset: !1
        })
      },
      gw = {
        set: Ow({
          resetOffset: !0
        })
      },
      mw = {
        set: Ow({
          resetOffset: !1
        })
      },
      vw = cw,
      yw = pw,
      bw = gw,
      Cw = ew,
      xw = nw,
      ww = ow,
      Aw = sw;

    function Ew(t, e, n) {
      return (r, {
        refBBox: i
      }) => {
        if (null == r) return null;
        let o = parseFloat(r);
        const s = a.isPercentage(r);
        let l;
        if (s && (o /= 100), isFinite(o)) {
          const r = i[n];
          l = s || o > 0 && o < 1 ? r[t] + i[e] * o : r[t] + o
        }
        const c = new hC;
        return c[t] = l || 0, c
      }
    }

    function Sw(t, e) {
      return function(n, {
        refBBox: r
      }) {
        let i = parseFloat(n);
        const o = a.isPercentage(n);
        o && (i /= 100);
        const s = {};
        if (isFinite(i)) {
          const n = o || i >= 0 && i <= 1 ? i * r[e] : Math.max(i + r[e], 0);
          s[t] = n
        }
        return s
      }
    }

    function Mw(t, e) {
      const n = e && e.resetOffset;
      return function(e, {
        view: r,
        elem: i,
        refBBox: o
      }) {
        const s = r.$(i);
        let a = s.data("x6-shape");
        if (!a || a.value !== e) {
          const n = t(e);
          a = {
            value: e,
            shape: n,
            shapeBBox: n.bbox()
          }, s.data("x6-shape", a)
        }
        const l = a.shape.clone(),
          c = a.shapeBBox.clone(),
          h = c.getOrigin(),
          u = o.getOrigin();
        c.x = u.x, c.y = u.y;
        const d = o.maxRectScaleToFit(c, u),
          p = 0 === c.width || 0 === o.width ? 1 : d.sx,
          f = 0 === c.height || 0 === o.height ? 1 : d.sy;
        return l.scale(p, f, h), n && l.translate(-h.x, -h.y), l
      }
    }

    function kw(t) {
      const e = Mw(function(t) {
        return PC.parse(PC.normalize(t))
      }, t);
      return (t, n) => {
        return {
          d: e(t, n).serialize()
        }
      }
    }

    function Ow(t) {
      const e = Mw(t => new fC(t), t);
      return (t, n) => {
        return {
          points: e(t, n).serialize()
        }
      }
    }
    const Pw = {
        qualify: o.isPlainObject,
        set: (t, {
          view: e
        }) => `url(#${e.graph.defineGradient(t)})`
      },
      Dw = {
        qualify: o.isPlainObject,
        set: (t, {
          view: e
        }) => `url(#${e.graph.defineGradient(t)})`
      },
      Tw = {
        qualify: (t, {
          attrs: e
        }) => null == e.textWrap || !o.isPlainObject(e.textWrap),
        set(t, {
          view: e,
          elem: n,
          attrs: r
        }) {
          const i = e.$(n),
            s = i.data("x6-text"),
            a = o.pick(r, "lineHeight", "annotations", "textPath", "x", "textVerticalAnchor", "eol",
              "displayEmpty", "fontSize");
          a.fontSize = r["font-size"] || r.fontSize;
          const l = a.fontSize,
            c = JSON.stringify([t, a]);
          if (null == s || s !== c) {
            l && n.setAttribute("font-size", l);
            const r = a.textPath;
            if (null != r && "object" == typeof r) {
              const t = r.selector;
              if ("string" == typeof t) {
                const n = e.find(t)[0];
                n instanceof SVGPathElement && (h.ensureId(n), a.textPath = Object.assign({
                  "xlink:href": `#${n.id}`
                }, r))
              }
            }
            h.text(n, `${t}`, a), i.data("x6-text", c)
          }
        }
      },
      _w = {
        qualify: o.isPlainObject,
        set(t, {
          view: e,
          elem: n,
          attrs: r,
          refBBox: i
        }) {
          const o = t,
            s = o.width || 0;
          a.isPercentage(s) ? i.width *= parseFloat(s) / 100 : s <= 0 ? i.width += s : i.width = s;
          const c = o.height || 0;
          let u;
          a.isPercentage(c) ? i.height *= parseFloat(c) / 100 : c <= 0 ? i.height += c : i.height = c;
          let d = o.text;
          null == d && (d = r.text), u = null != d ? h.breakText(`${d}`, i, {
            "font-weight": r["font-weight"] || r.fontWeight,
            "font-size": r["font-size"] || r.fontSize,
            "font-family": r["font-family"] || r.fontFamily,
            lineHeight: r.lineHeight
          }, {
            svgDocument: e.graph.view.svg,
            ellipsis: o.ellipsis,
            hyphen: o.hyphen
          }) : "", l.call(Tw.set, this, u, {
            view: e,
            elem: n,
            attrs: r,
            refBBox: i,
            cell: e.cell
          })
        }
      },
      jw = (t, {
        attrs: e
      }) => void 0 !== e.text,
      Lw = {
        qualify: jw
      },
      Nw = {
        qualify: jw
      },
      Fw = {
        qualify: jw
      },
      $w = {
        qualify: jw
      },
      Bw = {
        qualify: jw
      },
      Iw = {
        qualify: jw
      },
      zw = {
        qualify: (t, {
          elem: e
        }) => e instanceof SVGElement,
        set(t, {
          view: e,
          elem: n
        }) {
          const r = `${t}`,
            i = e.$(n),
            o = i.data("x6-title");
          if (null == o || o !== r) {
            i.data("x6-title", r);
            const t = n.firstChild;
            if (t && "TITLE" === t.tagName.toUpperCase()) {
              t.textContent = r
            } else {
              const e = document.createElementNS(n.namespaceURI, "title");
              e.textContent = r, n.insertBefore(e, t)
            }
          }
        }
      },
      Rw = {
        offset: Gw("x", "width", "right")
      },
      Vw = {
        offset: Gw("y", "height", "bottom")
      },
      Hw = {
        offset: (t, {
          refBBox: e
        }) => t ? {
          x: -e.x,
          y: -e.y
        } : {
          x: 0,
          y: 0
        }
      };

    function Gw(t, e, n) {
      return (r, {
        refBBox: i
      }) => {
        const o = new hC;
        let s;
        return s = "middle" === r ? i[e] / 2 : r === n ? i[e] : "number" == typeof r && isFinite(r) ? r > -1 &&
          r < 1 ? -i[e] * r : -r : a.isPercentage(r) ? i[e] * parseFloat(r) / 100 : 0, o[t] = -(i[t] + s), o
      }
    }
    const Uw = {
        qualify: o.isPlainObject,
        set(t, {
          view: e,
          elem: n
        }) {
          e.$(n).css(t)
        }
      },
      qw = {
        set(t, {
          view: e,
          elem: n
        }) {
          e.$(n).html(`${t}`)
        }
      },
      Ww = {
        qualify: o.isPlainObject,
        set: (t, {
          view: e
        }) => `url(#${e.graph.defineFilter(t)})`
      },
      Xw = {
        set: t => null != t && "object" == typeof t && t.id ? t.id : t
      };

    function Yw(t, e, n) {
      let r, i;
      "object" == typeof e ? (r = e.x, i = e.y) : (r = e, i = n);
      const o = PC.parse(PC.normalize(t)),
        s = o.bbox();
      if (s) {
        let t = -s.height / 2 - s.y,
          e = -s.width / 2 - s.x;
        "number" == typeof r && (e -= r), "number" == typeof i && (t -= i), o.translate(e, t)
      }
      return o.serialize()
    }
    var Jw = this && this.__rest || function(t, e) {
      var n = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
          .call(t, r[i]) && (n[r[i]] = t[r[i]])
      }
      return n
    };
    const Zw = t => {
        var {
          size: e,
          width: n,
          height: r,
          offset: i,
          open: o
        } = t;
        return Qw({
          size: e,
          width: n,
          height: r,
          offset: i
        }, !0 === o, !0, void 0, Jw(t, ["size", "width", "height", "offset", "open"]))
      },
      Kw = t => {
        var {
          size: e,
          width: n,
          height: r,
          offset: i,
          factor: o
        } = t;
        return Qw({
          size: e,
          width: n,
          height: r,
          offset: i
        }, !1, !1, o, Jw(t, ["size", "width", "height", "offset", "factor"]))
      };

    function Qw(t, e, n, r = .75, i = {}) {
      const o = t.size || 10,
        s = t.width || o,
        l = t.height || o,
        c = new PC,
        h = {};
      if (e) c.moveTo(s, 0).lineTo(0, l / 2).lineTo(s, l), h.fill = "none";
      else {
        if (c.moveTo(0, l / 2), c.lineTo(s, 0), !n) {
          const t = a.clamp(r, 0, 1);
          c.lineTo(s * t, l / 2)
        }
        c.lineTo(s, l), c.close()
      }
      return Object.assign(Object.assign(Object.assign({}, h), i), {
        tagName: "path",
        d: Yw(c.serialize(), {
          x: null != t.offset ? t.offset : -s / 2
        })
      })
    }
    var tA = this && this.__rest || function(t, e) {
      var n = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
          .call(t, r[i]) && (n[r[i]] = t[r[i]])
      }
      return n
    };
    const eA = t => {
      var {
        size: e,
        width: n,
        height: r,
        offset: i
      } = t, o = tA(t, ["size", "width", "height", "offset"]);
      const s = e || 10,
        a = n || s,
        l = r || s,
        c = new PC;
      return c.moveTo(0, l / 2).lineTo(a / 2, 0).lineTo(a, l / 2).lineTo(a / 2, l).close(), Object.assign(
        Object.assign({}, o), {
          tagName: "path",
          d: Yw(c.serialize(), null == i ? -a / 2 : i)
        })
    };
    var nA = this && this.__rest || function(t, e) {
      var n = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
          .call(t, r[i]) && (n[r[i]] = t[r[i]])
      }
      return n
    };
    const rA = t => {
      var {
        d: e,
        offsetX: n,
        offsetY: r
      } = t, i = nA(t, ["d", "offsetX", "offsetY"]);
      return Object.assign(Object.assign({}, i), {
        tagName: "path",
        d: Yw(e, n, r)
      })
    };
    var iA = this && this.__rest || function(t, e) {
      var n = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
          .call(t, r[i]) && (n[r[i]] = t[r[i]])
      }
      return n
    };
    const oA = t => {
      var {
        size: e,
        width: n,
        height: r,
        offset: i
      } = t, o = iA(t, ["size", "width", "height", "offset"]);
      const s = e || 10,
        a = n || s,
        l = r || s,
        c = new PC;
      return c.moveTo(0, 0).lineTo(a, l).moveTo(0, l).lineTo(a, 0), Object.assign(Object.assign({}, o), {
        tagName: "path",
        fill: "none",
        d: Yw(c.serialize(), i || -a / 2)
      })
    };
    var sA = this && this.__rest || function(t, e) {
      var n = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
          .call(t, r[i]) && (n[r[i]] = t[r[i]])
      }
      return n
    };
    const aA = t => {
      var {
        width: e,
        height: n,
        offset: r,
        open: i,
        flip: o
      } = t, s = sA(t, ["width", "height", "offset", "open", "flip"]);
      let a = n || 6;
      const l = e || 10,
        c = !0 === i,
        h = !0 === o,
        u = Object.assign(Object.assign({}, s), {
          tagName: "path"
        });
      h && (a = -a);
      const d = new PC;
      return d.moveTo(0, a).lineTo(l, 0), c ? u.fill = "none" : (d.lineTo(l, a), d.close()), u.d = Yw(d.serialize(), {
        x: r || -l / 2,
        y: a / 2
      }), u
    };
    var lA = this && this.__rest || function(t, e) {
      var n = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
          .call(t, r[i]) && (n[r[i]] = t[r[i]])
      }
      return n
    };
    const cA = t => {
        var {
          r: e
        } = t, n = lA(t, ["r"]);
        const r = e || 5;
        return Object.assign(Object.assign({
          cx: r
        }, n), {
          tagName: "circle",
          r: r
        })
      },
      hA = t => {
        var {
          r: e
        } = t, n = lA(t, ["r"]);
        const r = e || 5,
          i = new PC;
        return i.moveTo(r, 0).lineTo(r, 2 * r), i.moveTo(0, r).lineTo(2 * r, r), {
          children: [Object.assign(Object.assign({}, cA({
            r: r
          })), {
            fill: "none"
          }), Object.assign(Object.assign({}, n), {
            type: "path",
            d: Yw(i.serialize(), -r)
          })]
        }
      };
    var uA = this && this.__rest || function(t, e) {
      var n = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
          .call(t, r[i]) && (n[r[i]] = t[r[i]])
      }
      return n
    };
    const dA = t => {
      var {
        rx: e,
        ry: n
      } = t, r = uA(t, ["rx", "ry"]);
      const i = e || 5,
        o = n || 5;
      return Object.assign(Object.assign({
        cx: i
      }, r), {
        tagName: "ellipse",
        rx: i,
        ry: o
      })
    };
    var pA, fA;
    (fA = pA || (pA = {})).presets = u, fA.registry = Kx.create({
      type: "marker"
    }), fA.registry.register(fA.presets, !0), (pA || (pA = {})).normalize = Yw;
    var gA = this && this.__rest || function(t, e) {
      var n = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
          .call(t, r[i]) && (n[r[i]] = t[r[i]])
      }
      return n
    };

    function mA(t) {
      return "string" == typeof t || o.isPlainObject(t)
    }
    const vA = {
        qualify: mA,
        set: (t, {
          view: e,
          attrs: n
        }) => CA("marker-start", t, e, n)
      },
      yA = {
        qualify: mA,
        set: (t, {
          view: e,
          attrs: n
        }) => CA("marker-end", t, e, n, {
          transform: "rotate(180)"
        })
      },
      bA = {
        qualify: mA,
        set: (t, {
          view: e,
          attrs: n
        }) => CA("marker-mid", t, e, n)
      };

    function CA(t, e, n, r, i = {}) {
      const o = "string" == typeof e ? {
          name: e
        } : e,
        {
          name: s,
          args: a
        } = o,
        l = gA(o, ["name", "args"]);
      let c = l;
      if (s && "string" == typeof s) {
        const t = pA.registry.get(s);
        if (!t) return pA.registry.onNotFound(s);
        c = t(Object.assign(Object.assign({}, l), a))
      }
      const h = Object.assign(Object.assign(Object.assign({}, function(t) {
        const e = {},
          n = t.stroke;
        "string" == typeof n && (e.stroke = n, e.fill = n);
        let r = t.strokeOpacity;
        null == r && (r = t["stroke-opacity"]);
        null == r && (r = t.opacity);
        null != r && (e["stroke-opacity"] = r, e["fill-opacity"] = r);
        return e
      }(r)), i), c);
      return {
        [t]: `url(#${n.graph.defineMarker(h)})`
      }
    }
    const xA = (t, {
        view: e
      }) => e.cell.isEdge(),
      wA = {
        qualify: xA,
        set(t, e) {
          const n = e.view,
            r = t.stubs || 0;
          let i;
          if (isFinite(r) && 0 !== r) {
            let t;
            if (r < 0) {
              t = ((n.getConnectionLength() || 0) + r) / 2
            } else t = r;
            const e = n.getConnection();
            if (e) {
              const n = e.divideAtLength(t),
                r = e.divideAtLength(-t);
              n && r && (i = `${n[0].serialize()} ${r[1].serialize()}`)
            }
          }
          return {
            d: i || n.getConnectionPathData()
          }
        }
      },
      AA = {
        qualify: xA,
        set: PA("getTangentAtLength", {
          rotate: !0
        })
      },
      EA = {
        qualify: xA,
        set: PA("getTangentAtLength", {
          rotate: !1
        })
      },
      SA = {
        qualify: xA,
        set: PA("getTangentAtRatio", {
          rotate: !0
        })
      },
      MA = {
        qualify: xA,
        set: PA("getTangentAtRatio", {
          rotate: !1
        })
      },
      kA = AA,
      OA = SA;

    function PA(t, e) {
      const n = {
        x: 1,
        y: 0
      };
      return (r, i) => {
        let o, s;
        const a = i.view,
          l = a[t](Number(r));
        return l ? (s = e.rotate ? l.vector().vectorAngle(n) : 0, o = l.start) : (o = a.path.start, s = 0), 0 ===
          s ? {
            transform: `translate(${o.x},${o.y}')`
          } : {
            transform: `translate(${o.x},${o.y}') rotate(${s})`
          }
      }
    }
    var DA, TA;
    ! function(t) {
      (DA || (DA = {})).isValidDefinition = function(t, e, n) {
        if (null != t) {
          if ("string" == typeof t) return !0;
          if ("function" != typeof t.qualify || l.call(t.qualify, this, e, n)) return !0
        }
        return !1
      }
    }(), (TA = DA || (DA = {})).presets = Object.assign(Object.assign({}, Qx), d), TA.registry = Kx.create({
      type: "attribute definition"
    }), TA.registry.register(TA.presets, !0);
    const _A = {
        color: "#aaaaaa",
        thickness: 1,
        markup: "rect",
        update(t, e) {
          const n = e.thickness * e.sx,
            r = e.thickness * e.sy;
          h.attr(t, {
            width: n,
            height: r,
            rx: n,
            ry: r,
            fill: e.color
          })
        }
      },
      jA = {
        color: "#aaaaaa",
        thickness: 1,
        markup: "rect",
        update(t, e) {
          const n = e.sx <= 1 ? e.thickness * e.sx : e.thickness;
          h.attr(t, {
            width: n,
            height: n,
            rx: n,
            ry: n,
            fill: e.color
          })
        }
      },
      LA = {
        color: "rgba(224,224,224,1)",
        thickness: 1,
        markup: "path",
        update(t, e) {
          let n;
          const r = e.width,
            i = e.height,
            o = e.thickness;
          n = r - o >= 0 && i - o >= 0 ? ["M", r, 0, "H0 M0 0 V0", i].join(" ") : "M 0 0 0 0", h.attr(t, {
            d: n,
            stroke: e.color,
            "stroke-width": e.thickness
          })
        }
      },
      NA = [{
        color: "rgba(224,224,224,1)",
        thickness: 1,
        markup: "path",
        update(t, e) {
          let n;
          const r = e.width,
            i = e.height,
            o = e.thickness;
          n = r - o >= 0 && i - o >= 0 ? ["M", r, 0, "H0 M0 0 V0", i].join(" ") : "M 0 0 0 0", h.attr(t, {
            d: n,
            stroke: e.color,
            "stroke-width": e.thickness
          })
        }
      }, {
        color: "rgba(224,224,224,0.2)",
        thickness: 3,
        factor: 4,
        markup: "path",
        update(t, e) {
          let n;
          const r = e.factor || 1,
            i = e.width * r,
            o = e.height * r,
            s = e.thickness;
          n = i - s >= 0 && o - s >= 0 ? ["M", i, 0, "H0 M0 0 V0", o].join(" ") : "M 0 0 0 0", e.width = i, e.height =
            o, h.attr(t, {
              d: n,
              stroke: e.color,
              "stroke-width": e.thickness
            })
        }
      }];
    class FA {
      constructor() {
        this.patterns = {}, this.root = h.createVector(h.createSvgDocument(), {
          width: "100%",
          height: "100%"
        }, [h.createSvgElement("defs")]).node
      }
      add(t, e) {
        const n = this.root.childNodes[0];
        n && n.appendChild(e), this.patterns[t] = e, h.createVector("rect", {
          width: "100%",
          height: "100%",
          fill: `url(#${t})`
        }).appendTo(this.root)
      }
      get(t) {
        return this.patterns[t]
      }
      has(t) {
        return null != this.patterns[t]
      }
    }
    var $A, BA, IA;

    function zA(t, e) {
      return null != t ? t : e
    }

    function RA(t, e) {
      return null != t && isFinite(t) ? t : e
    }

    function VA(t = {}) {
      const e = zA(t.color, "blue"),
        n = RA(t.width, 1),
        r = RA(t.margin, 2);
      return `\n    <filter>\n      <feFlood flood-color="${e}" flood-opacity="${RA(t.opacity,1)}" result="colored"/>\n      <feMorphology in="SourceAlpha" result="morphedOuter" operator="dilate" radius="${r+n}" />\n      <feMorphology in="SourceAlpha" result="morphedInner" operator="dilate" radius="${r}" />\n      <feComposite result="morphedOuterColored" in="colored" in2="morphedOuter" operator="in"/>\n      <feComposite operator="xor" in="morphedOuterColored" in2="morphedInner" result="outline"/>\n      <feMerge>\n        <feMergeNode in="outline"/>\n        <feMergeNode in="SourceGraphic"/>\n      </feMerge>\n    </filter>\n  `
        .trim()
    }

    function HA(t = {}) {
      const e = zA(t.color, "red"),
        n = RA(t.blur, 0),
        r = RA(t.width, 1);
      return `\n      <filter>\n        <feFlood flood-color="${e}" flood-opacity="${RA(t.opacity,1)}" result="colored"/>\n        <feMorphology result="morphed" in="SourceGraphic" operator="dilate" radius="${r}"/>\n        <feComposite result="composed" in="colored" in2="morphed" operator="in"/>\n        <feGaussianBlur result="blured" in="composed" stdDeviation="${n}"/>\n        <feBlend in="SourceGraphic" in2="blured" mode="normal"/>\n      </filter>\n    `
        .trim()
    }

    function GA(t = {}) {
      const e = RA(t.x, 2);
      return `\n    <filter>\n      <feGaussianBlur stdDeviation="${null!=t.y&&isFinite(t.y)?[e,t.y]:e}"/>\n    </filter>\n  `
        .trim()
    }

    function UA(t = {}) {
      const e = RA(t.dx, 0),
        n = RA(t.dy, 0),
        r = zA(t.color, "black"),
        i = RA(t.blur, 4),
        o = RA(t.opacity, 1);
      return "SVGFEDropShadowElement" in window ?
        `<filter>\n         <feDropShadow stdDeviation="${i}" dx="${e}" dy="${n}" flood-color="${r}" flood-opacity="${o}" />\n       </filter>`
        .trim() :
        `<filter>\n         <feGaussianBlur in="SourceAlpha" stdDeviation="${i}" />\n         <feOffset dx="${e}" dy="${n}" result="offsetblur" />\n         <feFlood flood-color="${r}" />\n         <feComposite in2="offsetblur" operator="in" />\n         <feComponentTransfer>\n           <feFuncA type="linear" slope="${o}" />\n         </feComponentTransfer>\n         <feMerge>\n           <feMergeNode/>\n           <feMergeNode in="SourceGraphic"/>\n         </feMerge>\n       </filter>`
        .trim()
    }

    function qA(t = {}) {
      const e = RA(t.amount, 1),
        n = .7152 - .7152 * (1 - e);
      return `\n    <filter>\n      <feColorMatrix type="matrix" values="${.2126+.7874*(1-e)} ${n} ${.0722-.0722*(1-e)} 0 0 ${.2126-.2126*(1-e)} ${.7152+.2848*(1-e)} ${.0722-.0722*(1-e)} 0 0 ${.2126-.2126*(1-e)} ${n} ${.0722+.9278*(1-e)} 0 0 0 0 0 1 0"/>\n    </filter>\n  `
        .trim()
    }

    function WA(t = {}) {
      const e = RA(t.amount, 1);
      return `\n      <filter>\n        <feColorMatrix type="matrix" values="${.393+.607*(1-e)} ${.769-.769*(1-e)} ${.189-.189*(1-e)} 0 0 ${.349-.349*(1-e)} ${.686+.314*(1-e)} ${.168-.168*(1-e)} 0 0 ${.272-.272*(1-e)} ${.534-.534*(1-e)} ${.131+.869*(1-e)} 0 0 0 0 0 1 0"/>\n      </filter>\n    `
        .trim()
    }

    function XA(t = {}) {
      return `\n      <filter>\n        <feColorMatrix type="saturate" values="${1-RA(t.amount,1)}"/>\n      </filter>\n    `
        .trim()
    }

    function YA(t = {}) {
      return `\n      <filter>\n        <feColorMatrix type="hueRotate" values="${RA(t.angle,0)}"/>\n      </filter>\n    `
        .trim()
    }

    function JA(t = {}) {
      const e = RA(t.amount, 1),
        n = 1 - e;
      return `\n      <filter>\n        <feComponentTransfer>\n          <feFuncR type="table" tableValues="${e} ${n}"/>\n          <feFuncG type="table" tableValues="${e} ${n}"/>\n          <feFuncB type="table" tableValues="${e} ${n}"/>\n        </feComponentTransfer>\n      </filter>\n    `
        .trim()
    }

    function ZA(t = {}) {
      const e = RA(t.amount, 1);
      return `\n    <filter>\n      <feComponentTransfer>\n        <feFuncR type="linear" slope="${e}"/>\n        <feFuncG type="linear" slope="${e}"/>\n        <feFuncB type="linear" slope="${e}"/>\n      </feComponentTransfer>\n    </filter>\n  `
        .trim()
    }

    function KA(t = {}) {
      const e = RA(t.amount, 1),
        n = .5 - e / 2;
      return `\n    <filter>\n     <feComponentTransfer>\n        <feFuncR type="linear" slope="${e}" intercept="${n}"/>\n        <feFuncG type="linear" slope="${e}" intercept="${n}"/>\n        <feFuncB type="linear" slope="${e}" intercept="${n}"/>\n      </feComponentTransfer>\n    </filter>\n  `
        .trim()
    }($A = FA || (FA = {})).presets = p, $A.registry = Kx.create({
      type: "grid"
    }), $A.registry.register($A.presets, !0), (IA = BA || (BA = {})).presets = f, IA.registry = Kx.create({
      type: "filter"
    }), IA.registry.register(IA.presets, !0);
    const QA = function(t) {
        const e = document.createElement("canvas"),
          n = t.width,
          r = t.height;
        e.width = 2 * n, e.height = r;
        const i = e.getContext("2d");
        return i.drawImage(t, 0, 0, n, r), i.translate(2 * n, 0), i.scale(-1, 1), i.drawImage(t, 0, 0, n, r), e
      },
      tE = function(t) {
        const e = document.createElement("canvas"),
          n = t.width,
          r = t.height;
        e.width = n, e.height = 2 * r;
        const i = e.getContext("2d");
        return i.drawImage(t, 0, 0, n, r), i.translate(0, 2 * r), i.scale(1, -1), i.drawImage(t, 0, 0, n, r), e
      },
      eE = function(t) {
        const e = document.createElement("canvas"),
          n = t.width,
          r = t.height;
        e.width = 2 * n, e.height = 2 * r;
        const i = e.getContext("2d");
        return i.drawImage(t, 0, 0, n, r), i.setTransform(-1, 0, 0, -1, e.width, e.height), i.drawImage(t, 0, 0,
          n, r), i.setTransform(-1, 0, 0, 1, e.width, 0), i.drawImage(t, 0, 0, n, r), i.setTransform(1, 0, 0, -
          1, 0, e.height), i.drawImage(t, 0, 0, n, r), e
      },
      nE = function(t, e) {
        const n = t.width,
          r = t.height,
          i = document.createElement("canvas");
        i.width = 3 * n, i.height = 3 * r;
        const o = i.getContext("2d"),
          s = null != e.angle ? -e.angle : -20,
          a = nC.toRad(s),
          l = i.width / 4,
          c = i.height / 4;
        for (let e = 0; e < 4; e += 1)
          for (let i = 0; i < 4; i += 1)(e + i) % 2 > 0 && (o.setTransform(1, 0, 0, 1, (2 * e - 1) * l, (2 * i -
            1) * c), o.rotate(a), o.drawImage(t, -n / 2, -r / 2, n, r));
        return i
      };
    var rE, iE, oE;
    (iE = rE || (rE = {})).presets = Object.assign({}, g), iE.presets["flip-x"] = QA, iE.presets["flip-y"] = tE,
      iE.presets["flip-xy"] = eE, iE.registry = Kx.create({
        type: "background pattern"
      }), iE.registry.register(iE.presets, !0),
      function(t) {
        t.snapToGrid = sC, t.normalizeMarker = Yw, t.prefix = function(t) {
          return `${Jx.prefixCls}-${t}`
        }
      }(oE || (oE = {})),
      function(t) {
        (oE || (oE = {})).makeTree = function(t, e, n, r = []) {
          const i = "function" == typeof e.children ? e.children(t) : t[e.children || "children"];
          return n || (n = e.createNode(t), r.push(n)), Array.isArray(i) && i.forEach(t => {
            const i = e.createNode(t),
              o = e.createEdge(n, i);
            r.push(i, o), this.makeTree(t, e, i, r)
          }), r
        }
      }();
    const sE = "0.10.76",
      aE = oE.prefix("highlighted"),
      lE = {
        highlight(t, e, n) {
          const r = n && n.className || aE;
          h.addClass(e, r)
        },
        unhighlight(t, e, n) {
          const r = n && n.className || aE;
          h.removeClass(e, r)
        }
      },
      cE = oE.prefix("highlight-opacity"),
      hE = {
        highlight(t, e) {
          h.addClass(e, cE)
        },
        unhighlight(t, e) {
          h.removeClass(e, cE)
        }
      },
      uE = {
        padding: 3,
        rx: 0,
        ry: 0,
        attrs: {
          "stroke-width": 3,
          stroke: "#FEB663"
        }
      },
      dE = {
        highlight(t, e, n) {
          const r = pE.getHighlighterId(e, n);
          if (pE.hasCache(r)) return;
          n = o.defaultsDeep({}, n, uE);
          const i = h.createVector(e);
          let s, a;
          try {
            s = i.convertToPathData()
          } catch (t) {
            a = i.bbox(!0), s = h.rectToPathData(Object.assign(Object.assign({}, n), a))
          }
          const l = h.createSvgElement("path");
          if (h.attr(l, Object.assign({
              d: s,
              "pointer-events": "none",
              "vector-effect": "non-scaling-stroke",
              fill: "none"
            }, n.attrs)), t.isEdgeElement(e)) h.attr(l, "d", t.getConnectionPathData());
          else {
            let e = i.getTransformToElement(t.container);
            const r = n.padding;
            if (r) {
              null == a && (a = i.bbox(!0));
              const t = a.x + a.width / 2,
                n = a.y + a.height / 2;
              a = h.transformRectangle(a, e);
              const o = Math.max(a.width, 1),
                s = Math.max(a.height, 1),
                l = (o + r) / o,
                c = (s + r) / s,
                u = h.createSVGMatrix({
                  a: l,
                  b: 0,
                  c: 0,
                  d: c,
                  e: t - l * t,
                  f: n - c * n
                });
              e = e.multiply(u)
            }
            h.transform(l, e)
          }
          h.addClass(l, oE.prefix("highlight-stroke"));
          const c = t.cell,
            u = () => pE.removeHighlighter(r);
          c.on("removed", u), c.model && c.model.on("reseted", u), t.container.appendChild(l), pE.setCache(r, l)
        },
        unhighlight(t, e, n) {
          pE.removeHighlighter(pE.getHighlighterId(e, n))
        }
      };
    var pE, fE, gE;

    function mE(t, e = {}) {
      return new hC(a.normalizePercentage(e.x, t.width), a.normalizePercentage(e.y, t.height))
    }

    function vE(t, e, n) {
      return Object.assign({
        angle: e,
        position: t.toJSON()
      }, n)
    }! function(t) {
      t.getHighlighterId = function(t, e) {
        return h.ensureId(t), t.id + JSON.stringify(e)
      };
      const e = {};
      t.setCache = function(t, n) {
        e[t] = n
      }, t.hasCache = function(t) {
        return null != e[t]
      }, t.removeHighlighter = function(t) {
        const n = e[t];
        n && (h.remove(n), delete e[t])
      }
    }(pE || (pE = {})),
    function(t) {
      (fE || (fE = {})).check = function(t, e) {
        if ("function" != typeof e.highlight) throw new Error(
          `Highlighter '${t}' is missing required \`highlight()\` method`);
        if ("function" != typeof e.unhighlight) throw new Error(
          `Highlighter '${t}' is missing required \`unhighlight()\` method`)
      }
    }(), (gE = fE || (fE = {})).presets = m, gE.registry = Kx.create({
      type: "highlighter"
    }), gE.registry.register(gE.presets, !0);
    const yE = (t, e) => t.map(({
        x: t,
        y: n,
        angle: r
      }) => vE(mE(e, {
        x: t,
        y: n
      }), r || 0)),
      bE = (t, e, n) => {
        const r = n.start || 0,
          i = n.step || 20;
        return xE(t, e, r, (t, e) => (t + .5 - e / 2) * i)
      },
      CE = (t, e, n) => {
        const r = n.start || 0,
          i = n.step || 360 / t.length;
        return xE(t, e, r, t => t * i)
      };

    function xE(t, e, n, r) {
      const i = e.getCenter(),
        o = e.getTopCenter(),
        s = e.width / e.height,
        a = pC.fromRect(e),
        l = t.length;
      return t.map((t, e) => {
        const c = n + r(e, l),
          h = o.clone().rotate(-c, i).scale(s, 1, i),
          u = t.compensateRotate ? -a.tangentTheta(h) : 0;
        return (t.dx || t.dy) && h.translate(t.dx || 0, t.dy || 0), t.dr && h.move(i, t.dr), vE(h.round(), u,
          t)
      })
    }
    var wE = this && this.__rest || function(t, e) {
      var n = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
          .call(t, r[i]) && (n[r[i]] = t[r[i]])
      }
      return n
    };
    const AE = (t, e, n) => {
        return OE(t, mE(e, n.start || e.getOrigin()), mE(e, n.end || e.getCorner()), n)
      },
      EE = (t, e, n) => OE(t, e.getTopLeft(), e.getBottomLeft(), n),
      SE = (t, e, n) => OE(t, e.getTopRight(), e.getBottomRight(), n),
      ME = (t, e, n) => OE(t, e.getTopLeft(), e.getTopRight(), n),
      kE = (t, e, n) => OE(t, e.getBottomLeft(), e.getBottomRight(), n);

    function OE(t, e, n, r) {
      const i = new dC(e, n),
        o = t.length;
      return t.map((t, e) => {
        var {
          strict: n
        } = t, s = wE(t, ["strict"]);
        const a = n || r.strict ? (e + 1) / (o + 1) : (e + .5) / o,
          l = i.pointAt(a);
        return (s.dx || s.dy) && l.translate(s.dx || 0, s.dy || 0), vE(l.round(), 0, s)
      })
    }
    var PE, DE;
    (DE = PE || (PE = {})).presets = v, DE.registry = Kx.create({
      type: "port layout"
    }), DE.registry.register(DE.presets, !0);
    const TE = {
      position: {
        x: 0,
        y: 0
      },
      angle: 0,
      attrs: {
        ".": {
          y: "0",
          "text-anchor": "start"
        }
      }
    };

    function _E(t, e) {
      const {
        x: n,
        y: r,
        angle: i,
        attrs: s
      } = e || {};
      return o.defaultsDeep({}, {
        angle: i,
        attrs: s,
        position: {
          x: n,
          y: r
        }
      }, t, TE)
    }
    const jE = (t, e, n) => _E({
        position: e.getTopLeft()
      }, n),
      LE = (t, e, n) => _E({
        position: {
          x: -15,
          y: 0
        },
        attrs: {
          ".": {
            y: ".3em",
            "text-anchor": "end"
          }
        }
      }, n),
      NE = (t, e, n) => _E({
        position: {
          x: 15,
          y: 0
        },
        attrs: {
          ".": {
            y: ".3em",
            "text-anchor": "start"
          }
        }
      }, n),
      FE = (t, e, n) => _E({
        position: {
          x: 0,
          y: -15
        },
        attrs: {
          ".": {
            "text-anchor": "middle"
          }
        }
      }, n),
      $E = (t, e, n) => _E({
        position: {
          x: 0,
          y: 15
        },
        attrs: {
          ".": {
            y: ".6em",
            "text-anchor": "middle"
          }
        }
      }, n),
      BE = (t, e, n) => VE(t, e, !1, n),
      IE = (t, e, n) => VE(t, e, !0, n),
      zE = (t, e, n) => HE(t, e, !1, n),
      RE = (t, e, n) => HE(t, e, !0, n);

    function VE(t, e, n, r) {
      const i = null != r.offset ? r.offset : 15,
        o = e.getCenter().theta(t),
        s = GE(e);
      let a, l, c, h, u = 0;
      return o < s[1] || o > s[2] ? (a = ".3em", l = i, c = 0, h = "start") : o < s[0] ? (a = "0", l = 0, c = -i,
        n ? (u = -90, h = "start") : h = "middle") : o < s[3] ? (a = ".3em", l = -i, c = 0, h = "end") : (a =
        ".6em", l = 0, c = i, n ? (u = 90, h = "start") : h = "middle"), _E({
        position: {
          x: Math.round(l),
          y: Math.round(c)
        },
        angle: u,
        attrs: {
          ".": {
            y: a,
            "text-anchor": h
          }
        }
      }, r)
    }

    function HE(t, e, n, r) {
      const i = null != r.offset ? r.offset : 15,
        o = e.getCenter().theta(t),
        s = GE(e);
      let a, l, c, h, u = 0;
      return o < s[1] || o > s[2] ? (a = ".3em", l = -i, c = 0, h = "end") : o < s[0] ? (a = ".6em", l = 0, c = i,
        n ? (u = 90, h = "start") : h = "middle") : o < s[3] ? (a = ".3em", l = i, c = 0, h = "start") : (a =
        "0em", l = 0, c = -i, n ? (u = -90, h = "start") : h = "middle"), _E({
        position: {
          x: Math.round(l),
          y: Math.round(c)
        },
        angle: u,
        attrs: {
          ".": {
            y: a,
            "text-anchor": h
          }
        }
      }, r)
    }

    function GE(t) {
      const e = t.getCenter(),
        n = e.theta(t.getTopLeft()),
        r = e.theta(t.getBottomLeft()),
        i = e.theta(t.getBottomRight());
      return [n, e.theta(t.getTopRight()), i, r]
    }
    const UE = (t, e, n) => WE(t.diff(e.getCenter()), !1, n),
      qE = (t, e, n) => WE(t.diff(e.getCenter()), !0, n);

    function WE(t, e, n) {
      const r = null != n.offset ? n.offset : 20,
        i = new hC(0, 0),
        o = -t.theta(i),
        s = t.clone().move(i, r).diff(t).round();
      let a, l = ".3em",
        c = o;
      return (o + 90) % 180 == 0 ? (a = e ? "end" : "middle", e || -270 !== o || (l = "0em")) : o > -270 && o < -
        90 ? (a = "start", c = o - 180) : a = "end", _E({
          position: s.round().toJSON(),
          angle: e ? c : 0,
          attrs: {
            ".": {
              y: l,
              "text-anchor": a
            }
          }
        }, n)
    }
    var XE, YE, JE;
    (YE = XE || (XE = {})).presets = y, YE.registry = Kx.create({
      type: "port label layout"
    }), YE.registry.register(YE.presets, !0);
    class ZE extends Vx {
      constructor() {
        super(), this.cid = JE.uniqueId(), ZE.views[this.cid] = this
      }
      get priority() {
        return 2
      }
      confirmUpdate(t, e) {
        return 0
      }
      $(t) {
        return ZE.$(t)
      }
      empty(t = this.container) {
        return this.$(t).empty(), this
      }
      unmount(t = this.container) {
        return this.$(t).remove(), this
      }
      remove(t = this.container) {
        return t === this.container && (this.removeEventListeners(document), this.onRemove(), delete ZE.views[
          this.cid]), this.unmount(t), this
      }
      onRemove() {}
      addClass(t, e = this.container) {
        return this.$(e).addClass(Array.isArray(t) ? t.join(" ") : t), this
      }
      removeClass(t, e = this.container) {
        return this.$(e).removeClass(Array.isArray(t) ? t.join(" ") : t), this
      }
      setStyle(t, e = this.container) {
        return this.$(e).css(t), this
      }
      setAttrs(t, e = this.container) {
        return null != t && null != e && (e instanceof SVGElement ? h.attr(e, t) : this.$(e).attr(t)), this
      }
      findAttr(t, e = this.container) {
        let n = e;
        for (; n && 1 === n.nodeType;) {
          const e = n.getAttribute(t);
          if (null != e) return e;
          if (n === this.container) return null;
          n = n.parentNode
        }
        return null
      }
      find(t, e = this.container, n = this.selectors) {
        return ZE.find(t, e, n).elems
      }
      findOne(t, e = this.container, n = this.selectors) {
        const r = this.find(t, e, n);
        return r.length > 0 ? r[0] : null
      }
      findByAttr(t, e = this.container) {
        let n = e;
        for (; n && n.getAttribute;) {
          const e = n.getAttribute(t);
          if ((null != e || n === this.container) && "false" !== e) return n;
          n = n.parentNode
        }
        return null
      }
      getSelector(t, e) {
        let n;
        if (t === this.container) return "string" == typeof e && (n = `> ${e}`), n;
        if (t) {
          const r = h.index(t) + 1;
          n = `${t.tagName.toLowerCase()}:nth-child(${r})`, e && (n += ` > ${e}`), n = this.getSelector(t.parentNode,
            n)
        }
        return n
      }
      prefixClassName(t) {
        return oE.prefix(t)
      }
      delegateEvents(t, e) {
        if (null == t) return this;
        e || this.undelegateEvents();
        const n = /^(\S+)\s*(.*)$/;
        return Object.keys(t).forEach(e => {
          const r = e.match(n);
          if (null == r) return;
          const i = this.getEventHandler(t[e]);
          "function" == typeof i && this.delegateEvent(r[1], r[2], i)
        }), this
      }
      undelegateEvents() {
        return this.$(this.container).off(this.getEventNamespace()), this
      }
      delegateDocumentEvents(t, e) {
        return this.addEventListeners(document, t, e), this
      }
      undelegateDocumentEvents() {
        return this.removeEventListeners(document), this
      }
      delegateEvent(t, e, n) {
        return this.$(this.container).on(t + this.getEventNamespace(), e, n), this
      }
      undelegateEvent(t, e, n) {
        const r = t + this.getEventNamespace();
        return null == e ? this.$(this.container).off(r) : "string" == typeof e ? this.$(this.container).off(r,
          e, n) : this.$(this.container).off(r, e), this
      }
      addEventListeners(t, e, n) {
        if (null == e) return this;
        const r = this.getEventNamespace(),
          i = this.$(t);
        return Object.keys(e).forEach(t => {
          const o = this.getEventHandler(e[t]);
          "function" == typeof o && i.on(t + r, n, o)
        }), this
      }
      removeEventListeners(t) {
        return null != t && this.$(t).off(this.getEventNamespace()), this
      }
      getEventNamespace() {
        return `.${Jx.prefixCls}-event-${this.cid}`
      }
      getEventHandler(t) {
        let e;
        if ("string" == typeof t) {
          const n = this[t];
          "function" == typeof n && (e = ((...t) => n.call(this, ...t)))
        } else e = ((...e) => t.call(this, ...e));
        return e
      }
      getEventTarget(t, e = {}) {
        const {
          target: n,
          type: r,
          clientX: i = 0,
          clientY: o = 0
        } = t;
        return e.fromPoint || "touchmove" === r || "touchend" === r ? document.elementFromPoint(i, o) : n
      }
      stopPropagation(t) {
        return this.setEventData(t, {
          propagationStopped: !0
        }), this
      }
      isPropagationStopped(t) {
        return !0 === this.getEventData(t).propagationStopped
      }
      getEventData(t) {
        return this.eventData(t)
      }
      setEventData(t, e) {
        return this.eventData(t, e)
      }
      eventData(t, e) {
        if (null == t) throw new TypeError("Event object required");
        let n = t.data;
        const r = `__${this.cid}__`;
        return null == e ? null == n ? {} : n[r] || {} : (null == n && (n = t.data = {}), null == n[r] ? n[r] =
          Object.assign({}, e) : n[r] = Object.assign(Object.assign({}, n[r]), e), n[r])
      }
      normalizeEvent(t) {
        return ZE.normalizeEvent(t)
      }
    }! function(t) {
      function e(t) {
        return P()(t)
      }
      t.$ = e, t.createElement = function(t, e) {
        return e ? h.createSvgElement(t || "g") : h.createElementNS(t || "div")
      }, t.find = function(t, n = this.container, r = this.selectors) {
        if (!t || "." === t) return {
          elems: [n]
        };
        if (r) {
          const e = r[t];
          if (e) return {
            elems: Array.isArray(e) ? e : [e]
          }
        }
        return Jx.useCSSSelector ? {
          isCSSSelector: !0,
          elems: e(n).find(t).toArray()
        } : {
          elems: []
        }
      }, t.normalizeEvent = function(t) {
        let e = t;
        const n = t.originalEvent,
          r = n && n.changedTouches && n.changedTouches[0];
        if (r) {
          for (const e in t) void 0 === r[e] && (r[e] = t[e]);
          e = r
        }
        const i = e.target;
        if (i) {
          const t = i.correspondingUseElement;
          t && (e.target = t)
        }
        return e
      }
    }(ZE || (ZE = {})),
    function(t) {
      t.views = {}, t.getView = function(e) {
        return t.views[e] || null
      }
    }(ZE || (ZE = {})),
    function(t) {
      let e = 0;
      (JE || (JE = {})).uniqueId = function() {
        const t = `v${e}`;
        return e += 1, t
      }
    }();
    const KE = t => t;

    function QE(t, e) {
      return 0 === e ? "0%" : `${Math.round(t/e*100)}%`
    }

    function tS(t) {
      return (e, n, r, i) => n.isEdgeElement(r) ? function(t, e, n, r, i) {
        const o = n.getConnection();
        if (!o) return e;
        const s = o.closestPointLength(i);
        if (t) {
          const t = o.length();
          e.anchor = {
            name: "ratio",
            args: {
              ratio: s / t
            }
          }
        } else e.anchor = {
          name: "length",
          args: {
            length: s
          }
        };
        return e
      }(t, e, n, 0, i) : function(t, e, n, r, i) {
        const o = n.cell,
          s = o.getAngle(),
          a = n.getUnrotatedBBoxOfElement(r),
          l = o.getBBox().getCenter(),
          c = hC.create(i).rotate(s, l);
        let h = c.x - a.x,
          u = c.y - a.y;
        return t && (h = QE(h, a.width), u = QE(u, a.height)), e.anchor = {
          name: "topLeft",
          args: {
            dx: h,
            dy: u,
            rotate: !0
          }
        }, e
      }(t, e, n, r, i)
    }
    const eS = tS(!0),
      nS = tS(!1);
    var rS, iS, oS;
    (iS = rS || (rS = {})).presets = b, iS.registry = Kx.create({
      type: "connection strategy"
    }), iS.registry.register(iS.presets, !0);
    class sS {
      constructor(t) {
        this.view = t, this.clean()
      }
      clean() {
        this.elemCache && this.elemCache.dispose(), this.elemCache = new Xx, this.pathCache = {}
      }
      get(t) {
        return this.elemCache.has(t) || this.elemCache.set(t, {}), this.elemCache.get(t)
      }
      getData(t) {
        const e = this.get(t);
        return e.data || (e.data = {}), e.data
      }
      getMatrix(t) {
        const e = this.get(t);
        if (null == e.matrix) {
          const n = this.view.rotatableNode || this.view.container;
          e.matrix = h.getTransformToElement(t, n)
        }
        return h.createSVGMatrix(e.matrix)
      }
      getShape(t) {
        const e = this.get(t);
        return null == e.shape && (e.shape = h.toGeometryShape(t)), e.shape.clone()
      }
      getBoundingRect(t) {
        const e = this.get(t);
        return null == e.boundingRect && (e.boundingRect = h.getBBox(t)), e.boundingRect.clone()
      }
    }! function(t) {
      function e(t) {
        return null != t && "string" == typeof t
      }

      function n(t) {
        return `${t}`.trim().replace(/[\r|\n]/g, " ").replace(/>\s+</g, "><")
      }

      function r(t, e = {
        ns: h.ns.svg
      }) {
        const n = document.createDocumentFragment(),
          r = {},
          i = {},
          o = [{
            markup: Array.isArray(t) ? t : [t],
            parent: n,
            ns: e.ns
          }];
        for (; o.length > 0;) {
          const t = o.pop();
          let e = t.ns || h.ns.svg;
          const n = t.markup,
            s = t.parent;
          n.forEach(t => {
            const n = t.tagName;
            if (!n) throw new TypeError("Invalid tagName");
            t.ns && (e = t.ns);
            const a = e === h.ns.svg,
              l = e ? h.createElementNS(n, e) : h.createElement(n),
              c = t.attrs;
            c && (a ? h.attr(l, c) : P()(l).attr(c));
            const u = t.style;
            u && P()(l).css(u);
            const d = t.className;
            null != d && l.setAttribute("class", Array.isArray(d) ? d.join(" ") : d), t.textContent && (l.textContent =
              t.textContent);
            const p = t.selector;
            if (null != p) {
              if (i[p]) throw new TypeError("Selector must be unique");
              i[p] = l
            }
            if (t.groupSelector) {
              let e = t.groupSelector;
              Array.isArray(e) || (e = [e]), e.forEach(t => {
                r[t] || (r[t] = []), r[t].push(l)
              })
            }
            s.appendChild(l);
            const f = t.children;
            Array.isArray(f) && o.push({
              ns: e,
              markup: f,
              parent: l
            })
          })
        }
        return Object.keys(r).forEach(t => {
          if (i[t]) throw new Error("Ambiguous group selector");
          i[t] = r[t]
        }), {
          fragment: n,
          selectors: i,
          groups: r
        }
      }

      function i(t) {
        return t instanceof SVGElement ? h.createSvgElement("g") : h.createElement("div")
      }
      t.isJSONMarkup = function(t) {
        return null != t && !e(t)
      }, t.isStringMarkup = e, t.clone = function(t) {
        return null == t || e(t) ? t : o.cloneDeep(t)
      }, t.sanitize = n, t.parseStringMarkup = function(t) {
        const e = document.createDocumentFragment(),
          r = n(t);
        return s.sanitizeHTML(r, {
          raw: !0
        }).forEach(t => {
          e.appendChild(t)
        }), {
          fragment: e,
          selectors: {},
          groups: {}
        }
      }, t.parseJSONMarkup = r, t.renderMarkup = function(t) {
        if (e(t)) {
          const e = h.createVectors(t),
            n = e.length;
          if (1 === n) return {
            elem: e[0].node
          };
          if (n > 1) {
            const t = i(e[0].node);
            return e.forEach(e => {
              t.appendChild(e.node)
            }), {
              elem: t
            }
          }
          return {}
        }
        const n = r(t),
          o = n.fragment;
        let s = null;
        return o.childNodes.length > 1 ? (s = i(o.firstChild)).appendChild(o) : s = o.firstChild, {
          elem: s,
          selectors: n.selectors
        }
      }, t.parseLabelStringMarkup = function(t) {
        const e = h.createVectors(t),
          n = document.createDocumentFragment();
        for (let t = 0, r = e.length; t < r; t += 1) {
          const r = e[t].node;
          n.appendChild(r)
        }
        return {
          fragment: n,
          selectors: {}
        }
      }
    }(oS || (oS = {})),
    function(t) {
      t.getPortContainerMarkup = function() {
        return "g"
      }, t.getPortMarkup = function() {
        return {
          tagName: "circle",
          selector: "circle",
          attrs: {
            r: 10,
            fill: "#FFFFFF",
            stroke: "#000000"
          }
        }
      }, t.getPortLabelMarkup = function() {
        return {
          tagName: "text",
          selector: "text",
          attrs: {
            fill: "#000000"
          }
        }
      }
    }(oS || (oS = {})),
    function(t) {
      t.getEdgeMarkup = function() {
        return t.sanitize(
          '\n    <path class="connection" stroke="black" d="M 0 0 0 0"/>\n    <path class="source-marker" fill="black" stroke="black" d="M 0 0 0 0"/>\n    <path class="target-marker" fill="black" stroke="black" d="M 0 0 0 0"/>\n    <path class="connection-wrap" d="M 0 0 0 0"/>\n    <g class="labels"/>\n    <g class="vertices"/>\n    <g class="arrowheads"/>\n    <g class="tools"/>\n  '
        )
      }, t.getEdgeToolMarkup = function() {
        return t.sanitize(
          '\n    <g class="edge-tool">\n      <g class="tool-remove" event="edge:remove">\n        <circle r="11" />\n        <path transform="scale(.8) translate(-16, -16)" d="M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z" />\n        <title>Remove edge.</title>\n      </g>\n      <g class="tool-options" event="edge:options">\n        <circle r="11" transform="translate(25)"/>\n        <path fill="white" transform="scale(.55) translate(29, -16)" d="M31.229,17.736c0.064-0.571,0.104-1.148,0.104-1.736s-0.04-1.166-0.104-1.737l-4.377-1.557c-0.218-0.716-0.504-1.401-0.851-2.05l1.993-4.192c-0.725-0.91-1.549-1.734-2.458-2.459l-4.193,1.994c-0.647-0.347-1.334-0.632-2.049-0.849l-1.558-4.378C17.165,0.708,16.588,0.667,16,0.667s-1.166,0.041-1.737,0.105L12.707,5.15c-0.716,0.217-1.401,0.502-2.05,0.849L6.464,4.005C5.554,4.73,4.73,5.554,4.005,6.464l1.994,4.192c-0.347,0.648-0.632,1.334-0.849,2.05l-4.378,1.557C0.708,14.834,0.667,15.412,0.667,16s0.041,1.165,0.105,1.736l4.378,1.558c0.217,0.715,0.502,1.401,0.849,2.049l-1.994,4.193c0.725,0.909,1.549,1.733,2.459,2.458l4.192-1.993c0.648,0.347,1.334,0.633,2.05,0.851l1.557,4.377c0.571,0.064,1.148,0.104,1.737,0.104c0.588,0,1.165-0.04,1.736-0.104l1.558-4.377c0.715-0.218,1.399-0.504,2.049-0.851l4.193,1.993c0.909-0.725,1.733-1.549,2.458-2.458l-1.993-4.193c0.347-0.647,0.633-1.334,0.851-2.049L31.229,17.736zM16,20.871c-2.69,0-4.872-2.182-4.872-4.871c0-2.69,2.182-4.872,4.872-4.872c2.689,0,4.871,2.182,4.871,4.872C20.871,18.689,18.689,20.871,16,20.871z"/>\n        <title>Edge options.</title>\n      </g>\n    </g>\n  '
        )
      }, t.getEdgeVertexMarkup = function() {
        return t.sanitize(
          '\n    <g class="vertex-group" transform="translate(<%= x %>, <%= y %>)">\n      <circle class="vertex" data-index="<%= index %>" r="10" />\n      <path class="vertex-remove-area" data-index="<%= index %>" d="M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z" transform="translate(5, -33)"/>\n      <path class="vertex-remove" data-index="<%= index %>" transform="scale(.8) translate(9.5, -37)" d="M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z">\n      <title>Remove vertex.</title>\n      </path>\n    </g>\n  '
        )
      }, t.getEdgeArrowheadMarkup = function() {
        return t.sanitize(
          '\n    <g class="arrowhead-group arrowhead-group-<%= end %>">\n      <path class="arrowhead" data-terminal="<%= end %>" d="M 26 0 L 0 13 L 26 26 z" />\n    </g>\n  '
        )
      }
    }(oS || (oS = {})),
    function(t) {
      (oS || (oS = {})).getForeignObjectMarkup = function() {
        return {
          tagName: "foreignObject",
          selector: "fo",
          children: [{
            ns: h.ns.xhtml,
            tagName: "body",
            selector: "foBody",
            attrs: {
              xmlns: h.ns.xhtml
            },
            style: {
              width: "100%",
              height: "100%"
            },
            children: [{
              tagName: "div",
              selector: "foContent",
              style: {
                width: "100%",
                height: "100%"
              }
            }]
          }]
        }
      }
    }();
    class aS {
      constructor(t) {
        this.view = t
      }
      get cell() {
        return this.view.cell
      }
      getDefinition(t) {
        return this.cell.getAttrDefinition(t)
      }
      processAttrs(t, e) {
        let n, r, i, o;
        const s = [];
        return Object.keys(e).forEach(r => {
          const i = e[r],
            o = this.getDefinition(r),
            a = l.call(DA.isValidDefinition, this.view, o, i, {
              elem: t,
              attrs: e,
              cell: this.cell,
              view: this.view
            });
          o && a ? "string" == typeof o ? (null == n && (n = {}), n[o] = i) : null !== i && s.push({
            name: r,
            definition: o
          }) : (null == n && (n = {}), n[(t => t.replace(/[A-Z]/g, "-$&").toLowerCase())(r)] = i)
        }), s.forEach(({
          name: t,
          definition: n
        }) => {
          const s = e[t];
          "function" == typeof n.set && (null == r && (r = {}), r[t] = s), "function" == typeof n.offset &&
            (null == i && (i = {}), i[t] = s), "function" == typeof n.position && (null == o && (o = {}), o[
              t] = s)
        }), {
          raw: e,
          normal: n,
          set: r,
          offset: i,
          position: o
        }
      }
      mergeProcessedAttrs(t, e) {
        t.set = Object.assign(Object.assign({}, t.set), e.set), t.position = Object.assign(Object.assign({}, t.position),
          e.position), t.offset = Object.assign(Object.assign({}, t.offset), e.offset);
        const n = t.normal && t.normal.transform;
        null != n && e.normal && (e.normal.transform = n), t.normal = e.normal
      }
      findAttrs(t, e, n, r) {
        const s = [],
          a = new Xx;
        return Object.keys(t).forEach(l => {
          const c = t[l];
          if (!o.isPlainObject(c)) return;
          const {
            isCSSSelector: h,
            elems: u
          } = ZE.find(l, e, r);
          n[l] = u;
          for (let t = 0, e = u.length; t < e; t += 1) {
            const n = u[t],
              o = r && r[l] === n,
              d = a.get(n);
            if (d) {
              d.array || (s.push(n), d.array = !0, d.attrs = [d.attrs], d.priority = [d.priority]);
              const t = d.attrs,
                r = d.priority;
              if (o) t.unshift(c), r.unshift(-1);
              else {
                const n = i.sortedIndex(r, h ? -1 : e);
                t.splice(n, 0, c), r.splice(n, 0, e)
              }
            } else a.set(n, {
              elem: n,
              attrs: c,
              priority: o ? -1 : e,
              array: !1
            })
          }
        }), s.forEach(t => {
          const e = a.get(t),
            n = e.attrs;
          e.attrs = n.reduceRight((t, e) => Object.assign(Object.assign({}, t), e), {})
        }), a
      }
      updateRelativeAttrs(t, e, n, r) {
        const i = e.raw || {};
        let o = e.normal || {};
        const s = e.set,
          a = e.position,
          c = e.offset,
          u = () => ({
            elem: t,
            cell: this.cell,
            view: this.view,
            attrs: i,
            refBBox: n.clone()
          });
        if (null != s && Object.keys(s).forEach(t => {
            const e = s[t],
              n = this.getDefinition(t);
            if (null != n) {
              const r = l.call(n.set, this.view, e, u());
              "object" == typeof r ? o = Object.assign(Object.assign({}, o), r) : null != r && (o[t] = r)
            }
          }), t instanceof HTMLElement) return void this.view.setAttrs(o, t);
        const d = o.transform,
          p = d ? `${d}` : null,
          f = h.transformStringToMatrix(p),
          g = new hC(f.e, f.f);
        d && (delete o.transform, f.e = 0, f.f = 0);
        let m = 1,
          v = 1;
        if (a || c) {
          const e = this.view.getScaleOfElement(t, r.scalableNode);
          m = e.sx, v = e.sy
        }
        let y = !1;
        null != a && Object.keys(a).forEach(t => {
          const e = a[t],
            n = this.getDefinition(t);
          if (null != n) {
            const t = l.call(n.position, this.view, e, u());
            null != t && (y = !0, g.translate(hC.create(t).scale(m, v)))
          }
        }), this.view.setAttrs(o, t);
        let b = !1;
        if (null != c) {
          const e = this.view.getBoundingRectOfElement(t);
          if (e.width > 0 && e.height > 0) {
            const n = h.transformRectangle(e, f).scale(1 / m, 1 / v);
            Object.keys(c).forEach(e => {
              const r = c[e],
                o = this.getDefinition(e);
              if (null != o) {
                const e = l.call(o.offset, this.view, r, {
                  elem: t,
                  cell: this.cell,
                  view: this.view,
                  attrs: i,
                  refBBox: n
                });
                null != e && (b = !0, g.translate(hC.create(e).scale(m, v)))
              }
            })
          }
        }(null != d || y || b) && (g.round(1), f.e = g.x, f.f = g.y, t.setAttribute("transform", h.matrixToTransformString(
          f)))
      }
      update(t, e, n) {
        const r = {},
          i = this.findAttrs(n.attrs || e, t, r, n.selectors),
          o = n.attrs ? this.findAttrs(e, t, r, n.selectors) : i,
          s = [];
        i.each(e => {
          const i = e.elem,
            a = e.attrs,
            l = this.processAttrs(i, a);
          if (null == l.set && null == l.position && null == l.offset) this.view.setAttrs(l.normal, i);
          else {
            const e = o.get(i),
              c = e ? e.attrs : null,
              h = c && null == a.ref ? c.ref : a.ref;
            let u;
            if (h) {
              if (!(u = (r[h] || this.view.find(h, t, n.selectors))[0])) throw new Error(
                `"${h}" reference does not exist.`)
            } else u = null;
            const d = {
                node: i,
                refNode: u,
                attributes: c,
                processedAttributes: l
              },
              p = s.findIndex(t => t.refNode === i);
            p > -1 ? s.splice(p, 0, d) : s.push(d)
          }
        });
        const a = new Xx;
        let l;
        s.forEach(e => {
          const r = e.node,
            i = e.refNode;
          let o;
          const s = null != i && null != n.rotatableNode && h.contains(n.rotatableNode, i);
          if (i && (o = a.get(i)), !o) {
            const e = s ? n.rotatableNode : t;
            o = i ? h.getBBox(i, {
              target: e
            }) : n.rootBBox, i && a.set(i, o)
          }
          let c;
          n.attrs && e.attributes ? (c = this.processAttrs(r, e.attributes), this.mergeProcessedAttrs(c, e.processedAttributes)) :
            c = e.processedAttributes;
          let u = o;
          s && null != n.rotatableNode && !n.rotatableNode.contains(r) && (l || (l = h.transformStringToMatrix(
            h.attr(n.rotatableNode, "transform"))), u = h.transformRectangle(o, l)), this.updateRelativeAttrs(
            r, c, u, n)
        })
      }
    }
    class lS {
      constructor(t, e, n = []) {
        this.view = t;
        const r = {},
          i = {};
        let o = 0;
        Object.keys(e).forEach(t => {
          let n = e[t];
          Array.isArray(n) || (n = [n]), n.forEach(e => {
            let n = r[e];
            n || (o += 1, n = r[e] = 1 << o), i[t] |= n
          })
        });
        let s = n;
        if (Array.isArray(s) || (s = [s]), s.forEach(t => {
            r[t] || (o += 1, r[t] = 1 << o)
          }), o > 25) throw new Error("Maximum number of flags exceeded.");
        this.flags = r, this.attrs = i, this.bootstrap = n
      }
      get cell() {
        return this.view.cell
      }
      getFlag(t) {
        const e = this.flags;
        return null == e ? 0 : Array.isArray(t) ? t.reduce((t, n) => t | e[n], 0) : 0 | e[t]
      }
      hasAction(t, e) {
        return t & this.getFlag(e)
      }
      removeAction(t, e) {
        return t ^ t & this.getFlag(e)
      }
      getBootstrapFlag() {
        return this.getFlag(this.bootstrap)
      }
      getChangedFlag() {
        let t = 0;
        return this.attrs ? (Object.keys(this.attrs).forEach(e => {
          this.cell.hasChanged(e) && (t |= this.attrs[e])
        }), t) : t
      }
    }
    var cS, hS, uS = this && this.__rest || function(t, e) {
      var n = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
          .call(t, r[i]) && (n[r[i]] = t[r[i]])
      }
      return n
    };
    class dS extends ZE {
      constructor(t, e = {}) {
        super(), this.cell = t, this.options = this.ensureOptions(e), this.attr = new aS(this), this.flag = new lS(
          this, this.options.actions, this.options.bootstrap), this.cache = new sS(this), this.setContainer(
          this.ensureContainer()), this.setup(), this.$(this.container).data("view", this), this.init()
      }
      static getDefaults() {
        return this.defaults
      }
      static config(t) {
        this.defaults = this.getOptions(t)
      }
      static getOptions(t) {
        const e = (t, e) => null != e ? i.uniq([...Array.isArray(t) ? t : [t], ...Array.isArray(e) ? e : [e]]) :
          Array.isArray(t) ? [...t] : [t],
          n = o.cloneDeep(this.getDefaults()),
          {
            bootstrap: r,
            actions: s,
            events: a,
            documentEvents: l
          } = t,
          c = uS(t, ["bootstrap", "actions", "events", "documentEvents"]);
        return r && (n.bootstrap = e(n.bootstrap, r)), s && Object.keys(s).forEach(t => {
          const r = s[t],
            i = n.actions[t];
          r && i ? n.actions[t] = e(i, r) : r && (n.actions[t] = e(r))
        }), a && (n.events = Object.assign(Object.assign({}, n.events), a)), t.documentEvents && (n.documentEvents =
          Object.assign(Object.assign({}, n.documentEvents), l)), o.merge(n, c)
      }
      init() {}
      get priority() {
        return this.options.priority
      }
      get rootSelector() {
        return this.options.rootSelector
      }
      getConstructor() {
        return this.constructor
      }
      ensureOptions(t) {
        return this.getConstructor().getOptions(t)
      }
      getContainerTagName() {
        return this.options.isSvgElement ? "g" : "div"
      }
      getContainerStyle() {}
      getContainerAttrs() {
        return {
          "data-cell-id": this.cell.id,
          "data-shape": this.cell.shape
        }
      }
      getContainerClassName() {
        return this.prefixClassName("cell")
      }
      ensureContainer() {
        return ZE.createElement(this.getContainerTagName(), this.options.isSvgElement)
      }
      setContainer(t) {
        if (this.container !== t) {
          this.undelegateEvents(), this.container = t, null != this.options.events && this.delegateEvents(this.options
            .events);
          const e = this.getContainerAttrs();
          null != e && this.setAttrs(e, t);
          const n = this.getContainerStyle();
          null != n && this.setStyle(n, t);
          const r = this.getContainerClassName();
          null != r && this.addClass(r, t)
        }
        return this
      }
      isNodeView() {
        return !1
      }
      isEdgeView() {
        return !1
      }
      render() {
        return this
      }
      confirmUpdate(t, e = {}) {
        return 0
      }
      getBootstrapFlag() {
        return this.flag.getBootstrapFlag()
      }
      getFlag(t) {
        return this.flag.getFlag(t)
      }
      hasAction(t, e) {
        return this.flag.hasAction(t, e)
      }
      removeAction(t, e) {
        return this.flag.removeAction(t, e)
      }
      handleAction(t, e, n, r) {
        if (this.hasAction(t, e)) {
          n();
          const i = [e];
          return r && ("string" == typeof r ? i.push(r) : i.push(...r)), this.removeAction(t, i)
        }
        return t
      }
      setup() {
        this.cell.on("changed", ({
          options: t
        }) => this.onAttrsChange(t))
      }
      onAttrsChange(t) {
        let e = this.flag.getChangedFlag();
        !t.updated && e && (t.dirty && this.hasAction(e, "update") && (e |= this.getFlag("render")), t.tool &&
          (t.async = !1), null != this.graph && this.graph.renderer.requestViewUpdate(this, e, this.priority,
            t))
      }
      parseJSONMarkup(t, e) {
        const n = oS.parseJSONMarkup(t),
          r = n.selectors,
          i = this.rootSelector;
        if (e && i) {
          if (r[i]) throw new Error("Invalid root selector");
          r[i] = e
        }
        return n
      }
      can(t) {
        let e = this.options.interacting;
        return "object" == typeof(e = "function" == typeof e ? l.call(e, this.graph, this) : e) ? !1 !== e[t] :
          "boolean" == typeof e && e
      }
      setInteracting(t) {
        return this.options.interacting = t, this
      }
      cleanCache() {
        return this.cache.clean(), this
      }
      getCache(t) {
        return this.cache.get(t)
      }
      getDataOfElement(t) {
        return this.cache.getData(t)
      }
      getMatrixOfElement(t) {
        return this.cache.getMatrix(t)
      }
      getShapeOfElement(t) {
        return this.cache.getShape(t)
      }
      getScaleOfElement(t, e) {
        let n, r;
        if (e && e.contains(t)) {
          const t = h.scale(e);
          n = 1 / t.sx, r = 1 / t.sy
        } else n = 1, r = 1;
        return {
          sx: n,
          sy: r
        }
      }
      getBoundingRectOfElement(t) {
        return this.cache.getBoundingRect(t)
      }
      getBBoxOfElement(t) {
        const e = this.getBoundingRectOfElement(t),
          n = this.getMatrixOfElement(t),
          r = this.getRootRotatedMatrix(),
          i = this.getRootTranslatedMatrix();
        return h.transformRectangle(e, i.multiply(r).multiply(n))
      }
      getUnrotatedBBoxOfElement(t) {
        const e = this.getBoundingRectOfElement(t),
          n = this.getMatrixOfElement(t),
          r = this.getRootTranslatedMatrix();
        return h.transformRectangle(e, r.multiply(n))
      }
      getBBox(t = {}) {
        let e;
        if (t.useCellGeometry) {
          const t = this.cell,
            n = t.isNode() ? t.getAngle() : 0;
          e = t.getBBox().bbox(n)
        } else e = this.getBBoxOfElement(this.container);
        return this.graph.localToGraph(e)
      }
      getRootTranslatedMatrix() {
        const t = this.cell,
          e = t.isNode() ? t.getPosition() : {
            x: 0,
            y: 0
          };
        return h.createSVGMatrix().translate(e.x, e.y)
      }
      getRootRotatedMatrix() {
        let t = h.createSVGMatrix();
        const e = this.cell,
          n = e.isNode() ? e.getAngle() : 0;
        if (n) {
          const r = e.getBBox(),
            i = r.width / 2,
            o = r.height / 2;
          t = t.translate(i, o).rotate(n).translate(-i, -o)
        }
        return t
      }
      findMagnet(t = this.container) {
        return this.findByAttr("magnet", t)
      }
      updateAttrs(t, e, n = {}) {
        null == n.rootBBox && (n.rootBBox = new uC), null == n.selectors && (n.selectors = this.selectors),
          this.attr.update(t, e, n)
      }
      isEdgeElement(t) {
        return this.cell.isEdge() && (null == t || t === this.container)
      }
      prepareHighlight(t, e = {}) {
        const n = t && this.$(t)[0] || this.container;
        return e.partial = n === this.container, n
      }
      highlight(t, e = {}) {
        const n = this.prepareHighlight(t, e);
        return this.notify("cell:highlight", {
          magnet: n,
          options: e,
          view: this,
          cell: this.cell
        }), this.isEdgeView() ? this.notify("edge:highlight", {
          magnet: n,
          options: e,
          view: this,
          edge: this.cell,
          cell: this.cell
        }) : this.isNodeView() && this.notify("node:highlight", {
          magnet: n,
          options: e,
          view: this,
          node: this.cell,
          cell: this.cell
        }), this
      }
      unhighlight(t, e = {}) {
        const n = this.prepareHighlight(t, e);
        return this.notify("cell:unhighlight", {
          magnet: n,
          options: e,
          view: this,
          cell: this.cell
        }), this.isNodeView() ? this.notify("node:unhighlight", {
          magnet: n,
          options: e,
          view: this,
          node: this.cell,
          cell: this.cell
        }) : this.isEdgeView() && this.notify("edge:unhighlight", {
          magnet: n,
          options: e,
          view: this,
          edge: this.cell,
          cell: this.cell
        }), this
      }
      notifyUnhighlight(t, e) {}
      getEdgeTerminal(t, e, n, r, i) {
        const o = this.cell,
          s = this.findAttr("port", t),
          a = t.getAttribute("data-selector"),
          l = {
            cell: o.id
          };
        return null != a && (l.magnet = a), null != s ? (l.port = s, o.isNode() && (o.hasPort(s) || null != a ||
          (l.selector = this.getSelector(t)))) : null == a && this.container !== t && (l.selector = this.getSelector(
          t)), this.customizeEdgeTerminal(l, t, e, n, r, i)
      }
      customizeEdgeTerminal(t, e, n, r, i, o) {
        const s = i.getStrategy() || this.graph.options.connecting.strategy;
        if (s) {
          const a = "string" == typeof s ? s : s.name,
            c = "string" == typeof s ? {} : s.args || {},
            h = rS.registry;
          if (a) {
            const s = h.get(a);
            if (null == s) return h.onNotFound(a);
            const u = l.call(s, this.graph, t, this, e, new hC(n, r), i, o, c);
            if (u) return u
          }
        }
        return t
      }
      getMagnetFromEdgeTerminal(t) {
        const e = this.cell,
          n = this.container,
          r = t.port;
        let i, o = t.magnet;
        return null != r && e.isNode() && e.hasPort(r) ? i = this.findPortElem(r, o) || n : (o || (o = t.selector),
          o || null == r || (o = `[port="${r}"]`), i = this.findOne(o, n, this.selectors)), i
      }
      hasTools(t) {
        const e = this.tools;
        return null != e && (null == t || e.name === t)
      }
      addTools(t) {
        if (this.removeTools(), t) {
          const e = t instanceof pS ? t : new pS(t);
          this.tools = e, this.graph.on("tools:hide", this.hideTools, this), this.graph.on("tools:show", this.showTools,
            this), this.graph.on("tools:remove", this.removeTools, this), e.config({
            view: this
          }), e.mount()
        }
        return this
      }
      updateTools(t = {}) {
        return this.tools && this.tools.update(t), this
      }
      removeTools() {
        return this.tools && (this.tools.remove(), this.graph.off("tools:hide", this.hideTools, this), this.graph
          .off("tools:show", this.showTools, this), this.graph.off("tools:remove", this.removeTools, this),
          this.tools = null), this
      }
      hideTools() {
        return this.tools && this.tools.hide(), this
      }
      showTools() {
        return this.tools && this.tools.show(), this
      }
      renderTools() {
        const t = this.cell.getTools();
        return this.addTools(t), this
      }
      notify(t, e) {
        return this.trigger(t, e), this.graph.trigger(t, e), this
      }
      getEventArgs(t, e, n) {
        const r = this,
          i = r.cell;
        return null == e || null == n ? {
          e: t,
          view: r,
          cell: i
        } : {
          e: t,
          x: e,
          y: n,
          view: r,
          cell: i
        }
      }
      onClick(t, e, n) {
        this.notify("cell:click", this.getEventArgs(t, e, n))
      }
      onDblClick(t, e, n) {
        this.notify("cell:dblclick", this.getEventArgs(t, e, n))
      }
      onContextMenu(t, e, n) {
        this.notify("cell:contextmenu", this.getEventArgs(t, e, n))
      }
      onMouseDown(t, e, n) {
        this.cell.model && (this.cachedModelForMouseEvent = this.cell.model, this.cachedModelForMouseEvent.startBatch(
          "mouse")), this.notify("cell:mousedown", this.getEventArgs(t, e, n))
      }
      onMouseUp(t, e, n) {
        this.notify("cell:mouseup", this.getEventArgs(t, e, n)), this.cachedModelForMouseEvent && (this.cachedModelForMouseEvent
          .stopBatch("mouse", {
            cell: this.cell
          }), this.cachedModelForMouseEvent = null)
      }
      onMouseMove(t, e, n) {
        this.notify("cell:mousemove", this.getEventArgs(t, e, n))
      }
      onMouseOver(t) {
        this.notify("cell:mouseover", this.getEventArgs(t))
      }
      onMouseOut(t) {
        this.notify("cell:mouseout", this.getEventArgs(t))
      }
      onMouseEnter(t) {
        this.notify("cell:mouseenter", this.getEventArgs(t))
      }
      onMouseLeave(t) {
        this.notify("cell:mouseleave", this.getEventArgs(t))
      }
      onMouseWheel(t, e, n, r) {
        this.notify("cell:mousewheel", Object.assign({
          delta: r
        }, this.getEventArgs(t, e, n)))
      }
      onCustomEvent(t, e, n, r) {
        this.notify("cell:customevent", Object.assign({
          name: e
        }, this.getEventArgs(t, n, r))), this.notify(e, Object.assign({}, this.getEventArgs(t, n, r)))
      }
      onMagnetMouseDown(t, e, n, r) {}
      onMagnetDblClick(t, e, n, r) {}
      onMagnetContextMenu(t, e, n, r) {}
      onLabelMouseDown(t, e, n) {}
      checkMouseleave(t) {
        const e = this.graph;
        e.renderer.isAsync() && e.renderer.dumpView(this);
        const n = this.getEventTarget(t, {
            fromPoint: !0
          }),
          r = e.renderer.findViewByElem(n);
        r !== this && (this.onMouseLeave(t), r && r.onMouseEnter(t))
      }
    }
    dS.defaults = {
        isSvgElement: !0,
        rootSelector: "root",
        priority: 0,
        bootstrap: [],
        actions: {}
      }, (cS = dS || (dS = {})).Flag = lS, cS.Attr = aS,
      function(t) {
        t.priority = function(t) {
          return function(e) {
            e.config({
              priority: t
            })
          }
        }, t.bootstrap = function(t) {
          return function(e) {
            e.config({
              bootstrap: t
            })
          }
        }
      }(dS || (dS = {})), (dS || (dS = {})).registry = Kx.create({
        type: "view"
      });
    class pS extends ZE {
      constructor(t = {}) {
        super(), this.container = ZE.createElement(t.tagName || "g", !1 !== t.isSVGElement), h.addClass(this.container,
          this.prefixClassName("cell-tools")), t.className && h.addClass(this.container, t.className), this.config(
          t)
      }
      get name() {
        return this.options.name
      }
      get graph() {
        return this.cellView.graph
      }
      get cell() {
        return this.cellView.cell
      }
      get local() {
        return this.options.local
      }
      config(t) {
        if (this.options = Object.assign(Object.assign({}, this.options), t), !(t.view instanceof dS) || t.view ===
          this.cellView) return this;
        this.cellView = t.view, this.cell.isEdge() ? h.addClass(this.container, this.prefixClassName(
            "edge-tools")) : this.cell.isNode() && h.addClass(this.container, this.prefixClassName("node-tools")),
          this.container.setAttribute("data-cell-id", this.cell.id), this.name && this.container.setAttribute(
            "data-tools-name", this.name);
        const e = this.options.items;
        if (!Array.isArray(e)) return this;
        this.tools = [];
        for (let t = 0; t < e.length; t += 1) {
          const n = e[t];
          let r;
          if (n instanceof pS.ToolItem) r = n;
          else {
            const t = "object" == typeof n ? n.name : n,
              e = "object" == typeof n && n.args || {};
            if (t)
              if (this.cell.isNode()) {
                const n = PS.registry.get(t);
                if (!n) return PS.registry.onNotFound(t);
                r = new n(e)
              } else if (this.cell.isEdge()) {
              const n = TS.registry.get(t);
              if (!n) return TS.registry.onNotFound(t);
              r = new n(e)
            }
          }
          r && (r.config(this.cellView, this), r.render(), this.container.appendChild(r.container), this.tools.push(
            r))
        }
        return this
      }
      update(t = {}) {
        const e = this.tools;
        return e && e.forEach(e => {
          (t.toolId !== e.cid || e.isVisible()) && e.update()
        }), this
      }
      focus(t) {
        const e = this.tools;
        return e && e.forEach(e => {
          t === e ? e.show() : e.hide()
        }), this
      }
      blur(t) {
        const e = this.tools;
        return e && e.forEach(e => {
          e === t || e.isVisible() || (e.show(), e.update())
        }), this
      }
      hide() {
        return this.focus(null)
      }
      show() {
        return this.blur(null)
      }
      remove() {
        const t = this.tools;
        return t && (t.forEach(t => t.remove()), this.tools = null), super.remove()
      }
      mount() {
        const t = this.cellView;
        if (t) {
          (this.local ? t.container : t.graph.view.decorator).appendChild(this.container)
        }
        return this
      }
    }

    function fS(t, e, n, r) {
      return l.call(rS.presets.pinRelative, this.graph, {}, e, n, t, this.cell, r, {}).anchor
    }

    function gS(t, e) {
      return e ? t.cell.getBBox() : t.cell.isEdge() ? t.getConnection().bbox() : t.getUnrotatedBBoxOfElement(t.container)
    }! function(t) {
      class e extends ZE {
        constructor(t = {}) {
          super(), this.options = this.getOptions(t), this.container = ZE.createElement(this.options.tagName ||
            "g", !1 !== this.options.isSVGElement), h.addClass(this.container, this.prefixClassName(
            "cell-tool")), "string" == typeof this.options.className && h.addClass(this.container, this.options
            .className), this.init()
        }
        static getDefaults() {
          return this.defaults
        }
        static config(t) {
          this.defaults = this.getOptions(t)
        }
        static getOptions(t) {
          return o.merge(o.cloneDeep(this.getDefaults()), t)
        }
        get graph() {
          return this.cellView.graph
        }
        get cell() {
          return this.cellView.cell
        }
        get name() {
          return this.options.name
        }
        getOptions(t) {
          return this.constructor.getOptions(t)
        }
        init() {}
        delegateEvents() {
          return this.options.events && super.delegateEvents(this.options.events), this
        }
        config(t, e) {
          return this.cellView = t, this.parent = e, this.stamp(this.container), this.cell.isEdge() ? h.addClass(
            this.container, this.prefixClassName("edge-tool")) : this.cell.isNode() && h.addClass(this.container,
            this.prefixClassName("node-tool")), this.name && this.container.setAttribute("data-tool-name",
            this.name), this.delegateEvents(), this
        }
        render() {
          this.empty();
          const t = this.options.markup;
          if (t) {
            const e = oS.isStringMarkup(t) ? oS.parseStringMarkup(t) : oS.parseJSONMarkup(t);
            this.container.appendChild(e.fragment), this.childNodes = e.selectors
          }
          return this.onRender(), this
        }
        onRender() {}
        update() {
          return this
        }
        stamp(t = this.container) {
          t && t.setAttribute("data-cell-id", this.cellView.cell.id)
        }
        show() {
          return this.container.style.display = "", this.visible = !0, this
        }
        hide() {
          return this.container.style.display = "none", this.visible = !1, this
        }
        isVisible() {
          return this.visible
        }
        focus() {
          const t = this.options.focusOpacity;
          return null != t && isFinite(t) && (this.container.style.opacity = `${t}`), this.parent.focus(this),
            this
        }
        blur() {
          return this.container.style.opacity = "", this.parent.blur(this), this
        }
        guard(t) {
          return null == this.graph || null == this.cellView || this.graph.view.guard(t, this.cellView)
        }
      }
      e.defaults = {
          isSVGElement: !0,
          tagName: "g"
        }, t.ToolItem = e,
        function(t) {
          let e = 0;
          t.define = function(t) {
            const n = o.createClass((r = t.name) ? s.pascalCase(r) : `CustomTool${e+=1}`, this);
            var r;
            return n.config(t), n
          }
        }(e = t.ToolItem || (t.ToolItem = {}))
    }(pS || (pS = {}));
    class mS extends pS.ToolItem {
      onRender() {
        h.addClass(this.container, this.prefixClassName("cell-tool-button")), this.update()
      }
      update() {
        return this.updatePosition(), this
      }
      updatePosition() {
        const t = this.cellView.cell.isEdge() ? this.getEdgeMatrix() : this.getNodeMatrix();
        h.transform(this.container, t, {
          absolute: !0
        })
      }
      getNodeMatrix() {
        const t = this.cellView,
          e = this.options;
        let {
          x: n = 0,
          y: r = 0
        } = e;
        const {
          offset: i,
          useCellGeometry: o,
          rotate: s
        } = e;
        let l = gS(t, o);
        const c = t.cell.getAngle();
        s || (l = l.bbox(c));
        let u = 0,
          d = 0;
        "number" == typeof i ? (u = i, d = i) : "object" == typeof i && (u = i.x, d = i.y), n = a.normalizePercentage(
          n, l.width), r = a.normalizePercentage(r, l.height);
        let p = h.createSVGMatrix().translate(l.x + l.width / 2, l.y + l.height / 2);
        return s && (p = p.rotate(c)), p = p.translate(n + u - l.width / 2, r + d - l.height / 2)
      }
      getEdgeMatrix() {
        const t = this.cellView,
          e = this.options,
          {
            offset: n = 0,
            distance: r = 0,
            rotate: i
          } = e;
        let o, s, l;
        (o = a.isPercentage(r) ? t.getTangentAtRatio(parseFloat(r) / 100) : t.getTangentAtLength(r)) ? (s = o
          .start, l = o.vector().vectorAngle(new hC(1, 0)) || 0) : (s = t.getConnection().start, l = 0);
        let c = h.createSVGMatrix().translate(s.x, s.y).rotate(l);
        return c = "object" == typeof n ? c.translate(n.x || 0, n.y || 0) : c.translate(0, n), i || (c = c.rotate(
          -l)), c
      }
      onMouseDown(t) {
        if (this.guard(t)) return;
        t.stopPropagation(), t.preventDefault();
        const e = this.options.onClick;
        "function" == typeof e && l.call(e, this.cellView, {
          e: t,
          view: this.cellView,
          btn: this
        })
      }
    }(mS || (mS = {})).config({
      name: "button",
      events: {
        mousedown: "onMouseDown",
        touchstart: "onMouseDown"
      }
    }), (hS = mS || (mS = {})).Remove = hS.define({
      name: "button-remove",
      markup: [{
        tagName: "circle",
        selector: "button",
        attrs: {
          r: 7,
          fill: "#FF1D00",
          cursor: "pointer"
        }
      }, {
        tagName: "path",
        selector: "icon",
        attrs: {
          d: "M -3 -3 3 3 M -3 3 3 -3",
          fill: "none",
          stroke: "#FFFFFF",
          "stroke-width": 2,
          "pointer-events": "none"
        }
      }],
      distance: 60,
      offset: 0,
      onClick({
        view: t,
        btn: e
      }) {
        e.parent.remove(), t.cell.remove({
          ui: !0,
          toolId: e.cid
        })
      }
    });
    var vS, yS = this && this.__rest || function(t, e) {
      var n = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
          .call(t, r[i]) && (n[r[i]] = t[r[i]])
      }
      return n
    };
    class bS extends pS.ToolItem {
      onRender() {
        if (h.addClass(this.container, this.prefixClassName("cell-tool-boundary")), this.options.attrs) {
          const t = this.options.attrs,
            {
              class: e
            } = t,
            n = yS(t, ["class"]);
          h.attr(this.container, n), e && h.addClass(this.container, e)
        }
        this.update()
      }
      update() {
        const t = this.cellView,
          e = this.options,
          {
            useCellGeometry: n,
            rotate: r
          } = e,
          i = a.normalizeSides(e.padding);
        let o = gS(t, n).moveAndExpand({
          x: -i.left,
          y: -i.top,
          width: i.left + i.right,
          height: i.top + i.bottom
        });
        const s = t.cell;
        if (s.isNode()) {
          const t = s.getAngle();
          if (t)
            if (r) {
              const e = s.getBBox().getCenter();
              h.rotate(this.container, t, e.x, e.y, {
                absolute: !0
              })
            } else o = o.bbox(t)
        }
        return h.attr(this.container, o.toJSON()), this
      }
    }(bS || (bS = {})).config({
      name: "boundary",
      tagName: "rect",
      padding: 10,
      attrs: {
        fill: "none",
        stroke: "#333",
        "stroke-width": .5,
        "stroke-dasharray": "5, 5",
        "pointer-events": "none"
      }
    });
    class CS extends pS.ToolItem {
        constructor() {
          super(...arguments), this.handles = []
        }
        get vertices() {
          return this.cellView.cell.getVertices()
        }
        onRender() {
          return this.addClass(this.prefixClassName("edge-tool-vertices")), this.options.addable && this.updatePath(),
            this.resetHandles(), this.renderHandles(), this
        }
        update() {
          return this.vertices.length === this.handles.length ? this.updateHandles() : (this.resetHandles(),
            this.renderHandles()), this.options.addable && this.updatePath(), this
        }
        resetHandles() {
          const t = this.handles;
          this.handles = [], t && t.forEach(t => {
            this.stopHandleListening(t), t.remove()
          })
        }
        renderHandles() {
          const t = this.vertices;
          for (let e = 0, n = t.length; e < n; e += 1) {
            const n = t[e],
              r = this.options.createHandle,
              i = this.options.processHandle,
              o = r({
                index: e,
                graph: this.graph,
                guard: t => this.guard(t),
                attrs: this.options.attrs || {}
              });
            i && i(o), this.graph.hook.onToolItemCreated({
                name: "vertices",
                cell: this.cell,
                view: this.cellView,
                tool: o
              }), o.updatePosition(n.x, n.y), this.stamp(o.container), this.container.appendChild(o.container),
              this.handles.push(o), this.startHandleListening(o)
          }
        }
        updateHandles() {
          const t = this.vertices;
          for (let e = 0, n = t.length; e < n; e += 1) {
            const n = t[e],
              r = this.handles[e];
            r && r.updatePosition(n.x, n.y)
          }
        }
        updatePath() {
          const t = this.childNodes.connection;
          t && t.setAttribute("d", this.cellView.getConnectionPathData())
        }
        startHandleListening(t) {
          const e = this.cellView;
          e.can("vertexMovable") && (t.on("change", this.onHandleChange, this), t.on("changing", this.onHandleChanging,
            this), t.on("changed", this.onHandleChanged, this)), e.can("vertexDeletable") && t.on("remove",
            this.onHandleRemove, this)
        }
        stopHandleListening(t) {
          const e = this.cellView;
          e.can("vertexMovable") && (t.off("change", this.onHandleChange, this), t.off("changing", this.onHandleChanging,
            this), t.off("changed", this.onHandleChanged, this)), e.can("vertexDeletable") && t.off("remove",
            this.onHandleRemove, this)
        }
        getNeighborPoints(t) {
          const e = this.cellView,
            n = this.vertices,
            r = t > 0 ? n[t - 1] : e.sourceAnchor,
            i = t < n.length - 1 ? n[t + 1] : e.targetAnchor;
          return {
            prev: hC.create(r),
            next: hC.create(i)
          }
        }
        getMouseEventArgs(t) {
          const e = this.normalizeEvent(t),
            {
              x: n,
              y: r
            } = this.graph.snapToGrid(e.clientX, e.clientY);
          return {
            e: e,
            x: n,
            y: r
          }
        }
        onHandleChange({
          e: t
        }) {
          this.focus();
          const e = this.cellView;
          if (e.cell.startBatch("move-vertex", {
              ui: !0,
              toolId: this.cid
            }), !this.options.stopPropagation) {
            const {
              e: n,
              x: r,
              y: i
            } = this.getMouseEventArgs(t);
            e.notifyMouseDown(n, r, i)
          }
        }
        onHandleChanging({
          handle: t,
          e: e
        }) {
          const n = this.cellView,
            r = t.options.index,
            {
              e: i,
              x: o,
              y: s
            } = this.getMouseEventArgs(e),
            a = {
              x: o,
              y: s
            };
          this.snapVertex(a, r), n.cell.setVertexAt(r, a, {
            ui: !0,
            toolId: this.cid
          }), t.updatePosition(a.x, a.y), this.options.stopPropagation || n.notifyMouseMove(i, o, s)
        }
        onHandleChanged({
          e: t
        }) {
          const e = this.options,
            n = this.cellView;
          if (e.addable && this.updatePath(), !e.removeRedundancies) return;
          n.removeRedundantLinearVertices({
            ui: !0,
            toolId: this.cid
          }) && this.render(), this.blur(), n.cell.stopBatch("move-vertex", {
            ui: !0,
            toolId: this.cid
          }), this.eventData(t).vertexAdded && n.cell.stopBatch("add-vertex", {
            ui: !0,
            toolId: this.cid
          });
          const {
            e: r,
            x: i,
            y: o
          } = this.getMouseEventArgs(t);
          this.options.stopPropagation || n.notifyMouseUp(r, i, o), n.checkMouseleave(r)
        }
        snapVertex(t, e) {
          const n = this.options.snapRadius || 0;
          if (n > 0) {
            const r = this.getNeighborPoints(e),
              i = r.prev,
              o = r.next;
            Math.abs(t.x - i.x) < n ? t.x = i.x : Math.abs(t.x - o.x) < n && (t.x = o.x), Math.abs(t.y - i.y) <
              n ? t.y = r.prev.y : Math.abs(t.y - o.y) < n && (t.y = o.y)
          }
        }
        onHandleRemove({
          handle: t,
          e: e
        }) {
          if (this.options.removable) {
            const n = t.options.index,
              r = this.cellView;
            r.cell.removeVertexAt(n, {
              ui: !0
            }), this.options.addable && this.updatePath(), r.checkMouseleave(this.normalizeEvent(e))
          }
        }
        onPathMouseDown(t) {
          if (console.log("onPathMouseDown"), this.guard(t) || !this.options.addable) return;
          t.stopPropagation(), t.preventDefault();
          const e = this.normalizeEvent(t),
            n = this.graph.snapToGrid(e.clientX, e.clientY).toJSON(),
            r = this.cellView;
          r.cell.startBatch("add-vertex", {
            ui: !0,
            toolId: this.cid
          });
          const i = r.getVertexIndex(n.x, n.y);
          this.snapVertex(n, i), r.cell.setVertexAt(i, n, {
            ui: !0,
            toolId: this.cid
          }), this.render();
          const o = this.handles[i];
          this.eventData(e, {
            vertexAdded: !0
          }), o.onMouseDown(e)
        }
        onRemove() {
          this.resetHandles()
        }
      }! function(t) {
        t.Handle = class extends ZE {
          constructor(t) {
            super(), this.options = t, this.render(), this.delegateEvents({
              mousedown: "onMouseDown",
              touchstart: "onMouseDown",
              dblclick: "onDoubleClick"
            })
          }
          get graph() {
            return this.options.graph
          }
          render() {
            this.container = ZE.createElement("circle", !0);
            const e = this.options.attrs;
            if ("function" == typeof e) {
              const n = t.getDefaults();
              this.setAttrs(Object.assign(Object.assign({}, n.attrs), e(this)))
            } else this.setAttrs(e);
            this.addClass(this.prefixClassName("edge-tool-vertex"))
          }
          updatePosition(t, e) {
            this.setAttrs({
              cx: t,
              cy: e
            })
          }
          onMouseDown(t) {
            this.options.guard(t) || (t.stopPropagation(), t.preventDefault(), this.graph.view.undelegateEvents(),
              this.delegateDocumentEvents({
                mousemove: "onMouseMove",
                touchmove: "onMouseMove",
                mouseup: "onMouseUp",
                touchend: "onMouseUp",
                touchcancel: "onMouseUp"
              }, t.data), this.emit("change", {
                e: t,
                handle: this
              }))
          }
          onMouseMove(t) {
            this.emit("changing", {
              e: t,
              handle: this
            })
          }
          onMouseUp(t) {
            this.emit("changed", {
              e: t,
              handle: this
            }), this.undelegateDocumentEvents(), this.graph.view.delegateEvents()
          }
          onDoubleClick(t) {
            this.emit("remove", {
              e: t,
              handle: this
            })
          }
        }
      }(CS || (CS = {})),
      function(t) {
        const e = oE.prefix("edge-tool-vertex-path");
        t.config({
          name: "vertices",
          snapRadius: 20,
          addable: !0,
          removable: !0,
          removeRedundancies: !0,
          stopPropagation: !0,
          attrs: {
            r: 6,
            fill: "#333",
            stroke: "#fff",
            cursor: "move",
            "stroke-width": 2
          },
          createHandle: e => new t.Handle(e),
          markup: [{
            tagName: "path",
            selector: "connection",
            className: e,
            attrs: {
              fill: "none",
              stroke: "transparent",
              "stroke-width": 10,
              cursor: "pointer"
            }
          }],
          events: {
            [`mousedown .${e}`]: "onPathMouseDown",
            [`touchstart .${e}`]: "onPathMouseDown"
          }
        })
      }(CS || (CS = {}));
    class xS extends pS.ToolItem {
      constructor() {
        super(...arguments), this.handles = []
      }
      get vertices() {
        return this.cellView.cell.getVertices()
      }
      update() {
        return this.render(), this
      }
      onRender() {
        h.addClass(this.container, this.prefixClassName("edge-tool-segments")), this.resetHandles();
        const t = this.cellView,
          e = [...this.vertices];
        e.unshift(t.sourcePoint), e.push(t.targetPoint);
        for (let t = 0, n = e.length; t < n - 1; t += 1) {
          const n = e[t],
            r = e[t + 1],
            i = this.renderHandle(n, r, t);
          this.stamp(i.container), this.handles.push(i)
        }
        return this
      }
      renderHandle(t, e, n) {
        const r = this.options.createHandle({
          index: n,
          graph: this.graph,
          guard: t => this.guard(t),
          attrs: this.options.attrs || {}
        });
        return this.options.processHandle && this.options.processHandle(r), this.graph.hook.onToolItemCreated({
          name: "segments",
          cell: this.cell,
          view: this.cellView,
          tool: r
        }), this.updateHandle(r, t, e), this.container.appendChild(r.container), this.startHandleListening(
          r), r
      }
      startHandleListening(t) {
        t.on("change", this.onHandleChange, this), t.on("changing", this.onHandleChanging, this), t.on(
          "changed", this.onHandleChanged, this)
      }
      stopHandleListening(t) {
        t.off("change", this.onHandleChange, this), t.off("changing", this.onHandleChanging, this), t.off(
          "changed", this.onHandleChanged, this)
      }
      resetHandles() {
        const t = this.handles;
        this.handles = [], t && t.forEach(t => {
          this.stopHandleListening(t), t.remove()
        })
      }
      shiftHandleIndexes(t) {
        const e = this.handles;
        for (let n = 0, r = e.length; n < r; n += 1) e[n].options.index += t
      }
      resetAnchor(t, e) {
        const n = this.cellView.cell,
          r = {
            ui: !0,
            toolId: this.cid
          };
        e ? n.prop([t, "anchor"], e, r) : n.removeProp([t, "anchor"], r)
      }
      snapHandle(t, e, n) {
        const r = t.options.axis,
          i = t.options.index,
          o = this.cellView.cell.getVertices(),
          s = o[i - 2] || n.sourceAnchor,
          a = o[i + 1] || n.targetAnchor,
          l = this.options.snapRadius;
        return Math.abs(e[r] - s[r]) < l ? e[r] = s[r] : Math.abs(e[r] - a[r]) < l && (e[r] = a[r]), e
      }
      onHandleChanging({
        handle: t,
        e: e
      }) {
        const n = this.graph,
          r = this.options,
          i = this.cellView,
          s = r.anchor,
          a = t.options.axis,
          c = t.options.index - 1,
          h = this.getEventData(e),
          u = this.normalizeEvent(e),
          d = n.snapToGrid(u.clientX, u.clientY),
          p = this.snapHandle(t, d.clone(), h),
          f = o.cloneDeep(this.vertices);
        let g = f[c],
          m = f[c + 1];
        const v = i.sourceView,
          y = i.sourceBBox;
        let b = !1,
          C = !1;
        if (g ? 0 === c ? y.containsPoint(g) ? (f.shift(), this.shiftHandleIndexes(-1), b = !0) : (g[a] = p[a],
            C = !0) : g[a] = p[a] : ((g = i.sourceAnchor.toJSON())[a] = p[a], y.containsPoint(g) ? b = !0 : (
            f.unshift(g), this.shiftHandleIndexes(1), C = !0)), "function" == typeof s && v) {
          if (b) {
            const t = h.sourceAnchor.clone();
            t[a] = p[a];
            const e = l.call(s, i, t, v, i.sourceMagnet || v.container, "source", i, this);
            this.resetAnchor("source", e)
          }
          C && this.resetAnchor("source", h.sourceAnchorDef)
        }
        const x = i.targetView,
          w = i.targetBBox;
        let A = !1,
          E = !1;
        if (m ? c === f.length - 2 ? w.containsPoint(m) ? (f.pop(), A = !0) : (m[a] = p[a], E = !0) : m[a] =
          p[a] : ((m = i.targetAnchor.toJSON())[a] = p[a], w.containsPoint(m) ? A = !0 : (f.push(m), E = !0)),
          "function" == typeof s && x) {
          if (A) {
            const t = h.targetAnchor.clone();
            t[a] = p[a];
            const e = l.call(s, i, t, x, i.targetMagnet || x.container, "target", i, this);
            this.resetAnchor("target", e)
          }
          E && this.resetAnchor("target", h.targetAnchorDef)
        }
        hC.equalPoints(f, this.vertices) || this.cellView.cell.setVertices(f, {
          ui: !0,
          toolId: this.cid
        }), this.updateHandle(t, g, m, 0), r.stopPropagation || i.notifyMouseMove(u, d.x, d.y)
      }
      onHandleChange({
        handle: t,
        e: e
      }) {
        const n = this.options,
          r = this.handles,
          i = this.cellView,
          s = t.options.index;
        if (Array.isArray(r)) {
          for (let t = 0, e = r.length; t < e; t += 1) t !== s && r[t].hide();
          if (this.focus(), this.setEventData(e, {
              sourceAnchor: i.sourceAnchor.clone(),
              targetAnchor: i.targetAnchor.clone(),
              sourceAnchorDef: o.cloneDeep(this.cell.prop(["source", "anchor"])),
              targetAnchorDef: o.cloneDeep(this.cell.prop(["target", "anchor"]))
            }), this.cell.startBatch("move-segment", {
              ui: !0,
              toolId: this.cid
            }), !n.stopPropagation) {
            const t = this.normalizeEvent(e),
              n = this.graph.snapToGrid(t.clientX, t.clientY);
            i.notifyMouseDown(t, n.x, n.y)
          }
        }
      }
      onHandleChanged({
        e: t
      }) {
        const e = this.options,
          n = this.cellView;
        e.removeRedundancies && n.removeRedundantLinearVertices({
          ui: !0,
          toolId: this.cid
        });
        const r = this.normalizeEvent(t),
          i = this.graph.snapToGrid(r.clientX, r.clientY);
        this.render(), this.blur(), this.cell.stopBatch("move-segment", {
          ui: !0,
          toolId: this.cid
        }), e.stopPropagation || n.notifyMouseUp(r, i.x, i.y), n.checkMouseleave(r)
      }
      updateHandle(t, e, n, r = 0) {
        const i = this.options.precision || 0,
          o = Math.abs(e.x - n.x) < i,
          s = Math.abs(e.y - n.y) < i;
        if (o || s) {
          const i = new dC(e, n);
          if (i.length() < this.options.threshold) t.hide();
          else {
            const e = i.getCenter(),
              n = o ? "x" : "y";
            e[n] += r || 0;
            const s = i.vector().vectorAngle(new hC(1, 0));
            t.updatePosition(e.x, e.y, s, this.cellView), t.show(), t.options.axis = n
          }
        } else t.hide()
      }
      onRemove() {
        this.resetHandles()
      }
    }! function(t) {
      t.Handle = class extends ZE {
        constructor(t) {
          super(), this.options = t, this.render(), this.delegateEvents({
            mousedown: "onMouseDown",
            touchstart: "onMouseDown"
          })
        }
        render() {
          this.container = ZE.createElement("rect", !0);
          const e = this.options.attrs;
          if ("function" == typeof e) {
            const n = t.getDefaults();
            this.setAttrs(Object.assign(Object.assign({}, n.attrs), e(this)))
          } else this.setAttrs(e);
          this.addClass(this.prefixClassName("edge-tool-segment"))
        }
        updatePosition(t, e, n, r) {
          const i = r.getClosestPoint(new hC(t, e)) || new hC(t, e);
          let o = h.createSVGMatrix().translate(i.x, i.y);
          if (i.equals({
              x: t,
              y: e
            })) o = o.rotate(n);
          else {
            let n = new dC(t, e, i.x, i.y).vector().vectorAngle(new hC(1, 0));
            0 !== n && (n += 90), o = o.rotate(n)
          }
          this.setAttrs({
            transform: h.matrixToTransformString(o),
            cursor: n % 180 == 0 ? "row-resize" : "col-resize"
          })
        }
        onMouseDown(t) {
          this.options.guard(t) || (this.trigger("change", {
              e: t,
              handle: this
            }), t.stopPropagation(), t.preventDefault(), this.options.graph.view.undelegateEvents(), this
            .delegateDocumentEvents({
              mousemove: "onMouseMove",
              touchmove: "onMouseMove",
              mouseup: "onMouseUp",
              touchend: "onMouseUp",
              touchcancel: "onMouseUp"
            }, t.data))
        }
        onMouseMove(t) {
          this.emit("changing", {
            e: t,
            handle: this
          })
        }
        onMouseUp(t) {
          this.emit("changed", {
            e: t,
            handle: this
          }), this.undelegateDocumentEvents(), this.options.graph.view.delegateEvents()
        }
        show() {
          this.container.style.display = ""
        }
        hide() {
          this.container.style.display = "none"
        }
      }
    }(xS || (xS = {})), (vS = xS || (xS = {})).config({
      name: "segments",
      precision: .5,
      threshold: 40,
      snapRadius: 10,
      stopPropagation: !0,
      removeRedundancies: !0,
      attrs: {
        width: 20,
        height: 8,
        x: -10,
        y: -4,
        rx: 4,
        ry: 4,
        fill: "#333",
        stroke: "#fff",
        "stroke-width": 2
      },
      createHandle: t => new vS.Handle(t),
      anchor: fS
    });
    class wS extends pS.ToolItem {
      get type() {
        return this.options.type
      }
      onRender() {
        h.addClass(this.container, this.prefixClassName(`edge-tool-${this.type}-anchor`)), this.toggleArea(!1),
          this.update()
      }
      update() {
        const t = this.type;
        return this.cellView.getTerminalView(t) ? (this.updateAnchor(), this.updateArea(), this.container.style
          .display = "") : this.container.style.display = "none", this
      }
      updateAnchor() {
        const t = this.childNodes;
        if (!t) return;
        const e = t.anchor;
        if (!e) return;
        const n = this.type,
          r = this.cellView,
          i = this.options,
          o = r.getTerminalAnchor(n),
          s = r.cell.prop([n, "anchor"]);
        e.setAttribute("transform", `translate(${o.x}, ${o.y})`);
        const a = s ? i.customAnchorAttrs : i.defaultAnchorAttrs;
        if (a)
          for (const t in a) e.setAttribute(t, a[t])
      }
      updateArea() {
        const t = this.childNodes;
        if (!t) return;
        const e = t.area;
        if (!e) return;
        const n = this.type,
          r = this.cellView,
          i = r.getTerminalView(n);
        if (i) {
          const t = i.cell,
            o = r.getTerminalMagnet(n);
          let s, a, l, c = this.options.areaPadding || 0;
          isFinite(c) || (c = 0), i.isEdgeElement(o) ? (s = i.getBBox(), a = 0, l = s.getCenter()) : (s = i.getUnrotatedBBoxOfElement(
              o), a = t.getAngle(), l = s.getCenter(), a && l.rotate(-a, t.getBBox().getCenter())), s.inflate(c),
            h.attr(e, {
              x: -s.width / 2,
              y: -s.height / 2,
              width: s.width,
              height: s.height,
              transform: `translate(${l.x}, ${l.y}) rotate(${a})`
            })
        }
      }
      toggleArea(t) {
        if (this.childNodes) {
          const e = this.childNodes.area;
          e && (e.style.display = t ? "" : "none")
        }
      }
      onMouseDown(t) {
        this.guard(t) || (t.stopPropagation(), t.preventDefault(), this.graph.view.undelegateEvents(), this.options
          .documentEvents && this.delegateDocumentEvents(this.options.documentEvents), this.focus(), this.toggleArea(
            this.options.restrictArea), this.cell.startBatch("move-anchor", {
            ui: !0,
            toolId: this.cid
          }))
      }
      resetAnchor(t) {
        const e = this.type,
          n = this.cell;
        t ? n.prop([e, "anchor"], t, {
          rewrite: !0,
          ui: !0,
          toolId: this.cid
        }) : n.removeProp([e, "anchor"], {
          ui: !0,
          toolId: this.cid
        })
      }
      onMouseMove(t) {
        const e = this.type,
          n = this.cellView,
          r = n.getTerminalView(e);
        if (null == r) return;
        const i = this.normalizeEvent(t),
          o = r.cell,
          s = n.getTerminalMagnet(e);
        let a = this.graph.clientToLocal(i.clientX, i.clientY);
        const c = this.options.snap;
        if ("function" == typeof c) {
          const t = l.call(c, n, a, r, s, e, n, this);
          a = hC.create(t)
        }
        if (this.options.restrictArea)
          if (r.isEdgeElement(s)) {
            const t = r.getClosestPoint(a);
            t && (a = t)
          } else {
            const t = r.getUnrotatedBBoxOfElement(s),
              e = o.getAngle(),
              n = o.getBBox().getCenter(),
              i = a.clone().rotate(e, n);
            t.containsPoint(i) || (a = t.pointNearestToPoint(i).rotate(-e, n))
          } let h;
        const u = this.options.anchor;
        "function" == typeof u && (h = l.call(u, n, a, r, s, e, n, this)), this.resetAnchor(h), this.update()
      }
      onMouseUp(t) {
        this.graph.view.delegateEvents(), this.undelegateDocumentEvents(), this.blur(), this.toggleArea(!1);
        const e = this.cellView;
        this.options.removeRedundancies && e.removeRedundantLinearVertices({
          ui: !0,
          toolId: this.cid
        }), this.cell.stopBatch("move-anchor", {
          ui: !0,
          toolId: this.cid
        })
      }
      onDblClick() {
        this.resetAnchor(), this.update()
      }
    }(wS || (wS = {})).config({
      tagName: "g",
      markup: [{
        tagName: "circle",
        selector: "anchor",
        attrs: {
          cursor: "pointer"
        }
      }, {
        tagName: "rect",
        selector: "area",
        attrs: {
          "pointer-events": "none",
          fill: "none",
          stroke: "#33334F",
          "stroke-dasharray": "2,4",
          rx: 5,
          ry: 5
        }
      }],
      events: {
        mousedown: "onMouseDown",
        touchstart: "onMouseDown",
        dblclick: "onDblClick"
      },
      documentEvents: {
        mousemove: "onMouseMove",
        touchmove: "onMouseMove",
        mouseup: "onMouseUp",
        touchend: "onMouseUp",
        touchcancel: "onMouseUp"
      },
      customAnchorAttrs: {
        "stroke-width": 4,
        stroke: "#33334F",
        fill: "#FFFFFF",
        r: 5
      },
      defaultAnchorAttrs: {
        "stroke-width": 2,
        stroke: "#FFFFFF",
        fill: "#33334F",
        r: 6
      },
      areaPadding: 6,
      restrictArea: !0,
      snapRadius: 10,
      removeRedundancies: !0,
      anchor: fS,
      snap(t, e, n, r, i, o) {
        const s = o.options.snapRadius || 0,
          a = "source" === r,
          l = a ? 0 : -1,
          c = this.cell.getVertexAt(l) || this.getTerminalAnchor(a ? "target" : "source");
        return c && (Math.abs(c.x - t.x) < s && (t.x = c.x), Math.abs(c.y - t.y) < s && (t.y = c.y)), t
      }
    });
    const AS = wS.define({
        name: "source-anchor",
        type: "source"
      }),
      ES = wS.define({
        name: "target-anchor",
        type: "target"
      });
    var SS = this && this.__rest || function(t, e) {
      var n = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
          .call(t, r[i]) && (n[r[i]] = t[r[i]])
      }
      return n
    };
    class MS extends pS.ToolItem {
      get type() {
        return this.options.type
      }
      get ratio() {
        return this.options.ratio
      }
      init() {
        if (this.options.attrs) {
          const t = this.options.attrs,
            {
              class: e
            } = t,
            n = SS(t, ["class"]);
          this.setAttrs(n, this.container), e && h.addClass(this.container, e)
        }
      }
      onRender() {
        h.addClass(this.container, this.prefixClassName(`edge-tool-${this.type}-arrowhead`)), this.update()
      }
      update() {
        const t = this.ratio,
          e = this.cellView,
          n = e.getTangentAtRatio(t),
          r = n ? n.start : e.getPointAtRatio(t),
          i = n && n.vector().vectorAngle(new hC(1, 0)) || 0;
        if (!r) return this;
        const o = h.createSVGMatrix().translate(r.x, r.y).rotate(i);
        return h.transform(this.container, o, {
          absolute: !0
        }), this
      }
      onMouseDown(t) {
        if (this.guard(t)) return;
        t.stopPropagation(), t.preventDefault();
        const e = this.cellView;
        if (e.can("arrowheadMovable")) {
          e.cell.startBatch("move-arrowhead", {
            ui: !0,
            toolId: this.cid
          });
          const n = e.prepareArrowheadDragging(this.type, {
            options: {
              toolId: this.cid
            }
          });
          this.cellView.setEventData(t, n), this.delegateDocumentEvents(this.options.documentEvents, t.data), e
            .graph.view.undelegateEvents(), this.container.style.pointerEvents = "none"
        }
        this.focus()
      }
      onMouseMove(t) {
        const e = this.normalizeEvent(t),
          n = this.graph.snapToGrid(e.clientX, e.clientY);
        this.cellView.onMouseMove(e, n.x, n.y)
      }
      onMouseUp(t) {
        this.undelegateDocumentEvents();
        const e = this.normalizeEvent(t),
          n = this.cellView,
          r = this.graph.snapToGrid(e.clientX, e.clientY);
        n.onMouseUp(e, r.x, r.y), this.graph.view.delegateEvents(), this.blur(), this.container.style.pointerEvents =
          "", n.cell.stopBatch("move-arrowhead", {
            ui: !0,
            toolId: this.cid
          })
      }
    }(MS || (MS = {})).config({
      tagName: "path",
      isSVGElement: !0,
      events: {
        mousedown: "onMouseDown",
        touchstart: "onMouseDown"
      },
      documentEvents: {
        mousemove: "onMouseMove",
        touchmove: "onMouseMove",
        mouseup: "onMouseUp",
        touchend: "onMouseUp",
        touchcancel: "onMouseUp"
      }
    });
    const kS = MS.define({
        name: "source-arrowhead",
        type: "source",
        ratio: 0,
        attrs: {
          d: "M 10 -8 -10 0 10 8 Z",
          fill: "#333",
          stroke: "#fff",
          "stroke-width": 2,
          cursor: "move"
        }
      }),
      OS = MS.define({
        name: "target-arrowhead",
        type: "target",
        ratio: 1,
        attrs: {
          d: "M -10 -8 10 0 -10 8 Z",
          fill: "#333",
          stroke: "#fff",
          "stroke-width": 2,
          cursor: "move"
        }
      });
    var PS, DS, TS, _S, jS = this && this.__rest || function(t, e) {
      var n = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
          .call(t, r[i]) && (n[r[i]] = t[r[i]])
      }
      return n
    };
    (DS = PS || (PS = {})).presets = {
      boundary: bS,
      button: mS,
      "button-remove": mS.Remove
    }, DS.registry = Kx.create({
      type: "node tool",
      process(t, e) {
        if ("function" == typeof e) return e;
        let n = pS.ToolItem;
        const {
          inherit: r
        } = e, i = jS(e, ["inherit"]);
        if (r) {
          const t = this.get(r);
          null == t ? this.onNotFound(r, "inherited") : n = t
        }
        return null == i.name && (i.name = t), n.define.call(n, i)
      }
    }), DS.registry.register(DS.presets, !0), (_S = TS || (TS = {})).presets = {
      boundary: bS,
      vertices: CS,
      segments: xS,
      button: mS,
      "button-remove": mS.Remove,
      "source-anchor": AS,
      "target-anchor": ES,
      "source-arrowhead": kS,
      "target-arrowhead": OS
    }, _S.registry = Kx.create({
      type: "edge tool",
      process(t, e) {
        if ("function" == typeof e) return e;
        let n = pS.ToolItem;
        const {
          inherit: r
        } = e, i = jS(e, ["inherit"]);
        if (r) {
          const t = this.get(r);
          null == t ? this.onNotFound(r, "inherited") : n = t
        }
        return null == i.name && (i.name = t), n.define.call(n, i)
      }
    }), _S.registry.register(_S.presets, !0);
    const LS = HS("center"),
      NS = HS("topCenter"),
      FS = HS("bottomCenter"),
      $S = HS("leftMiddle"),
      BS = HS("rightMiddle"),
      IS = HS("topLeft"),
      zS = HS("topRight"),
      RS = HS("bottomLeft"),
      VS = HS("bottomRight");

    function HS(t) {
      return function(e, n, r, i = {}) {
        const o = i.rotated ? e.getUnrotatedBBoxOfElement(n) : e.getBBoxOfElement(n),
          s = o[t];
        s.x += a.normalizePercentage(i.dx, o.width), s.y += a.normalizePercentage(i.dy, o.height);
        const l = e.cell;
        return i.rotated ? s.rotate(-l.getAngle(), l.getBBox().getCenter()) : s
      }
    }

    function GS(t) {
      return function(e, n, r, i) {
        if (r instanceof Element) {
          const o = this.graph.renderer.findViewByElem(r);
          let s;
          if (o)
            if (o.isEdgeElement(r)) {
              s = US(o, null != i.fixedAt ? i.fixedAt : "50%")
            } else s = o.getBBoxOfElement(r).getCenter();
          else s = new hC;
          return t.call(this, e, n, s, i)
        }
        return t.apply(this, arguments)
      }
    }

    function US(t, e) {
      const n = a.isPercentage(e),
        r = "string" == typeof e ? parseFloat(e) : e;
      return n ? t.getPointAtRatio(r / 100) : t.getPointAtLength(r)
    }
    const qS = GS(function(t, e, n, r) {
        const i = t.cell.getAngle(),
          o = t.getBBoxOfElement(e),
          s = o.getCenter(),
          a = o.getTopLeft(),
          l = o.getBottomRight();
        let c = r.padding;
        if (isFinite(c) || (c = 0), a.y + c <= n.y && n.y <= l.y - c) {
          const t = n.y - s.y;
          s.x += 0 === i || 180 === i ? 0 : 1 * t / Math.tan(nC.toRad(i)), s.y += t
        } else if (a.x + c <= n.x && n.x <= l.x - c) {
          const t = n.x - s.x;
          s.y += 90 === i || 270 === i ? 0 : t * Math.tan(nC.toRad(i)), s.x += t
        }
        return s
      }),
      WS = function(t, e, n, r, i) {
        const o = t.cell.getConnectionPoint(this.cell, i);
        return (r.dx || r.dy) && o.translate(r.dx || 0, r.dy || 0), o
      },
      XS = GS(function(t, e, n, r) {
        let i, o, s = 0;
        const a = t.cell;
        r.rotated ? (i = t.getUnrotatedBBoxOfElement(e), o = a.getBBox().getCenter(), s = a.getAngle()) : i = t
          .getBBoxOfElement(e);
        const l = r.padding;
        let c;
        switch (null != l && isFinite(l) && i.inflate(l), r.rotated && n.rotate(s, o), i.sideNearestToPoint(n)) {
          case "left":
            c = i.getLeftMiddle();
            break;
          case "right":
            c = i.getRightMiddle();
            break;
          case "top":
            c = i.getTopCenter();
            break;
          case "bottom":
            c = i.getBottomCenter()
        }
        return r.rotated ? c.rotate(-s, o) : c
      });
    var YS, JS;
    (JS = YS || (YS = {})).presets = C, JS.registry = Kx.create({
      type: "node endpoint"
    }), JS.registry.register(JS.presets, !0);
    const ZS = function(t, e, n, r) {
        let i = null != r.ratio ? r.ratio : .5;
        return i > 1 && (i /= 100), t.getPointAtRatio(i)
      },
      KS = function(t, e, n, r) {
        const i = null != r.length ? r.length : 20;
        return t.getPointAtLength(i)
      },
      QS = function(t, e, n, r) {
        const i = t.getClosestPoint(n);
        return null != i ? i : new hC
      },
      tM = GS(QS),
      eM = GS(function(t, e, n, r) {
        const i = t.getConnection(),
          o = t.getConnectionSubdivisions(),
          s = new dC(n.clone().translate(0, 1e6), n.clone().translate(0, -1e6)),
          a = new dC(n.clone().translate(1e6, 0), n.clone().translate(-1e6, 0)),
          c = s.intersect(i, {
            segmentSubdivisions: o
          }),
          h = a.intersect(i, {
            segmentSubdivisions: o
          }),
          u = [];
        return c && u.push(...c), h && u.push(...h), u.length > 0 ? n.closest(u) : null != r.fallbackAt ? US(t,
          r.fallbackAt) : l.call(QS, this, t, e, n, r)
      });
    var nM, rM;

    function iM(t, e, n) {
      if (null == n) return t;
      const r = t.distance(e);
      return 0 === n && r > 0 ? t : t.move(e, -Math.min(n, r - 1))
    }

    function oM(t) {
      const e = t.getAttribute("stroke-width");
      return null === e ? 0 : parseFloat(e) || 0
    }(rM = nM || (nM = {})).presets = x, rM.registry = Kx.create({
      type: "edge endpoint"
    }), rM.registry.register(rM.presets, !0);
    const sM = function(t, e, n, r) {
        const i = e.getBBoxOfElement(n);
        r.stroked && i.inflate(oM(n) / 2);
        const o = t.intersect(i);
        return iM(o && o.length ? t.start.closest(o) : t.end, t.start, r.offset)
      },
      aM = function(t, e, n, r, i) {
        const o = e.cell,
          s = o.isNode() ? o.getAngle() : 0;
        if (0 === s) return l.call(sM, this, t, e, n, r, i);
        const a = e.getUnrotatedBBoxOfElement(n);
        r.stroked && a.inflate(oM(n) / 2);
        const c = a.getCenter(),
          h = t.clone().rotate(s, c),
          u = h.setLength(1e6).intersect(a);
        return iM(u && u.length ? h.start.closest(u).rotate(-s, c) : t.end, t.start, r.offset)
      },
      lM = function(t, e, n, r) {
        let i, s;
        const a = t.end,
          l = r.selector;
        if (i = "string" == typeof l ? e.findOne(l) : Array.isArray(l) ? o.getByPath(n, l) : function(t) {
            if (null == t) return null;
            let e = t;
            do {
              let t = e.tagName;
              if ("string" != typeof t) return null;
              if ("G" === (t = t.toUpperCase())) e = e.firstElementChild;
              else {
                if ("TITLE" !== t) break;
                e = e.nextElementSibling
              }
            } while (e);
            return e
          }(n), !h.isSVGGraphicsElement(i)) {
          if (i === n || !h.isSVGGraphicsElement(n)) return a;
          i = n
        }
        const c = e.getShapeOfElement(i),
          u = e.getMatrixOfElement(i),
          d = e.getRootTranslatedMatrix(),
          p = e.getRootRotatedMatrix(),
          f = d.multiply(p).multiply(u),
          g = f.inverse(),
          m = h.transformLine(t, g),
          v = m.start.clone(),
          y = e.getDataOfElement(i);
        if (!1 === r.insideout) {
          null == y.shapeBBox && (y.shapeBBox = c.bbox());
          const t = y.shapeBBox;
          if (null != t && t.containsPoint(v)) return a
        }
        let b;
        if (!0 === r.extrapolate && m.setLength(1e6), c instanceof PC) {
          const t = r.precision || 2;
          null == y.segmentSubdivisions && (y.segmentSubdivisions = c.getSegmentSubdivisions({
            precision: t
          })), b = {
            precision: t,
            segmentSubdivisions: y.segmentSubdivisions
          }, s = m.intersect(c, b)
        } else s = m.intersect(c);
        s ? Array.isArray(s) && (s = v.closest(s)) : !0 === r.sticky && (s = c instanceof uC ? c.pointNearestToPoint(
          v) : c instanceof pC ? c.intersectionWithLineFromCenterToPoint(v) : c.closestPoint(v, b));
        const C = s ? h.transformPoint(s, f) : a;
        let x = r.offset || 0;
        return r.stroked && (x += oM(i) / 2), iM(C, t.start, x)
      },
      cM = function(t, e, n, r) {
        return iM(t.end, t.start, r.offset)
      };
    var hM, uM;
    (uM = hM || (hM = {})).presets = w, uM.registry = Kx.create({
      type: "connection point"
    }), uM.registry.register(uM.presets, !0);
    const dM = function(t) {
        return [...t]
      },
      pM = function(t, e, n) {
        const r = e.side || "bottom",
          i = a.normalizeSides(e.padding || 40),
          o = n.sourceBBox,
          s = n.targetBBox,
          l = o.getCenter(),
          c = s.getCenter();
        let h, u, d;
        switch (r) {
          case "top":
            d = -1, h = "y", u = "height";
            break;
          case "left":
            d = -1, h = "x", u = "width";
            break;
          case "right":
            d = 1, h = "x", u = "width";
            break;
          case "bottom":
          default:
            d = 1, h = "y", u = "height"
        }
        return l[h] += d * (o[u] / 2 + i[r]), c[h] += d * (s[u] / 2 + i[r]), d * (l[h] - c[h]) > 0 ? c[h] = l[h] :
          l[h] = c[h], [l.toJSON(), ...t, c.toJSON()]
      };

    function fM(t) {
      return new uC(t.x, t.y, 0, 0)
    }

    function gM(t = {}) {
      const e = a.normalizeSides(t.padding || 20);
      return {
        x: -e.left,
        y: -e.top,
        width: e.left + e.right,
        height: e.top + e.bottom
      }
    }

    function mM(t, e = {}) {
      return t.sourceBBox.clone().moveAndExpand(gM(e))
    }

    function vM(t, e = {}) {
      return t.targetBBox.clone().moveAndExpand(gM(e))
    }
    const yM = function(t, e, n) {
      let r = mM(n, e),
        i = vM(n, e);
      const o = function(t, e = {}) {
          return t.sourceAnchor ? t.sourceAnchor : mM(t, e).getCenter()
        }(n, e),
        s = function(t, e = {}) {
          return t.targetAnchor ? t.targetAnchor : vM(t, e).getCenter()
        }(n, e);
      r = r.union(fM(o)), i = i.union(fM(s));
      const a = t.map(t => hC.create(t));
      a.unshift(o), a.push(s);
      let l = null;
      const c = [];
      for (let t = 0, n = a.length - 1; t < n; t += 1) {
        let o = null;
        const s = a[t],
          h = a[t + 1],
          u = null != bM.getBearing(s, h);
        if (0 === t) t + 1 === n ? r.intersect(i.clone().inflate(1)) ? o = bM.insideNode(s, h, r, i) : u || (o =
          bM.nodeToNode(s, h, r, i)) : r.containsPoint(h) ? o = bM.insideNode(s, h, r, fM(h).moveAndExpand(gM(
          e))) : u || (o = bM.nodeToVertex(s, h, r));
        else if (t + 1 === n) {
          const t = u && bM.getBearing(h, s) === l;
          i.containsPoint(s) || t ? o = bM.insideNode(s, h, fM(s).moveAndExpand(gM(e)), i, l) : u || (o = bM.vertexToNode(
            s, h, i, l))
        } else u || (o = bM.vertexToVertex(s, h, l));
        o ? (c.push(...o.points), l = o.direction) : l = bM.getBearing(s, h), t + 1 < n && c.push(h)
      }
      return c
    };
    var bM;
    ! function(t) {
      const e = {
          N: "S",
          S: "N",
          E: "W",
          W: "E"
        },
        n = {
          N: -Math.PI / 2 * 3,
          S: -Math.PI / 2,
          E: 0,
          W: Math.PI
        };

      function r(t, e, n) {
        let r = new hC(t.x, e.y);
        return n.containsPoint(r) && (r = new hC(e.x, t.y)), r
      }

      function o(t, e) {
        return t["W" === e || "E" === e ? "width" : "height"]
      }

      function s(t, e) {
        return t.x === e.x ? t.y > e.y ? "N" : "S" : t.y === e.y ? t.x > e.x ? "W" : "E" : null
      }

      function a(t, n, r) {
        const i = new hC(t.x, n.y),
          o = new hC(n.x, t.y),
          a = s(t, i),
          l = s(t, o),
          c = r ? e[r] : null,
          h = a === r || a !== c && (l === c || l !== r) ? i : o;
        return {
          points: [h],
          direction: s(h, n)
        }
      }

      function l(t, e, n) {
        const i = r(t, e, n);
        return {
          points: [i],
          direction: s(i, e)
        }
      }
      t.getBBoxSize = o, t.getBearing = s, t.vertexToVertex = a, t.nodeToVertex = l, t.vertexToNode = function(t,
        e, n, a) {
        const l = [new hC(t.x, e.y), new hC(e.x, t.y)],
          c = l.filter(t => !n.containsPoint(t)),
          h = c.filter(e => s(e, t) !== a);
        let u;
        if (h.length > 0) return {
          points: [u = (u = h.filter(e => s(t, e) === a).pop()) || h[0]],
          direction: s(u, e)
        }; {
          u = i.difference(l, c)[0];
          const h = hC.create(e).move(u, -o(n, a) / 2);
          return {
            points: [r(h, t, n), h],
            direction: s(h, e)
          }
        }
      }, t.nodeToNode = function(t, e, n, r) {
        let i = l(e, t, r);
        const c = i.points[0];
        if (n.containsPoint(c)) {
          const h = (i = l(t, e, n)).points[0];
          if (r.containsPoint(h)) {
            const u = hC.create(t).move(h, -o(n, s(t, h)) / 2),
              d = hC.create(e).move(c, -o(r, s(e, c)) / 2),
              p = new dC(u, d).getCenter(),
              f = l(t, p, n),
              g = a(p, e, f.direction);
            i.points = [f.points[0], g.points[0]], i.direction = g.direction
          }
        }
        return i
      }, t.insideNode = function(t, e, i, o, a) {
        const l = i.union(o).inflate(1),
          c = l.getCenter(),
          h = c.distance(e) > c.distance(t),
          u = h ? e : t,
          d = h ? t : e;
        let p, f, g, m;
        return a ? (p = hC.fromPolar(l.width + l.height, n[a], u), p = l.pointNearestToPoint(p).move(p, -1)) :
          p = l.pointNearestToPoint(u).move(u, 1), f = r(p, d, l), p.round().equals(f.round()) ? (f = hC.fromPolar(
            l.width + l.height, nC.toRad(p.theta(u)) + Math.PI / 2, d), g = r(p, f = l.pointNearestToPoint(f)
            .move(d, 1).round(), l), m = h ? [f, g, p] : [p, g, f]) : m = h ? [f, p] : [p, f], {
            points: m,
            direction: s(h ? p : f, e)
          }
      }
    }(bM || (bM = {}));
    const CM = {
      step: 10,
      maxLoopCount: 2e3,
      precision: 1,
      maxDirectionChange: 90,
      perpendicular: !0,
      excludeTerminals: [],
      excludeShapes: [],
      startDirections: ["top", "right", "bottom", "left"],
      endDirections: ["top", "right", "bottom", "left"],
      directionMap: {
        top: {
          x: 0,
          y: -1
        },
        right: {
          x: 1,
          y: 0
        },
        bottom: {
          x: 0,
          y: 1
        },
        left: {
          x: -1,
          y: 0
        }
      },
      cost() {
        return xM(this.step, this)
      },
      directions() {
        const t = xM(this.step, this),
          e = xM(this.cost, this);
        return [{
          cost: e,
          offsetX: t,
          offsetY: 0
        }, {
          cost: e,
          offsetX: 0,
          offsetY: t
        }, {
          cost: e,
          offsetX: -t,
          offsetY: 0
        }, {
          cost: e,
          offsetX: 0,
          offsetY: -t
        }]
      },
      penalties() {
        const t = xM(this.step, this);
        return {
          0: 0,
          45: t / 2,
          90: t / 2
        }
      },
      paddingBox() {
        const t = xM(this.step, this);
        return {
          x: -t,
          y: -t,
          width: 2 * t,
          height: 2 * t
        }
      },
      fallbackRouter: yM,
      draggingRouter: null
    };

    function xM(t, e) {
      return "function" == typeof t ? t.call(e) : t
    }
    const wM = 1,
      AM = 2;
    class EM {
      constructor() {
        this.items = [], this.hash = {}, this.values = {}
      }
      add(t, e) {
        this.hash[t] ? this.items.splice(this.items.indexOf(t), 1) : this.hash[t] = wM, this.values[t] = e;
        const n = i.sortedIndexBy(this.items, t, t => this.values[t]);
        this.items.splice(n, 0, t)
      }
      pop() {
        const t = this.items.shift();
        return t && (this.hash[t] = AM), t
      }
      isOpen(t) {
        return this.hash[t] === wM
      }
      isClose(t) {
        return this.hash[t] === AM
      }
      isEmpty() {
        return 0 === this.items.length
      }
    }

    function SM(t, e) {
      const n = t.sourceBBox.clone();
      return e && e.paddingBox ? n.moveAndExpand(e.paddingBox) : n
    }

    function MM(t, e) {
      const n = t.targetBBox.clone();
      return e && e.paddingBox ? n.moveAndExpand(e.paddingBox) : n
    }

    function kM(t, e) {
      if (t.sourceAnchor) return t.sourceAnchor;
      return SM(t, e).getCenter()
    }

    function OM(t, e, n, r, i) {
      const o = 360 / n,
        s = t.theta(function(t, e, n, r) {
          const i = r.step,
            o = e.x - t.x,
            s = e.y - t.y,
            a = o / n.x,
            l = s / n.y,
            c = a * i,
            h = l * i;
          return new hC(t.x + c, t.y + h)
        }(t, e, r, i)),
        a = nC.normalize(s + o / 2);
      return o * Math.floor(a / o)
    }

    function PM(t, e) {
      const n = Math.abs(t - e);
      return n > 180 ? 360 - n : n
    }

    function DM(t, e) {
      if (!t) return e;
      const n = Math.abs(t),
        r = Math.round(n / e);
      return r ? e + (n - r * e) / r : n
    }

    function TM(t, e) {
      return t.round(e)
    }

    function _M(t, e, n) {
      return TM(function(t, e) {
        const n = e.source,
          r = oE.snapToGrid(t.x - n.x, e.x) + n.x,
          i = oE.snapToGrid(t.y - n.y, e.y) + n.y;
        return new hC(r, i)
      }(t.clone(), e), n)
    }

    function jM(t) {
      return t.toString()
    }

    function LM(t) {
      return new hC(0 === t.x ? 0 : Math.abs(t.x) / t.x, 0 === t.y ? 0 : Math.abs(t.y) / t.y)
    }

    function NM(t, e) {
      let n = 1 / 0;
      for (let r = 0, i = e.length; r < i; r += 1) {
        const i = t.manhattanDistance(e[r]);
        i < n && (n = i)
      }
      return n
    }

    function FM(t, e, n, r, i) {
      const o = i.precision,
        s = i.directionMap,
        a = t.diff(e.getCenter()),
        l = Object.keys(s).reduce((i, l) => {
          if (n.includes(l)) {
            const n = s[l],
              c = new hC(t.x + n.x * (Math.abs(a.x) + e.width), t.y + n.y * (Math.abs(a.y) + e.height)),
              h = new dC(t, c).intersect(e) || [];
            let u, d = null;
            for (let e = 0; e < h.length; e += 1) {
              const n = h[e],
                r = t.squaredDistance(n);
              (null == u || r > u) && (u = r, d = n)
            }
            if (d) {
              let t = _M(d, r, o);
              e.containsPoint(t) && (t = _M(t.translate(n.x * r.x, n.y * r.y), r, o)), i.push(t)
            }
          }
          return i
        }, []);
      return e.containsPoint(t) || l.push(_M(t, r, o)), l
    }

    function $M(t, e, n, r, i) {
      const o = [];
      let s, a = LM(i.diff(n)),
        l = jM(n),
        c = t[l];
      for (; c;) {
        const n = LM((s = e[l]).diff(c));
        n.equals(a) || (o.unshift(s), a = n), c = t[l = jM(c)]
      }
      const h = e[l];
      return LM(h.diff(r)).equals(a) || o.unshift(h), o
    }

    function BM(t, e, n, r, i) {
      const o = i.precision;
      let s, a;
      s = TM(e instanceof uC ? kM(t, i).clone() : e.clone(), o), a = TM(n instanceof uC ? function(t, e) {
        return t.targetAnchor ? t.targetAnchor : MM(t, e).getCenter()
      }(t, i).clone() : n.clone(), o);
      const c = (h = i.step, d = a, {
        source: (u = s).clone(),
        x: DM(d.x - u.x, h),
        y: DM(d.y - u.y, h)
      });
      var h, u, d;
      const p = s,
        f = a;
      let g, m;
      if (g = e instanceof uC ? FM(p, e, i.startDirections, c, i) : [p], m = n instanceof uC ? FM(a, n, i.endDirections,
          c, i) : [f], g = g.filter(t => r.isAccessible(t)), m = m.filter(t => r.isAccessible(t)), g.length > 0 &&
        m.length > 0) {
        const t = new EM,
          e = {},
          n = {},
          s = {};
        for (let n = 0, r = g.length; n < r; n += 1) {
          const r = g[n],
            i = jM(r);
          t.add(i, NM(r, m)), e[i] = r, s[i] = 0
        }
        const a = i.previousDirectionAngle,
          l = void 0 === a;
        let h, u;
        const d = function(t, e) {
            const n = e.step;
            return e.directions.forEach(e => {
              e.gridOffsetX = e.offsetX / n * t.x, e.gridOffsetY = e.offsetY / n * t.y
            }), e.directions
          }(c, i),
          v = d.length,
          y = m.reduce((t, e) => {
            const n = jM(e);
            return t.push(n), t
          }, []),
          b = hC.equalPoints(g, m);
        let C = i.maxLoopCount;
        for (; !t.isEmpty() && C > 0;) {
          const g = t.pop(),
            x = e[g],
            w = n[g],
            A = s[g],
            E = x.equals(p),
            S = null == w;
          let M;
          if (M = S ? l ? E ? null : OM(p, x, v, c, i) : a : OM(w, x, v, c, i), !(S && b) && y.indexOf(g) >= 0)
            return i.previousDirectionAngle = M, $M(n, e, x, p, f);
          for (let a = 0; a < v; a += 1) {
            const p = (h = d[a]).angle;
            if (u = PM(M, p), (!l || !E) && u > i.maxDirectionChange) continue;
            const g = _M(x.clone().translate(h.gridOffsetX || 0, h.gridOffsetY || 0), c, o),
              b = jM(g);
            if (t.isClose(b) || !r.isAccessible(g)) continue;
            if (y.indexOf(b) >= 0) {
              if (!g.equals(f)) {
                if (PM(p, OM(g, f, v, c, i)) > i.maxDirectionChange) continue
              }
            }
            const C = A + h.cost + (E ? 0 : i.penalties[u]);
            (!t.isOpen(b) || C < s[b]) && (e[b] = g, n[b] = x, s[b] = C, t.add(b, C + NM(g, m)))
          }
          C -= 1
        }
      }
      return i.fallbackRoute ? l.call(i.fallbackRoute, this, p, f, i) : null
    }
    const IM = function(t, e, n) {
        const r = function(t) {
            const e = Object.keys(t).reduce((e, n) => {
              const r = e;
              return r[n] = "fallbackRouter" === n || "draggingRouter" === n || "fallbackRoute" === n ? t[n] :
                xM(t[n], t), e
            }, {});
            if (e.padding) {
              const n = a.normalizeSides(e.padding);
              t.paddingBox = {
                x: -n.left,
                y: -n.top,
                width: n.left + n.right,
                height: n.top + n.bottom
              }
            }
            return e.directions.forEach(t => {
              const e = new hC(0, 0),
                n = new hC(t.offsetX, t.offsetY);
              t.angle = nC.normalize(e.theta(n))
            }), e
          }(e),
          o = SM(n, r),
          s = MM(n, r),
          c = kM(n, r),
          h = new class {
            constructor(t) {
              this.options = t, this.mapGridSize = 100, this.map = {}
            }
            build(t, e) {
              const n = this.options,
                r = n.excludeTerminals.reduce((n, r) => {
                  const i = e[r];
                  if (i) {
                    const e = t.getCell(i.cell);
                    e && n.push(e)
                  }
                  return n
                }, []);
              let o = [];
              const s = t.getCell(e.getSourceCellId());
              s && (o = i.union(o, s.getAncestors().map(t => t.id)));
              const a = t.getCell(e.getTargetCellId());
              a && (o = i.union(o, a.getAncestors().map(t => t.id)));
              const l = this.mapGridSize;
              return t.getNodes().reduce((t, e) => {
                const i = e.shape,
                  s = n.excludeShapes,
                  a = !!i && s.includes(i),
                  c = r.some(t => t.id === e.id),
                  h = o.includes(e.id);
                if (!(a || c || h)) {
                  const r = e.getBBox().moveAndExpand(n.paddingBox),
                    i = r.getOrigin().snapToGrid(l),
                    o = r.getCorner().snapToGrid(l);
                  for (let e = i.x; e <= o.x; e += l)
                    for (let n = i.y; n <= o.y; n += l) {
                      const i = new hC(e, n).toString();
                      null == t[i] && (t[i] = []), t[i].push(r)
                    }
                }
                return t
              }, this.map), this
            }
            isAccessible(t) {
              const e = t.clone().snapToGrid(this.mapGridSize).toString(),
                n = this.map[e];
              return !n || n.every(e => !e.containsPoint(t))
            }
          }(r).build(n.graph.model, n.cell),
          u = t.map(t => hC.create(t)),
          d = [];
        let p, f, g = c;
        for (let e = 0, i = u.length; e <= i; e += 1) {
          let i = null;
          if (p = f || o, null == (f = u[e])) {
            f = s;
            const t = n.cell;
            if ((null == t.getSourceCellId() || null == t.getTargetCellId()) && "function" == typeof r.draggingRouter) {
              const t = p === o ? c : p,
                e = f.getOrigin();
              i = l.call(r.draggingRouter, n, t, e, r)
            }
          }
          if (null == i && (i = BM(n, p, f, h, r)), null === i) return l.call(r.fallbackRouter, this, t, r, n);
          const a = i[0];
          a && a.equals(g) && i.shift(), g = i[i.length - 1] || g, d.push(...i)
        }
        return d
      },
      zM = function(t, e, n) {
        return l.call(IM, this, t, Object.assign(Object.assign({}, CM), e), n)
      },
      RM = {
        maxDirectionChange: 45,
        directions() {
          const t = xM(this.step, this),
            e = xM(this.cost, this),
            n = Math.ceil(Math.sqrt(t * t << 1));
          return [{
            cost: e,
            offsetX: t,
            offsetY: 0
          }, {
            cost: n,
            offsetX: t,
            offsetY: t
          }, {
            cost: e,
            offsetX: 0,
            offsetY: t
          }, {
            cost: n,
            offsetX: -t,
            offsetY: t
          }, {
            cost: e,
            offsetX: -t,
            offsetY: 0
          }, {
            cost: n,
            offsetX: -t,
            offsetY: -t
          }, {
            cost: e,
            offsetX: 0,
            offsetY: -t
          }, {
            cost: n,
            offsetX: t,
            offsetY: -t
          }]
        },
        fallbackRoute(t, e, n) {
          const r = t.theta(e),
            i = [];
          let o = {
              x: e.x,
              y: t.y
            },
            s = {
              x: t.x,
              y: e.y
            };
          if (r % 180 > 90) {
            const t = o;
            o = s, s = t
          }
          const a = r % 90 < 45 ? o : s,
            l = new dC(t, a),
            c = 90 * Math.ceil(r / 90),
            h = hC.fromPolar(l.squaredLength(), nC.toRad(c + 135), a),
            u = new dC(e, h),
            d = l.intersectionWithLine(u),
            p = d || e,
            f = d ? p : t,
            g = 360 / n.directions.length,
            m = f.theta(e),
            v = nC.normalize(m + g / 2),
            y = g * Math.floor(v / g);
          return n.previousDirectionAngle = y, p && i.push(p.round()), i.push(e), i
        }
      },
      VM = function(t, e, n) {
        return l.call(zM, this, t, Object.assign(Object.assign({}, RM), e), n)
      },
      HM = function(t, e, n) {
        const r = e.offset || 32;
        let i = e.direction;
        const o = n.sourceBBox,
          s = n.targetBBox,
          a = o.getCenter(),
          l = s.getCenter();
        if (null == i) {
          const t = a.x - l.x,
            e = a.y - l.y;
          i = Math.abs(t) > Math.abs(e) ? t > 0 ? "R" : "L" : e > 0 ? "B" : "T"
        }
        let c, h, u;
        const d = "L" === i || "R" === i || "H" === i;
        if (d) {
          if (l.y === a.y) return [...t];
          u = "L" === i || "H" === i && l.x > a.x ? 1 : -1, c = "x", h = "width"
        } else {
          if (l.x === a.x) return [...t];
          u = "T" === i || "V" === i && l.y > a.y ? 1 : -1, c = "y", h = "height"
        }
        const p = a.clone(),
          f = l.clone();
        p[c] += u * (o[h] / 2 + r), f[c] -= u * (s[h] / 2 + r);
        if (d) {
          const t = p.x,
            e = f.x,
            n = o.width / 2 + 16,
            r = s.width / 2 + 16;
          l.x > a.x ? e <= t && (p.x = Math.max(e, a.x + n), f.x = Math.min(t, l.x - r)) : e >= t && (p.x = Math.min(
            e, a.x - n), f.x = Math.max(t, l.x + r))
        } else {
          const t = p.y,
            e = f.y,
            n = o.height / 2 + 16,
            r = s.height / 2 + 16;
          l.y > a.y ? e <= t && (p.y = Math.max(e, a.y + n), f.y = Math.min(t, l.y - r)) : e >= t && (p.y = Math.min(
            e, a.y - n), f.y = Math.max(t, l.y + r))
        }
        return [p.toJSON(), ...t, f.toJSON()]
      };
    var GM, UM;
    (UM = GM || (GM = {})).presets = A, UM.registry = Kx.create({
      type: "router"
    }), UM.registry.register(UM.presets, !0);
    const qM = function(t, e, n, r = {}) {
        const i = [t, ...n, e],
          o = new fC(i),
          s = new PC(o);
        return r.raw ? s : s.serialize()
      },
      WM = function(t, e, n, r = {}) {
        const i = new PC;
        i.appendSegment(PC.createSegment("M", t));
        const o = r.radius || 10;
        let s, a;
        for (let r = 0, l = n.length; r < l; r += 1) {
          const l = hC.create(n[r]),
            c = n[r - 1] || t,
            h = n[r + 1] || e;
          s = a || l.distance(c) / 2, a = l.distance(h) / 2;
          const u = -Math.min(o, s),
            d = -Math.min(o, a),
            p = l.clone().move(c, u).round(),
            f = l.clone().move(h, d).round(),
            g = new hC(1 / 3 * p.x + 2 / 3 * l.x, 2 / 3 * l.y + 1 / 3 * p.y),
            m = new hC(1 / 3 * f.x + 2 / 3 * l.x, 2 / 3 * l.y + 1 / 3 * f.y);
          i.appendSegment(PC.createSegment("L", p)), i.appendSegment(PC.createSegment("C", g, m, f))
        }
        return i.appendSegment(PC.createSegment("L", e)), r.raw ? i : i.serialize()
      },
      XM = function(t, e, n, r = {}) {
        let i;
        if (n && 0 !== n.length) {
          const r = [t, ...n, e],
            o = gC.throughPoints(r);
          i = new PC(o)
        } else if ((i = new PC).appendSegment(PC.createSegment("M", t)), Math.abs(t.x - e.x) >= Math.abs(t.y - e.y)) {
          const n = (t.x + e.x) / 2;
          i.appendSegment(PC.createSegment("C", n, t.y, n, e.y, e.x, e.y))
        } else {
          const n = (t.y + e.y) / 2;
          i.appendSegment(PC.createSegment("C", t.x, n, e.x, n, e.x, e.y))
        }
        return r.raw ? i : i.serialize()
      },
      YM = 1,
      JM = 1 / 3,
      ZM = 2 / 3;

    function KM(t, e, n) {
      const r = [t, ...n, e],
        i = [];
      return r.forEach((t, e) => {
        const n = r[e + 1];
        null != n && i.push(new dC(t, n))
      }), i
    }

    function QM(t, e) {
      return new dC(t, e).squaredLength()
    }

    function tk(t, e, n, r) {
      const i = new PC;
      let o;
      return o = PC.createSegment("M", t[0].start), i.appendSegment(o), t.forEach((s, a) => {
        if (ek.includes(s)) {
          let t, r, a, l;
          if ("arc" === n) {
            t = -90, ((r = s.start.diff(s.end)).x < 0 || 0 === r.x && r.y < 0) && (t += 180);
            const e = s.getCenter(),
              n = new dC(e, s.end).rotate(t, e);
            let c;
            a = (c = new dC(s.start, e)).pointAt(2 / 3).rotate(t, s.start), l = n.pointAt(1 / 3).rotate(-t, n
                .end), o = PC.createSegment("C", a, l, n.end), i.appendSegment(o), c = new dC(e, s.end), a =
              n.pointAt(1 / 3).rotate(t, n.end), l = c.pointAt(1 / 3).rotate(-t, s.end), o = PC.createSegment(
                "C", a, l, s.end), i.appendSegment(o)
          } else if ("gap" === n) o = PC.createSegment("M", s.end), i.appendSegment(o);
          else if ("cubic" === n) {
            t = s.start.theta(s.end);
            const n = .6 * e;
            let c = 1.35 * e;
            ((r = s.start.diff(s.end)).x < 0 || 0 === r.x && r.y < 0) && (c *= -1), a = new hC(s.start.x + n,
                s.start.y + c).rotate(t, s.start), l = new hC(s.end.x - n, s.end.y + c).rotate(t, s.end), o =
              PC.createSegment("C", a, l, s.end), i.appendSegment(o)
          }
        } else {
          const e = t[a + 1];
          0 === r || !e || ek.includes(e) ? (o = PC.createSegment("L", s.end), i.appendSegment(o)) : function(
            t, e, n, r, i) {
            const o = n.distance(r) / 2,
              s = n.distance(i) / 2,
              a = -Math.min(t, o),
              l = -Math.min(t, s),
              c = n.clone().move(r, a).round(),
              h = n.clone().move(i, l).round(),
              u = new hC(JM * c.x + ZM * n.x, ZM * n.y + JM * c.y),
              d = new hC(JM * h.x + ZM * n.x, ZM * n.y + JM * h.y);
            let p;
            p = PC.createSegment("L", c), e.appendSegment(p), p = PC.createSegment("C", u, d, h), e.appendSegment(
              p)
          }(r, i, s.end, s.start, e.end)
        }
      }), i
    }
    let ek, nk;
    const rk = function(t, e, n, r = {}) {
      ek = [], nk = [],
        function(t) {
          let e = t.graph._jumpOverUpdateList;
          if (null == e && (e = t.graph._jumpOverUpdateList = [], t.graph.on("cell:mouseup", () => {
              const e = t.graph._jumpOverUpdateList;
              for (let t = 0; t < e.length; t += 1) e[t].update()
            }), t.graph.on("model:reseted", () => {
              e = t.graph._jumpOverUpdateList = []
            })), e.indexOf(t) < 0) {
            e.push(t);
            const n = () => e.splice(e.indexOf(t), 1);
            t.cell.once("change:connector", n), t.cell.once("removed", n)
          }
        }(this);
      const i = r.size || 5,
        o = r.type || "arc",
        s = r.radius || 0,
        a = r.ignoreConnectors || ["smooth"],
        l = this.graph,
        c = l.model.getEdges();
      if (1 === c.length) return tk(KM(t, e, n), i, o, s);
      const h = this.cell,
        u = c.indexOf(h),
        d = l.options.connecting.connector || {},
        p = c.filter((t, e) => {
          const n = t.getConnector() || d;
          return !a.includes(n.name) && (!(e > u) || "jumpover" !== n.name)
        }),
        f = p.map(t => l.renderer.findViewByCell(t)),
        g = KM(t, e, n),
        m = f.map(t => null == t ? [] : t === this ? g : KM(t.sourcePoint, t.targetPoint, t.routePoints)),
        v = [];
      g.forEach(t => {
        const e = p.reduce((e, n, r) => {
          if (n !== h) {
            const n = function(t, e) {
              const n = [];
              return e.forEach(e => {
                const r = t.intersectionWithLine(e);
                r && n.push(r)
              }), n
            }(t, m[r]);
            e.push(...n)
          }
          return e
        }, []).sort((e, n) => QM(t.start, e) - QM(t.start, n));
        e.length > 0 ? v.push(... function(t, e, n) {
          return e.reduce((r, i, o) => {
            if (nk.includes(i)) return r;
            const s = r.pop() || t,
              a = hC.create(i).move(s.start, -n);
            let l = hC.create(i).move(s.start, +n);
            const c = e[o + 1];
            if (null != c) {
              const t = l.distance(c);
              t <= n && (l = c.move(s.start, t), nk.push(c))
            } else if (a.distance(s.end) < 2 * n + YM) return r.push(s), r;
            if (l.distance(s.start) < 2 * n + YM) return r.push(s), r;
            const h = new dC(a, l);
            return ek.push(h), r.push(new dC(s.start, a), h, new dC(l, s.end)), r
          }, [])
        }(t, e, i)) : v.push(t)
      });
      const y = tk(v, i, o, s);
      return ek = [], nk = [], r.raw ? y : y.serialize()
    };
    var ik, ok;
    (ok = ik || (ik = {})).presets = E, ok.registry = Kx.create({
      type: "connector"
    }), ok.registry.register(ok.presets, !0);
    const sk = Kx.create;
    class ak {
      constructor(t) {
        this.cell = t, this.ids = {}
      }
      get() {
        return Object.keys(this.ids)
      }
      start(t, e, n = {}, r = "/") {
        const i = Object.assign({
          delay: 10,
          duration: 100,
          timing: "linear"
        }, n);
        let o = Ux.linear;
        null != i.timing && (o = "string" == typeof i.timing ? Ux[i.timing] : i.timing);
        const s = this.cell.getPropByPath(t),
          a = i.interp;
        let l;
        a ? l = a(s, e) : "object" == typeof e ? l = qx.object(s, e) : "number" == typeof e ? l = qx.number(s,
          e) : "string" == typeof e && (l = "#" === e[0] ? qx.color(s, e) : qx.unit(s, e));
        let c = 0;
        const u = Array.isArray(t) ? t.join(r) : t,
          d = () => {
            let e, s;
            const a = (new Date).getTime();
            0 === c && (c = a);
            let p = (a - c) / i.duration;
            p < 1 ? this.ids[u] = e = h.requestAnimationFrame(d) : (p = 1, delete this.ids[u]), s = l(o(p)), n.transitionId =
              e, this.cell.setPropByPath(Array.isArray(t) ? t : t.split(r), s), null == e && this.cell.notify(
                "transition:end", {
                  cell: this.cell,
                  path: u
                })
          },
          p = e => {
            this.stop(t, r), this.ids[u] = h.requestAnimationFrame(e), this.cell.notify("transition:begin", {
              cell: this.cell,
              path: u
            })
          };
        return setTimeout(() => {
          p(d)
        }, n.delay)
      }
      stop(t, e = "/") {
        const n = Array.isArray(t) ? t : t.split(e);
        return Object.keys(this.ids).filter(t => o.isEqual(n, t.split(e).slice(0, n.length))).forEach(t => {
          h.cancelAnimationFrame(this.ids[t]), delete this.ids[t], this.cell.notify("transition:end", {
            cell: this.cell,
            path: t
          })
        }), this
      }
    }
    var lk = this && this.__decorate || function(t, e, n, r) {
      var i, o = arguments.length,
        s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r);
      else
        for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) ||
          s);
      return o > 3 && s && Object.defineProperty(e, n, s), s
    };
    class ck extends Vx {
      constructor(t = {}) {
        super(), this.pending = !1, this.changing = !1, this.data = {}, this.mutate(o.cloneDeep(t)), this.changed = {}
      }
      mutate(t, e = {}) {
        const n = !0 === e.unset,
          r = !0 === e.silent,
          i = [],
          s = this.changing;
        this.changing = !0, s || (this.previous = o.cloneDeep(this.data), this.changed = {});
        const a = this.data,
          l = this.previous,
          c = this.changed;
        if (Object.keys(t).forEach(e => {
            const r = e,
              s = t[r];
            o.isEqual(a[r], s) || i.push(r), o.isEqual(l[r], s) ? delete c[r] : c[r] = s, n ? delete a[r] : a[
              r] = s
          }), !r && i.length > 0 && (this.pending = !0, this.pendingOptions = e, i.forEach(t => {
            this.emit("change:*", {
              key: t,
              options: e,
              store: this,
              current: a[t],
              previous: l[t]
            })
          })), s) return this;
        if (!r)
          for (; this.pending;) this.pending = !1, this.emit("changed", {
            current: a,
            previous: l,
            store: this,
            options: this.pendingOptions
          });
        return this.pending = !1, this.changing = !1, this.pendingOptions = null, this
      }
      get(t, e) {
        if (null == t) return this.data;
        const n = this.data[t];
        return null == n ? e : n
      }
      getPrevious(t) {
        if (this.previous) {
          const e = this.previous[t];
          return null == e ? void 0 : e
        }
      }
      set(t, e, n) {
        return null != t && ("object" == typeof t ? this.mutate(t, e) : this.mutate({
          [t]: e
        }, n)), this
      }
      remove(t, e) {
        const n = {};
        let r;
        if ("string" == typeof t) n[t] = void 0, r = e;
        else if (Array.isArray(t)) t.forEach(t => n[t] = void 0), r = e;
        else {
          for (const t in this.data) n[t] = void 0;
          r = t
        }
        return this.mutate(n, Object.assign(Object.assign({}, r), {
          unset: !0
        })), this
      }
      getByPath(t) {
        return o.getByPath(this.data, t, "/")
      }
      setByPath(t, e, n = {}) {
        const r = Array.isArray(t) ? t : t.split("/"),
          i = Array.isArray(t) ? t.join("/") : t,
          s = r[0],
          a = r.length;
        if (n.propertyPath = i, n.propertyValue = e, n.propertyPathArray = r, 1 === a) this.set(s, e, n);
        else {
          const i = {};
          let l = i,
            c = s;
          for (let t = 1; t < a; t += 1) {
            const e = r[t],
              n = Number.isFinite(Number(e));
            l = l[c] = n ? [] : {}, c = e
          }
          o.setByPath(i, r, e, "/");
          const h = o.cloneDeep(this.data);
          n.rewrite && o.unsetByPath(h, t, "/");
          const u = o.merge(h, i);
          this.set(s, u[s], n)
        }
        return this
      }
      removeByPath(t, e) {
        const n = Array.isArray(t) ? t : t.split("/"),
          r = n[0];
        if (1 === n.length) this.remove(r, e);
        else {
          const t = n.slice(1),
            i = o.cloneDeep(this.get(r));
          i && o.unsetByPath(i, t), this.set(r, i, e)
        }
        return this
      }
      hasChanged(t) {
        return null == t ? Object.keys(this.changed).length > 0 : t in this.changed
      }
      getChanges(t) {
        if (null == t) return this.hasChanged() ? o.cloneDeep(this.changed) : null;
        const e = this.changing ? this.previous : this.data,
          n = {};
        let r;
        for (const i in t) {
          const s = t[i];
          o.isEqual(e[i], s) || (n[i] = s, r = !0)
        }
        return r ? o.cloneDeep(n) : null
      }
      toJSON() {
        return o.cloneDeep(this.data)
      }
      clone() {
        return new(0, this.constructor)(this.data)
      }
      dispose() {
        this.off(), this.data = {}, this.previous = {}, this.changed = {}, this.pending = !1, this.changing = !
          1, this.pendingOptions = null, this.trigger("disposed", {
            store: this
          })
      }
    }
    lk([Vx.dispose()], ck.prototype, "dispose", null);
    var hk, uk, dk = this && this.__decorate || function(t, e, n, r) {
        var i, o = arguments.length,
          s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r);
        else
          for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) ||
            s);
        return o > 3 && s && Object.defineProperty(e, n, s), s
      },
      pk = this && this.__rest || function(t, e) {
        var n = {};
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
        if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
          var i = 0;
          for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
            .call(t, r[i]) && (n[r[i]] = t[r[i]])
        }
        return n
      };
    class fk extends Vx {
      constructor(t = {}) {
        super();
        const e = this.constructor.getDefaults(!0),
          n = o.merge({}, this.preprocess(e), this.preprocess(t));
        this.id = n.id || s.uuid(), this.store = new ck(n), this.animation = new ak(this), this.setup(), this.init(),
          this.postprocess(t)
      }
      static config(t) {
        const {
          markup: e,
          propHooks: n,
          attrHooks: r
        } = t, i = pk(t, ["markup", "propHooks", "attrHooks"]);
        null != e && (this.markup = e), n && (this.propHooks = this.propHooks.slice(), Array.isArray(n) ? this.propHooks
            .push(...n) : "function" == typeof n ? this.propHooks.push(n) : Object.keys(n).forEach(t => {
              const e = n[t];
              "function" == typeof e && this.propHooks.push(e)
            })), r && (this.attrHooks = Object.assign(Object.assign({}, this.attrHooks), r)), this.defaults = o
          .merge({}, this.defaults, i)
      }
      static getMarkup() {
        return this.markup
      }
      static getDefaults(t) {
        return t ? this.defaults : o.cloneDeep(this.defaults)
      }
      static getAttrHooks() {
        return this.attrHooks
      }
      static applyPropHooks(t, e) {
        return this.propHooks.reduce((e, n) => n ? l.call(n, t, e) : e, e)
      }
      init() {}
      get model() {
        return this._model
      }
      set model(t) {
        this._model !== t && (this._model = t)
      }
      preprocess(t, e) {
        const n = t.id,
          r = this.constructor.applyPropHooks(this, t);
        return null == n && !0 !== e && (r.id = s.uuid()), r
      }
      postprocess(t) {}
      setup() {
        this.store.on("change:*", t => {
          const {
            key: e,
            current: n,
            previous: r,
            options: i
          } = t;
          this.notify("change:*", {
            key: e,
            options: i,
            current: n,
            previous: r,
            cell: this
          }), this.notify(`change:${e}`, {
            options: i,
            current: n,
            previous: r,
            cell: this
          });
          const o = e;
          "source" !== o && "target" !== o || this.notify("change:terminal", {
            type: o,
            current: n,
            previous: r,
            options: i,
            cell: this
          })
        }), this.store.on("changed", ({
          options: t
        }) => this.notify("changed", {
          options: t,
          cell: this
        }))
      }
      notify(t, e) {
        this.trigger(t, e);
        const n = this.model;
        return n && (n.notify(`cell:${t}`, e), this.isNode() ? n.notify(`node:${t}`, Object.assign(Object.assign({},
          e), {
          node: this
        })) : this.isEdge() && n.notify(`edge:${t}`, Object.assign(Object.assign({}, e), {
          edge: this
        }))), this
      }
      isNode() {
        return !1
      }
      isEdge() {
        return !1
      }
      isSameStore(t) {
        return this.store === t.store
      }
      get view() {
        return this.store.get("view")
      }
      get shape() {
        return this.store.get("shape", "")
      }
      getProp(t, e) {
        return null == t ? this.store.get() : this.store.get(t, e)
      }
      setProp(t, e, n) {
        return "string" == typeof t ? this.store.set(t, e, n) : this.store.set(o.merge({}, this.getProp(), t),
          e), this
      }
      removeProp(t, e) {
        return "string" == typeof t || Array.isArray(t) ? this.store.removeByPath(t, e) : this.store.remove(e),
          this
      }
      hasChanged(t) {
        return null == t ? this.store.hasChanged() : this.store.hasChanged(t)
      }
      getPropByPath(t) {
        return this.store.getByPath(t)
      }
      setPropByPath(t, e, n = {}) {
        return this.store.setByPath(t, e, n), this
      }
      removePropByPath(t, e = {}) {
        const n = Array.isArray(t) ? t : t.split("/");
        return "attrs" === n[0] && (e.dirty = !0), this.store.removeByPath(n, e), this
      }
      prop(t, e, n) {
        return null == t ? this.getProp() : "string" == typeof t || Array.isArray(t) ? 1 === arguments.length ?
          (Array.isArray(t), this.getPropByPath(t)) : null == e ? Array.isArray(t) ? this.removePropByPath(t) :
          this.removeAttrByPath(t, n || {}) : (Array.isArray(t), this.setPropByPath(t, e, n || {})) : this.setProp(
            t, e || {})
      }
      previous(t) {
        return this.store.getPrevious(t)
      }
      get zIndex() {
        return this.getZIndex()
      }
      set zIndex(t) {
        null == t ? this.removeZIndex() : this.setZIndex(t)
      }
      getZIndex() {
        return this.store.get("zIndex")
      }
      setZIndex(t, e = {}) {
        return this.store.set("zIndex", t, e), this
      }
      removeZIndex(t = {}) {
        return this.store.remove("zIndex", t), this
      }
      toFront(t = {}) {
        const e = this.model;
        if (e) {
          let n, r = e.getMaxZIndex();
          t.deep ? (n = this.getDescendants({
            deep: !0,
            breadthFirst: !0
          })).unshift(this) : n = [this], r = r - n.length + 1;
          const i = e.total();
          let o = e.indexOf(this) !== i - n.length;
          o || (o = n.some((t, e) => t.getZIndex() !== r + e)), o && this.batchUpdate("to-front", () => {
            r += n.length, n.forEach((e, n) => {
              e.setZIndex(r + n, t)
            })
          })
        }
        return this
      }
      toBack(t = {}) {
        const e = this.model;
        if (e) {
          let n, r = e.getMinZIndex();
          t.deep ? (n = this.getDescendants({
            deep: !0,
            breadthFirst: !0
          })).unshift(this) : n = [this];
          let i = 0 !== e.indexOf(this);
          i || (i = n.some((t, e) => t.getZIndex() !== r + e)), i && this.batchUpdate("to-back", () => {
            r -= n.length, n.forEach((e, n) => {
              e.setZIndex(r + n, t)
            })
          })
        }
        return this
      }
      get markup() {
        return this.getMarkup()
      }
      set markup(t) {
        null == t ? this.removeMarkup() : this.setMarkup(t)
      }
      getMarkup() {
        let t = this.store.get("markup");
        if (null == t) {
          t = this.constructor.getMarkup()
        }
        return t
      }
      setMarkup(t, e = {}) {
        return this.store.set("markup", t, e), this
      }
      removeMarkup(t = {}) {
        return this.store.remove("markup", t), this
      }
      get attrs() {
        return this.getAttrs()
      }
      set attrs(t) {
        null == t ? this.removeAttrs() : this.setAttrs(t)
      }
      getAttrs() {
        const t = this.store.get("attrs");
        return t ? Object.assign({}, t) : {}
      }
      setAttrs(t, e = {}) {
        if (null == t) this.removeAttrs(e);
        else {
          const n = t => this.store.set("attrs", t, e);
          if (!0 === e.overwrite) n(t);
          else {
            const r = this.getAttrs();
            !1 === e.deep ? n(Object.assign(Object.assign({}, r), t)) : n(o.merge({}, r, t))
          }
        }
        return this
      }
      replaceAttrs(t, e = {}) {
        return this.setAttrs(t, Object.assign(Object.assign({}, e), {
          overwrite: !0
        }))
      }
      updateAttrs(t, e = {}) {
        return this.setAttrs(t, Object.assign(Object.assign({}, e), {
          deep: !1
        }))
      }
      removeAttrs(t = {}) {
        return this.store.remove("attrs", t), this
      }
      getAttrDefinition(t) {
        if (!t) return null;
        const e = this.constructor.getAttrHooks() || {};
        let n = e[t] || DA.registry.get(t);
        if (!n) {
          const r = s.camelCase(t);
          n = e[r] || DA.registry.get(r)
        }
        return n || null
      }
      getAttrByPath(t) {
        return null == t || "" === t ? this.getAttrs() : this.getPropByPath(this.prefixAttrPath(t))
      }
      setAttrByPath(t, e, n = {}) {
        return this.setPropByPath(this.prefixAttrPath(t), e, n), this
      }
      removeAttrByPath(t, e = {}) {
        return this.removePropByPath(this.prefixAttrPath(t), e), this
      }
      prefixAttrPath(t) {
        return Array.isArray(t) ? ["attrs"].concat(t) : `attrs/${t}`
      }
      attr(t, e, n) {
        return null == t ? this.getAttrByPath() : "string" == typeof t || Array.isArray(t) ? 1 === arguments.length ?
          this.getAttrByPath(t) : null == e ? this.removeAttrByPath(t, n || {}) : this.setAttrByPath(t, e, n ||
            {}) : this.setAttrs(t, e || {})
      }
      get visible() {
        return this.isVisible()
      }
      set visible(t) {
        this.setVisible(t)
      }
      setVisible(t, e = {}) {
        return this.store.set("visible", t, e), this
      }
      isVisible() {
        return !1 !== this.store.get("visible")
      }
      show(t = {}) {
        return this.isVisible() || this.setVisible(!0, t), this
      }
      hide(t = {}) {
        return this.isVisible() && this.setVisible(!1, t), this
      }
      toggleVisible(t = {}) {
        return this.isVisible() ? this.hide(t) : this.show(t), this
      }
      get data() {
        return this.getData()
      }
      set data(t) {
        this.setData(t)
      }
      getData() {
        return this.store.get("data")
      }
      setData(t, e = {}) {
        if (null == t) this.removeData(e);
        else {
          const n = t => this.store.set("data", t, e);
          if (!0 === e.overwrite) n(t);
          else {
            const r = this.getData();
            !1 === e.deep ? n("object" == typeof t ? Object.assign(Object.assign({}, r), t) : t) : n(o.merge({},
              r, t))
          }
        }
        return this
      }
      replaceData(t, e = {}) {
        return this.setData(t, Object.assign(Object.assign({}, e), {
          overwrite: !0
        }))
      }
      updateData(t, e = {}) {
        return this.setData(t, Object.assign(Object.assign({}, e), {
          deep: !1
        }))
      }
      removeData(t = {}) {
        return this.store.remove("data", t), this
      }
      get parent() {
        return this.getParent()
      }
      get children() {
        return this.getChildren()
      }
      getParent() {
        let t = this._parent;
        if (null == t && this.store) {
          const e = this.getParentId();
          null != e && this.model && (t = this.model.getCell(e), this._parent = t)
        }
        return t
      }
      getParentId() {
        return this.store.get("parent")
      }
      getChildren() {
        let t = this._children;
        if (null == t) {
          const e = this.store.get("children");
          e && e.length && this.model && (t = e.map(t => {
            var e;
            return null === (e = this.model) || void 0 === e ? void 0 : e.getCell(t)
          }).filter(t => null != t), this._children = t)
        }
        return t ? [...t] : null
      }
      hasParent() {
        return null != this.parent
      }
      isParentOf(t) {
        return null != t && t.getParent() === this
      }
      isChildOf(t) {
        return null != t && this.getParent() === t
      }
      eachChild(t, e) {
        return this.children && this.children.forEach(t, e), this
      }
      filterChild(t, e) {
        return this.children ? this.children.filter(t, e) : []
      }
      getChildCount() {
        return null == this.children ? 0 : this.children.length
      }
      getChildIndex(t) {
        return null == this.children ? -1 : this.children.indexOf(t)
      }
      getChildAt(t) {
        return null != this.children && t >= 0 ? this.children[t] : null
      }
      getAncestors(t = {}) {
        const e = [];
        let n = this.getParent();
        for (; n;) e.push(n), n = !1 !== t.deep ? n.getParent() : null;
        return e
      }
      getDescendants(t = {}) {
        if (!1 !== t.deep) {
          if (t.breadthFirst) {
            const t = [],
              e = this.getChildren() || [];
            for (; e.length > 0;) {
              const n = e.shift(),
                r = n.getChildren();
              t.push(n), r && e.push(...r)
            }
            return t
          } {
            const e = this.getChildren() || [];
            return e.forEach(n => {
              e.push(...n.getDescendants(t))
            }), e
          }
        }
        return this.getChildren() || []
      }
      isDescendantOf(t, e = {}) {
        if (null == t) return !1;
        if (!1 !== e.deep) {
          let e = this.getParent();
          for (; e;) {
            if (e === t) return !0;
            e = e.getParent()
          }
          return !1
        }
        return this.isChildOf(t)
      }
      isAncestorOf(t, e = {}) {
        return null != t && t.isDescendantOf(this, e)
      }
      contains(t) {
        return this.isAncestorOf(t)
      }
      getCommonAncestor(...t) {
        return fk.getCommonAncestor(this, ...t)
      }
      setParent(t, e = {}) {
        return this._parent = t, t ? this.store.set("parent", t.id, e) : this.store.remove("parent", e), this
      }
      setChildren(t, e = {}) {
        return this._children = t, null != t ? this.store.set("children", t.map(t => t.id), e) : this.store.remove(
          "children", e), this
      }
      unembed(t, e = {}) {
        const n = this.children;
        if (null != n && null != t) {
          const r = this.getChildIndex(t);
          n.splice(r, 1), t.setParent(null, e), this.setChildren(n, e)
        }
        return this
      }
      embed(t, e = {}) {
        return t.addTo(this, e), this
      }
      addTo(t, e = {}) {
        return t instanceof fk ? t.addChild(this, e) : t.addCell(this, e), this
      }
      insertTo(t, e, n = {}) {
        return t.insertChild(this, e, n), this
      }
      addChild(t, e = {}) {
        return this.insertChild(t, void 0, e)
      }
      insertChild(t, e, n = {}) {
        if (null != t && t !== this) {
          const r = t.getParent(),
            i = this !== r;
          let o = e;
          if (null == o && (o = this.getChildCount(), i || (o -= 1)), r) {
            const e = r.getChildren();
            if (e) {
              const i = e.indexOf(t);
              i >= 0 && (t.setParent(null, n), e.splice(i, 1), r.setChildren(e, n))
            }
          }
          let s = this.children;
          if (null == s ? (s = []).push(t) : s.splice(o, 0, t), t.setParent(this, n), this.setChildren(s, n), i &&
            this.model) {
            const t = this.model.getIncomingEdges(this),
              e = this.model.getOutgoingEdges(this);
            t && t.forEach(t => t.updateParent(n)), e && e.forEach(t => t.updateParent(n))
          }
          this.model && this.model.addCell(t, n)
        }
        return this
      }
      removeFromParent(t = {}) {
        const e = this.getParent();
        if (null != e) {
          const n = e.getChildIndex(this);
          e.removeChildAt(n, t)
        }
        return this
      }
      removeChild(t, e = {}) {
        const n = this.getChildIndex(t);
        return this.removeChildAt(n, e)
      }
      removeChildAt(t, e = {}) {
        const n = this.getChildAt(t);
        return null != this.children && null != n && (this.unembed(n, e), n.remove(e)), n
      }
      remove(t = {}) {
        const e = this.getParent();
        return e ? e.removeChild(this, t) : this.batchUpdate("remove", () => {
          !1 !== t.deep && this.eachChild(e => e.remove(t)), this.model && this.model.removeCell(this, t)
        }), this
      }
      transition(t, e, n = {}, r = "/") {
        return this.animation.start(t, e, n, r)
      }
      stopTransition(t, e = "/") {
        return this.animation.stop(t, e), this
      }
      getTransitions() {
        return this.animation.get()
      }
      translate(t, e, n) {
        return this
      }
      scale(t, e, n, r) {
        return this
      }
      addTools(t, e, n = {}) {
        const r = Array.isArray(t) ? t : [t];
        if (n.reset) this.setTools({
          name: e,
          items: r
        }, n);
        else {
          let t = this.getTools();
          if (null == t || null == e || t.name === e) return null == t && (t = {}), t.items || (t.items = []),
            t.name = e, t.items = [...t.items, ...r], this.setTools(Object.assign({}, t), n)
        }
      }
      setTools(t, e = {}) {
        return null == t ? this.removeTools() : this.store.set("tools", fk.normalizeTools(t), e), this
      }
      getTools() {
        return this.store.get("tools")
      }
      removeTools(t = {}) {
        return this.store.remove("tools", t), this
      }
      hasTools(t) {
        const e = this.getTools();
        return null != e && (null == t || e.name === t)
      }
      getBBox(t) {
        return new uC
      }
      getConnectionPoint(t, e) {
        return new hC
      }
      toJSON(t = {}) {
        const e = Object.assign({}, this.store.get()),
          n = Object.prototype.toString,
          r = this.isNode() ? "node" : this.isEdge() ? "edge" : "cell";
        if (!e.shape) {
          const t = this.constructor;
          throw new Error(
            `Unable to serialize ${r} missing "shape" prop, check the ${r} "${t.name||n.call(t)}"`)
        }
        const i = this.constructor,
          s = !0 === t.diff,
          a = e.attrs || {},
          l = i.getDefaults(!0),
          c = s ? this.preprocess(l, !0) : l,
          h = c.attrs || {},
          u = {};
        Object.keys(e).forEach(t => {
          const i = e[t];
          if (!Array.isArray(i) && "object" == typeof i && !o.isPlainObject(i)) throw new Error(
            `Can only serialize ${r} with plain-object props, but got a "${n.call(i)}" type of key "${t}" on ${r} "${this.id}"`
          );
          if ("attrs" !== t && "shape" !== t && s) {
            const n = c[t];
            o.isEqual(i, n) && delete e[t]
          }
        }), Object.keys(a).forEach(t => {
          const e = a[t],
            n = h[t];
          Object.keys(e).forEach(r => {
            const i = e[r],
              s = n ? n[r] : null;
            null == i || "object" != typeof i || Array.isArray(i) ? null != n && o.isEqual(s, i) || (
              null == u[t] && (u[t] = {}), u[t][r] = i) : Object.keys(i).forEach(e => {
              const a = i[e];
              if (null == n || null == s || !o.isObject(s) || !o.isEqual(s[e], a)) {
                null == u[t] && (u[t] = {}), null == u[t][r] && (u[t][r] = {}), u[t][r][e] = a
              }
            })
          })
        });
        const d = Object.assign(Object.assign({}, e), {
          attrs: o.isEmpty(u) ? void 0 : u
        });
        null == d.attrs && delete d.attrs;
        const p = d;
        return 0 === p.angle && delete p.angle, o.cloneDeep(p)
      }
      clone(t = {}) {
        if (!t.deep) {
          const t = Object.assign({}, this.store.get());
          return delete t.id, delete t.parent, delete t.children, new(0, this.constructor)(t)
        }
        return fk.deepClone(this)[this.id]
      }
      findView(t) {
        return t.renderer.findViewByCell(this)
      }
      startBatch(t, e = {}, n = this.model) {
        return n && n.startBatch(t, Object.assign(Object.assign({}, e), {
          cell: this
        })), this
      }
      stopBatch(t, e = {}, n = this.model) {
        return n && n.stopBatch(t, Object.assign(Object.assign({}, e), {
          cell: this
        })), this
      }
      batchUpdate(t, e, n) {
        const r = this.model;
        this.startBatch(t, n, r);
        const i = e();
        return this.stopBatch(t, n, r), i
      }
      dispose() {
        this.removeFromParent(), this.store.dispose()
      }
    }
    fk.defaults = {}, fk.attrHooks = {}, fk.propHooks = [], dk([Vx.dispose()], fk.prototype, "dispose", null),
      function(t) {
        (fk || (fk = {})).normalizeTools = function(t) {
          return "string" == typeof t ? {
            items: [t]
          } : Array.isArray(t) ? {
            items: t
          } : t.items ? t : {
            items: [t]
          }
        }
      }(),
      function(t) {
        t.getCommonAncestor = function(...t) {
          const e = t.filter(t => null != t).map(t => t.getAncestors()).sort((t, e) => t.length - e.length);
          return e.shift().find(t => e.every(e => e.includes(t))) || null
        }, t.getCellsBBox = function(t, e = {}) {
          let n = null;
          for (let r = 0, i = t.length; r < i; r += 1) {
            const i = t[r];
            let o = i.getBBox(e);
            if (o) {
              if (i.isNode()) {
                const t = i.getAngle();
                null != t && 0 !== t && (o = o.bbox(t))
              }
              n = null == n ? o : n.union(o)
            }
          }
          return n
        }, t.deepClone = function(e) {
          const n = [e, ...e.getDescendants({
            deep: !0
          })];
          return t.cloneCells(n)
        }, t.cloneCells = function(t) {
          const e = i.uniq(t),
            n = e.reduce((t, e) => (t[e.id] = e.clone(), t), {});
          return e.forEach(t => {
            const e = n[t.id];
            if (e.isEdge()) {
              const t = e.getSourceCellId(),
                r = e.getTargetCellId();
              t && n[t] && e.setSource(Object.assign(Object.assign({}, e.getSource()), {
                cell: n[t].id
              })), r && n[r] && e.setTarget(Object.assign(Object.assign({}, e.getTarget()), {
                cell: n[r].id
              }))
            }
            const r = t.getParent();
            r && n[r.id] && e.setParent(n[r.id]);
            const i = t.getChildren();
            if (i && i.length) {
              const t = i.reduce((t, e) => (n[e.id] && t.push(n[e.id]), t), []);
              t.length > 0 && e.setChildren(t)
            }
          }), n
        }
      }(fk || (fk = {})), (hk = fk || (fk = {})).config({
        propHooks(t) {
          var {
            tools: e
          } = t, n = pk(t, ["tools"]);
          return e && (n.tools = hk.normalizeTools(e)), n
        }
      }),
      function(t) {
        let e, n;
        t.exist = function(t, r) {
          return r ? null != e && e.exist(t) : null != n && n.exist(t)
        }, t.setEdgeRegistry = function(t) {
          e = t
        }, t.setNodeRegistry = function(t) {
          n = t
        }
      }(uk || (uk = {}));
    class gk {
      constructor(t) {
        this.ports = [], this.groups = {}, this.init(o.cloneDeep(t))
      }
      getPorts() {
        return this.ports
      }
      getGroup(t) {
        return null != t ? this.groups[t] : null
      }
      getPortsByGroup(t) {
        return this.ports.filter(e => e.group === t || null == e.group && null == t)
      }
      getPortsLayoutByGroup(t, e) {
        const n = this.getPortsByGroup(t),
          r = t ? this.getGroup(t) : null,
          i = r ? r.position : null,
          o = i ? i.name : null;
        let s;
        if (null != o) {
          const t = PE.registry.get(o);
          if (null == t) return PE.registry.onNotFound(o);
          s = t
        } else s = PE.presets.left;
        const a = n.map(t => t && t.position && t.position.args || {}),
          l = i && i.args || {};
        return s(a, e, l).map((t, r) => {
          const i = n[r];
          return {
            portLayout: t,
            portId: i.id,
            portSize: i.size,
            portAttrs: i.attrs,
            labelSize: i.label.size,
            labelLayout: this.getPortLabelLayout(i, hC.create(t.position), e)
          }
        })
      }
      init(t) {
        const {
          groups: e,
          items: n
        } = t;
        null != e && Object.keys(e).forEach(t => {
          this.groups[t] = this.parseGroup(e[t])
        }), Array.isArray(n) && n.forEach(t => {
          this.ports.push(this.parsePort(t))
        })
      }
      parseGroup(t) {
        return Object.assign(Object.assign({}, t), {
          label: this.getLabel(t, !0),
          position: this.getPortPosition(t.position, !0)
        })
      }
      parsePort(t) {
        const e = Object.assign({}, t),
          n = this.getGroup(t.group) || {};
        return e.markup = e.markup || n.markup, e.attrs = o.merge({}, n.attrs, e.attrs), e.position = this.createPosition(
            n, e), e.label = o.merge({}, n.label, this.getLabel(e)), e.zIndex = this.getZIndex(n, e), e.size =
          Object.assign({}, n.size, e.size), e
      }
      getZIndex(t, e) {
        return "number" == typeof e.zIndex ? e.zIndex : "number" == typeof t.zIndex || "auto" === t.zIndex ? t.zIndex :
          "auto"
      }
      createPosition(t, e) {
        return o.merge({
          name: "left",
          args: {}
        }, t.position, {
          args: e.args
        })
      }
      getPortPosition(t, e = !1) {
        if (null == t) {
          if (e) return {
            name: "left",
            args: {}
          }
        } else {
          if ("string" == typeof t) return {
            name: t,
            args: {}
          };
          if (Array.isArray(t)) return {
            name: "absolute",
            args: {
              x: t[0],
              y: t[1]
            }
          };
          if ("object" == typeof t) return t
        }
        return {
          args: {}
        }
      }
      getPortLabelPosition(t, e = !1) {
        if (null == t) {
          if (e) return {
            name: "left",
            args: {}
          }
        } else {
          if ("string" == typeof t) return {
            name: t,
            args: {}
          };
          if ("object" == typeof t) return t
        }
        return {
          args: {}
        }
      }
      getLabel(t, e = !1) {
        const n = t.label || {};
        return n.position = this.getPortLabelPosition(n.position, e), n
      }
      getPortLabelLayout(t, e, n) {
        const r = t.label.position.name || "left",
          i = t.label.position.args || {},
          o = XE.registry.get(r) || XE.presets.left;
        return o ? o(e, n, i) : null
      }
    }
    var mk, vk = this && this.__rest || function(t, e) {
      var n = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
          .call(t, r[i]) && (n[r[i]] = t[r[i]])
      }
      return n
    };
    class yk extends fk {
      constructor(t = {}) {
        super(t), this.initPorts()
      }
      preprocess(t, e) {
        const {
          x: n,
          y: r,
          width: i,
          height: o
        } = t, s = vk(t, ["x", "y", "width", "height"]);
        if (null != n || null != r) {
          const t = s.position;
          s.position = Object.assign(Object.assign({}, t), {
            x: null != n ? n : t ? t.x : 0,
            y: null != r ? r : t ? t.y : 0
          })
        }
        if (null != i || null != o) {
          const t = s.size;
          s.size = Object.assign(Object.assign({}, t), {
            width: null != i ? i : t ? t.width : 0,
            height: null != o ? o : t ? t.height : 0
          })
        }
        return super.preprocess(s, e)
      }
      isNode() {
        return !0
      }
      size(t, e, n) {
        return void 0 === t ? this.getSize() : "number" == typeof t ? this.setSize(t, e, n) : this.setSize(t, e)
      }
      getSize() {
        const t = this.store.get("size");
        return t ? Object.assign({}, t) : {
          width: 1,
          height: 1
        }
      }
      setSize(t, e, n) {
        return "object" == typeof t ? this.resize(t.width, t.height, e) : this.resize(t, e, n), this
      }
      resize(t, e, n = {}) {
        this.startBatch("resize", n);
        const r = n.direction;
        if (r) {
          const i = this.getSize();
          switch (r) {
            case "left":
            case "right":
              e = i.height;
              break;
            case "top":
            case "bottom":
              t = i.width
          }
          let o = {
            right: 0,
            "top-right": 0,
            top: 1,
            "top-left": 1,
            left: 2,
            "bottom-left": 2,
            bottom: 3,
            "bottom-right": 3
          } [r];
          const s = nC.normalize(this.getAngle() || 0);
          n.absolute && (o += Math.floor((s + 45) / 90), o %= 4);
          const a = this.getBBox();
          let l;
          const c = (l = 0 === o ? a.getBottomLeft() : 1 === o ? a.getCorner() : 2 === o ? a.getTopRight() : a.getOrigin())
            .clone().rotate(-s, a.getCenter()),
            h = Math.sqrt(t * t + e * e) / 2;
          let u = o * Math.PI / 2;
          u += Math.atan(o % 2 == 0 ? e / t : t / e), u -= nC.toRad(s);
          const d = hC.fromPolar(h, u, c).clone().translate(t / -2, e / -2);
          this.store.set("size", {
            width: t,
            height: e
          }, n), this.setPosition(d.x, d.y, n)
        } else this.store.set("size", {
          width: t,
          height: e
        }, n);
        return this.stopBatch("resize", n), this
      }
      scale(t, e, n, r = {}) {
        const i = this.getBBox().scale(t, e, null == n ? void 0 : n);
        return this.startBatch("scale", r), this.setPosition(i.x, i.y, r), this.resize(i.width, i.height, r),
          this.stopBatch("scale"), this
      }
      position(t, e, n) {
        return "number" == typeof t ? this.setPosition(t, e, n) : this.getPosition(t)
      }
      getPosition(t = {}) {
        if (t.relative) {
          const t = this.getParent();
          if (null != t && t.isNode()) {
            const e = this.getPosition(),
              n = t.getPosition();
            return {
              x: e.x - n.x,
              y: e.y - n.y
            }
          }
        }
        const e = this.store.get("position");
        return e ? Object.assign({}, e) : {
          x: 0,
          y: 0
        }
      }
      setPosition(t, e, n = {}) {
        let r, i, o;
        if ("object" == typeof t ? (r = t.x, i = t.y, o = e || {}) : (r = t, i = e, o = n || {}), o.relative) {
          const t = this.getParent();
          if (null != t && t.isNode()) {
            const e = t.getPosition();
            r += e.x, i += e.y
          }
        }
        if (o.deep) {
          const t = this.getPosition();
          this.translate(r - t.x, i - t.y, o)
        } else this.store.set("position", {
          x: r,
          y: i
        }, o);
        return this
      }
      translate(t = 0, e = 0, n = {}) {
        if (0 === t && 0 === e) return this;
        n.translateBy = n.translateBy || this.id;
        const r = this.getPosition();
        if (null != n.restrict && n.translateBy === this.id) {
          const i = this.getBBox({
              deep: !0
            }),
            o = n.restrict,
            s = r.x - i.x,
            a = r.y - i.y,
            l = Math.max(o.x + s, Math.min(o.x + o.width + s - i.width, r.x + t)),
            c = Math.max(o.y + a, Math.min(o.y + o.height + a - i.height, r.y + e));
          t = l - r.x, e = c - r.y
        }
        const i = {
          x: r.x + t,
          y: r.y + e
        };
        return n.tx = t, n.ty = e, n.transition ? ("object" != typeof n.transition && (n.transition = {}), this
          .transition("position", i, Object.assign(Object.assign({}, n.transition), {
            interp: qx.object
          })), this.eachChild(r => r.translate(t, e, n))) : (this.startBatch("translate", n), this.store.set(
          "position", i, n), this.eachChild(r => r.translate(t, e, n)), this.stopBatch("translate", n)), this
      }
      angle(t, e) {
        return null == t ? this.getAngle() : this.rotate(t)
      }
      getAngle() {
        return this.store.get("angle", 0)
      }
      rotate(t, e = {}) {
        const n = this.getAngle();
        if (e.center) {
          const r = this.getSize(),
            i = this.getPosition(),
            o = this.getBBox().getCenter();
          o.rotate(n - t, e.center);
          const s = o.x - r.width / 2 - i.x,
            a = o.y - r.height / 2 - i.y;
          this.startBatch("rotate", {
            angle: t,
            options: e
          }), this.setPosition(i.x + s, i.y + a, e), this.rotate(t, Object.assign(Object.assign({}, e), {
            center: null
          })), this.stopBatch("rotate")
        } else this.store.set("angle", e.absolute ? t : (n + t) % 360, e);
        return this
      }
      getBBox(t = {}) {
        if (t.deep) {
          const t = this.getDescendants({
            deep: !0,
            breadthFirst: !0
          });
          return t.push(this), fk.getCellsBBox(t)
        }
        return uC.fromPositionAndSize(this.getPosition(), this.getSize())
      }
      getConnectionPoint(t, e) {
        const n = this.getBBox(),
          r = n.getCenter(),
          i = t.getTerminal(e);
        if (null == i) return r;
        const o = i.port;
        if (!o || !this.hasPort(o)) return r;
        const s = this.getPort(o);
        if (!s || !s.group) return r;
        const a = this.getPortsPosition(s.group)[o].position,
          l = hC.create(a).translate(n.getOrigin()),
          c = this.getAngle();
        return c && l.rotate(-c, r), l
      }
      fit(t = {}) {
        const e = (this.getChildren() || []).filter(t => t.isNode());
        if (0 === e.length) return this;
        this.startBatch("fit-embeds", t), t.deep && e.forEach(e => e.fit(t));
        let {
          x: n,
          y: r,
          width: i,
          height: o
        } = fk.getCellsBBox(e);
        const s = a.normalizeSides(t.padding);
        return n -= s.left, r -= s.top, i += s.left + s.right, o += s.bottom + s.top, this.store.set({
          position: {
            x: n,
            y: r
          },
          size: {
            width: i,
            height: o
          }
        }, t), this.stopBatch("fit-embeds"), this
      }
      get portContainerMarkup() {
        return this.getPortContainerMarkup()
      }
      set portContainerMarkup(t) {
        this.setPortContainerMarkup(t)
      }
      getDefaultPortContainerMarkup() {
        return this.store.get("defaultPortContainerMarkup") || oS.getPortContainerMarkup()
      }
      getPortContainerMarkup() {
        return this.store.get("portContainerMarkup") || this.getDefaultPortContainerMarkup()
      }
      setPortContainerMarkup(t, e = {}) {
        return this.store.set("portContainerMarkup", oS.clone(t), e), this
      }
      get portMarkup() {
        return this.getPortMarkup()
      }
      set portMarkup(t) {
        this.setPortMarkup(t)
      }
      getDefaultPortMarkup() {
        return this.store.get("defaultPortMarkup") || oS.getPortMarkup()
      }
      getPortMarkup() {
        return this.store.get("portMarkup") || this.getDefaultPortMarkup()
      }
      setPortMarkup(t, e = {}) {
        return this.store.set("portMarkup", oS.clone(t), e), this
      }
      get portLabelMarkup() {
        return this.getPortLabelMarkup()
      }
      set portLabelMarkup(t) {
        this.setPortLabelMarkup(t)
      }
      getDefaultPortLabelMarkup() {
        return this.store.get("defaultPortLabelMarkup") || oS.getPortLabelMarkup()
      }
      getPortLabelMarkup() {
        return this.store.get("portLabelMarkup") || this.getDefaultPortLabelMarkup()
      }
      setPortLabelMarkup(t, e = {}) {
        return this.store.set("portLabelMarkup", oS.clone(t), e), this
      }
      get ports() {
        const t = this.store.get("ports", {
          items: []
        });
        return null == t.items && (t.items = []), t
      }
      getPorts() {
        return o.cloneDeep(this.ports.items)
      }
      getPortsByGroup(t) {
        return this.getPorts().filter(e => e.group === t)
      }
      getPort(t) {
        return o.cloneDeep(this.ports.items.find(e => e.id && e.id === t))
      }
      getPortAt(t) {
        return this.ports.items[t] || null
      }
      hasPorts() {
        return this.ports.items.length > 0
      }
      hasPort(t) {
        return -1 !== this.getPortIndex(t)
      }
      getPortIndex(t) {
        const e = "string" == typeof t ? t : t.id;
        return null != e ? this.ports.items.findIndex(t => t.id === e) : -1
      }
      getPortsPosition(t) {
        const e = this.getSize();
        return this.port.getPortsLayoutByGroup(t, new uC(0, 0, e.width, e.height)).reduce((t, e) => {
          const n = e.portLayout;
          return t[e.portId] = {
            position: Object.assign({}, n.position),
            angle: n.angle || 0
          }, t
        }, {})
      }
      getPortProp(t, e) {
        return this.getPropByPath(this.prefixPortPath(t, e))
      }
      setPortProp(t, e, n, r) {
        if ("string" == typeof e || Array.isArray(e)) {
          const i = this.prefixPortPath(t, e),
            o = n;
          return this.setPropByPath(i, o, r)
        }
        const i = this.prefixPortPath(t),
          o = e;
        return this.setPropByPath(i, o, n)
      }
      removePortProp(t, e, n) {
        return "string" == typeof e || Array.isArray(e) ? this.removePropByPath(this.prefixPortPath(t, e), n) :
          this.removePropByPath(this.prefixPortPath(t), e)
      }
      portProp(t, e, n, r) {
        return null == e ? this.getPortProp(t) : "string" == typeof e || Array.isArray(e) ? 2 === arguments.length ?
          this.getPortProp(t, e) : null == n ? this.removePortProp(t, e, r) : this.setPortProp(t, e, n, r) :
          this.setPortProp(t, e, n)
      }
      prefixPortPath(t, e) {
        const n = this.getPortIndex(t);
        if (-1 === n) throw new Error(`Unable to find port with id: "${t}"`);
        return null == e || "" === e ? ["ports", "items", `${n}`] : Array.isArray(e) ? ["ports", "items",
          `${n}`, ...e
        ] : `ports/items/${n}/${e}`
      }
      addPort(t, e) {
        const n = [...this.ports.items];
        return n.push(t), this.setPropByPath("ports/items", n, e), this
      }
      addPorts(t, e) {
        return this.setPropByPath("ports/items", [...this.ports.items, ...t], e), this
      }
      removePort(t, e = {}) {
        return this.removePortAt(this.getPortIndex(t), e)
      }
      removePortAt(t, e = {}) {
        if (t >= 0) {
          const n = [...this.ports.items];
          n.splice(t, 1), e.rewrite = !0, this.setPropByPath("ports/items", n, e)
        }
        return this
      }
      removePorts(t, e) {
        let n;
        if (Array.isArray(t)) {
          if (n = e || {}, t.length) {
            n.rewrite = !0;
            const e = [...this.ports.items].filter(e => !t.some(t => {
              const n = "string" == typeof t ? t : t.id;
              return e.id === n
            }));
            this.setPropByPath("ports/items", e, n)
          }
        } else(n = t || {}).rewrite = !0, this.setPropByPath("ports/items", [], n);
        return this
      }
      getParsedPorts() {
        return this.port.getPorts()
      }
      getParsedGroups() {
        return this.port.groups
      }
      getPortsLayoutByGroup(t, e) {
        return this.port.getPortsLayoutByGroup(t, e)
      }
      initPorts() {
        this.updatePortData(), this.on("change:ports", () => {
          this.processRemovedPort(), this.updatePortData()
        })
      }
      processRemovedPort() {
        const t = {};
        this.ports.items.forEach(e => {
          e.id && (t[e.id] = !0)
        });
        const e = {};
        (this.store.getPrevious("ports") || {
          items: []
        }).items.forEach(n => {
          n.id && !t[n.id] && (e[n.id] = !0)
        });
        const n = this.model;
        if (n && !o.isEmpty(e)) {
          n.getConnectedEdges(this, {
            incoming: !0
          }).forEach(t => {
            const n = t.getTargetPortId();
            n && e[n] && t.remove()
          }), n.getConnectedEdges(this, {
            outgoing: !0
          }).forEach(t => {
            const n = t.getSourcePortId();
            n && e[n] && t.remove()
          })
        }
      }
      validatePorts() {
        const t = {},
          e = [];
        return this.ports.items.forEach(n => {
          "object" != typeof n && e.push(`Invalid port ${n}.`), null == n.id && (n.id = this.generatePortId()),
            t[n.id] && e.push("Duplicitied port id."), t[n.id] = !0
        }), e
      }
      generatePortId() {
        return s.uuid()
      }
      updatePortData() {
        const t = this.validatePorts();
        if (t.length > 0) throw this.store.set("ports", this.store.getPrevious("ports")), new Error(t.join(" "));
        const e = this.port ? this.port.getPorts() : null;
        this.port = new gk(this.ports);
        const n = this.port.getPorts(),
          r = e ? n.filter(t => {
            if (!e.find(e => e.id === t.id)) return t
          }) : [...n],
          i = e ? e.filter(t => {
            if (!n.find(e => e.id === t.id)) return t
          }) : [];
        r.length > 0 && this.notify("ports:added", {
          added: r,
          cell: this,
          node: this
        }), i.length > 0 && this.notify("ports:removed", {
          removed: i,
          cell: this,
          node: this
        })
      }
    }
    yk.defaults = {
        angle: 0,
        position: {
          x: 0,
          y: 0
        },
        size: {
          width: 1,
          height: 1
        }
      }, (mk = yk || (yk = {})).registry = Kx.create({
        type: "node",
        process(t, e) {
          if (uk.exist(t, !0)) throw new Error(`Node with name '${t}' was registered by anthor Edge`);
          if ("function" == typeof e) return e.config({
            shape: t
          }), e;
          let n = mk;
          const {
            inherit: r
          } = e, i = vk(e, ["inherit"]);
          if (r)
            if ("string" == typeof r) {
              const t = this.get(r);
              null == t ? this.onNotFound(r, "inherited") : n = t
            } else n = r;
          null == i.constructorName && (i.constructorName = t);
          const o = n.define.call(n, i);
          return o.config({
            shape: t
          }), o
        }
      }), uk.setNodeRegistry(mk.registry), (yk || (yk = {})).config({
        propHooks(t) {
          var {
            ports: e
          } = t, n = vk(t, ["ports"]);
          return e && (n.ports = Array.isArray(e) ? {
            items: e
          } : e), n
        }
      }),
      function(t) {
        let e = 0;
        t.define = function(n) {
          const {
            constructorName: r
          } = n, i = vk(n, ["constructorName"]), a = o.createClass((l = r || i.shape) ? s.pascalCase(l) :
            `CustomNode${e+=1}`, this);
          var l;
          return a.config(i), i.shape && t.registry.register(i.shape, a), a
        }, t.create = function(e) {
          const n = e.shape || "rect",
            r = t.registry.get(n);
          return r ? new r(e) : t.registry.onNotFound(n)
        }
      }(yk || (yk = {}));
    var bk, Ck = this && this.__rest || function(t, e) {
      var n = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
          .call(t, r[i]) && (n[r[i]] = t[r[i]])
      }
      return n
    };
    class xk extends fk {
      constructor(t = {}) {
        super(t)
      }
      preprocess(t, e) {
        const {
          source: n,
          sourceCell: r,
          sourcePort: i,
          sourcePoint: o,
          target: s,
          targetCell: a,
          targetPort: l,
          targetPoint: c
        } = t, h = Ck(t, ["source", "sourceCell", "sourcePort", "sourcePoint", "target", "targetCell",
          "targetPort", "targetPoint"
        ]), u = t => "string" == typeof t || "number" == typeof t;
        if (null != n)
          if (n instanceof fk) h.source = {
            cell: n.id
          };
          else if (u(n)) h.source = {
          cell: n
        };
        else if (n instanceof hC) h.source = n.toJSON();
        else if (Array.isArray(n)) h.source = {
          x: n[0],
          y: n[1]
        };
        else {
          const t = n.cell;
          h.source = t instanceof fk ? Object.assign(Object.assign({}, n), {
            cell: t.id
          }) : n
        }
        if (null != r || null != i) {
          let t = h.source;
          if (null != r) {
            const e = u(r) ? r : r.id;
            t ? t.cell = e : t = h.source = {
              cell: e
            }
          }
          null != i && t && (t.port = i)
        } else null != o && (h.source = hC.create(o).toJSON());
        if (null != s)
          if (s instanceof fk) h.target = {
            cell: s.id
          };
          else if (u(s)) h.target = {
          cell: s
        };
        else if (s instanceof hC) h.target = s.toJSON();
        else if (Array.isArray(s)) h.target = {
          x: s[0],
          y: s[1]
        };
        else {
          const t = s.cell;
          h.target = t instanceof fk ? Object.assign(Object.assign({}, s), {
            cell: t.id
          }) : s
        }
        if (null != a || null != l) {
          let t = h.target;
          if (null != a) {
            const e = u(a) ? a : a.id;
            t ? t.cell = e : t = h.target = {
              cell: e
            }
          }
          null != l && t && (t.port = l)
        } else null != c && (h.target = hC.create(c).toJSON());
        return super.preprocess(h, e)
      }
      setup() {
        super.setup(), this.on("change:labels", t => this.onLabelsChanged(t)), this.on("change:vertices", t =>
          this.onVertexsChanged(t))
      }
      isEdge() {
        return !0
      }
      disconnect(t = {}) {
        return this.store.set({
          source: {
            x: 0,
            y: 0
          },
          target: {
            x: 0,
            y: 0
          }
        }, t), this
      }
      get source() {
        return this.getSource()
      }
      set source(t) {
        this.setSource(t)
      }
      getSource() {
        return this.getTerminal("source")
      }
      getSourceCellId() {
        return this.source.cell
      }
      getSourcePortId() {
        return this.source.port
      }
      setSource(t, e, n = {}) {
        return this.setTerminal("source", t, e, n)
      }
      get target() {
        return this.getTarget()
      }
      set target(t) {
        this.setTarget(t)
      }
      getTarget() {
        return this.getTerminal("target")
      }
      getTargetCellId() {
        return this.target.cell
      }
      getTargetPortId() {
        return this.target.port
      }
      setTarget(t, e, n = {}) {
        return this.setTerminal("target", t, e, n)
      }
      getTerminal(t) {
        return Object.assign({}, this.store.get(t))
      }
      setTerminal(t, e, n, r = {}) {
        if (e instanceof fk) return this.store.set(t, o.merge({}, n, {
          cell: e.id
        }), r), this;
        const i = e;
        return e instanceof hC || null != i.x && null != i.y ? (this.store.set(t, o.merge({}, n, {
          x: i.x,
          y: i.y
        }), r), this) : (this.store.set(t, o.cloneDeep(e), r), this)
      }
      getSourcePoint() {
        return this.getTerminalPoint("source")
      }
      getTargetPoint() {
        return this.getTerminalPoint("target")
      }
      getTerminalPoint(t) {
        const e = this[t];
        if (hC.isPointLike(e)) return hC.create(e);
        const n = this.getTerminalCell(t);
        return n ? n.getConnectionPoint(this, t) : new hC
      }
      getSourceCell() {
        return this.getTerminalCell("source")
      }
      getTargetCell() {
        return this.getTerminalCell("target")
      }
      getTerminalCell(t) {
        if (this.model) {
          const e = "source" === t ? this.getSourceCellId() : this.getTargetCellId();
          if (e) return this.model.getCell(e)
        }
        return null
      }
      getSourceNode() {
        return this.getTerminalNode("source")
      }
      getTargetNode() {
        return this.getTerminalNode("target")
      }
      getTerminalNode(t) {
        let e = this;
        const n = {};
        for (; e && e.isEdge();) {
          if (n[e.id]) return null;
          n[e.id] = !0, e = e.getTerminalCell(t)
        }
        return e && e.isNode() ? e : null
      }
      get router() {
        return this.getRouter()
      }
      set router(t) {
        null == t ? this.removeRouter() : this.setRouter(t)
      }
      getRouter() {
        return this.store.get("router")
      }
      setRouter(t, e, n) {
        return "object" == typeof t ? this.store.set("router", t, e) : this.store.set("router", {
          name: t,
          args: e
        }, n), this
      }
      removeRouter(t = {}) {
        return this.store.remove("router", t), this
      }
      get connector() {
        return this.getConnector()
      }
      set connector(t) {
        null == t ? this.removeConnector() : this.setConnector(t)
      }
      getConnector() {
        return this.store.get("connector")
      }
      setConnector(t, e, n) {
        return "object" == typeof t ? this.store.set("connector", t, e) : this.store.set("connector", {
          name: t,
          args: e
        }, n), this
      }
      removeConnector(t = {}) {
        return this.store.remove("connector", t)
      }
      get strategy() {
        return this.getStrategy()
      }
      set strategy(t) {
        null == t ? this.removeStrategy() : this.setStrategy(t)
      }
      getStrategy() {
        return this.store.get("strategy")
      }
      setStrategy(t, e, n) {
        return "object" == typeof t ? this.store.set("strategy", t, e) : this.store.set("strategy", {
          name: t,
          args: e
        }, n), this
      }
      removeStrategy(t = {}) {
        return this.store.remove("strategy", t)
      }
      getDefaultLabel() {
        const t = this.constructor,
          e = this.store.get("defaultLabel") || t.defaultLabel || {};
        return o.cloneDeep(e)
      }
      get labels() {
        return this.getLabels()
      }
      set labels(t) {
        this.setLabels(t)
      }
      getLabels() {
        return [...this.store.get("labels", [])].map(t => this.parseLabel(t))
      }
      setLabels(t, e = {}) {
        return this.store.set("labels", Array.isArray(t) ? t : [t], e), this
      }
      insertLabel(t, e, n = {}) {
        const r = this.getLabels(),
          i = r.length;
        let o = null != e && isFinite(e) ? e : i;
        return o < 0 && (o = i + o + 1), r.splice(o, 0, this.parseLabel(t)), this.setLabels(r, n)
      }
      appendLabel(t, e = {}) {
        return this.insertLabel(t, -1, e)
      }
      getLabelAt(t) {
        const e = this.getLabels();
        return null != t && isFinite(t) ? this.parseLabel(e[t]) : null
      }
      setLabelAt(t, e, n = {}) {
        if (null != t && isFinite(t)) {
          const r = this.getLabels();
          r[t] = this.parseLabel(e), this.setLabels(r, n)
        }
        return this
      }
      removeLabelAt(t, e = {}) {
        const n = this.getLabels(),
          r = null != t && isFinite(t) ? t : -1,
          i = n.splice(r, 1);
        return this.setLabels(n, e), i.length ? i[0] : null
      }
      parseLabel(t) {
        if ("string" == typeof t) {
          return this.constructor.parseStringLabel(t)
        }
        return t
      }
      onLabelsChanged({
        previous: t,
        current: e
      }) {
        const n = t && e ? e.filter(e => {
            if (!t.find(t => e === t || o.isEqual(e, t))) return e
          }) : e ? [...e] : [],
          r = t && e ? t.filter(t => {
            if (!e.find(e => t === e || o.isEqual(t, e))) return t
          }) : t ? [...t] : [];
        n.length > 0 && this.notify("labels:added", {
          added: n,
          cell: this,
          edge: this
        }), r.length > 0 && this.notify("labels:removed", {
          removed: r,
          cell: this,
          edge: this
        })
      }
      get vertexMarkup() {
        return this.getVertexMarkup()
      }
      set vertexMarkup(t) {
        this.setVertexMarkup(t)
      }
      getDefaultVertexMarkup() {
        return this.store.get("defaultVertexMarkup") || oS.getEdgeVertexMarkup()
      }
      getVertexMarkup() {
        return this.store.get("vertexMarkup") || this.getDefaultVertexMarkup()
      }
      setVertexMarkup(t, e = {}) {
        return this.store.set("vertexMarkup", oS.clone(t), e), this
      }
      get vertices() {
        return this.getVertices()
      }
      set vertices(t) {
        this.setVertices(t)
      }
      getVertices() {
        return [...this.store.get("vertices", [])]
      }
      setVertices(t, e = {}) {
        const n = Array.isArray(t) ? t : [t];
        return this.store.set("vertices", n.map(t => hC.toJSON(t)), e), this
      }
      insertVertex(t, e, n = {}) {
        const r = this.getVertices(),
          i = r.length;
        let o = null != e && isFinite(e) ? e : i;
        return o < 0 && (o = i + o + 1), r.splice(o, 0, hC.toJSON(t)), this.setVertices(r, n)
      }
      appendVertex(t, e = {}) {
        return this.insertVertex(t, -1, e)
      }
      getVertexAt(t) {
        if (null != t && isFinite(t)) {
          return this.getVertices()[t]
        }
        return null
      }
      setVertexAt(t, e, n = {}) {
        if (null != t && isFinite(t)) {
          const r = this.getVertices();
          r[t] = e, this.setVertices(r, n)
        }
        return this
      }
      removeVertexAt(t, e = {}) {
        const n = this.getVertices(),
          r = null != t && isFinite(t) ? t : -1;
        return n.splice(r, 1), this.setVertices(n, e)
      }
      onVertexsChanged({
        previous: t,
        current: e
      }) {
        const n = t && e ? e.filter(e => {
            if (!t.find(t => hC.equals(e, t))) return e
          }) : e ? [...e] : [],
          r = t && e ? t.filter(t => {
            if (!e.find(e => hC.equals(t, e))) return t
          }) : t ? [...t] : [];
        n.length > 0 && this.notify("vertexs:added", {
          added: n,
          cell: this,
          edge: this
        }), r.length > 0 && this.notify("vertexs:removed", {
          removed: r,
          cell: this,
          edge: this
        })
      }
      getDefaultMarkup() {
        return this.store.get("defaultMarkup") || oS.getEdgeMarkup()
      }
      getMarkup() {
        return super.getMarkup() || this.getDefaultMarkup()
      }
      get toolMarkup() {
        return this.getToolMarkup()
      }
      set toolMarkup(t) {
        this.setToolMarkup(t)
      }
      getDefaultToolMarkup() {
        return this.store.get("defaultToolMarkup") || oS.getEdgeToolMarkup()
      }
      getToolMarkup() {
        return this.store.get("toolMarkup") || this.getDefaultToolMarkup()
      }
      setToolMarkup(t, e = {}) {
        return this.store.set("toolMarkup", t, e), this
      }
      get doubleToolMarkup() {
        return this.getDoubleToolMarkup()
      }
      set doubleToolMarkup(t) {
        this.setDoubleToolMarkup(t)
      }
      getDefaultDoubleToolMarkup() {
        return this.store.get("defaultDoubleToolMarkup")
      }
      getDoubleToolMarkup() {
        return this.store.get("doubleToolMarkup") || this.getDefaultDoubleToolMarkup()
      }
      setDoubleToolMarkup(t, e = {}) {
        return this.store.set("doubleToolMarkup", t, e), this
      }
      get arrowheadMarkup() {
        return this.getArrowheadMarkup()
      }
      set arrowheadMarkup(t) {
        this.setArrowheadMarkup(t)
      }
      getDefaultArrowheadMarkup() {
        return this.store.get("defaultArrowheadMarkup") || oS.getEdgeArrowheadMarkup()
      }
      getArrowheadMarkup() {
        return this.store.get("arrowheadMarkup") || this.getDefaultArrowheadMarkup()
      }
      setArrowheadMarkup(t, e = {}) {
        return this.store.set("arrowheadMarkup", t, e), this
      }
      translate(t, e, n = {}) {
        return n.translateBy = n.translateBy || this.id, n.tx = t, n.ty = e, this.applyToPoints(n => ({
          x: (n.x || 0) + t,
          y: (n.y || 0) + e
        }), n)
      }
      scale(t, e, n, r = {}) {
        return this.applyToPoints(r => hC.create(r).scale(t, e, n).toJSON(), r)
      }
      applyToPoints(t, e = {}) {
        const n = {},
          r = this.getSource(),
          i = this.getTarget();
        hC.isPointLike(r) && (n.source = t(r)), hC.isPointLike(i) && (n.target = t(i));
        const o = this.getVertices();
        return o.length > 0 && (n.vertices = o.map(t)), this.store.set(n, e), this
      }
      getBBox() {
        return this.getPolyline().bbox()
      }
      getConnectionPoint() {
        return this.getPolyline().pointAt(.5)
      }
      getPolyline() {
        const t = [this.getSourcePoint(), this.getTargetPoint()];
        return this.getVertices().forEach(e => t.push(hC.create(e))), new fC(t)
      }
      updateParent(t) {
        let e = null;
        const n = this.getSourceCell(),
          r = this.getTargetCell(),
          i = this.getParent();
        return n && r && (e = n === r || n.isDescendantOf(r) ? r : r.isDescendantOf(n) ? n : fk.getCommonAncestor(
          n, r)), !i || e && e.id === i.id || i.unembed(this, t), e && e.embed(this, t), e
      }
      hasLoop(t = {}) {
        const e = this.getSource(),
          n = this.getTarget(),
          r = e.cell,
          i = n.cell;
        if (!r || !i) return !1;
        let o = r === i;
        if (!o && t.deep && this._model) {
          const e = this.getSourceCell(),
            n = this.getTargetCell();
          e && n && (o = e.isAncestorOf(n, t) || n.isAncestorOf(e, t))
        }
        return o
      }
      getFragmentAncestor() {
        const t = [this, this.getSourceNode(), this.getTargetNode()].filter(t => null != t);
        return this.getCommonAncestor(...t)
      }
      isFragmentDescendantOf(t) {
        const e = this.getFragmentAncestor();
        return !!e && (e.id === t.id || e.isDescendantOf(t))
      }
    }
    xk.defaults = {},
      function(t) {
        (xk || (xk = {})).equalTerminals = function(t, e) {
          const n = t,
            r = e;
          return n.cell === r.cell && (n.port === r.port || null == n.port && null == r.port)
        }
      }(),
      function(t) {
        t.defaultLabel = {
          markup: [{
            tagName: "rect",
            selector: "body"
          }, {
            tagName: "text",
            selector: "label"
          }],
          attrs: {
            text: {
              fill: "#000",
              fontSize: 14,
              textAnchor: "middle",
              textVerticalAnchor: "middle",
              pointerEvents: "none"
            },
            rect: {
              ref: "label",
              fill: "#fff",
              rx: 3,
              ry: 3,
              refWidth: 1,
              refHeight: 1,
              refX: 0,
              refY: 0
            }
          },
          position: {
            distance: .5
          }
        }, t.parseStringLabel = function(t) {
          return {
            attrs: {
              label: {
                text: t
              }
            }
          }
        }
      }(xk || (xk = {})), (bk = xk || (xk = {})).registry = Kx.create({
        type: "edge",
        process(t, e) {
          if (uk.exist(t, !1)) throw new Error(`Edge with name '${t}' was registered by anthor Node`);
          if ("function" == typeof e) return e.config({
            shape: t
          }), e;
          let n = bk;
          const {
            inherit: r
          } = e, i = Ck(e, ["inherit"]);
          if (r) {
            const t = this.get(r);
            null == t ? this.onNotFound(r, "inherited") : n = t
          }
          null == i.constructorName && (i.constructorName = t);
          const o = n.define.call(n, i);
          return o.config({
            shape: t
          }), o
        }
      }), uk.setEdgeRegistry(bk.registry),
      function(t) {
        t.config({
          shape: "basic.edge",
          propHooks(e) {
            const {
              label: n
            } = e, r = Ck(e, ["label"]);
            if (n) {
              null == r.labels && (r.labels = []);
              const e = "string" == typeof n ? t.parseStringLabel(n) : n;
              r.labels.push(e)
            }
            return r
          }
        }), t.registry.register("basic.edge", t)
      }(xk || (xk = {})),
      function(t) {
        let e = 0;
        t.define = function(n) {
          const {
            constructorName: r
          } = n, i = Ck(n, ["constructorName"]), a = o.createClass((l = r || i.shape) ? s.pascalCase(l) :
            `CustomEdge${e+=1}`, this);
          var l;
          return a.config(i), i.shape && t.registry.register(i.shape, a), a
        }, t.create = function(e) {
          const n = e.shape || "edge",
            r = t.registry.get(n);
          return r ? new r(e) : t.registry.onNotFound(n)
        }
      }(xk || (xk = {}));
    class wk extends Vx {
      constructor(t, e = {}) {
        super(), this.length = 0, this.comparator = e.comparator || "zIndex", this.clean(), t && this.reset(t, {
          silent: !0
        })
      }
      toJSON() {
        return this.cells.map(t => t.toJSON())
      }
      add(t, e, n) {
        let r, i;
        "number" == typeof e ? (r = e, i = Object.assign({
          merge: !1
        }, n)) : (r = this.length, i = Object.assign({
          merge: !1
        }, e)), r > this.length && (r = this.length), r < 0 && (r += this.length + 1);
        const o = Array.isArray(t) ? t : [t],
          s = this.comparator && "number" != typeof e && !1 !== i.sort,
          a = this.comparator || null;
        let l = !1;
        const c = [],
          h = [];
        return o.forEach(t => {
            const e = this.get(t);
            e ? i.merge && !t.isSameStore(e) && (e.setProp(t.getProp(), n), h.push(e), s && !l && (l = null ==
              a || "function" == typeof a ? e.hasChanged() : "string" == typeof a ? e.hasChanged(a) : a.some(
                t => e.hasChanged(t)))) : (c.push(t), this.reference(t))
          }), c.length && (s && (l = !0), this.cells.splice(r, 0, ...c), this.length = this.cells.length), l &&
          this.sort({
            silent: !0
          }), i.silent || (c.forEach((t, e) => {
            const n = {
              cell: t,
              index: r + e,
              options: i
            };
            this.trigger("added", n), i.dryrun || t.notify("added", Object.assign({}, n))
          }), l && this.trigger("sorted"), (c.length || h.length) && this.trigger("updated", {
            added: c,
            merged: h,
            removed: [],
            options: i
          })), this
      }
      remove(t, e = {}) {
        const n = Array.isArray(t) ? t : [t],
          r = this.removeCells(n, e);
        return !e.silent && r.length > 0 && this.trigger("updated", {
          options: e,
          removed: r,
          added: [],
          merged: []
        }), Array.isArray(t) ? r : r[0]
      }
      removeCells(t, e) {
        const n = [];
        for (let r = 0; r < t.length; r += 1) {
          const i = this.get(t[r]);
          if (null == i) continue;
          const o = this.cells.indexOf(i);
          this.cells.splice(o, 1), this.length -= 1, delete this.map[i.id], n.push(i), this.unreference(i), e.dryrun ||
            i.remove(), e.silent || (this.trigger("removed", {
              cell: i,
              index: o,
              options: e
            }), e.dryrun || i.notify("removed", {
              cell: i,
              index: o,
              options: e
            }))
        }
        return n
      }
      reset(t, e = {}) {
        const n = this.cells.slice();
        if (n.forEach(t => this.unreference(t)), this.clean(), this.add(t, Object.assign({
            silent: !0
          }, e)), !e.silent) {
          const t = this.cells.slice();
          this.trigger("reseted", {
            options: e,
            previous: n,
            current: t
          });
          const r = [],
            i = [];
          t.forEach(t => {
            n.some(e => e.id === t.id) || r.push(t)
          }), n.forEach(e => {
            t.some(t => t.id === e.id) || i.push(e)
          }), this.trigger("updated", {
            options: e,
            added: r,
            removed: i,
            merged: []
          })
        }
        return this
      }
      push(t, e) {
        return this.add(t, this.length, e)
      }
      pop(t) {
        const e = this.at(this.length - 1);
        return this.remove(e, t)
      }
      unshift(t, e) {
        return this.add(t, 0, e)
      }
      shift(t) {
        const e = this.at(0);
        return this.remove(e, t)
      }
      get(t) {
        if (null == t) return null;
        const e = "string" == typeof t || "number" == typeof t ? t : t.id;
        return this.map[e] || null
      }
      has(t) {
        return null != this.get(t)
      }
      at(t) {
        return t < 0 && (t += this.length), this.cells[t] || null
      }
      first() {
        return this.at(0)
      }
      last() {
        return this.at(-1)
      }
      indexOf(t) {
        return this.cells.indexOf(t)
      }
      toArray() {
        return this.cells.slice()
      }
      sort(t = {}) {
        return null != this.comparator && (this.cells = i.sortBy(this.cells, this.comparator), t.silent || this
          .trigger("sorted")), this
      }
      clone() {
        return new(0, this.constructor)(this.cells.slice(), {
          comparator: this.comparator
        })
      }
      reference(t) {
        this.map[t.id] = t, t.on("*", this.notifyCellEvent, this), t.on("change:zIndex", this.onCellZIndexChanged,
          this)
      }
      unreference(t) {
        t.off("*", this.notifyCellEvent, this), t.off("change:zIndex", this.onCellZIndexChanged, this), delete this
          .map[t.id]
      }
      notifyCellEvent(t, e) {
        const n = e.cell;
        this.trigger(`cell:${t}`, e), n && (n.isNode() ? this.trigger(`node:${t}`, Object.assign(Object.assign({},
          e), {
          node: n
        })) : n.isEdge() && this.trigger(`edge:${t}`, Object.assign(Object.assign({}, e), {
          edge: n
        })))
      }
      onCellZIndexChanged(t) {
        this.sort(t.options)
      }
      clean() {
        this.length = 0, this.cells = [], this.map = {}
      }
    }
    class Ak extends Vx {
      constructor(t = []) {
        super(), this.batches = {}, this.addings = new WeakMap, this.nodes = {}, this.edges = {}, this.outgoings = {},
          this.incomings = {}, this.collection = new wk(t), this.setup()
      }
      notify(t, e) {
        this.trigger(t, e);
        const n = this.graph;
        return n && ("sorted" === t || "reseted" === t || "updated" === t ? n.trigger(`model:${t}`, e) : n.trigger(
          t, e)), this
      }
      setup() {
        const t = this.collection;
        t.on("sorted", () => this.notify("sorted", null)), t.on("updated", t => this.notify("updated", t)), t.on(
          "cell:change:zIndex", () => this.sortOnChangeZ()), t.on("added", ({
          cell: t
        }) => {
          this.onCellAdded(t)
        }), t.on("removed", t => {
          const e = t.cell;
          this.onCellRemoved(e, t.options), this.notify("cell:removed", t), e.isNode() ? this.notify(
            "node:removed", Object.assign(Object.assign({}, t), {
              node: e
            })) : e.isEdge() && this.notify("edge:removed", Object.assign(Object.assign({}, t), {
            edge: e
          }))
        }), t.on("reseted", t => {
          this.onReset(t.current), this.notify("reseted", t)
        }), t.on("edge:change:source", ({
          edge: t
        }) => this.onEdgeTerminalChanged(t, "source")), t.on("edge:change:target", ({
          edge: t
        }) => {
          this.onEdgeTerminalChanged(t, "target")
        })
      }
      sortOnChangeZ() {
        this.collection.sort()
      }
      onCellAdded(t) {
        const e = t.id;
        t.isEdge() ? (this.edges[e] = !0, this.onEdgeTerminalChanged(t, "source"), this.onEdgeTerminalChanged(t,
          "target")) : this.nodes[e] = !0
      }
      onCellRemoved(t, e) {
        const n = t.id;
        if (t.isEdge()) {
          delete this.edges[n];
          const e = t.getSource(),
            r = t.getTarget();
          if (e && e.cell) {
            const t = this.outgoings[e.cell],
              r = t ? t.indexOf(n) : -1;
            r >= 0 && (t.splice(r, 1), 0 === t.length && delete this.outgoings[e.cell])
          }
          if (r && r.cell) {
            const t = this.incomings[r.cell],
              e = t ? t.indexOf(n) : -1;
            e >= 0 && (t.splice(e, 1), 0 === t.length && delete this.incomings[r.cell])
          }
        } else delete this.nodes[n];
        e.clear || (e.disconnectEdges ? this.disconnectConnectedEdges(t, e) : this.removeConnectedEdges(t, e)),
          t.model === this && (t.model = null)
      }
      onReset(t) {
        this.nodes = {}, this.edges = {}, this.outgoings = {}, this.incomings = {}, t.forEach(t => this.onCellAdded(
          t))
      }
      onEdgeTerminalChanged(t, e) {
        const n = "source" === e ? this.outgoings : this.incomings,
          r = t.previous(e);
        if (r && r.cell) {
          const e = n[r.cell],
            i = e ? e.indexOf(t.id) : -1;
          i >= 0 && (e.splice(i, 1), 0 === e.length && delete n[r.cell])
        }
        const i = t.getTerminal(e);
        if (i && i.cell) {
          const e = n[i.cell] || []; - 1 === e.indexOf(t.id) && e.push(t.id), n[i.cell] = e
        }
      }
      prepareCell(t, e) {
        return t.model || e && e.dryrun || (t.model = this), null == t.zIndex && (t.zIndex = this.getMaxZIndex() +
          1), t
      }
      resetCells(t, e = {}) {
        return t.map(t => this.prepareCell(t, Object.assign(Object.assign({}, e), {
          dryrun: !0
        }))), this.collection.reset(t, e), t.map(t => this.prepareCell(t, {
          options: e
        })), this
      }
      clear(t = {}) {
        const e = this.getCells();
        if (0 === e.length) return this;
        const n = Object.assign(Object.assign({}, t), {
          clear: !0
        });
        return this.batchUpdate("clear", () => {
          const t = e.sort(t => t.isEdge() ? 1 : 2);
          for (; t.length > 0;) {
            const e = t.shift();
            e && e.remove(n)
          }
        }, n), this
      }
      addNode(t, e = {}) {
        const n = t instanceof yk ? t : this.createNode(t);
        return this.addCell(n, e), n
      }
      createNode(t) {
        return yk.create(t)
      }
      addEdge(t, e = {}) {
        const n = t instanceof xk ? t : this.createEdge(t);
        return this.addCell(n, e), n
      }
      createEdge(t) {
        return xk.create(t)
      }
      addCell(t, e = {}) {
        return Array.isArray(t) ? this.addCells(t, e) : (this.collection.has(t) || this.addings.has(t) || (this
          .addings.set(t, !0), this.collection.add(this.prepareCell(t, e), e), t.eachChild(t => this.addCell(
            t, e)), this.addings.delete(t)), this)
      }
      addCells(t, e = {}) {
        const n = t.length;
        if (0 === n) return this;
        const r = Object.assign(Object.assign({}, e), {
          position: n - 1,
          maxPosition: n - 1
        });
        return this.startBatch("add", r), t.forEach(t => {
          this.addCell(t, r), r.position -= 1
        }), this.stopBatch("add", r), this
      }
      removeCell(t, e = {}) {
        const n = "string" == typeof t ? this.getCell(t) : t;
        return n && this.has(n) ? this.collection.remove(n, e) : null
      }
      removeCells(t, e = {}) {
        return t.length ? this.batchUpdate("remove", () => t.map(t => this.removeCell(t, e))) : []
      }
      removeConnectedEdges(t, e = {}) {
        const n = this.getConnectedEdges(t);
        return n.forEach(t => {
          t.remove(e)
        }), n
      }
      disconnectConnectedEdges(t, e = {}) {
        const n = "string" == typeof t ? t : t.id;
        this.getConnectedEdges(t).forEach(t => {
          const r = t.getSourceCell(),
            i = t.getTargetCell();
          r && r.id === n && t.setSource({
            x: 0,
            y: 0
          }, e), i && i.id === n && t.setTarget({
            x: 0,
            y: 0
          }, e)
        })
      }
      has(t) {
        return this.collection.has(t)
      }
      total() {
        return this.collection.length
      }
      indexOf(t) {
        return this.collection.indexOf(t)
      }
      getCell(t) {
        return this.collection.get(t)
      }
      getCells() {
        return this.collection.toArray()
      }
      getFirstCell() {
        return this.collection.first()
      }
      getLastCell() {
        return this.collection.last()
      }
      getMinZIndex() {
        const t = this.collection.first();
        return t && t.getZIndex() || 0
      }
      getMaxZIndex() {
        const t = this.collection.last();
        return t && t.getZIndex() || 0
      }
      getCellsFromCache(t) {
        return t ? Object.keys(t).map(t => this.getCell(t)).filter(t => null != t) : []
      }
      getNodes() {
        return this.getCellsFromCache(this.nodes)
      }
      getEdges() {
        return this.getCellsFromCache(this.edges)
      }
      getOutgoingEdges(t) {
        const e = "string" == typeof t ? t : t.id,
          n = this.outgoings[e];
        return n ? n.map(t => this.getCell(t)).filter(t => t && t.isEdge()) : null
      }
      getIncomingEdges(t) {
        const e = "string" == typeof t ? t : t.id,
          n = this.incomings[e];
        return n ? n.map(t => this.getCell(t)).filter(t => t && t.isEdge()) : null
      }
      getConnectedEdges(t, e = {}) {
        const n = [],
          r = "string" == typeof t ? this.getCell(t) : t;
        if (null == r) return n;
        const i = {},
          o = e.indirect;
        let s = e.incoming,
          a = e.outgoing;
        null == s && null == a && (s = a = !0);
        const l = (t, e) => {
          const r = e ? this.getOutgoingEdges(t) : this.getIncomingEdges(t);
          if (null != r && r.forEach(t => {
              i[t.id] || (n.push(t), i[t.id] = !0, o && (s && l(t, !1), a && l(t, !0)))
            }), o && t.isEdge()) {
            const r = e ? t.getTargetCell() : t.getSourceCell();
            r && r.isEdge() && (i[r.id] || (n.push(r), l(r, e)))
          }
        };
        if (a && l(r, !0), s && l(r, !1), e.deep) {
          const t = r.getDescendants({
              deep: !0
            }),
            o = {};
          t.forEach(t => {
            t.isNode() && (o[t.id] = !0)
          });
          const l = (t, r) => {
            const s = r ? this.getOutgoingEdges(t.id) : this.getIncomingEdges(t.id);
            null != s && s.forEach(t => {
              if (!i[t.id]) {
                const r = t.getSourceCell(),
                  s = t.getTargetCell();
                if (!e.enclosed && r && o[r.id] && s && o[s.id]) return;
                n.push(t), i[t.id] = !0
              }
            })
          };
          t.forEach(t => {
            t.isEdge() || (a && l(t, !0), s && l(t, !1))
          })
        }
        return n
      }
      isBoundary(t, e) {
        const n = "string" == typeof t ? this.getCell(t) : t,
          r = e ? this.getIncomingEdges(n) : this.getOutgoingEdges(n);
        return null == r || 0 === r.length
      }
      getBoundaryNodes(t) {
        const e = [];
        return Object.keys(this.nodes).forEach(n => {
          if (this.isBoundary(n, t)) {
            const t = this.getCell(n);
            t && e.push(t)
          }
        }), e
      }
      getRoots() {
        return this.getBoundaryNodes(!0)
      }
      getLeafs() {
        return this.getBoundaryNodes(!1)
      }
      isRoot(t) {
        return this.isBoundary(t, !0)
      }
      isLeaf(t) {
        return this.isBoundary(t, !1)
      }
      getNeighbors(t, e = {}) {
        let n = e.incoming,
          r = e.outgoing;
        null == n && null == r && (n = r = !0);
        const i = this.getConnectedEdges(t, e).reduce((i, o) => {
          const s = o.hasLoop(e),
            a = o.getSourceCell(),
            l = o.getTargetCell();
          return n && a && a.isNode() && !i[a.id] && (!s && (a === t || e.deep && a.isDescendantOf(t)) || (
            i[a.id] = a)), r && l && l.isNode() && !i[l.id] && (!s && (l === t || e.deep && l.isDescendantOf(
            t)) || (i[l.id] = l)), i
        }, {});
        if (t.isEdge()) {
          if (n) {
            const e = t.getSourceCell();
            e && e.isNode() && !i[e.id] && (i[e.id] = e)
          }
          if (r) {
            const e = t.getTargetCell();
            e && e.isNode() && !i[e.id] && (i[e.id] = e)
          }
        }
        return Object.keys(i).map(t => i[t])
      }
      isNeighbor(t, e, n = {}) {
        let r = n.incoming,
          i = n.outgoing;
        return null == r && null == i && (r = i = !0), this.getConnectedEdges(t, n).some(t => {
          const n = t.getSourceCell(),
            o = t.getTargetCell();
          return !(!r || !n || n.id !== e.id) || (!(!i || !o || o.id !== e.id) || void 0)
        })
      }
      getSuccessors(t, e = {}) {
        const n = [];
        return this.search(t, (r, i) => {
          r !== t && this.matchDistance(i, e.distance) && n.push(r)
        }, Object.assign(Object.assign({}, e), {
          outgoing: !0
        })), n
      }
      isSuccessor(t, e, n = {}) {
        let r = !1;
        return this.search(t, (i, o) => {
          if (i === e && i !== t && this.matchDistance(o, n.distance)) return r = !0, !1
        }, Object.assign(Object.assign({}, n), {
          outgoing: !0
        })), r
      }
      getPredecessors(t, e = {}) {
        const n = [];
        return this.search(t, (r, i) => {
          r !== t && this.matchDistance(i, e.distance) && n.push(r)
        }, Object.assign(Object.assign({}, e), {
          incoming: !0
        })), n
      }
      isPredecessor(t, e, n = {}) {
        let r = !1;
        return this.search(t, (i, o) => {
          if (i === e && i !== t && this.matchDistance(o, n.distance)) return r = !0, !1
        }, Object.assign(Object.assign({}, n), {
          incoming: !0
        })), r
      }
      matchDistance(t, e) {
        return null == e || ("function" == typeof e ? e(t) : !(!Array.isArray(e) || !e.includes(t)) || t === e)
      }
      getCommonAncestor(...t) {
        const e = [];
        return t.forEach(t => {
          t && (Array.isArray(t) ? e.push(...t) : e.push(t))
        }), fk.getCommonAncestor(...e)
      }
      getSubGraph(t, e = {}) {
        const n = [],
          r = {},
          i = [],
          o = [],
          s = t => {
            r[t.id] || (n.push(t), r[t.id] = t, t.isEdge() && o.push(t), t.isNode() && i.push(t))
          };
        return t.forEach(t => {
          if (s(t), e.deep) {
            t.getDescendants({
              deep: !0
            }).forEach(t => s(t))
          }
        }), o.forEach(t => {
          const e = t.getSourceCell(),
            o = t.getTargetCell();
          e && !r[e.id] && (n.push(e), r[e.id] = e, e.isNode() && i.push(e)), o && !r[o.id] && (n.push(o),
            r[o.id] = o, o.isNode() && i.push(o))
        }), i.forEach(t => {
          this.getConnectedEdges(t, e).forEach(t => {
            const e = t.getSourceCell(),
              i = t.getTargetCell();
            !r[t.id] && e && r[e.id] && i && r[i.id] && (n.push(t), r[t.id] = t)
          })
        }), n
      }
      cloneSubGraph(t, e = {}) {
        const n = this.getSubGraph(t, e);
        return this.cloneCells(n)
      }
      cloneCells(t) {
        return fk.cloneCells(t)
      }
      getNodesFromPoint(t, e) {
        const n = "number" == typeof t ? {
          x: t,
          y: e || 0
        } : t;
        return this.getNodes().filter(t => t.getBBox().containsPoint(n))
      }
      getNodesInArea(t, e, n, r, i) {
        const o = "number" == typeof t ? new uC(t, e, n, r) : uC.create(t),
          s = "number" == typeof t ? i : e,
          a = s && s.strict;
        return this.getNodes().filter(t => {
          const e = t.getBBox();
          return a ? o.containsRect(e) : o.isIntersectWith(e)
        })
      }
      getNodesUnderNode(t, e = {}) {
        const n = t.getBBox();
        return (null == e.by || "bbox" === e.by ? this.getNodesInArea(n) : this.getNodesFromPoint(n[e.by])).filter(
          e => t.id !== e.id && !e.isDescendantOf(t))
      }
      getAllCellsBBox() {
        return this.getCellsBBox(this.getCells())
      }
      getCellsBBox(t, e = {}) {
        return fk.getCellsBBox(t, e)
      }
      search(t, e, n = {}) {
        n.breadthFirst ? this.breadthFirstSearch(t, e, n) : this.depthFirstSearch(t, e, n)
      }
      breadthFirstSearch(t, e, n = {}) {
        const r = [],
          i = {},
          o = {};
        for (r.push(t), o[t.id] = 0; r.length > 0;) {
          const t = r.shift();
          null == t || i[t.id] || (i[t.id] = !0, !1 !== l.call(e, this, t, o[t.id]) && this.getNeighbors(t, n).forEach(
            e => {
              o[e.id] = o[t.id] + 1, r.push(e)
            }))
        }
      }
      depthFirstSearch(t, e, n = {}) {
        const r = [],
          i = {},
          o = {};
        for (r.push(t), o[t.id] = 0; r.length > 0;) {
          const t = r.pop();
          if (null == t || i[t.id]) continue;
          if (i[t.id] = !0, !1 === l.call(e, this, t, o[t.id])) continue;
          const s = this.getNeighbors(t, n),
            a = r.length;
          s.forEach(e => {
            o[e.id] = o[t.id] + 1, r.splice(a, 0, e)
          })
        }
      }
      getShortestPath(t, e, n = {}) {
        const r = {};
        this.getEdges().forEach(t => {
          const e = t.getSourceCellId(),
            i = t.getTargetCellId();
          e && i && (r[e] || (r[e] = []), r[i] || (r[i] = []), r[e].push(i), n.directed || r[i].push(e))
        });
        const i = "string" == typeof t ? t : t.id,
          o = Gx.run(r, i, n.weight),
          s = [];
        let a = "string" == typeof e ? e : e.id;
        for (o[a] && s.push(a); a = o[a];) s.unshift(a);
        return s
      }
      translate(t, e, n) {
        return this.getCells().filter(t => !t.hasParent()).forEach(r => r.translate(t, e, n)), this
      }
      resize(t, e, n) {
        return this.resizeCells(t, e, this.getCells(), n)
      }
      resizeCells(t, e, n, r = {}) {
        const i = this.getCellsBBox(n);
        if (i) {
          const o = Math.max(t / i.width, 0),
            s = Math.max(e / i.height, 0),
            a = i.getOrigin();
          n.forEach(t => t.scale(o, s, a, r))
        }
        return this
      }
      toJSON(t = {}) {
        return Ak.toJSON(this.getCells(), t)
      }
      parseJSON(t) {
        return Ak.fromJSON(t)
      }
      fromJSON(t, e = {}) {
        const n = this.parseJSON(t);
        return this.resetCells(n, e), this
      }
      startBatch(t, e = {}) {
        return this.batches[t] = (this.batches[t] || 0) + 1, this.notify("batch:start", {
          name: t,
          data: e
        }), this
      }
      stopBatch(t, e = {}) {
        return this.batches[t] = (this.batches[t] || 0) - 1, this.notify("batch:stop", {
          name: t,
          data: e
        }), this
      }
      batchUpdate(t, e, n = {}) {
        this.startBatch(t, n);
        const r = e();
        return this.stopBatch(t, n), r
      }
      hasActiveBatch(t = Object.keys(this.batches)) {
        return (Array.isArray(t) ? t : [t]).some(t => this.batches[t] > 0)
      }
    }! function(t) {
      t.toJSON = function(t, e = {}) {
        return {
          cells: t.map(t => t.toJSON(e))
        }
      }, t.fromJSON = function(t) {
        const e = [];
        return Array.isArray(t) ? e.push(...t) : (t.cells && e.push(...t.cells), t.nodes && t.nodes.forEach(t => {
          null == t.shape && (t.shape = "rect"), e.push(t)
        }), t.edges && t.edges.forEach(t => {
          null == t.shape && (t.shape = "edge"), e.push(t)
        })), e.map(t => {
          const e = t.shape;
          if (e) {
            if (yk.registry.exist(e)) return yk.create(t);
            if (xk.registry.exist(e)) return xk.create(t)
          }
          throw new Error("The `shape` should be specipied when creating a node/edge instance")
        })
      }
    }(Ak || (Ak = {}));
    class Ek extends dS {
      constructor() {
        super(...arguments), this.POINT_ROUNDING = 2, this.markerCache = {}
      }
      getContainerClassName() {
        return [super.getContainerClassName(), this.prefixClassName("edge")].join(" ")
      }
      get sourceBBox() {
        const t = this.sourceView;
        if (!t) {
          const t = this.cell.getSource();
          return new uC(t.x, t.y)
        }
        const e = this.sourceMagnet;
        return t.isEdgeElement(e) ? new uC(this.sourceAnchor.x, this.sourceAnchor.y) : t.getBBoxOfElement(e ||
          t.container)
      }
      get targetBBox() {
        const t = this.targetView;
        if (!t) {
          const t = this.cell.getTarget();
          return new uC(t.x, t.y)
        }
        const e = this.targetMagnet;
        return t.isEdgeElement(e) ? new uC(this.targetAnchor.x, this.targetAnchor.y) : t.getBBoxOfElement(e ||
          t.container)
      }
      isEdgeView() {
        return !0
      }
      confirmUpdate(t, e = {}) {
        let n = t;
        if (this.hasAction(n, "source")) {
          if (!this.updateTerminalProperties("source")) return n;
          n = this.removeAction(n, "source")
        }
        if (this.hasAction(n, "target")) {
          if (!this.updateTerminalProperties("target")) return n;
          n = this.removeAction(n, "target")
        }
        const r = this.graph,
          i = this.sourceView,
          o = this.targetView;
        return r && (i && !r.renderer.isViewMounted(i) || o && !r.renderer.isViewMounted(o)) ? n : this.hasAction(
          n, "render") ? (this.render(), n = this.removeAction(n, ["render", "update", "vertices", "labels",
          "tools", "widget"
        ])) : (n = this.handleAction(n, "vertices", () => this.renderVertexMarkers()), n = this.handleAction(
          n, "update", () => this.update(null, e)), n = this.handleAction(n, "labels", () => this.onLabelsChange(
          e)), n = this.handleAction(n, "tools", () => {
          this.renderTools(), this.updateToolsPosition()
        }), n = this.handleAction(n, "widget", () => this.renderExternalTools()))
      }
      onLabelsChange(t = {}) {
        this.shouldRerenderLabels(t) ? this.renderLabels() : this.updateLabels(), this.updateLabelPositions()
      }
      shouldRerenderLabels(t = {}) {
        const e = this.cell.previous("labels");
        if (null == e) return !0;
        if ("propertyPathArray" in t && "propertyValue" in t) {
          const n = t.propertyPathArray || [],
            r = n.length;
          if (r > 1) {
            if (e[n[1]]) {
              if (2 === r) return "object" == typeof t.propertyValue && o.has(t.propertyValue, "markup");
              if ("markup" !== n[2]) return !1
            }
          }
        }
        return !0
      }
      render() {
        return this.empty(), this.containers = {}, this.renderMarkup(), this.renderLabels(), this.update(),
          this
      }
      renderMarkup() {
        const t = this.cell.markup;
        if (t) return "string" == typeof t ? this.renderStringMarkup(t) : this.renderJSONMarkup(t);
        throw new TypeError("Invalid edge markup.")
      }
      renderJSONMarkup(t) {
        const e = this.parseJSONMarkup(t, this.container);
        this.selectors = e.selectors, this.container.append(e.fragment)
      }
      renderStringMarkup(t) {
        const e = this.containers,
          n = h.createVectors(t);
        n.forEach(t => {
          const n = t.attr("class");
          n && (e[s.camelCase(n)] = t.node)
        }), this.renderTools(), this.renderVertexMarkers(), this.renderArrowheadMarkers(), h.append(this.container,
          n.map(t => t.node))
      }
      renderLabels() {
        const t = this.cell,
          e = t.getLabels(),
          n = e.length;
        let r = this.containers.labels;
        if (this.labelCache = {}, this.labelSelectors = {}, n <= 0) return r && r.parentNode && r.parentNode.removeChild(
          r), this;
        r ? this.empty(r) : (r = h.createSvgElement("g"), this.addClass(this.prefixClassName("edge-labels"), r),
          this.containers.labels = r);
        for (let n = 0, i = e.length; n < i; n += 1) {
          const i = e[n],
            o = this.normalizeLabelMarkup(this.parseLabelMarkup(i.markup));
          let s, a;
          if (o) s = o.node, a = o.selectors;
          else {
            const e = t.getDefaultLabel(),
              n = this.normalizeLabelMarkup(this.parseLabelMarkup(e.markup));
            s = n.node, a = n.selectors
          }
          s.setAttribute("data-index", `${n}`), r.appendChild(s);
          const l = this.rootSelector;
          if (a[l]) throw new Error("Ambiguous label root selector.");
          a[l] = s, this.labelCache[n] = s, this.labelSelectors[n] = a
        }
        return null == r.parentNode && this.container.appendChild(r), this.updateLabels(), this.customizeLabels(),
          this
      }
      parseLabelMarkup(t) {
        return t ? "string" == typeof t ? this.parseLabelStringMarkup(t) : this.parseJSONMarkup(t) : null
      }
      parseLabelStringMarkup(t) {
        const e = h.createVectors(t),
          n = document.createDocumentFragment();
        for (let t = 0, r = e.length; t < r; t += 1) {
          const r = e[t].node;
          n.appendChild(r)
        }
        return {
          fragment: n,
          selectors: {}
        }
      }
      normalizeLabelMarkup(t) {
        if (null == t) return;
        const e = t.fragment;
        if (!(e instanceof DocumentFragment && e.hasChildNodes())) throw new Error("Invalid label markup.");
        let n;
        const r = e.childNodes;
        return (n = r.length > 1 || "G" !== r[0].nodeName.toUpperCase() ? h.createVector("g").append(e) : h.createVector(
          r[0])).addClass(this.prefixClassName("edge-label")), {
          node: n.node,
          selectors: t.selectors
        }
      }
      updateLabels() {
        if (this.containers.labels) {
          const t = this.cell,
            e = t.labels,
            n = this.can("edgeLabelMovable"),
            r = t.getDefaultLabel();
          for (let t = 0, i = e.length; t < i; t += 1) {
            const i = this.labelCache[t],
              s = this.labelSelectors[t];
            i.setAttribute("cursor", n ? "move" : "default");
            const a = e[t],
              l = o.merge({}, r.attrs, a.attrs);
            this.updateAttrs(i, l, {
              selectors: s,
              rootBBox: a.size ? uC.fromSize(a.size) : void 0
            })
          }
        }
      }
      mergeLabelAttrs(t, e, n) {
        if (null === e) return null;
        if (void 0 === e) {
          if (null === n) return null;
          if (void 0 === n) return;
          return t ? n : o.merge({}, n)
        }
        return t ? o.merge({}, n, e) : void 0
      }
      customizeLabels() {
        if (this.containers.labels) {
          const t = this.cell,
            e = t.labels;
          for (let n = 0, r = e.length; n < r; n += 1) {
            const r = e[n],
              i = this.labelCache[n],
              o = this.labelSelectors[n];
            this.graph.hook.onEdgeLabelRendered({
              edge: t,
              label: r,
              container: i,
              selectors: o
            })
          }
        }
      }
      renderTools() {
        const t = this.containers.tools;
        if (null == t) return this;
        const e = this.cell.toolMarkup,
          n = this.$(t).empty();
        if (oS.isStringMarkup(e)) {
          let t = s.template(e);
          const r = h.createVector(t());
          if (n.append(r.node), this.toolCache = r.node, this.options.doubleTools) {
            let e;
            const i = this.cell.doubleToolMarkup;
            oS.isStringMarkup(i) ? (t = s.template(i), e = h.createVector(t())) : e = r.clone(), n.append(e.node),
              this.tool2Cache = e.node
          }
        }
        return this
      }
      renderExternalTools() {
        const t = this.cell.getTools();
        return this.addTools(t), this
      }
      renderVertexMarkers() {
        const t = this.containers.vertices;
        if (null == t) return this;
        const e = this.cell.vertexMarkup,
          n = this.$(t).empty();
        if (oS.isStringMarkup(e)) {
          const t = s.template(e);
          this.cell.getVertices().forEach((e, r) => {
            n.append(h.createVector(t(Object.assign({
              index: r
            }, e))).node)
          })
        }
        return this
      }
      renderArrowheadMarkers() {
        const t = this.containers.arrowheads;
        if (null == t) return this;
        const e = this.cell.arrowheadMarkup,
          n = this.$(t).empty();
        if (oS.isStringMarkup(e)) {
          const t = s.template(e),
            r = h.createVector(t({
              end: "source"
            })).node,
            i = h.createVector(t({
              end: "target"
            })).node;
          this.containers.sourceArrowhead = r, this.containers.targetArrowhead = i, n.append(r, i)
        }
        return this
      }
      update(t, e = {}) {
        this.cleanCache(), this.updateConnection(e);
        const n = this.cell.getAttrs();
        return null != n && this.updateAttrs(this.container, n, {
            attrs: t === n ? null : t,
            selectors: this.selectors
          }), this.updateConnectionPath(), this.updateLabelPositions(), this.updateToolsPosition(), this.updateArrowheadMarkers(),
          null == e.toolId ? this.renderExternalTools() : this.updateTools(e), this
      }
      removeRedundantLinearVertices(t = {}) {
        const e = this.cell,
          n = e.getVertices(),
          r = [this.sourceAnchor, ...n, this.targetAnchor],
          i = r.length,
          o = new fC(r);
        o.simplify({
          threshold: .01
        });
        const s = o.points.map(t => t.toJSON()),
          a = s.length;
        return i === a ? 0 : (e.setVertices(s.slice(1, a - 1), t), i - a)
      }
      updateConnectionPath() {
        const t = this.containers;
        if (t.connection) {
          const e = this.getConnectionPathData();
          t.connection.setAttribute("d", e)
        }
        if (t.connectionWrap) {
          const e = this.getConnectionPathData();
          t.connectionWrap.setAttribute("d", e)
        }
        t.sourceMarker && t.targetMarker && this.translateAndAutoOrientArrows(t.sourceMarker, t.targetMarker)
      }
      getTerminalView(t) {
        switch (t) {
          case "source":
            return this.sourceView || null;
          case "target":
            return this.targetView || null;
          default:
            throw new Error(`Unknown terminal type '${t}'`)
        }
      }
      getTerminalAnchor(t) {
        switch (t) {
          case "source":
            return hC.create(this.sourceAnchor);
          case "target":
            return hC.create(this.targetAnchor);
          default:
            throw new Error(`Unknown terminal type '${t}'`)
        }
      }
      getTerminalConnectionPoint(t) {
        switch (t) {
          case "source":
            return hC.create(this.sourcePoint);
          case "target":
            return hC.create(this.targetPoint);
          default:
            throw new Error(`Unknown terminal type '${t}'`)
        }
      }
      getTerminalMagnet(t, e = {}) {
        switch (t) {
          case "source":
            if (e.raw) return this.sourceMagnet;
            const n = this.sourceView;
            return n ? this.sourceMagnet || n.container : null;
          case "target":
            if (e.raw) return this.targetMagnet;
            const r = this.targetView;
            return r ? this.targetMagnet || r.container : null;
          default:
            throw new Error(`Unknown terminal type '${t}'`)
        }
      }
      updateConnection(t = {}) {
        const e = this.cell;
        if (t.translateBy && e.isFragmentDescendantOf(t.translateBy)) {
          const e = t.tx || 0,
            n = t.ty || 0;
          this.routePoints = new fC(this.routePoints).translate(e, n).points, this.translateConnectionPoints(e,
            n), this.path.translate(e, n)
        } else {
          const t = e.getVertices(),
            n = this.findAnchors(t);
          this.sourceAnchor = n.source, this.targetAnchor = n.target, this.routePoints = this.findRoutePoints(t);
          const r = this.findConnectionPoints(this.routePoints, this.sourceAnchor, this.targetAnchor);
          this.sourcePoint = r.source, this.targetPoint = r.target;
          const i = this.findMarkerPoints(this.routePoints, this.sourcePoint, this.targetPoint);
          this.path = this.findPath(this.routePoints, i.source || this.sourcePoint, i.target || this.targetPoint)
        }
        this.cleanCache()
      }
      findAnchors(t) {
        const e = this.cell,
          n = e.source,
          r = e.target,
          i = t[0],
          o = t[t.length - 1];
        return r.priority && !n.priority ? this.findAnchorsOrdered("target", o, "source", i) : this.findAnchorsOrdered(
          "source", i, "target", o)
      }
      findAnchorsOrdered(t, e, n, r) {
        let i, o;
        const s = this.cell,
          a = s[t],
          l = s[n],
          c = this.getTerminalView(t),
          h = this.getTerminalView(n),
          u = this.getTerminalMagnet(t),
          d = this.getTerminalMagnet(n);
        if (c) {
          let n;
          n = e ? hC.create(e) : h ? d : hC.create(l), i = this.getAnchor(a.anchor, c, u, n, t)
        } else i = hC.create(a);
        if (h) {
          const t = hC.create(r || i);
          o = this.getAnchor(l.anchor, h, d, t, n)
        } else o = hC.isPointLike(l) ? hC.create(l) : new hC;
        return {
          [t]: i,
          [n]: o
        }
      }
      getAnchor(t, e, n, r, i) {
        const o = e.isEdgeElement(n),
          s = this.graph.options.connecting;
        let a, c = "string" == typeof t ? {
          name: t
        } : t;
        if (!c) {
          const t = o ? ("source" === i ? s.sourceEdgeAnchor : s.targetEdgeAnchor) || s.edgeAnchor : ("source" ===
            i ? s.sourceAnchor : s.targetAnchor) || s.anchor;
          c = "string" == typeof t ? {
            name: t
          } : t
        }
        if (!c) throw new Error("Anchor should be specified.");
        const h = c.name;
        if (o) {
          const t = nM.registry.get(h);
          if ("function" != typeof t) return nM.registry.onNotFound(h);
          a = l.call(t, this, e, n, r, c.args || {}, i)
        } else {
          const t = YS.registry.get(h);
          if ("function" != typeof t) return YS.registry.onNotFound(h);
          a = l.call(t, this, e, n, r, c.args || {}, i)
        }
        return a ? a.round(this.POINT_ROUNDING) : new hC
      }
      findRoutePoints(t = []) {
        const e = this.graph.options.connecting.router || GM.presets.normal,
          n = this.cell.getRouter() || e;
        let r;
        if ("function" == typeof n) r = l.call(n, this, t, {}, this);
        else {
          const e = "string" == typeof n ? n : n.name,
            i = "string" == typeof n ? {} : n.args || {},
            o = e ? GM.registry.get(e) : GM.presets.normal;
          if ("function" != typeof o) return GM.registry.onNotFound(e);
          r = l.call(o, this, t, i, this)
        }
        return null == r ? t.map(t => hC.create(t)) : r.map(t => hC.create(t))
      }
      findConnectionPoints(t, e, n) {
        const r = this.cell,
          i = this.graph.options.connecting,
          o = r.getSource(),
          s = r.getTarget(),
          a = this.sourceView,
          l = this.targetView,
          c = t[0],
          h = t[t.length - 1];
        let u, d;
        if (a && !a.isEdgeElement(this.sourceMagnet)) {
          const t = this.sourceMagnet || a.container,
            r = new dC(c || n, e),
            s = o.connectionPoint || i.sourceConnectionPoint || i.connectionPoint;
          u = this.getConnectionPoint(s, a, t, r, "source")
        } else u = e;
        if (l && !l.isEdgeElement(this.targetMagnet)) {
          const t = this.targetMagnet || l.container,
            r = s.connectionPoint || i.targetConnectionPoint || i.connectionPoint,
            o = new dC(h || e, n);
          d = this.getConnectionPoint(r, l, t, o, "target")
        } else d = n;
        return {
          source: u,
          target: d
        }
      }
      getConnectionPoint(t, e, n, r, i) {
        const o = r.end;
        if (null == t) return o;
        const s = "string" == typeof t ? t : t.name,
          a = "string" == typeof t ? {} : t.args,
          c = hM.registry.get(s);
        if ("function" != typeof c) return hM.registry.onNotFound(s);
        const h = l.call(c, this, r, e, n, a || {}, i);
        return h ? h.round(this.POINT_ROUNDING) : o
      }
      updateMarkerAttr(t) {
        const e = this.cell.getAttrs(),
          n = `.${t}-marker`,
          r = e && e[n];
        r && this.updateAttrs(this.container, {}, {
          attrs: {
            [n]: r
          },
          selectors: this.selectors
        })
      }
      findMarkerPoints(t, e, n) {
        const r = t[0],
          i = t[t.length - 1],
          o = this.containers.sourceMarker,
          s = this.containers.targetMarker,
          a = this.markerCache;
        let l, c;
        if (o && (this.updateMarkerAttr("source"), a.sourceBBox = a.sourceBBox || h.getBBox(o), a.sourceBBox.width >
            0)) {
          const t = h.scale(o);
          l = e.clone().move(r || n, a.sourceBBox.width * t.sx * -1).round()
        }
        if (s && (this.updateMarkerAttr("target"), a.targetBBox = a.targetBBox || h.getBBox(s), a.targetBBox.width >
            0)) {
          const t = h.scale(s);
          c = n.clone().move(i || e, a.targetBBox.width * t.sx * -1).round()
        }
        return a.sourcePoint = l || e.clone(), a.targetPoint = c || n.clone(), {
          source: l,
          target: c
        }
      }
      findPath(t, e, n) {
        const r = this.cell.getConnector() || this.graph.options.connecting.connector;
        let i, o, s;
        if ("string" == typeof r ? i = r : (i = r.name, o = r.args), i) {
          const t = ik.registry.get(i);
          if ("function" != typeof t) return ik.registry.onNotFound(i);
          s = t
        } else s = ik.presets.normal;
        const a = l.call(s, this, e, n, t, Object.assign(Object.assign({}, o), {
          raw: !0
        }), this);
        return "string" == typeof a ? PC.parse(a) : a
      }
      translateConnectionPoints(t, e) {
        const n = this.markerCache;
        n.sourcePoint && n.sourcePoint.translate(t, e), n.targetPoint && n.targetPoint.translate(t, e), this.sourcePoint
          .translate(t, e), this.targetPoint.translate(t, e), this.sourceAnchor.translate(t, e), this.targetAnchor
          .translate(t, e)
      }
      updateLabelPositions() {
        if (null == this.containers.labels) return this;
        if (!this.path) return this;
        const t = this.cell,
          e = t.getLabels();
        if (0 === e.length) return this;
        const n = t.getDefaultLabel(),
          r = this.normalizeLabelPosition(n.position);
        for (let t = 0, n = e.length; t < n; t += 1) {
          const n = e[t],
            i = this.normalizeLabelPosition(n.position),
            s = o.merge({}, r, i),
            a = this.getLabelTransformationMatrix(s);
          this.labelCache[t].setAttribute("transform", h.matrixToTransformString(a))
        }
        return this
      }
      updateToolsPosition() {
        if (null == this.containers.tools) return this;
        let t = "",
          e = this.options.toolsOffset;
        const n = this.getConnectionLength();
        if (null != n) {
          n < this.options.shortLength && (t = "scale(.5)", e /= 2);
          let r = this.getPointAtLength(e);
          if (null != r && h.attr(this.toolCache, "transform", `translate(${r.x},${r.y}) ${t}`), this.options.doubleTools &&
            n >= this.options.longLength) {
            const i = this.options.doubleToolsOffset || e;
            null != (r = this.getPointAtLength(n - i)) && h.attr(this.tool2Cache, "transform",
              `translate(${r.x},${r.y}) ${t}`), h.attr(this.tool2Cache, "visibility", "visible")
          } else this.options.doubleTools && h.attr(this.tool2Cache, "visibility", "hidden")
        }
        return this
      }
      updateArrowheadMarkers() {
        const t = this.containers.arrowheads;
        if (null == t) return this;
        if ("none" === t.style.display) return this;
        const e = this.containers.sourceArrowhead,
          n = this.containers.targetArrowhead;
        if (e && n) {
          const t = (this.getConnectionLength() || 0) < this.options.shortLength ? .5 : 1;
          h.scale(e, t), h.scale(n, t), this.translateAndAutoOrientArrows(e, n)
        }
        return this
      }
      updateTerminalProperties(t) {
        const e = this.cell,
          n = this.graph,
          r = e[t],
          i = r && r.cell,
          o = `${t}View`;
        if (!i) return this[o] = null, this.updateTerminalMagnet(t), !0;
        const s = n.getCellById(i);
        if (!s) throw new Error(`Edge's ${t} node with id "${i}" not exists`);
        const a = s.findView(n);
        return !!a && (this[o] = a, this.updateTerminalMagnet(t), !0)
      }
      updateTerminalMagnet(t) {
        const e = `${t}Magnet`,
          n = this.getTerminalView(t);
        if (n) {
          let r = n.getMagnetFromEdgeTerminal(this.cell[t]);
          r === n.container && (r = null), this[e] = r
        } else this[e] = null
      }
      translateAndAutoOrientArrows(t, e) {
        const n = this.routePoints;
        t && h.translateAndAutoOrient(t, this.sourcePoint, n[0] || this.targetPoint, this.graph.view.stage), e &&
          h.translateAndAutoOrient(e, this.targetPoint, n[n.length - 1] || this.sourcePoint, this.graph.view.stage)
      }
      getLabelPositionAngle(t) {
        const e = this.cell.getLabelAt(t);
        return e && e.position && "object" == typeof e.position && e.position.angle || 0
      }
      getLabelPositionArgs(t) {
        const e = this.cell.getLabelAt(t);
        if (e && e.position && "object" == typeof e.position) return e.position.options
      }
      getDefaultLabelPositionArgs() {
        const t = this.cell.getDefaultLabel();
        if (t && t.position && "object" == typeof t.position) return t.position.options
      }
      mergeLabelPositionArgs(t, e) {
        return null === t ? null : void 0 === t ? null === e ? null : e : o.merge({}, e, t)
      }
      addLabel(t, e, n, r) {
        let i, o, s, a = 0;
        "number" != typeof t ? (i = t.x, o = t.y, "number" == typeof e ? (a = e, s = n) : s = e) : (i = t, o =
          e, "number" == typeof n ? (a = n, s = r) : s = n);
        const l = this.getDefaultLabelPositionArgs(),
          c = s,
          h = this.mergeLabelPositionArgs(c, l),
          u = {
            position: this.getLabelPosition(i, o, a, h)
          };
        return this.cell.insertLabel(u, -1, s), -1
      }
      addVertex(t, e, n) {
        const r = "number" != typeof t,
          i = r ? t.x : t,
          o = r ? t.y : e,
          s = r ? e : n,
          a = {
            x: i,
            y: o
          },
          l = this.getVertexIndex(i, o);
        return this.cell.insertVertex(a, l, s), l
      }
      sendToken(t, e, n) {
        let r, i, o;
        "object" == typeof e ? (r = e.duration, i = !0 === e.reversed, o = e.selector) : (r = e, i = !1, o =
          null);
        const s = {
          dur: `${r=r||1e3}ms`,
          repeatCount: "1",
          calcMode: "linear",
          fill: "freeze"
        };
        let a;
        if (i && (s.keyPoints = "1;0", s.keyTimes = "0;1"), !((a = "string" == typeof o ? this.findOne(o, this.container,
            this.selectors) : this.containers.connection ? this.containers.connection : this.container.querySelector(
            "path")) instanceof SVGPathElement)) throw new Error(
          "Token animation requires a valid connection path.");
        const l = h.createVector(t);
        return l.appendTo(this.graph.view.stage).animateAlongPath(s, a), setTimeout(() => {
          l.remove(), "function" == typeof n && n()
        }, r), this
      }
      getConnection() {
        return null != this.path ? this.path.clone() : null
      }
      getConnectionPathData() {
        if (null == this.path) return "";
        const t = this.cache.pathCache;
        return o.has(t, "data") || (t.data = this.path.serialize()), t.data || ""
      }
      getConnectionSubdivisions() {
        if (null == this.path) return null;
        const t = this.cache.pathCache;
        return o.has(t, "segmentSubdivisions") || (t.segmentSubdivisions = this.path.getSegmentSubdivisions()),
          t.segmentSubdivisions
      }
      getConnectionLength() {
        if (null == this.path) return 0;
        const t = this.cache.pathCache;
        return o.has(t, "length") || (t.length = this.path.length({
          segmentSubdivisions: this.getConnectionSubdivisions()
        })), t.length
      }
      getPointAtLength(t) {
        return null == this.path ? null : this.path.pointAtLength(t, {
          segmentSubdivisions: this.getConnectionSubdivisions()
        })
      }
      getPointAtRatio(t) {
        return null == this.path ? null : (a.isPercentage(t) && (t = parseFloat(t) / 100), this.path.pointAt(t, {
          segmentSubdivisions: this.getConnectionSubdivisions()
        }))
      }
      getTangentAtLength(t) {
        return null == this.path ? null : this.path.tangentAtLength(t, {
          segmentSubdivisions: this.getConnectionSubdivisions()
        })
      }
      getTangentAtRatio(t) {
        return null == this.path ? null : this.path.tangentAt(t, {
          segmentSubdivisions: this.getConnectionSubdivisions()
        })
      }
      getClosestPoint(t) {
        return null == this.path ? null : this.path.closestPoint(t, {
          segmentSubdivisions: this.getConnectionSubdivisions()
        })
      }
      getClosestPointLength(t) {
        return null == this.path ? null : this.path.closestPointLength(t, {
          segmentSubdivisions: this.getConnectionSubdivisions()
        })
      }
      getClosestPointRatio(t) {
        return null == this.path ? null : this.path.closestPointNormalizedLength(t, {
          segmentSubdivisions: this.getConnectionSubdivisions()
        })
      }
      getLabelPosition(t, e, n, r) {
        const i = {
          distance: 0
        };
        let o, s = 0;
        "number" == typeof n ? (s = n, o = r) : o = n, null != o && (i.options = o);
        const a = o && o.absoluteOffset,
          l = !(o && o.absoluteDistance),
          c = o && o.absoluteDistance && o.reverseDistance,
          h = this.path,
          u = {
            segmentSubdivisions: this.getConnectionSubdivisions()
          },
          d = new hC(t, e),
          p = h.closestPointT(d, u),
          f = this.getConnectionLength() || 0;
        let g, m, v = h.lengthAtT(p, u);
        if (l && (v = f > 0 ? v / f : 0), c && (v = -1 * (f - v) || 1), i.distance = v, a || (g = h.tangentAtT(
            p)), g) m = g.pointOffset(d);
        else {
          const t = h.pointAtT(p),
            e = d.diff(t);
          m = {
            x: e.x,
            y: e.y
          }
        }
        return i.offset = m, i.angle = s, i
      }
      normalizeLabelPosition(t) {
        return "number" == typeof t ? {
          distance: t
        } : t
      }
      getLabelTransformationMatrix(t) {
        const e = this.normalizeLabelPosition(t),
          n = e.options || {},
          r = e.angle || 0,
          i = e.distance,
          o = i > 0 && i <= 1;
        let s = 0;
        const a = {
            x: 0,
            y: 0
          },
          l = e.offset;
        l && ("number" == typeof l ? s = l : (null != l.x && (a.x = l.x), null != l.y && (a.y = l.y)));
        const c = 0 !== a.x || 0 !== a.y || 0 === s,
          u = n.keepGradient,
          d = n.ensureLegibility,
          p = this.path,
          f = {
            segmentSubdivisions: this.getConnectionSubdivisions()
          },
          g = o ? i * this.getConnectionLength() : i,
          m = p.tangentAtLength(g, f);
        let v, y = r;
        if (m) {
          if (c)(v = m.start).translate(a);
          else {
            const t = m.clone();
            t.rotate(-90, m.start), t.setLength(s), v = t.end
          }
          u && (y = m.angle() + r, d && (y = nC.normalize((y + 90) % 180 - 90)))
        } else v = p.start, c && v.translate(a);
        return h.createSVGMatrix().translate(v.x, v.y).rotate(y)
      }
      getLabelCoordinates(t) {
        const e = this.getLabelTransformationMatrix(t);
        return new hC(e.e, e.f)
      }
      getVertexIndex(t, e) {
        const n = this.cell.getVertices(),
          r = this.getClosestPointLength(new hC(t, e));
        let i = 0;
        if (null != r)
          for (const t = n.length; i < t; i += 1) {
            const t = n[i],
              e = this.getClosestPointLength(t);
            if (null != e && r < e) break
          }
        return i
      }
      getEventArgs(t, e, n) {
        const r = this,
          i = r.cell;
        return null == e || null == n ? {
          e: t,
          view: r,
          edge: i,
          cell: i
        } : {
          e: t,
          x: e,
          y: n,
          view: r,
          edge: i,
          cell: i
        }
      }
      notifyUnhandledMouseDown(t, e, n) {
        this.notify("edge:unhandled:mousedown", {
          e: t,
          x: e,
          y: n,
          view: this,
          cell: this.cell,
          edge: this.cell
        })
      }
      notifyMouseDown(t, e, n) {
        super.onMouseDown(t, e, n), this.notify("edge:mousedown", this.getEventArgs(t, e, n))
      }
      notifyMouseMove(t, e, n) {
        super.onMouseMove(t, e, n), this.notify("edge:mousemove", this.getEventArgs(t, e, n))
      }
      notifyMouseUp(t, e, n) {
        super.onMouseUp(t, e, n), this.notify("edge:mouseup", this.getEventArgs(t, e, n))
      }
      onClick(t, e, n) {
        super.onClick(t, e, n), this.notify("edge:click", this.getEventArgs(t, e, n))
      }
      onDblClick(t, e, n) {
        super.onDblClick(t, e, n), this.notify("edge:dblclick", this.getEventArgs(t, e, n))
      }
      onContextMenu(t, e, n) {
        super.onContextMenu(t, e, n), this.notify("edge:contextmenu", this.getEventArgs(t, e, n))
      }
      onMouseDown(t, e, n) {
        switch (this.notifyMouseDown(t, e, n), t.target.getAttribute("class")) {
          case "vertex":
            return void this.startVertexDragging(t, e, n);
          case "vertex-remove":
          case "vertex-remove-area":
            return void this.handleVertexRemoving(t, e, n);
          case "connection":
          case "connection-wrap":
            return void this.handleVertexAdding(t, e, n);
          case "arrowhead":
            return void this.startArrowheadDragging(t, e, n);
          case "source-marker":
          case "target-marker":
            return void this.notifyUnhandledMouseDown(t, e, n)
        }
        this.startEdgeDragging(t, e, n)
      }
      onMouseMove(t, e, n) {
        switch (this.getEventData(t).action) {
          case "drag-vertex":
            this.dragVertex(t, e, n);
            break;
          case "drag-label":
            this.dragLabel(t, e, n);
            break;
          case "drag-arrowhead":
            this.dragArrowhead(t, e, n);
            break;
          case "drag-edge":
            this.dragEdge(t, e, n)
        }
        this.notifyMouseMove(t, e, n)
      }
      onMouseUp(t, e, n) {
        switch (this.getEventData(t).action) {
          case "drag-vertex":
            this.stopVertexDragging(t, e, n);
            break;
          case "drag-label":
            this.stopLabelDragging(t, e, n);
            break;
          case "drag-arrowhead":
            this.stopArrowheadDragging(t, e, n);
            break;
          case "drag-edge":
            this.stopEdgeDragging(t, e, n)
        }
        this.notifyMouseUp(t, e, n), this.checkMouseleave(t)
      }
      onMouseOver(t) {
        super.onMouseOver(t), this.notify("edge:mouseover", this.getEventArgs(t))
      }
      onMouseOut(t) {
        super.onMouseOut(t), this.notify("edge:mouseout", this.getEventArgs(t))
      }
      onMouseEnter(t) {
        super.onMouseEnter(t), this.notify("edge:mouseenter", this.getEventArgs(t))
      }
      onMouseLeave(t) {
        super.onMouseLeave(t), this.notify("edge:mouseleave", this.getEventArgs(t))
      }
      onMouseWheel(t, e, n, r) {
        super.onMouseWheel(t, e, n, r), this.notify("edge:mousewheel", Object.assign({
          delta: r
        }, this.getEventArgs(t, e, n)))
      }
      onCustomEvent(t, e, n, r) {
        if (h.findParentByClass(t.target, "edge-tool", this.container)) {
          if (t.stopPropagation(), this.can("useEdgeTools")) {
            if ("edge:remove" === e) return void this.cell.remove({
              ui: !0
            });
            this.notify("edge:customevent", Object.assign({
              name: e
            }, this.getEventArgs(t, n, r)))
          }
          this.notifyMouseDown(t, n, r)
        } else this.notify("edge:customevent", Object.assign({
          name: e
        }, this.getEventArgs(t, n, r))), super.onCustomEvent(t, e, n, r)
      }
      onLabelMouseDown(t, e, n) {
        this.notifyMouseDown(t, e, n), this.startLabelDragging(t, e, n), this.getEventData(t).stopPropagation &&
          t.stopPropagation()
      }
      startEdgeDragging(t, e, n) {
        this.can("edgeMovable") ? this.setEventData(t, {
          x: e,
          y: n,
          action: "drag-edge"
        }) : this.notifyUnhandledMouseDown(t, e, n)
      }
      dragEdge(t, e, n) {
        const r = this.getEventData(t);
        r.dragged || (r.dragged = !0), this.cell.translate(e - r.x, n - r.y, {
          ui: !0
        }), this.setEventData(t, {
          x: e,
          y: n
        })
      }
      stopEdgeDragging(t, e, n) {
        const r = this.getEventData(t);
        r.dragged && (r.dragged = !1, this.notify("edge:moved", {
          e: t,
          x: e,
          y: n,
          view: this,
          cell: this.cell,
          edge: this.cell
        }))
      }
      prepareArrowheadDragging(t, e = {}) {
        const n = this.getTerminalMagnet(t),
          r = {
            action: "drag-arrowhead",
            isNewEdge: !0 === e.isNewEdge,
            terminalType: t,
            initialMagnet: n,
            initialTerminal: o.clone(this.cell[t]),
            fallbackAction: e.fallbackAction || "revert",
            getValidateConnectionArgs: this.createValidateConnectionArgs(t),
            options: e.options
          };
        return this.beforeArrowheadDragging(r), r
      }
      createValidateConnectionArgs(t) {
        const e = [];
        let n;
        e[4] = t, e[5] = this;
        let r = 0,
          i = 0;
        "source" === t ? (r = 2, n = "target") : (i = 2, n = "source");
        const o = this.cell[n],
          s = o.cell;
        if (s) {
          let t;
          const n = e[r] = this.graph.renderer.findViewByCell(s);
          n && (t = n.getMagnetFromEdgeTerminal(o)) === n.container && (t = void 0), e[r + 1] = t
        }
        return (t, n) => (e[i] = t, e[i + 1] = t.container === n ? void 0 : n, e)
      }
      beforeArrowheadDragging(t) {
        t.zIndex = this.cell.zIndex, this.cell.toFront();
        const e = this.container.style;
        t.pointerEvents = e.pointerEvents, e.pointerEvents = "none", this.graph.options.connecting.highlight &&
          this.highlightAvailableMagnets(t)
      }
      afterArrowheadDragging(t) {
        null != t.zIndex && (this.cell.setZIndex(t.zIndex, {
            ui: !0
          }), t.zIndex = null), this.container.style.pointerEvents = t.pointerEvents || "", this.graph.options.connecting
          .highlight && this.unhighlightAvailableMagnets(t)
      }
      arrowheadDragging(t, e, n, r) {
        r.currentTarget !== t && (r.currentMagnet && r.currentView && r.currentView.unhighlight(r.currentMagnet, {
          type: "magnetAdsorbed"
        }), r.currentView = this.graph.renderer.findViewByElem(t), r.currentView ? (r.currentMagnet = r.currentView
          .findMagnet(t), r.currentMagnet && this.graph.hook.validateConnection(...r.getValidateConnectionArgs(
            r.currentView, r.currentMagnet)) ? r.currentView.highlight(r.currentMagnet, {
            type: "magnetAdsorbed"
          }) : r.currentMagnet = null) : r.currentMagnet = null), r.currentTarget = t, this.cell.prop(r.terminalType, {
          x: e,
          y: n
        }, Object.assign(Object.assign({}, r.options), {
          ui: !0
        }))
      }
      arrowheadDragged(t, e, n) {
        const r = t.currentView,
          i = t.currentMagnet;
        if (!i || !r) return;
        r.unhighlight(i, {
          type: "magnetAdsorbed"
        });
        const o = t.terminalType,
          s = r.getEdgeTerminal(i, e, n, this.cell, o);
        this.cell.setTerminal(o, s, {
          ui: !0
        })
      }
      snapArrowhead(t, e, n) {
        const r = this.graph,
          i = r.options.connecting.snap,
          o = "object" == typeof i && i.radius || 50,
          s = r.renderer.findViewsInArea({
            x: t - o,
            y: e - o,
            width: 2 * o,
            height: 2 * o
          }),
          a = n.closestView || null,
          l = n.closestMagnet || null;
        let c;
        n.closestView = null, n.closestMagnet = null;
        let h = Number.MAX_SAFE_INTEGER;
        const u = new hC(t, e);
        let d;
        s.forEach(t => {
          "false" !== t.container.getAttribute("magnet") && (c = t.cell.getBBox().getCenter().distance(u)) <
            o && c < h && (l === t.container || r.hook.validateConnection(...n.getValidateConnectionArgs(t,
              null))) && (h = c, n.closestView = t, n.closestMagnet = t.container), t.container.querySelectorAll(
              "[magnet]").forEach(e => {
              if ("false" !== e.getAttribute("magnet")) {
                const i = t.getBBoxOfElement(e);
                (c = u.distance(i.getCenter())) < o && c < h && (l === e || r.hook.validateConnection(...
                  n.getValidateConnectionArgs(t, e))) && (h = c, n.closestView = t, n.closestMagnet = e)
              }
            })
        });
        const p = n.terminalType,
          f = n.closestView,
          g = n.closestMagnet,
          m = l !== g;
        if (a && m && a.unhighlight(l, {
            type: "magnetAdsorbed"
          }), f) {
          if (!m) return;
          f.highlight(g, {
            type: "magnetAdsorbed"
          }), d = f.getEdgeTerminal(g, t, e, this.cell, p)
        } else d = {
          x: t,
          y: e
        };
        this.cell.setTerminal(p, d, {}, Object.assign(Object.assign({}, n.options), {
          ui: !0
        }))
      }
      snapArrowheadEnd(t) {
        const e = t.closestView,
          n = t.closestMagnet;
        e && n && (e.unhighlight(n, {
          type: "magnetAdsorbed"
        }), t.currentMagnet = e.findMagnet(n)), t.closestView = null, t.closestMagnet = null
      }
      finishEmbedding(t) {
        this.graph.options.embedding.enabled && this.cell.updateParent() && (t.zIndex = null)
      }
      fallbackConnection(t) {
        switch (t.fallbackAction) {
          case "remove":
            this.cell.remove({
              ui: !0
            });
            break;
          case "revert":
          default:
            this.cell.prop(t.terminalType, t.initialTerminal, {
              ui: !0
            })
        }
      }
      notifyConnectionEvent(t, e) {
        const n = t.terminalType,
          r = t.initialTerminal,
          i = this.cell[n];
        if (i && !xk.equalTerminals(r, i)) {
          const o = this.graph,
            s = r,
            a = s.cell ? o.getCellById(s.cell) : null,
            l = s.port,
            c = a ? o.findViewByCell(a) : null,
            h = a ? null : hC.create(r).toJSON(),
            u = i,
            d = u.cell ? o.getCellById(u.cell) : null,
            p = s.port,
            f = d ? o.findViewByCell(d) : null,
            g = d ? null : hC.create(i).toJSON();
          this.notify("edge:connected", {
            e: e,
            previousCell: a,
            previousPort: l,
            previousView: c,
            previousPoint: h,
            currentCell: d,
            currentView: f,
            currentPort: p,
            currentPoint: g,
            previousMagnet: t.initialMagnet,
            currentMagnet: t.currentMagnet,
            edge: this.cell,
            view: this,
            type: n,
            isNew: t.isNewEdge
          })
        }
      }
      highlightAvailableMagnets(t) {
        const e = this.graph,
          n = e.model.getCells();
        t.marked = {};
        for (let r = 0, i = n.length; r < i; r += 1) {
          const i = e.renderer.findViewByCell(n[r]);
          if (!i) continue;
          const o = Array.prototype.slice.call(i.container.querySelectorAll("[magnet]"));
          "false" !== i.container.getAttribute("magnet") && o.push(i.container);
          const s = o.filter(n => e.hook.validateConnection(...t.getValidateConnectionArgs(i, n)));
          if (s.length > 0) {
            for (let t = 0, e = s.length; t < e; t += 1) i.highlight(s[t], {
              type: "magnetAvailable"
            });
            i.highlight(null, {
              type: "nodeAvailable"
            }), t.marked[i.cell.id] = s
          }
        }
      }
      unhighlightAvailableMagnets(t) {
        const e = t.marked || {};
        Object.keys(e).forEach(t => {
          const n = this.graph.renderer.findViewByCell(t);
          if (n) {
            e[t].forEach(t => {
              n.unhighlight(t, {
                type: "magnetAvailable"
              })
            }), n.unhighlight(null, {
              type: "nodeAvailable"
            })
          }
        }), t.marked = null
      }
      startArrowheadDragging(t, e, n) {
        if (!this.can("arrowheadMovable")) return void this.notifyUnhandledMouseDown(t, e, n);
        const r = t.target.getAttribute("data-terminal"),
          i = this.prepareArrowheadDragging(r);
        this.setEventData(t, i)
      }
      dragArrowhead(t, e, n) {
        const r = this.getEventData(t);
        this.graph.options.connecting.snap ? this.snapArrowhead(e, n, r) : this.arrowheadDragging(this.getEventTarget(
          t), e, n, r)
      }
      stopArrowheadDragging(t, e, n) {
        const r = this.graph,
          i = this.getEventData(t);
        r.options.connecting.snap ? this.snapArrowheadEnd(i) : this.arrowheadDragged(i, e, n), l.toDeferredBoolean(
          r.hook.validateEdge(this.cell, i.terminalType, i.initialTerminal)).then(e => {
          e ? (this.finishEmbedding(i), this.notifyConnectionEvent(i, t)) : this.fallbackConnection(i),
            this.afterArrowheadDragging(i)
        })
      }
      startLabelDragging(t, e, n) {
        if (this.can("edgeLabelMovable")) {
          const e = t.currentTarget,
            n = parseInt(e.getAttribute("data-index"), 10),
            r = this.getLabelPositionAngle(n),
            i = this.getLabelPositionArgs(n),
            o = this.getDefaultLabelPositionArgs(),
            s = this.mergeLabelPositionArgs(i, o);
          this.setEventData(t, {
            index: n,
            positionAngle: r,
            positionArgs: s,
            stopPropagation: !0,
            action: "drag-label"
          })
        } else this.setEventData(t, {
          stopPropagation: !0
        });
        this.graph.view.delegateDragEvents(t, this)
      }
      dragLabel(t, e, n) {
        const r = this.getEventData(t),
          i = {
            position: this.getLabelPosition(e, n, r.positionAngle, r.positionArgs)
          };
        this.cell.setLabelAt(r.index, i)
      }
      stopLabelDragging(t, e, n) {}
      handleVertexAdding(t, e, n) {
        if (!this.can("vertexAddable")) return void this.notifyUnhandledMouseDown(t, e, n);
        const r = this.addVertex({
          x: e,
          y: n
        }, {
          ui: !0
        });
        this.setEventData(t, {
          index: r,
          action: "drag-vertex"
        })
      }
      handleVertexRemoving(t, e, n) {
        if (!this.can("vertexDeletable")) return void this.notifyUnhandledMouseDown(t, e, n);
        const r = t.target,
          i = parseInt(r.getAttribute("idx"), 10);
        this.cell.removeVertexAt(i)
      }
      startVertexDragging(t, e, n) {
        if (!this.can("vertexMovable")) return void this.notifyUnhandledMouseDown(t, e, n);
        const r = t.target,
          i = parseInt(r.getAttribute("idx"), 10);
        this.setEventData(t, {
          index: i,
          action: "drag-vertex"
        })
      }
      dragVertex(t, e, n) {
        const r = this.getEventData(t);
        this.cell.setVertexAt(r.index, {
          x: e,
          y: n
        }, {
          ui: !0
        })
      }
      stopVertexDragging(t, e, n) {}
    }
    Ek.config({
      isSvgElement: !0,
      priority: 1,
      bootstrap: ["render", "source", "target"],
      actions: {
        view: ["render"],
        markup: ["render"],
        attrs: ["update"],
        source: ["source", "update"],
        target: ["target", "update"],
        router: ["update"],
        connector: ["update"],
        labels: ["labels"],
        defaultLabel: ["labels"],
        vertices: ["vertices", "update"],
        vertexMarkup: ["vertices"],
        toolMarkup: ["tools"],
        tools: ["widget"]
      },
      shortLength: 105,
      longLength: 155,
      toolsOffset: 40,
      doubleTools: !1,
      doubleToolsOffset: 65,
      sampleInterval: 50
    }), Ek.registry.register("edge", Ek, !0);
    class Sk extends dS {
      constructor() {
        super(...arguments), this.scalableNode = null, this.rotatableNode = null, this.scalableSelector =
          "scalable", this.rotatableSelector = "rotatable", this.defaultPortMarkup = oS.getPortMarkup(), this.defaultPortLabelMarkup =
          oS.getPortLabelMarkup(), this.defaultPortContainerMarkup = oS.getPortContainerMarkup(), this.portsCache = {}
      }
      getContainerClassName() {
        return [super.getContainerClassName(), this.prefixClassName("node")].join(" ")
      }
      isNodeView() {
        return !0
      }
      confirmUpdate(t, e = {}) {
        let n = t;
        return this.hasAction(n, "ports") && (this.removePorts(), this.cleanPortsCache()), this.hasAction(n,
          "render") ? (this.render(), n = this.removeAction(n, ["render", "update", "resize", "translate",
          "rotate", "ports", "tools"
        ])) : (n = this.handleAction(n, "resize", () => this.resize(e), "update"), n = this.handleAction(n,
            "update", () => this.update(), Jx.useCSSSelector ? "ports" : null), n = this.handleAction(n,
            "translate", () => this.translate()), n = this.handleAction(n, "rotate", () => this.rotate()), n =
          this.handleAction(n, "ports", () => this.renderPorts()), n = this.handleAction(n, "tools", () =>
            this.renderTools())), n
      }
      update(t) {
        this.cleanCache(), Jx.useCSSSelector && this.removePorts();
        const e = this.cell,
          n = e.getSize(),
          r = e.getAttrs();
        this.updateAttrs(this.container, r, {
          attrs: t === r ? null : t,
          rootBBox: new uC(0, 0, n.width, n.height),
          selectors: this.selectors,
          scalableNode: this.scalableNode,
          rotatableNode: this.rotatableNode
        }), Jx.useCSSSelector && this.renderPorts()
      }
      renderMarkup() {
        const t = this.cell.markup;
        if (t) return "string" == typeof t ? this.renderStringMarkup(t) : this.renderJSONMarkup(t);
        throw new TypeError("Invalid node markup.")
      }
      renderJSONMarkup(t) {
        const e = this.parseJSONMarkup(t, this.container),
          n = t => Array.isArray(t) ? t[0] : t;
        this.selectors = e.selectors, this.rotatableNode = n(this.selectors[this.rotatableSelector]), this.scalableNode =
          n(this.selectors[this.scalableSelector]), this.container.appendChild(e.fragment)
      }
      renderStringMarkup(t) {
        h.append(this.container, h.toHTMLElements(h.createVectors(t))), this.rotatableNode = h.findOne(this.container,
          `.${this.rotatableSelector}`), this.scalableNode = h.findOne(this.container,
          `.${this.scalableSelector}`), this.selectors = {}, this.rootSelector && (this.selectors[this.rootSelector] =
          this.container)
      }
      render() {
        return this.empty(), this.renderMarkup(), this.scalableNode && this.update(), this.resize(), this.rotatableNode ?
          (this.rotate(), this.translate()) : this.updateTransform(), Jx.useCSSSelector || this.renderPorts(),
          this.renderTools(), this
      }
      resize(t = {}) {
        if (this.scalableNode) return this.updateSize(t);
        this.cell.getAngle() && this.rotate(), this.update()
      }
      translate() {
        if (this.rotatableNode) return this.updateTranslation();
        this.updateTransform()
      }
      rotate() {
        if (this.rotatableNode) return this.updateRotation(), void this.update();
        this.updateTransform()
      }
      getTranslationString() {
        const t = this.cell.getPosition();
        return `translate(${t.x},${t.y})`
      }
      getRotationString() {
        const t = this.cell.getAngle();
        if (t) {
          const e = this.cell.getSize();
          return `rotate(${t},${e.width/2},${e.height/2})`
        }
      }
      updateTransform() {
        let t = this.getTranslationString();
        const e = this.getRotationString();
        e && (t += ` ${e}`), this.container.setAttribute("transform", t)
      }
      updateRotation() {
        if (null != this.rotatableNode) {
          const t = this.getRotationString();
          null != t ? this.rotatableNode.setAttribute("transform", t) : this.rotatableNode.removeAttribute(
            "transform")
        }
      }
      updateTranslation() {
        this.container.setAttribute("transform", this.getTranslationString())
      }
      updateSize(t = {}) {
        const e = this.cell,
          n = e.getSize(),
          r = e.getAngle(),
          i = this.scalableNode;
        let o = !1;
        i.getElementsByTagName("path").length > 0 && (o = !0);
        const s = h.getBBox(i, {
            recursive: o
          }),
          a = n.width / (s.width || 1),
          l = n.height / (s.height || 1);
        i.setAttribute("transform", `scale(${a},${l})`);
        const c = this.rotatableNode;
        if (null != c) {
          const o = c.getAttribute("transform");
          if (o) {
            c.setAttribute("transform", `${o} rotate(${-r},${n.width/2},${n.height/2})`);
            const s = h.getBBox(i, {
              target: this.graph.view.stage
            });
            e.prop("position", {
              x: s.x,
              y: s.y
            }, Object.assign({
              updated: !0
            }, t)), this.translate(), this.rotate()
          }
        }
        this.update()
      }
      findPortElem(t, e) {
        const n = t ? this.portsCache[t] : null;
        if (!n) return null;
        const r = n.portContentElement,
          i = n.portContentSelectors || {};
        return this.findOne(e, r, i)
      }
      initializePorts() {
        this.cleanPortsCache()
      }
      refreshPorts() {
        this.removePorts(), this.cleanPortsCache(), this.renderPorts()
      }
      cleanPortsCache() {
        this.portsCache = {}
      }
      removePorts() {
        Object.keys(this.portsCache).forEach(t => {
          const e = this.portsCache[t];
          h.remove(e.portElement)
        })
      }
      renderPorts() {
        const t = this.getPortsContainer(),
          e = [];
        t.childNodes.forEach(t => {
          e.push(t)
        });
        const n = i.groupBy(this.cell.getParsedPorts(), "zIndex");
        n.auto && n.auto.forEach(n => {
          const r = this.getPortElement(n);
          t.append(r), e.push(r)
        }), Object.keys(n).forEach(t => {
          if ("auto" !== t) {
            const r = parseInt(t, 10);
            this.appendPorts(n[t], r, e)
          }
        }), this.updatePorts()
      }
      getPortsContainer() {
        return this.rotatableNode || this.container
      }
      appendPorts(t, e, n) {
        const r = t.map(t => this.getPortElement(t));
        n[e] || e < 0 ? h.before(n[Math.max(e, 0)], r) : h.append(this.getPortsContainer(), r)
      }
      getPortElement(t) {
        const e = this.portsCache[t.id];
        return e ? e.portElement : this.createPortElement(t)
      }
      createPortElement(t) {
        let e = oS.renderMarkup(this.getPortContainerMarkup());
        const n = e.elem;
        if (null == n) throw new Error("Invalid port container markup.");
        const r = (e = oS.renderMarkup(this.getPortMarkup(t))).elem,
          i = e.selectors;
        if (null == r) throw new Error("Invalid port markup.");
        this.setAttrs({
          port: t.id,
          "port-group": t.group
        }, r);
        const o = (e = oS.renderMarkup(this.getPortLabelMarkup(t.label))).elem,
          s = e.selectors;
        if (null == o) throw new Error("Invalid port label markup.");
        let a;
        if (i && s) {
          for (const t in s)
            if (i[t] && t !== this.rootSelector) throw new Error("Selectors within port must be unique.");
          a = Object.assign(Object.assign({}, i), s)
        } else a = i || s;
        return h.addClass(n, "x6-port"), h.addClass(r, "x6-port-body"), h.addClass(o, "x6-port-label"), n.appendChild(
          r), n.appendChild(o), this.portsCache[t.id] = {
          portElement: n,
          portSelectors: a,
          portLabelElement: o,
          portLabelSelectors: s,
          portContentElement: r,
          portContentSelectors: i
        }, this.graph.hook.onPortRendered({
          port: t,
          node: this.cell,
          container: n,
          selectors: a,
          labelContainer: o,
          labelSelectors: s,
          contentContainer: r,
          contentSelectors: i
        }), n
      }
      updatePorts() {
        this.updatePortGroup();
        const t = this.cell.getParsedGroups();
        Object.keys(t).forEach(t => this.updatePortGroup(t))
      }
      updatePortGroup(t) {
        const e = uC.fromSize(this.cell.getSize()),
          n = this.cell.getPortsLayoutByGroup(t, e);
        for (let t = 0, e = n.length; t < e; t += 1) {
          const e = n[t],
            r = e.portId,
            i = this.portsCache[r] || {},
            o = e.portLayout;
          if (this.applyPortTransform(i.portElement, o), null != e.portAttrs) {
            const t = {
              selectors: i.portSelectors || {}
            };
            e.portSize && (t.rootBBox = uC.fromSize(e.portSize)), this.updateAttrs(i.portElement, e.portAttrs,
              t)
          }
          const s = e.labelLayout;
          if (s && (this.applyPortTransform(i.portLabelElement, s, -(o.angle || 0)), s.attrs)) {
            const t = {
              selectors: i.portLabelSelectors || {}
            };
            e.labelSize && (t.rootBBox = uC.fromSize(e.labelSize)), this.updateAttrs(i.portLabelElement, s.attrs,
              t)
          }
        }
      }
      applyPortTransform(t, e, n = 0) {
        const r = e.angle,
          i = e.position,
          o = h.createSVGMatrix().rotate(n).translate(i.x || 0, i.y || 0).rotate(r || 0);
        h.transform(t, o, {
          absolute: !0
        })
      }
      getPortContainerMarkup() {
        return this.cell.getPortContainerMarkup() || this.defaultPortContainerMarkup
      }
      getPortMarkup(t) {
        return t.markup || this.cell.portMarkup || this.defaultPortMarkup
      }
      getPortLabelMarkup(t) {
        return t.markup || this.cell.portLabelMarkup || this.defaultPortLabelMarkup
      }
      getEventArgs(t, e, n) {
        const r = this,
          i = r.cell;
        return null == e || null == n ? {
          e: t,
          view: r,
          node: i,
          cell: i
        } : {
          e: t,
          x: e,
          y: n,
          view: r,
          node: i,
          cell: i
        }
      }
      notifyMouseDown(t, e, n) {
        super.onMouseDown(t, e, n), this.notify("node:mousedown", this.getEventArgs(t, e, n))
      }
      notifyMouseMove(t, e, n) {
        super.onMouseMove(t, e, n), this.notify("node:mousemove", this.getEventArgs(t, e, n))
      }
      notifyMouseUp(t, e, n) {
        super.onMouseUp(t, e, n), this.notify("node:mouseup", this.getEventArgs(t, e, n))
      }
      onClick(t, e, n) {
        super.onClick(t, e, n), this.notify("node:click", this.getEventArgs(t, e, n))
      }
      onDblClick(t, e, n) {
        super.onDblClick(t, e, n), this.notify("node:dblclick", this.getEventArgs(t, e, n))
      }
      onContextMenu(t, e, n) {
        super.onContextMenu(t, e, n), this.notify("node:contextmenu", this.getEventArgs(t, e, n))
      }
      onMouseDown(t, e, n) {
        this.isPropagationStopped(t) || (this.notifyMouseDown(t, e, n), this.startNodeDragging(t, e, n))
      }
      onMouseMove(t, e, n) {
        const r = this.getEventData(t),
          i = r.action;
        if ("magnet" === i) this.dragMagnet(t, e, n);
        else {
          if ("move" === i) {
            (r.targetView || this).dragNode(t, e, n)
          }
          this.notifyMouseMove(t, e, n)
        }
        this.setEventData(t, r)
      }
      onMouseUp(t, e, n) {
        const r = this.getEventData(t),
          i = r.action;
        if ("magnet" === i) this.stopMagnetDragging(t, e, n);
        else if (this.notifyMouseUp(t, e, n), "move" === i) {
          (r.targetView || this).stopNodeDragging(t, e, n)
        }
        const o = r.targetMagnet;
        o && this.onMagnetClick(t, o, e, n), this.checkMouseleave(t)
      }
      onMouseOver(t) {
        super.onMouseOver(t), this.notify("node:mouseover", this.getEventArgs(t))
      }
      onMouseOut(t) {
        super.onMouseOut(t), this.notify("node:mouseout", this.getEventArgs(t))
      }
      onMouseEnter(t) {
        super.onMouseEnter(t), this.notify("node:mouseenter", this.getEventArgs(t))
      }
      onMouseLeave(t) {
        super.onMouseLeave(t), this.notify("node:mouseleave", this.getEventArgs(t))
      }
      onMouseWheel(t, e, n, r) {
        super.onMouseWheel(t, e, n, r), this.notify("node:mousewheel", Object.assign({
          delta: r
        }, this.getEventArgs(t, e, n)))
      }
      onMagnetClick(t, e, n, r) {
        this.graph.view.getMouseMovedCount(t) > this.graph.options.clickThreshold || this.notify(
          "node:magnet:click", Object.assign({
            magnet: e
          }, this.getEventArgs(t, n, r)))
      }
      onMagnetDblClick(t, e, n, r) {
        this.notify("node:magnet:dblclick", Object.assign({
          magnet: e
        }, this.getEventArgs(t, n, r)))
      }
      onMagnetContextMenu(t, e, n, r) {
        this.notify("node:magnet:contextmenu", Object.assign({
          magnet: e
        }, this.getEventArgs(t, n, r)))
      }
      onMagnetMouseDown(t, e, n, r) {
        this.startMagnetDragging(t, n, r)
      }
      onCustomEvent(t, e, n, r) {
        this.notify("node:customevent", Object.assign({
          name: e
        }, this.getEventArgs(t, n, r))), super.onCustomEvent(t, e, n, r)
      }
      prepareEmbedding(t) {
        const e = t.cell || this.cell,
          n = (t.graph || this.graph).model;
        n.startBatch("to-front"), e.toFront({
          deep: !0,
          ui: !0
        });
        const r = n.getNodes().reduce((t, e) => Math.max(t, e.getZIndex() || 0), 0);
        n.getConnectedEdges(e, {
          deep: !0,
          enclosed: !0
        }).forEach(t => {
          (t.getZIndex() || 0) <= r && t.setZIndex(r + 1, {
            ui: !0
          })
        }), n.stopBatch("to-front");
        const i = e.getParent();
        i && i.unembed(e, {
          ui: !0
        })
      }
      processEmbedding(t) {
        const e = t.cell || this.cell,
          n = t.graph || this.graph,
          r = n.options.embedding,
          i = r.findParent;
        let o = "function" == typeof i ? l.call(i, n, {
          view: this,
          node: this.cell
        }).filter(t => t instanceof fk && this.cell.id !== t.id && !t.isDescendantOf(this.cell)) : n.model.getNodesUnderNode(
          e, {
            by: r.findParent
          });
        r.frontOnly && (o = o.slice(-1));
        let s = null;
        const a = t.candidateEmbedView,
          c = r.validate;
        for (let t = o.length - 1; t >= 0; t -= 1) {
          const e = o[t];
          if (a && a.cell.id === e.id) {
            s = a;
            break
          } {
            const t = e.findView(n);
            if (l.call(c, n, {
                child: this.cell,
                parent: t.cell,
                childView: this,
                parentView: t
              })) {
              s = t;
              break
            }
          }
        }
        s && s !== a && (this.clearEmbedding(t), s.highlight(null, {
          type: "embedding"
        }), t.candidateEmbedView = s), !s && a && this.clearEmbedding(t)
      }
      clearEmbedding(t) {
        const e = t.candidateEmbedView;
        e && (e.unhighlight(null, {
          type: "embedding"
        }), t.candidateEmbedView = null)
      }
      finalizeEmbedding(t) {
        const e = t.cell || this.cell,
          n = t.graph || this.graph,
          r = t.candidateEmbedView;
        r && (r.cell.insertChild(e, void 0, {
          ui: !0
        }), r.unhighlight(null, {
          type: "embedding"
        }), t.candidateEmbedView = null), n.model.getConnectedEdges(e, {
          deep: !0
        }).forEach(t => {
          t.updateParent({
            ui: !0
          })
        })
      }
      getDelegatedView() {
        let t = this.cell,
          e = this;
        for (; e && !t.isEdge();) {
          if (!t.hasParent() || e.can("stopDelegateOnDragging")) return e;
          t = t.getParent(), e = this.graph.renderer.findViewByCell(t)
        }
        return null
      }
      startMagnetDragging(t, e, n) {
        if (!this.can("magnetConnectable")) return;
        t.stopPropagation();
        const r = t.currentTarget,
          i = this.graph;
        this.setEventData(t, {
          targetMagnet: r
        }), i.hook.validateMagnet(this, r, t) ? (i.options.magnetThreshold <= 0 && this.startConnectting(t, r,
          e, n), this.setEventData(t, {
          action: "magnet"
        }), this.stopPropagation(t)) : this.onMouseDown(t, e, n), i.view.delegateDragEvents(t, this)
      }
      startConnectting(t, e, n, r) {
        this.graph.model.startBatch("add-edge");
        const i = this.createEdgeFromMagnet(e, n, r);
        i.notifyMouseDown(t, n, r), i.setEventData(t, i.prepareArrowheadDragging("target", {
          isNewEdge: !0,
          fallbackAction: "remove"
        })), this.setEventData(t, {
          edgeView: i
        })
      }
      createEdgeFromMagnet(t, e, n) {
        const r = this.graph,
          i = r.model,
          o = r.hook.getDefaultEdge(this, t);
        return o.setSource(Object.assign(Object.assign({}, o.getSource()), this.getEdgeTerminal(t, e, n, o,
          "source"))), o.setTarget(Object.assign(Object.assign({}, o.getTarget()), {
          x: e,
          y: n
        })), o.addTo(i, {
          async: !1,
          ui: !0
        }), o.findView(r)
      }
      dragMagnet(t, e, n) {
        const r = this.getEventData(t),
          i = r.edgeView;
        if (i) i.onMouseMove(t, e, n);
        else {
          const i = this.graph,
            o = i.options.magnetThreshold,
            s = this.getEventTarget(t),
            a = r.targetMagnet;
          if ("onleave" === o) {
            if (a === s || a.contains(s)) return
          } else if (i.view.getMouseMovedCount(t) <= o) return;
          this.startConnectting(t, a, e, n)
        }
      }
      stopMagnetDragging(t, e, n) {
        const r = this.eventData(t).edgeView;
        r && (r.onMouseUp(t, e, n), this.graph.model.stopBatch("add-edge"))
      }
      notifyUnhandledMouseDown(t, e, n) {
        this.notify("node:unhandled:mousedown", {
          e: t,
          x: e,
          y: n,
          view: this,
          cell: this.cell,
          node: this.cell
        })
      }
      startNodeDragging(t, e, n) {
        const r = this.getDelegatedView();
        if (null == r || !r.can("nodeMovable")) return this.notifyUnhandledMouseDown(t, e, n);
        this.setEventData(t, {
          targetView: r,
          action: "move"
        });
        const i = hC.create(r.cell.getPosition());
        r.setEventData(t, {
          offset: i.diff(e, n),
          restrict: this.graph.hook.getRestrictArea(r)
        })
      }
      dragNode(t, e, n) {
        const r = this.cell,
          i = this.graph,
          o = i.getGridSize(),
          s = this.getEventData(t),
          a = s.offset,
          l = s.restrict;
        let c = s.embedding;
        const h = oE.snapToGrid(e + a.x, o),
          u = oE.snapToGrid(n + a.y, o),
          d = this.getEventData(t);
        d.moved || (d.moved = !0), r.setPosition(h, u, {
            restrict: l,
            deep: !0,
            ui: !0
          }), i.options.embedding.enabled && (c || (this.prepareEmbedding(s), c = !0), this.processEmbedding(s)),
          this.setEventData(t, {
            embedding: c
          })
      }
      stopNodeDragging(t, e, n) {
        this.getEventData(t).moved && this.notify("node:moved", {
          e: t,
          x: e,
          y: n,
          view: this,
          cell: this.cell,
          node: this.cell
        });
        const r = this.getEventData(t);
        r.embedding && this.finalizeEmbedding(r)
      }
    }
    Sk.config({
      isSvgElement: !0,
      priority: 0,
      bootstrap: ["render"],
      actions: {
        view: ["render"],
        markup: ["render"],
        attrs: ["update"],
        size: ["resize", "ports", "tools"],
        angle: ["rotate", "tools"],
        position: ["translate", "tools"],
        ports: ["ports"],
        tools: ["tools"]
      }
    }), Sk.registry.register("node", Sk, !0);
    var Mk, kk = this && this.__rest || function(t, e) {
      var n = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
          .call(t, r[i]) && (n[r[i]] = t[r[i]])
      }
      return n
    };
    class Ok extends yk {
      get label() {
        return this.getLabel()
      }
      set label(t) {
        this.setLabel(t)
      }
      getLabel() {
        return this.getAttrByPath("text/text")
      }
      setLabel(t, e) {
        return null == t ? this.removeLabel() : this.setAttrByPath("text/text", t, e), this
      }
      removeLabel() {
        return this.removeAttrByPath("text/text"), this
      }
    }(Ok || (Ok = {})).config({
      attrs: {
        text: {
          fontSize: 14,
          fill: "#000000",
          refX: .5,
          refY: .5,
          textAnchor: "middle",
          textVerticalAnchor: "middle",
          fontFamily: "Arial, helvetica, sans-serif"
        }
      },
      propHooks(t) {
        const {
          label: e
        } = t, n = kk(t, ["label"]);
        return e && o.setByPath(n, "attrs/text/text", e), n
      }
    });
    class Pk extends Ok {
      get html() {
        return this.getHTML()
      }
      set html(t) {
        this.setHTML(t)
      }
      getHTML() {
        return this.store.get("html")
      }
      setHTML(t, e = {}) {
        return null == t ? this.removeHTML(e) : this.store.set("html", t, e), this
      }
      removeHTML(t = {}) {
        return this.store.remove("html", t)
      }
    }! function(t) {
      class e extends Sk {
        render() {
          return super.render(), this.renderHTMLComponent(), this
        }
        confirmUpdate(t) {
          const n = super.confirmUpdate(t);
          return this.handleAction(n, e.action, () => this.renderHTMLComponent())
        }
        renderHTMLComponent() {
          const t = this.selectors.foContent;
          if (t) {
            const e = this.$(t).empty(),
              n = this.graph.hook.getHTMLComponent(this.cell);
            n && ("string" == typeof n ? e.html(n) : e.append(n))
          }
        }
      }
      t.View = e,
        function(t) {
          t.action = "html", t.config({
            bootstrap: [t.action],
            actions: {
              html: t.action
            }
          }), Sk.registry.register("html-view", t)
        }(e = t.View || (t.View = {}))
    }(Pk || (Pk = {})), (Mk = Pk || (Pk = {})).config({
      view: "html-view",
      markup: [{
        tagName: "rect",
        selector: "body"
      }, Object.assign({}, oS.getForeignObjectMarkup()), {
        tagName: "text",
        selector: "label"
      }],
      attrs: {
        body: {
          fill: "none",
          stroke: "none",
          refWidth: "100%",
          refHeight: "100%"
        },
        fo: {
          refWidth: "100%",
          refHeight: "100%"
        }
      }
    }), yk.registry.register("html", Mk), (Pk || (Pk = {})).componentRegistry = Kx.create({
      type: "html componnet"
    });
    class Dk extends Ix {
      constructor(t) {
        super(), this.graph = t, this.init()
      }
      get options() {
        return this.graph.options
      }
      get model() {
        return this.graph.model
      }
      get view() {
        return this.graph.view
      }
      init() {}
    }
    var Tk, _k = this && this.__decorate || function(t, e, n, r) {
      var i, o = arguments.length,
        s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r);
      else
        for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) ||
          s);
      return o > 3 && s && Object.defineProperty(e, n, s), s
    };
    class jk extends ZE {
      constructor(t) {
        super(), this.graph = t;
        const {
          selectors: e,
          fragment: n
        } = oS.parseJSONMarkup(jk.markup);
        this.background = e.background, this.grid = e.grid, this.svg = e.svg, this.defs = e.defs, this.viewport =
          e.viewport, this.primer = e.primer, this.stage = e.stage, this.decorator = e.decorator, this.overlay =
          e.overlay, this.container = this.options.container, this.$(this.container).addClass(this.prefixClassName(
            "graph")).append(n), this.delegateEvents()
      }
      get model() {
        return this.graph.model
      }
      get options() {
        return this.graph.options
      }
      delegateEvents() {
        const t = this.constructor;
        return super.delegateEvents(t.events), this
      }
      guard(t, e) {
        return "mousedown" === t.type && 2 === t.button || (!(!this.options.guard || !this.options.guard(t, e)) ||
          (t.data && void 0 !== t.data.guarded ? t.data.guarded : !(e && e.cell && e.cell instanceof fk) && (
            this.svg !== t.target && this.container !== t.target && !P.a.contains(this.svg, t.target))))
      }
      findView(t) {
        return this.graph.renderer.findViewByElem(t)
      }
      onDblClick(t) {
        t.preventDefault();
        const e = this.normalizeEvent(t),
          n = this.findView(e.target);
        if (this.guard(e, n)) return;
        const r = this.graph.snapToGrid(e.clientX, e.clientY);
        n ? n.onDblClick(e, r.x, r.y) : this.graph.trigger("blank:dblclick", {
          e: e,
          x: r.x,
          y: r.y
        })
      }
      onClick(t) {
        if (this.getMouseMovedCount(t) <= this.options.clickThreshold) {
          const e = this.normalizeEvent(t),
            n = this.findView(e.target);
          if (this.guard(e, n)) return;
          const r = this.graph.snapToGrid(e.clientX, e.clientY);
          n ? n.onClick(e, r.x, r.y) : this.graph.trigger("blank:click", {
            e: e,
            x: r.x,
            y: r.y
          })
        }
      }
      onContextMenu(t) {
        this.options.preventDefaultContextMenu && t.preventDefault();
        const e = this.normalizeEvent(t),
          n = this.findView(e.target);
        if (this.guard(e, n)) return;
        const r = this.graph.snapToGrid(e.clientX, e.clientY);
        n ? n.onContextMenu(e, r.x, r.y) : this.graph.trigger("blank:contextmenu", {
          e: e,
          x: r.x,
          y: r.y
        })
      }
      delegateDragEvents(t, e) {
        null == t.data && (t.data = {}), this.setEventData(t, {
          currentView: e || null,
          mouseMovedCount: 0
        });
        const n = this.constructor;
        this.delegateDocumentEvents(n.documentEvents, t.data), this.undelegateEvents()
      }
      getMouseMovedCount(t) {
        return this.getEventData(t).mouseMovedCount || 0
      }
      onMouseDown(t) {
        const e = this.normalizeEvent(t),
          n = this.findView(e.target);
        if (this.guard(e, n)) return;
        const r = this.graph.snapToGrid(e.clientX, e.clientY);
        n ? (e.preventDefault(), n.onMouseDown(e, r.x, r.y)) : (this.options.preventDefaultBlankAction && e.preventDefault(),
          this.graph.trigger("blank:mousedown", {
            e: e,
            x: r.x,
            y: r.y
          })), this.delegateDragEvents(e, n)
      }
      onMouseMove(t) {
        const e = this.getEventData(t);
        if (null == e.mouseMovedCount && (e.mouseMovedCount = 0), e.mouseMovedCount += 1, e.mouseMovedCount <=
          this.options.moveThreshold) return;
        const n = this.normalizeEvent(t),
          r = this.graph.snapToGrid(n.clientX, n.clientY),
          i = e.currentView;
        i ? i.onMouseMove(n, r.x, r.y) : this.graph.trigger("blank:mousemove", {
          e: n,
          x: r.x,
          y: r.y
        }), this.setEventData(n, e)
      }
      onMouseUp(t) {
        this.undelegateDocumentEvents();
        const e = this.normalizeEvent(t),
          n = this.graph.snapToGrid(e.clientX, e.clientY),
          r = this.getEventData(t).currentView;
        r ? r.onMouseUp(e, n.x, n.y) : this.graph.trigger("blank:mouseup", {
          e: e,
          x: n.x,
          y: n.y
        }), t.isPropagationStopped() || this.onClick(P.a.Event(t, {
          type: "click",
          data: t.data
        })), t.stopImmediatePropagation(), this.delegateEvents()
      }
      onMouseOver(t) {
        const e = this.normalizeEvent(t),
          n = this.findView(e.target);
        if (!this.guard(e, n))
          if (n) n.onMouseOver(e);
          else {
            if (this.container === e.target) return;
            this.graph.trigger("blank:mouseover", {
              e: e
            })
          }
      }
      onMouseOut(t) {
        const e = this.normalizeEvent(t),
          n = this.findView(e.target);
        if (!this.guard(e, n))
          if (n) n.onMouseOut(e);
          else {
            if (this.container === e.target) return;
            this.graph.trigger("blank:mouseout", {
              e: e
            })
          }
      }
      onMouseEnter(t) {
        const e = this.normalizeEvent(t),
          n = this.findView(e.target);
        if (this.guard(e, n)) return;
        const r = this.graph.renderer.findViewByElem(e.relatedTarget);
        if (n) {
          if (r === n) return;
          n.onMouseEnter(e)
        } else {
          if (r) return;
          this.graph.trigger("graph:mouseenter", {
            e: e
          })
        }
      }
      onMouseLeave(t) {
        const e = this.normalizeEvent(t),
          n = this.findView(e.target);
        if (this.guard(e, n)) return;
        const r = this.graph.renderer.findViewByElem(e.relatedTarget);
        if (n) {
          if (r === n) return;
          n.onMouseLeave(e)
        } else {
          if (r) return;
          this.graph.trigger("graph:mouseleave", {
            e: e
          })
        }
      }
      onMouseWheel(t) {
        const e = this.normalizeEvent(t),
          n = this.findView(e.target);
        if (this.guard(e, n)) return;
        const r = e.originalEvent,
          i = this.graph.snapToGrid(r.clientX, r.clientY),
          o = Math.max(-1, Math.min(1, r.wheelDelta || -r.detail));
        n ? n.onMouseWheel(e, i.x, i.y, o) : this.graph.trigger("blank:mousewheel", {
          e: e,
          delta: o,
          x: i.x,
          y: i.y
        })
      }
      onCustomEvent(t) {
        const e = t.currentTarget,
          n = e.getAttribute("event") || e.getAttribute("data-event");
        if (n) {
          const r = this.findView(e);
          if (r) {
            const e = this.normalizeEvent(t);
            if (this.guard(e, r)) return;
            const i = this.graph.snapToGrid(e.clientX, e.clientY);
            r.onCustomEvent(e, n, i.x, i.y)
          }
        }
      }
      handleMagnetEvent(t, e) {
        const n = t.currentTarget,
          r = n.getAttribute("magnet");
        if (r && "false" !== r.toLowerCase()) {
          const r = this.findView(n);
          if (r) {
            const i = this.normalizeEvent(t);
            if (this.guard(i, r)) return;
            const o = this.graph.snapToGrid(i.clientX, i.clientY);
            l.call(e, this.graph, r, i, n, o.x, o.y)
          }
        }
      }
      onMagnetMouseDown(t) {
        this.handleMagnetEvent(t, (t, e, n, r, i) => {
          t.onMagnetMouseDown(e, n, r, i)
        })
      }
      onMagnetDblClick(t) {
        this.handleMagnetEvent(t, (t, e, n, r, i) => {
          t.onMagnetDblClick(e, n, r, i)
        })
      }
      onMagnetContextMenu(t) {
        this.options.preventDefaultContextMenu && t.preventDefault(), this.handleMagnetEvent(t, (t, e, n, r, i) => {
          t.onMagnetContextMenu(e, n, r, i)
        })
      }
      onLabelMouseDown(t) {
        const e = t.currentTarget,
          n = this.findView(e);
        if (n) {
          const e = this.normalizeEvent(t);
          if (this.guard(e, n)) return;
          const r = this.graph.snapToGrid(e.clientX, e.clientY);
          n.onLabelMouseDown(e, r.x, r.y)
        }
      }
      onImageDragStart() {
        return !1
      }
      dispose() {
        const t = this.graph.scroller.widget;
        t && t.dispose(), this.undelegateEvents(), this.undelegateDocumentEvents()
      }
    }
    _k([ZE.dispose()], jk.prototype, "dispose", null),
      function(t) {
        const e = `${Jx.prefixCls}-graph`;
        t.markup = [{
          ns: h.ns.xhtml,
          tagName: "div",
          selector: "background",
          className: `${e}-background`
        }, {
          ns: h.ns.xhtml,
          tagName: "div",
          selector: "grid",
          className: `${e}-grid`
        }, {
          ns: h.ns.svg,
          tagName: "svg",
          selector: "svg",
          className: `${e}-svg`,
          attrs: {
            width: "100%",
            height: "100%",
            "xmlns:xlink": h.ns.xlink
          },
          children: [{
            tagName: "defs",
            selector: "defs"
          }, {
            tagName: "g",
            selector: "viewport",
            className: `${e}-svg-viewport`,
            children: [{
              tagName: "g",
              selector: "primer",
              className: `${e}-svg-primer`
            }, {
              tagName: "g",
              selector: "stage",
              className: `${e}-svg-stage`
            }, {
              tagName: "g",
              selector: "decorator",
              className: `${e}-svg-decorator`
            }, {
              tagName: "g",
              selector: "overlay",
              className: `${e}-svg-overlay`
            }]
          }]
        }]
      }(jk || (jk = {})),
      function(t) {
        const e = Jx.prefixCls;
        t.events = {
          dblclick: "onDblClick",
          contextmenu: "onContextMenu",
          touchstart: "onMouseDown",
          mousedown: "onMouseDown",
          mouseover: "onMouseOver",
          mouseout: "onMouseOut",
          mouseenter: "onMouseEnter",
          mouseleave: "onMouseLeave",
          mousewheel: "onMouseWheel",
          DOMMouseScroll: "onMouseWheel",
          [`mouseenter  .${e}-cell`]: "onMouseEnter",
          [`mouseleave  .${e}-cell`]: "onMouseLeave",
          [`mouseenter  .${e}-cell-tools`]: "onMouseEnter",
          [`mouseleave  .${e}-cell-tools`]: "onMouseLeave",
          [`mousedown   .${e}-cell [event]`]: "onCustomEvent",
          [`touchstart  .${e}-cell [event]`]: "onCustomEvent",
          [`mousedown   .${e}-cell [data-event]`]: "onCustomEvent",
          [`touchstart  .${e}-cell [data-event]`]: "onCustomEvent",
          [`dblclick    .${e}-cell [magnet]`]: "onMagnetDblClick",
          [`contextmenu .${e}-cell [magnet]`]: "onMagnetContextMenu",
          [`mousedown   .${e}-cell [magnet]`]: "onMagnetMouseDown",
          [`touchstart  .${e}-cell [magnet]`]: "onMagnetMouseDown",
          [`dblclick    .${e}-cell [data-magnet]`]: "onMagnetDblClick",
          [`contextmenu .${e}-cell [data-magnet]`]: "onMagnetContextMenu",
          [`mousedown   .${e}-cell [data-magnet]`]: "onMagnetMouseDown",
          [`touchstart  .${e}-cell [data-magnet]`]: "onMagnetMouseDown",
          [`dragstart   .${e}-cell image`]: "onImageDragStart",
          [`mousedown   .${e}-edge .label`]: "onLabelMouseDown",
          [`touchstart  .${e}-edge .label`]: "onLabelMouseDown"
        }, t.documentEvents = {
          mousemove: "onMouseMove",
          touchmove: "onMouseMove",
          mouseup: "onMouseUp",
          touchend: "onMouseUp",
          touchcancel: "onMouseUp"
        }
      }(jk || (jk = {})),
      function(t) {
        (Tk || (Tk = {})).checkScroller = function(t, e) {
          return (n, r, i) => {
            const o = i.value;
            i.value = function(...n) {
              if (null == this.scroller.widget) {
                const n = `Shoule enable scroller to use method '${r}'`;
                if (!1 !== t) throw console.error(n), new Error(n);
                return !1 !== e && console.warn(n), this
              }
              return o.call(this, ...n)
            }
          }
        }
      }();
    const Lk =
      ".x6-graph {\n  position: relative;\n  outline: none;\n}\n.x6-graph-background,\n.x6-graph-grid,\n.x6-graph-svg {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.x6-graph-background-stage,\n.x6-graph-grid-stage,\n.x6-graph-svg-stage {\n  user-select: none;\n}\n.x6-node {\n  cursor: move;\n  /* stylelint-disable-next-line */\n}\n.x6-node * {\n  -webkit-user-drag: none;\n}\n.x6-node .scalable * {\n  vector-effect: non-scaling-stroke;\n}\n.x6-node [magnet='true'] {\n  cursor: crosshair;\n  transition: opacity 0.3s;\n}\n.x6-node [magnet='true']:hover {\n  opacity: 0.7;\n}\n.x6-node foreignobject {\n  display: block;\n  overflow: visible;\n  background-color: transparent;\n}\n.x6-node foreignobject > body {\n  position: static;\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  overflow: visible;\n  background-color: transparent;\n}\n.x6-edge .source-marker,\n.x6-edge .target-marker {\n  vector-effect: non-scaling-stroke;\n}\n.x6-edge .connection {\n  stroke-linejoin: round;\n  fill: none;\n}\n.x6-edge .connection-wrap {\n  cursor: move;\n  opacity: 0;\n  fill: none;\n  stroke: #000;\n  stroke-width: 15;\n  stroke-linecap: round;\n  stroke-linejoin: round;\n}\n.x6-edge .connection-wrap:hover {\n  opacity: 0.4;\n  stroke-opacity: 0.4;\n}\n.x6-edge .vertices {\n  cursor: move;\n  opacity: 0;\n}\n.x6-edge .vertices .vertex {\n  fill: #1abc9c;\n}\n.x6-edge .vertices .vertex :hover {\n  fill: #34495e;\n  stroke: none;\n}\n.x6-edge .vertices .vertex-remove {\n  cursor: pointer;\n  fill: #fff;\n}\n.x6-edge .vertices .vertex-remove-area {\n  cursor: pointer;\n  opacity: 0.1;\n}\n.x6-edge .vertices .vertex-group:hover .vertex-remove-area {\n  opacity: 1;\n}\n.x6-edge .arrowheads {\n  cursor: move;\n  opacity: 0;\n}\n.x6-edge .arrowheads .arrowhead {\n  fill: #1abc9c;\n}\n.x6-edge .arrowheads .arrowhead :hover {\n  fill: #f39c12;\n  stroke: none;\n}\n.x6-edge .tools {\n  cursor: pointer;\n  opacity: 0;\n}\n.x6-edge .tools .tool-options {\n  display: none;\n}\n.x6-edge .tools .tool-remove circle {\n  fill: #f00;\n}\n.x6-edge .tools .tool-remove path {\n  fill: #fff;\n}\n.x6-edge:hover .vertices,\n.x6-edge:hover .arrowheads,\n.x6-edge:hover .tools {\n  opacity: 1;\n}\n.x6-highlight-opacity {\n  opacity: 0.3;\n}\n@keyframes halo-pie-visibility {\n  0% {\n    visibility: hidden;\n  }\n  100% {\n    visibility: visible;\n  }\n}\n@keyframes halo-pie-opening {\n  0% {\n    transform: scale(0.4) rotate(-20deg);\n  }\n  100% {\n    transform: scale(1) rotate(0);\n  }\n}\n.x6-widget-handle {\n  position: absolute;\n  width: 20px;\n  height: 20px;\n  background-color: transparent;\n  background-repeat: no-repeat;\n  background-position: 0 0;\n  background-size: 20px 20px;\n  cursor: pointer;\n  user-select: none;\n  pointer-events: auto;\n  -webkit-user-drag: none;\n  user-drag: none;\n  /* stylelint-disable-line */\n}\n.x6-widget-handle.hidden {\n  display: none;\n}\n.x6-widget-handle-selected {\n  background-color: rgba(0, 0, 0, 0.1);\n  border-radius: 3px;\n}\n.x6-widget-handle-remove {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M15.386%2C3.365c-3.315-3.314-8.707-3.313-12.021%2C0c-3.314%2C3.315-3.314%2C8.706%2C0%2C12.02%20c3.314%2C3.314%2C8.707%2C3.314%2C12.021%2C0S18.699%2C6.68%2C15.386%2C3.365L15.386%2C3.365z%20M4.152%2C14.598C1.273%2C11.719%2C1.273%2C7.035%2C4.153%2C4.154%20c2.88-2.88%2C7.563-2.88%2C10.443%2C0c2.881%2C2.88%2C2.881%2C7.562%2C0%2C10.443C11.716%2C17.477%2C7.032%2C17.477%2C4.152%2C14.598L4.152%2C14.598z%22%2F%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M12.157%2C11.371L7.38%2C6.593C7.162%2C6.375%2C6.809%2C6.375%2C6.592%2C6.592c-0.218%2C0.219-0.218%2C0.572%2C0%2C0.79%20l4.776%2C4.776c0.218%2C0.219%2C0.571%2C0.219%2C0.79%2C0C12.375%2C11.941%2C12.375%2C11.588%2C12.157%2C11.371L12.157%2C11.371z%22%2F%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M11.369%2C6.593l-4.777%2C4.778c-0.217%2C0.217-0.217%2C0.568%2C0%2C0.787c0.219%2C0.219%2C0.571%2C0.217%2C0.788%2C0l4.777-4.777%20c0.218-0.218%2C0.218-0.571%2C0.001-0.789C11.939%2C6.375%2C11.587%2C6.375%2C11.369%2C6.593L11.369%2C6.593z%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');\n  cursor: pointer;\n}\n.x6-widget-handle-remove:hover {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M15.386%2C3.365c-3.315-3.314-8.707-3.313-12.021%2C0c-3.314%2C3.315-3.314%2C8.706%2C0%2C12.02%20c3.314%2C3.314%2C8.707%2C3.314%2C12.021%2C0S18.699%2C6.68%2C15.386%2C3.365L15.386%2C3.365z%22%2F%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M12.157%2C11.371L7.38%2C6.593C7.162%2C6.375%2C6.809%2C6.375%2C6.592%2C6.592c-0.218%2C0.219-0.218%2C0.572%2C0%2C0.79%20l4.776%2C4.776c0.218%2C0.219%2C0.571%2C0.219%2C0.79%2C0C12.375%2C11.941%2C12.375%2C11.588%2C12.157%2C11.371L12.157%2C11.371z%22%2F%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M11.369%2C6.593l-4.777%2C4.778c-0.217%2C0.217-0.217%2C0.568%2C0%2C0.787c0.219%2C0.219%2C0.571%2C0.217%2C0.788%2C0l4.777-4.777%20c0.218-0.218%2C0.218-0.571%2C0.001-0.789C11.939%2C6.375%2C11.587%2C6.375%2C11.369%2C6.593L11.369%2C6.593z%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');\n}\n.x6-widget-handle-rotate {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M9.374%2C17.592c-4.176%2C0-7.57-3.401-7.57-7.575c0-4.175%2C3.395-7.574%2C7.57-7.574c0.28%2C0%2C0.56%2C0.018%2C0.837%2C0.05%20V1.268c0-0.158%2C0.099-0.3%2C0.239-0.36c0.151-0.058%2C0.315-0.026%2C0.428%2C0.086l2.683%2C2.688c0.152%2C0.154%2C0.152%2C0.399%2C0%2C0.553l-2.68%2C2.693%20c-0.115%2C0.112-0.279%2C0.147-0.431%2C0.087c-0.141-0.063-0.239-0.205-0.239-0.361V5.296C9.934%2C5.243%2C9.654%2C5.22%2C9.374%2C5.22%20c-2.646%2C0-4.796%2C2.152-4.796%2C4.797s2.154%2C4.798%2C4.796%2C4.798c2.645%2C0%2C4.798-2.153%2C4.798-4.798c0-0.214%2C0.174-0.391%2C0.391-0.391h1.991%20c0.217%2C0%2C0.394%2C0.177%2C0.394%2C0.391C16.947%2C14.19%2C13.549%2C17.592%2C9.374%2C17.592L9.374%2C17.592z%20M9.374%2C17.592%22%2F%3E%3C%2Fsvg%3E%20');\n  cursor: move;\n}\n.x6-widget-handle-rotate:hover {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23FD6EB6%22%20d%3D%22M9.374%2C17.592c-4.176%2C0-7.57-3.401-7.57-7.575c0-4.175%2C3.395-7.574%2C7.57-7.574c0.28%2C0%2C0.56%2C0.018%2C0.837%2C0.05%20V1.268c0-0.158%2C0.099-0.3%2C0.239-0.36c0.151-0.058%2C0.315-0.026%2C0.428%2C0.086l2.683%2C2.688c0.152%2C0.154%2C0.152%2C0.399%2C0%2C0.553l-2.68%2C2.693%20c-0.115%2C0.112-0.279%2C0.147-0.431%2C0.087c-0.141-0.063-0.239-0.205-0.239-0.361V5.296C9.934%2C5.243%2C9.654%2C5.22%2C9.374%2C5.22%20c-2.646%2C0-4.796%2C2.152-4.796%2C4.797s2.154%2C4.798%2C4.796%2C4.798c2.645%2C0%2C4.798-2.153%2C4.798-4.798c0-0.214%2C0.174-0.391%2C0.391-0.391h1.991%20c0.217%2C0%2C0.394%2C0.177%2C0.394%2C0.391C16.947%2C14.19%2C13.549%2C17.592%2C9.374%2C17.592L9.374%2C17.592z%20M9.374%2C17.592%22%2F%3E%3C%2Fsvg%3E%20');\n}\n.x6-widget-handle-resize {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3Csvg%20height%3D%2224px%22%20version%3D%221.1%22%20viewBox%3D%220%200%2024%2024%22%20width%3D%2224px%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Asketch%3D%22http%3A%2F%2Fwww.bohemiancoding.com%2Fsketch%2Fns%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Ctitle%2F%3E%3Cdesc%2F%3E%3Cdefs%2F%3E%3Cg%20fill%3D%22none%22%20fill-rule%3D%22evenodd%22%20id%3D%22miu%22%20stroke%3D%22none%22%20stroke-width%3D%221%22%3E%3Cg%20id%3D%22Artboard-1%22%20transform%3D%22translate(-251.000000%2C%20-443.000000)%22%3E%3Cg%20id%3D%22slice%22%20transform%3D%22translate(215.000000%2C%20119.000000)%22%2F%3E%3Cpath%20d%3D%22M252%2C448%20L256%2C448%20L256%2C444%20L252%2C444%20L252%2C448%20Z%20M257%2C448%20L269%2C448%20L269%2C446%20L257%2C446%20L257%2C448%20Z%20M257%2C464%20L269%2C464%20L269%2C462%20L257%2C462%20L257%2C464%20Z%20M270%2C444%20L270%2C448%20L274%2C448%20L274%2C444%20L270%2C444%20Z%20M252%2C462%20L252%2C466%20L256%2C466%20L256%2C462%20L252%2C462%20Z%20M270%2C462%20L270%2C466%20L274%2C466%20L274%2C462%20L270%2C462%20Z%20M254%2C461%20L256%2C461%20L256%2C449%20L254%2C449%20L254%2C461%20Z%20M270%2C461%20L272%2C461%20L272%2C449%20L270%2C449%20L270%2C461%20Z%22%20fill%3D%22%236A6C8A%22%20id%3D%22editor-crop-glyph%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E');\n  cursor: se-resize;\n}\n.x6-widget-handle-resize:hover {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3Csvg%20height%3D%2224px%22%20version%3D%221.1%22%20viewBox%3D%220%200%2024%2024%22%20width%3D%2224px%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Asketch%3D%22http%3A%2F%2Fwww.bohemiancoding.com%2Fsketch%2Fns%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Ctitle%2F%3E%3Cdesc%2F%3E%3Cdefs%2F%3E%3Cg%20fill%3D%22none%22%20fill-rule%3D%22evenodd%22%20id%3D%22miu%22%20stroke%3D%22none%22%20stroke-width%3D%221%22%3E%3Cg%20id%3D%22Artboard-1%22%20transform%3D%22translate(-251.000000%2C%20-443.000000)%22%3E%3Cg%20id%3D%22slice%22%20transform%3D%22translate(215.000000%2C%20119.000000)%22%2F%3E%3Cpath%20d%3D%22M252%2C448%20L256%2C448%20L256%2C444%20L252%2C444%20L252%2C448%20Z%20M257%2C448%20L269%2C448%20L269%2C446%20L257%2C446%20L257%2C448%20Z%20M257%2C464%20L269%2C464%20L269%2C462%20L257%2C462%20L257%2C464%20Z%20M270%2C444%20L270%2C448%20L274%2C448%20L274%2C444%20L270%2C444%20Z%20M252%2C462%20L252%2C466%20L256%2C466%20L256%2C462%20L252%2C462%20Z%20M270%2C462%20L270%2C466%20L274%2C466%20L274%2C462%20L270%2C462%20Z%20M254%2C461%20L256%2C461%20L256%2C449%20L254%2C449%20L254%2C461%20Z%20M270%2C461%20L272%2C461%20L272%2C449%20L270%2C449%20L270%2C461%20Z%22%20fill%3D%22%23FD6EB6%22%20id%3D%22editor-crop-glyph%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E');\n}\n.x6-widget-handle-clone {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M12.852%2C0.875h-9.27c-0.853%2C0-1.547%2C0.694-1.547%2C1.547v10.816h1.547V2.422h9.27V0.875z%20M15.172%2C3.965h-8.5%20c-0.849%2C0-1.547%2C0.698-1.547%2C1.547v10.816c0%2C0.849%2C0.698%2C1.547%2C1.547%2C1.547h8.5c0.85%2C0%2C1.543-0.698%2C1.543-1.547V5.512%20C16.715%2C4.663%2C16.021%2C3.965%2C15.172%2C3.965L15.172%2C3.965z%20M15.172%2C16.328h-8.5V5.512h8.5V16.328z%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');\n  cursor: move;\n}\n.x6-widget-handle-clone:hover {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cpath%20fill%3D%22%23FD6EB6%22%20d%3D%22M12.852%2C0.875h-9.27c-0.853%2C0-1.547%2C0.694-1.547%2C1.547v10.816h1.547V2.422h9.27V0.875z%20M15.172%2C3.965h-8.5%20c-0.849%2C0-1.547%2C0.698-1.547%2C1.547v10.816c0%2C0.849%2C0.698%2C1.547%2C1.547%2C1.547h8.5c0.849%2C0%2C1.543-0.698%2C1.543-1.547V5.512%20C16.715%2C4.663%2C16.021%2C3.965%2C15.172%2C3.965L15.172%2C3.965z%20M15.172%2C16.328h-8.5V5.512h8.5V16.328z%20M15.172%2C16.328%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');\n}\n.x6-widget-handle-link {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M9.884%2C9.838c0.54-0.551%2C1.005-0.955%2C1.384-1.201c0.463-0.308%2C0.749-0.352%2C0.887-0.352h1.34v1.367%20c0%2C0.104%2C0.061%2C0.2%2C0.154%2C0.242s0.204%2C0.027%2C0.284-0.038l3.168-2.669c0.06-0.051%2C0.096-0.125%2C0.096-0.203S17.16%2C6.83%2C17.101%2C6.781%20l-3.168-2.677c-0.08-0.067-0.19-0.081-0.284-0.038c-0.094%2C0.045-0.154%2C0.139-0.154%2C0.242v1.414h-1.343%20c-1.24%2C0.014-2.215%2C0.67-2.927%2C1.242c-0.797%2C0.65-1.533%2C1.447-2.245%2C2.217c-0.361%2C0.391-0.7%2C0.759-1.044%2C1.1%20c-0.541%2C0.549-1.011%2C0.951-1.395%2C1.199c-0.354%2C0.231-0.678%2C0.357-0.921%2C0.357h-1.8c-0.146%2C0-0.266%2C0.12-0.266%2C0.265v2.029%20c0%2C0.148%2C0.12%2C0.268%2C0.266%2C0.268h1.8l0%2C0c1.255-0.014%2C2.239-0.667%2C2.958-1.24c0.82-0.661%2C1.572-1.475%2C2.297-2.256%20C9.225%2C10.524%2C9.555%2C10.169%2C9.884%2C9.838z%22%2F%3E%3C%2Fsvg%3E%20');\n  cursor: move;\n  cursor: -moz-grabbing;\n  cursor: -webkit-grabbing;\n}\n.x6-widget-handle-link:hover {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23FD6EB6%22%20d%3D%22M9.884%2C9.838c0.54-0.551%2C1.005-0.955%2C1.384-1.201c0.463-0.308%2C0.749-0.352%2C0.887-0.352h1.34v1.367%20c0%2C0.104%2C0.061%2C0.2%2C0.154%2C0.242s0.204%2C0.027%2C0.284-0.038l3.168-2.669c0.06-0.051%2C0.096-0.125%2C0.096-0.203S17.16%2C6.83%2C17.101%2C6.781%20l-3.168-2.677c-0.08-0.067-0.19-0.081-0.284-0.038c-0.094%2C0.045-0.154%2C0.139-0.154%2C0.242v1.414h-1.343%20c-1.24%2C0.014-2.215%2C0.67-2.927%2C1.242c-0.797%2C0.65-1.533%2C1.447-2.245%2C2.217c-0.361%2C0.391-0.7%2C0.759-1.044%2C1.1%20c-0.541%2C0.549-1.011%2C0.951-1.395%2C1.199c-0.354%2C0.231-0.678%2C0.357-0.921%2C0.357h-1.8c-0.146%2C0-0.266%2C0.12-0.266%2C0.265v2.029%20c0%2C0.148%2C0.12%2C0.268%2C0.266%2C0.268h1.8l0%2C0c1.255-0.014%2C2.239-0.667%2C2.958-1.24c0.82-0.661%2C1.572-1.475%2C2.297-2.256%20C9.225%2C10.524%2C9.555%2C10.169%2C9.884%2C9.838z%22%2F%3E%3C%2Fsvg%3E%20');\n}\n.x6-widget-handle-fork {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cg%3E%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20fill%3D%22%236A6C8A%22%20d%3D%22M13.307%2C11.593c-0.69%2C0-1.299%2C0.33-1.693%2C0.835l-4.136-2.387%20C7.552%2C9.82%2C7.602%2C9.589%2C7.602%2C9.344c0-0.25-0.051-0.487-0.129-0.71l4.097-2.364c0.393%2C0.536%2C1.022%2C0.888%2C1.737%2C0.888%20c1.193%2C0%2C2.16-0.967%2C2.16-2.159s-0.967-2.159-2.16-2.159c-1.191%2C0-2.158%2C0.967-2.158%2C2.159c0%2C0.076%2C0.014%2C0.149%2C0.021%2C0.223%20L6.848%2C7.716C6.469%2C7.39%2C5.982%2C7.185%2C5.442%2C7.185c-1.191%2C0-2.158%2C0.967-2.158%2C2.159s0.967%2C2.159%2C2.158%2C2.159%20c0.545%2C0%2C1.037-0.208%2C1.417-0.541l4.319%2C2.493c-0.014%2C0.098-0.029%2C0.194-0.029%2C0.296c0%2C1.193%2C0.967%2C2.159%2C2.158%2C2.159%20c1.193%2C0%2C2.16-0.966%2C2.16-2.159C15.467%2C12.559%2C14.5%2C11.593%2C13.307%2C11.593z%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');\n  cursor: move;\n}\n.x6-widget-handle-fork:hover {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cg%3E%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20fill%3D%22%23FD6EB6%22%20d%3D%22M13.307%2C11.593c-0.69%2C0-1.299%2C0.33-1.693%2C0.835l-4.136-2.387%20c0.075-0.22%2C0.125-0.452%2C0.125-0.697c0-0.25-0.051-0.487-0.129-0.71l4.097-2.365c0.394%2C0.536%2C1.022%2C0.888%2C1.737%2C0.888%20c1.193%2C0%2C2.16-0.967%2C2.16-2.159s-0.967-2.159-2.16-2.159c-1.191%2C0-2.158%2C0.967-2.158%2C2.159c0%2C0.076%2C0.015%2C0.148%2C0.022%2C0.223%20L6.848%2C7.716C6.469%2C7.39%2C5.981%2C7.185%2C5.442%2C7.185c-1.191%2C0-2.158%2C0.967-2.158%2C2.159s0.967%2C2.159%2C2.158%2C2.159%20c0.545%2C0%2C1.037-0.208%2C1.417-0.541l4.319%2C2.493c-0.013%2C0.098-0.029%2C0.194-0.029%2C0.296c0%2C1.193%2C0.967%2C2.159%2C2.158%2C2.159%20c1.193%2C0%2C2.16-0.966%2C2.16-2.159C15.467%2C12.559%2C14.5%2C11.593%2C13.307%2C11.593z%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');\n}\n.x6-widget-handle-unlink {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cg%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M12.285%2C9.711l-2.104-0.302L9.243%2C8.568L6.669%2C7.095C6.948%2C6.6%2C6.995%2C6.026%2C6.845%2C5.474%20c-0.191-0.698-0.695-1.36-1.438-1.786C4.068%2C2.922%2C2.464%2C3.214%2C1.82%2C4.338C1.536%2C4.836%2C1.489%2C5.414%2C1.64%2C5.97%20c0.189%2C0.698%2C0.694%2C1.36%2C1.438%2C1.787c0.328%2C0.187%2C0.67%2C0.31%2C1.01%2C0.372c0.002%2C0%2C0.006%2C0.002%2C0.008%2C0.004%20c0.027%2C0.004%2C0.057%2C0.009%2C0.088%2C0.011c2.12%2C0.316%2C3.203%2C0.915%2C3.73%2C1.337c-0.527%2C0.424-1.61%2C1.021-3.731%2C1.339%20c-0.029%2C0.003-0.058%2C0.007-0.087%2C0.012c-0.002%2C0.002-0.004%2C0.002-0.007%2C0.003c-0.341%2C0.062-0.684%2C0.187-1.013%2C0.374%20c-0.74%2C0.425-1.246%2C1.089-1.437%2C1.787c-0.149%2C0.555-0.105%2C1.133%2C0.181%2C1.632c0.011%2C0.018%2C0.021%2C0.033%2C0.033%2C0.049l0.883%2C0.783%20c0.765%2C0.366%2C1.775%2C0.328%2C2.67-0.184c0.744-0.425%2C1.248-1.088%2C1.439-1.786c0.148-0.552%2C0.104-1.126-0.176-1.62l2.573-1.473%20c0.573%2C0.287%2C2.299%2C1.292%2C2.299%2C1.292s3.602%2C1.445%2C4.241%2C1.812c0.773%2C0.191%2C0.566-0.151%2C0.566-0.151L12.285%2C9.711z%20M5.571%2C6.482%20C5.279%2C6.993%2C4.425%2C7.076%2C3.705%2C6.664C3.282%2C6.424%2C2.966%2C6.039%2C2.856%2C5.64C2.81%2C5.464%2C2.778%2C5.203%2C2.917%2C4.963%20c0.291-0.51%2C1.146-0.593%2C1.866-0.182C5.21%2C5.027%2C5.521%2C5.4%2C5.632%2C5.807C5.679%2C5.98%2C5.708%2C6.242%2C5.571%2C6.482z%20M5.632%2C13.159%20c-0.111%2C0.406-0.422%2C0.778-0.848%2C1.025c-0.719%2C0.409-1.576%2C0.327-1.867-0.184c-0.137-0.239-0.106-0.499-0.06-0.676%20c0.108-0.398%2C0.426-0.781%2C0.847-1.022c0.72-0.412%2C1.574-0.329%2C1.866%2C0.181C5.708%2C12.723%2C5.679%2C12.983%2C5.632%2C13.159z%20M16.181%2C5.139%20c-0.448%2C0.258-4.435%2C1.9-4.435%2C1.9s-1.556%2C0.855-2.104%2C1.13l0.937%2C0.843l2.057-0.229l4.11-3.638%20C16.745%2C5.146%2C17.013%2C4.664%2C16.181%2C5.139z%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');\n}\n.x6-widget-handle-unlink:hover {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cg%3E%3Cpath%20fill%3D%22%23FD6EB6%22%20d%3D%22M12.285%2C9.711l-2.104-0.302L9.243%2C8.568L6.669%2C7.095C6.948%2C6.6%2C6.995%2C6.026%2C6.845%2C5.474%20c-0.191-0.698-0.695-1.36-1.438-1.786C4.068%2C2.922%2C2.464%2C3.214%2C1.82%2C4.338C1.536%2C4.836%2C1.489%2C5.414%2C1.64%2C5.97%20c0.189%2C0.698%2C0.694%2C1.36%2C1.438%2C1.787c0.328%2C0.187%2C0.67%2C0.31%2C1.01%2C0.372c0.002%2C0%2C0.006%2C0.002%2C0.008%2C0.004%20c0.027%2C0.004%2C0.057%2C0.009%2C0.088%2C0.011c2.12%2C0.316%2C3.203%2C0.915%2C3.73%2C1.337c-0.527%2C0.424-1.61%2C1.021-3.731%2C1.339%20c-0.029%2C0.003-0.058%2C0.007-0.087%2C0.012c-0.002%2C0.002-0.004%2C0.002-0.007%2C0.003c-0.341%2C0.062-0.684%2C0.187-1.013%2C0.374%20c-0.74%2C0.425-1.246%2C1.089-1.437%2C1.787c-0.149%2C0.555-0.105%2C1.133%2C0.181%2C1.632c0.011%2C0.018%2C0.021%2C0.033%2C0.033%2C0.049l0.883%2C0.783%20c0.765%2C0.366%2C1.775%2C0.328%2C2.67-0.184c0.744-0.425%2C1.248-1.088%2C1.439-1.786c0.148-0.552%2C0.104-1.126-0.176-1.62l2.573-1.473%20c0.573%2C0.287%2C2.299%2C1.292%2C2.299%2C1.292s3.602%2C1.445%2C4.241%2C1.812c0.773%2C0.191%2C0.566-0.151%2C0.566-0.151L12.285%2C9.711z%20M5.571%2C6.482%20C5.279%2C6.993%2C4.425%2C7.076%2C3.705%2C6.664C3.282%2C6.424%2C2.966%2C6.039%2C2.856%2C5.64C2.81%2C5.464%2C2.778%2C5.203%2C2.917%2C4.963%20c0.291-0.51%2C1.146-0.593%2C1.866-0.182C5.21%2C5.027%2C5.521%2C5.4%2C5.632%2C5.807C5.679%2C5.98%2C5.708%2C6.242%2C5.571%2C6.482z%20M5.632%2C13.159%20c-0.111%2C0.406-0.422%2C0.778-0.848%2C1.025c-0.719%2C0.409-1.576%2C0.327-1.867-0.184c-0.137-0.239-0.106-0.499-0.06-0.676%20c0.108-0.398%2C0.426-0.781%2C0.847-1.022c0.72-0.412%2C1.574-0.329%2C1.866%2C0.181C5.708%2C12.723%2C5.679%2C12.983%2C5.632%2C13.159z%20M16.181%2C5.139%20c-0.448%2C0.258-4.435%2C1.9-4.435%2C1.9s-1.556%2C0.855-2.104%2C1.13l0.937%2C0.843l2.057-0.229l4.11-3.638%20C16.745%2C5.146%2C17.013%2C4.664%2C16.181%2C5.139z%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');\n}\n.x6-widget-handle-direction {\n  background-image: url(\"data:image/svg+xml;charset=UTF-8,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3C!DOCTYPE%20svg%20%20PUBLIC%20'-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN'%20%20'http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd'%3E%3Csvg%20id%3D%22Layer_1%22%20style%3D%22enable-background%3Anew%200%200%20512%20512%3B%22%20version%3D%221.1%22%20viewBox%3D%220%200%20512%20512%22%20xml%3Aspace%3D%22preserve%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Cstyle%20type%3D%22text%2Fcss%22%3E%0A%09.st0%7Bfill%3A%236A6C8A%3Bstroke%3A%236A6C8A%3Bstroke-width%3A30%7D%0A%09.dot%7Bfill%3A%236A6C8A%3B%7D%0A%3C%2Fstyle%3E%3Cg%3E%3Cg%20id%3D%22XMLID_475_%22%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M133.1%2C277.1c1.8%2C0%2C3.7-0.6%2C5.4-1.7c4.1-3%2C5-8.7%2C2-12.8c-3-4.1-8.7-5-12.8-2c0%2C0%2C0%2C0%2C0%2C0%20%20%20%20%20c-4.1%2C3-5%2C8.7-2%2C12.8C127.5%2C275.8%2C130.3%2C277.1%2C133.1%2C277.1z%22%20id%3D%22XMLID_489_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M138.5%2C359.6c-4.1-3-9.8-2.1-12.8%2C2c-3%2C4.1-2.1%2C9.8%2C2%2C12.8c1.6%2C1.2%2C3.5%2C1.7%2C5.4%2C1.7%20%20%20%20%20c2.8%2C0%2C5.6-1.3%2C7.4-3.7C143.5%2C368.3%2C142.6%2C362.6%2C138.5%2C359.6z%22%20id%3D%22XMLID_726_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M108.1%2C327.7c-4.8%2C1.6-7.4%2C6.7-5.9%2C11.5c1.3%2C3.9%2C4.8%2C6.3%2C8.7%2C6.3c0.9%2C0%2C1.9-0.1%2C2.8-0.4%20%20%20%20%20c4.8-1.6%2C7.4-6.7%2C5.9-11.5C118%2C328.8%2C112.9%2C326.2%2C108.1%2C327.7z%22%20id%3D%22XMLID_776_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M108.1%2C307.3c0.9%2C0.3%2C1.9%2C0.4%2C2.8%2C0.4c3.8%2C0%2C7.4-2.4%2C8.7-6.3c1.6-4.8-1.1-9.9-5.9-11.5%20%20%20%20%20c-4.8-1.6-9.9%2C1.1-11.5%2C5.9C100.7%2C300.6%2C103.3%2C305.7%2C108.1%2C307.3z%22%20id%3D%22XMLID_777_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M169.2%2C265.4c2.4%2C0%2C4.7-1%2C6.5-2.6c1.7-1.7%2C2.7-4.1%2C2.7-6.5c0-2.4-1-4.8-2.7-6.5%20%20%20%20%20c-1.7-1.7-4.1-2.7-6.5-2.7s-4.7%2C1-6.5%2C2.7c-1.7%2C1.7-2.7%2C4-2.7%2C6.5c0%2C2.4%2C1%2C4.7%2C2.7%2C6.5C164.4%2C264.4%2C166.8%2C265.4%2C169.2%2C265.4z%22%20id%3D%22XMLID_797_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M247.7%2C256.3c0-5-4.1-9.1-9.1-9.1c-5%2C0-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20C243.7%2C265.4%2C247.7%2C261.3%2C247.7%2C256.3z%22%20id%3D%22XMLID_798_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M213%2C256.3c0-5-4.1-9.1-9.1-9.1c-5%2C0-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20C208.9%2C265.4%2C213%2C261.3%2C213%2C256.3z%22%20id%3D%22XMLID_799_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M317.2%2C256.3c0-5-4.1-9.1-9.1-9.1c-5%2C0-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20C313.1%2C265.4%2C317.2%2C261.3%2C317.2%2C256.3z%22%20id%3D%22XMLID_800_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M282.5%2C256.3c0-5-4.1-9.1-9.1-9.1s-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20S282.5%2C261.3%2C282.5%2C256.3z%22%20id%3D%22XMLID_801_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M401.1%2C185.2c0.9%2C0%2C1.9-0.1%2C2.8-0.5c4.8-1.6%2C7.4-6.7%2C5.9-11.5c-1.6-4.8-6.7-7.4-11.5-5.8%20%20%20%20%20c-4.8%2C1.6-7.4%2C6.7-5.8%2C11.5C393.6%2C182.8%2C397.2%2C185.2%2C401.1%2C185.2z%22%20id%3D%22XMLID_802_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M403.9%2C205.2c-4.8-1.6-9.9%2C1-11.5%2C5.9l0%2C0c-1.6%2C4.8%2C1.1%2C9.9%2C5.9%2C11.5%20%20%20%20%20c0.9%2C0.3%2C1.9%2C0.5%2C2.8%2C0.5c3.9%2C0%2C7.4-2.5%2C8.7-6.3c0%2C0%2C0%2C0%2C0%2C0C411.3%2C211.9%2C408.7%2C206.8%2C403.9%2C205.2z%22%20id%3D%22XMLID_803_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M373.5%2C237.2L373.5%2C237.2c-4.1%2C3-5%2C8.7-2%2C12.8c1.8%2C2.4%2C4.6%2C3.7%2C7.4%2C3.7%20%20%20%20%20c1.8%2C0%2C3.7-0.6%2C5.4-1.8c4.1-3%2C4.9-8.7%2C2-12.8C383.3%2C235.1%2C377.6%2C234.2%2C373.5%2C237.2z%22%20id%3D%22XMLID_804_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M373.5%2C152.9c1.6%2C1.2%2C3.5%2C1.8%2C5.4%2C1.8c2.8%2C0%2C5.6-1.3%2C7.4-3.8c3-4.1%2C2.1-9.8-2-12.7%20%20%20%20%20c-4.1-3-9.8-2.1-12.7%2C2C368.5%2C144.2%2C369.4%2C149.9%2C373.5%2C152.9z%22%20id%3D%22XMLID_805_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M342.8%2C247.1c-2.4%2C0-4.8%2C1-6.5%2C2.7c-1.7%2C1.7-2.7%2C4-2.7%2C6.5c0%2C2.4%2C1%2C4.7%2C2.7%2C6.4%20%20%20%20%20c1.7%2C1.7%2C4%2C2.7%2C6.5%2C2.7c2.4%2C0%2C4.7-1%2C6.5-2.7c1.7-1.7%2C2.7-4%2C2.7-6.4c0-2.4-1-4.8-2.7-6.5C347.6%2C248.1%2C345.2%2C247.1%2C342.8%2C247.1z%22%20id%3D%22XMLID_806_%22%2F%3E%0A%3Cpath%20class%3D%22st0%22%20d%3D%22M342.8%2C124.7H206.6l36.4-36.4c3.6-3.6%2C3.6-9.3%2C0-12.9c-3.6-3.6-9.3-3.6-12.9%2C0l-51.5%2C51.5%20%20%20%20%20c-1.9%2C1.9-2.8%2C4.4-2.7%2C6.9c-0.1%2C2.5%2C0.7%2C5%2C2.7%2C6.9l51.5%2C51.5c1.8%2C1.8%2C4.1%2C2.7%2C6.5%2C2.7c2.3%2C0%2C4.7-0.9%2C6.5-2.7%20%20%20%20%20c3.6-3.6%2C3.6-9.3%2C0-12.9l-36.4-36.4h136.1c0%2C0%2C0.1%2C0%2C0.1%2C0c0.6%2C0%2C1.2-0.1%2C1.8-0.2c0.2%2C0%2C0.4-0.1%2C0.6-0.1c0.1%2C0%2C0.2%2C0%2C0.3-0.1%20%20%20%20%20c3.2-1%2C5.6-3.6%2C6.3-6.9c0.1-0.6%2C0.2-1.2%2C0.2-1.8c0-0.6-0.1-1.2-0.2-1.8C351%2C127.8%2C347.3%2C124.7%2C342.8%2C124.7z%22%20id%3D%22XMLID_807_%22%2F%3E%0A%3Cpath%20class%3D%22st0%22%20d%3D%22M322.1%2C371.3l-51.5-51.5c-3.6-3.6-9.3-3.6-12.9%2C0c-3.6%2C3.6-3.6%2C9.3%2C0%2C12.9l36.9%2C36.9H169.2%20%20%20%20%20c-2.8%2C0-5.4%2C1.3-7%2C3.3c-0.1%2C0.1-0.2%2C0.2-0.3%2C0.4c-0.1%2C0.1-0.2%2C0.2-0.2%2C0.3c-0.1%2C0.1-0.1%2C0.2-0.2%2C0.4c-0.1%2C0.1-0.2%2C0.3-0.2%2C0.4%20%20%20%20%20c0%2C0.1-0.1%2C0.2-0.1%2C0.2c-0.1%2C0.2-0.2%2C0.4-0.3%2C0.6c0%2C0%2C0%2C0%2C0%2C0.1c-0.4%2C1.1-0.7%2C2.2-0.7%2C3.4c0%2C1.5%2C0.4%2C2.9%2C1%2C4.2c0%2C0%2C0%2C0.1%2C0.1%2C0.1%20%20%20%20%20c0.1%2C0.1%2C0.1%2C0.2%2C0.2%2C0.3c0.4%2C0.7%2C0.9%2C1.3%2C1.4%2C1.8c0.4%2C0.4%2C0.7%2C0.7%2C1.2%2C1c0.1%2C0.1%2C0.1%2C0.1%2C0.2%2C0.2c0%2C0%2C0.1%2C0%2C0.1%2C0.1%20%20%20%20%20c1.4%2C0.9%2C3.1%2C1.5%2C5%2C1.5h124.4l-36%2C36c-3.6%2C3.6-3.6%2C9.3%2C0%2C12.9c1.8%2C1.8%2C4.1%2C2.7%2C6.5%2C2.7c2.3%2C0%2C4.7-0.9%2C6.5-2.7l51.5-51.5%20%20%20%20%20c1.9-1.9%2C2.8-4.4%2C2.7-6.9C324.8%2C375.7%2C324%2C373.2%2C322.1%2C371.3z%22%20id%3D%22XMLID_808_%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E\");\n}\n.x6-widget-handle-direction:hover {\n  background-image: url(\"data:image/svg+xml;charset=UTF-8,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3C!DOCTYPE%20svg%20%20PUBLIC%20'-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN'%20%20'http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd'%3E%3Csvg%20id%3D%22Layer_1%22%20style%3D%22enable-background%3Anew%200%200%20512%20512%3B%22%20version%3D%221.1%22%20viewBox%3D%220%200%20512%20512%22%20xml%3Aspace%3D%22preserve%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Cstyle%20type%3D%22text%2Fcss%22%3E%0A%09.st0%7Bfill%3A%23FD6EB6%3Bstroke%3A%23FD6EB6%3Bstroke-width%3A30%7D%0A%09.dot%7Bfill%3A%23FD6EB6%3B%7D%0A%3C%2Fstyle%3E%3Cg%3E%3Cg%20id%3D%22XMLID_475_%22%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M133.1%2C277.1c1.8%2C0%2C3.7-0.6%2C5.4-1.7c4.1-3%2C5-8.7%2C2-12.8c-3-4.1-8.7-5-12.8-2c0%2C0%2C0%2C0%2C0%2C0%20%20%20%20%20c-4.1%2C3-5%2C8.7-2%2C12.8C127.5%2C275.8%2C130.3%2C277.1%2C133.1%2C277.1z%22%20id%3D%22XMLID_489_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M138.5%2C359.6c-4.1-3-9.8-2.1-12.8%2C2c-3%2C4.1-2.1%2C9.8%2C2%2C12.8c1.6%2C1.2%2C3.5%2C1.7%2C5.4%2C1.7%20%20%20%20%20c2.8%2C0%2C5.6-1.3%2C7.4-3.7C143.5%2C368.3%2C142.6%2C362.6%2C138.5%2C359.6z%22%20id%3D%22XMLID_726_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M108.1%2C327.7c-4.8%2C1.6-7.4%2C6.7-5.9%2C11.5c1.3%2C3.9%2C4.8%2C6.3%2C8.7%2C6.3c0.9%2C0%2C1.9-0.1%2C2.8-0.4%20%20%20%20%20c4.8-1.6%2C7.4-6.7%2C5.9-11.5C118%2C328.8%2C112.9%2C326.2%2C108.1%2C327.7z%22%20id%3D%22XMLID_776_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M108.1%2C307.3c0.9%2C0.3%2C1.9%2C0.4%2C2.8%2C0.4c3.8%2C0%2C7.4-2.4%2C8.7-6.3c1.6-4.8-1.1-9.9-5.9-11.5%20%20%20%20%20c-4.8-1.6-9.9%2C1.1-11.5%2C5.9C100.7%2C300.6%2C103.3%2C305.7%2C108.1%2C307.3z%22%20id%3D%22XMLID_777_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M169.2%2C265.4c2.4%2C0%2C4.7-1%2C6.5-2.6c1.7-1.7%2C2.7-4.1%2C2.7-6.5c0-2.4-1-4.8-2.7-6.5%20%20%20%20%20c-1.7-1.7-4.1-2.7-6.5-2.7s-4.7%2C1-6.5%2C2.7c-1.7%2C1.7-2.7%2C4-2.7%2C6.5c0%2C2.4%2C1%2C4.7%2C2.7%2C6.5C164.4%2C264.4%2C166.8%2C265.4%2C169.2%2C265.4z%22%20id%3D%22XMLID_797_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M247.7%2C256.3c0-5-4.1-9.1-9.1-9.1c-5%2C0-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20C243.7%2C265.4%2C247.7%2C261.3%2C247.7%2C256.3z%22%20id%3D%22XMLID_798_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M213%2C256.3c0-5-4.1-9.1-9.1-9.1c-5%2C0-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20C208.9%2C265.4%2C213%2C261.3%2C213%2C256.3z%22%20id%3D%22XMLID_799_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M317.2%2C256.3c0-5-4.1-9.1-9.1-9.1c-5%2C0-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20C313.1%2C265.4%2C317.2%2C261.3%2C317.2%2C256.3z%22%20id%3D%22XMLID_800_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M282.5%2C256.3c0-5-4.1-9.1-9.1-9.1s-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20S282.5%2C261.3%2C282.5%2C256.3z%22%20id%3D%22XMLID_801_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M401.1%2C185.2c0.9%2C0%2C1.9-0.1%2C2.8-0.5c4.8-1.6%2C7.4-6.7%2C5.9-11.5c-1.6-4.8-6.7-7.4-11.5-5.8%20%20%20%20%20c-4.8%2C1.6-7.4%2C6.7-5.8%2C11.5C393.6%2C182.8%2C397.2%2C185.2%2C401.1%2C185.2z%22%20id%3D%22XMLID_802_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M403.9%2C205.2c-4.8-1.6-9.9%2C1-11.5%2C5.9l0%2C0c-1.6%2C4.8%2C1.1%2C9.9%2C5.9%2C11.5%20%20%20%20%20c0.9%2C0.3%2C1.9%2C0.5%2C2.8%2C0.5c3.9%2C0%2C7.4-2.5%2C8.7-6.3c0%2C0%2C0%2C0%2C0%2C0C411.3%2C211.9%2C408.7%2C206.8%2C403.9%2C205.2z%22%20id%3D%22XMLID_803_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M373.5%2C237.2L373.5%2C237.2c-4.1%2C3-5%2C8.7-2%2C12.8c1.8%2C2.4%2C4.6%2C3.7%2C7.4%2C3.7%20%20%20%20%20c1.8%2C0%2C3.7-0.6%2C5.4-1.8c4.1-3%2C4.9-8.7%2C2-12.8C383.3%2C235.1%2C377.6%2C234.2%2C373.5%2C237.2z%22%20id%3D%22XMLID_804_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M373.5%2C152.9c1.6%2C1.2%2C3.5%2C1.8%2C5.4%2C1.8c2.8%2C0%2C5.6-1.3%2C7.4-3.8c3-4.1%2C2.1-9.8-2-12.7%20%20%20%20%20c-4.1-3-9.8-2.1-12.7%2C2C368.5%2C144.2%2C369.4%2C149.9%2C373.5%2C152.9z%22%20id%3D%22XMLID_805_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M342.8%2C247.1c-2.4%2C0-4.8%2C1-6.5%2C2.7c-1.7%2C1.7-2.7%2C4-2.7%2C6.5c0%2C2.4%2C1%2C4.7%2C2.7%2C6.4%20%20%20%20%20c1.7%2C1.7%2C4%2C2.7%2C6.5%2C2.7c2.4%2C0%2C4.7-1%2C6.5-2.7c1.7-1.7%2C2.7-4%2C2.7-6.4c0-2.4-1-4.8-2.7-6.5C347.6%2C248.1%2C345.2%2C247.1%2C342.8%2C247.1z%22%20id%3D%22XMLID_806_%22%2F%3E%0A%3Cpath%20class%3D%22st0%22%20d%3D%22M342.8%2C124.7H206.6l36.4-36.4c3.6-3.6%2C3.6-9.3%2C0-12.9c-3.6-3.6-9.3-3.6-12.9%2C0l-51.5%2C51.5%20%20%20%20%20c-1.9%2C1.9-2.8%2C4.4-2.7%2C6.9c-0.1%2C2.5%2C0.7%2C5%2C2.7%2C6.9l51.5%2C51.5c1.8%2C1.8%2C4.1%2C2.7%2C6.5%2C2.7c2.3%2C0%2C4.7-0.9%2C6.5-2.7%20%20%20%20%20c3.6-3.6%2C3.6-9.3%2C0-12.9l-36.4-36.4h136.1c0%2C0%2C0.1%2C0%2C0.1%2C0c0.6%2C0%2C1.2-0.1%2C1.8-0.2c0.2%2C0%2C0.4-0.1%2C0.6-0.1c0.1%2C0%2C0.2%2C0%2C0.3-0.1%20%20%20%20%20c3.2-1%2C5.6-3.6%2C6.3-6.9c0.1-0.6%2C0.2-1.2%2C0.2-1.8c0-0.6-0.1-1.2-0.2-1.8C351%2C127.8%2C347.3%2C124.7%2C342.8%2C124.7z%22%20id%3D%22XMLID_807_%22%2F%3E%0A%3Cpath%20class%3D%22st0%22%20d%3D%22M322.1%2C371.3l-51.5-51.5c-3.6-3.6-9.3-3.6-12.9%2C0c-3.6%2C3.6-3.6%2C9.3%2C0%2C12.9l36.9%2C36.9H169.2%20%20%20%20%20c-2.8%2C0-5.4%2C1.3-7%2C3.3c-0.1%2C0.1-0.2%2C0.2-0.3%2C0.4c-0.1%2C0.1-0.2%2C0.2-0.2%2C0.3c-0.1%2C0.1-0.1%2C0.2-0.2%2C0.4c-0.1%2C0.1-0.2%2C0.3-0.2%2C0.4%20%20%20%20%20c0%2C0.1-0.1%2C0.2-0.1%2C0.2c-0.1%2C0.2-0.2%2C0.4-0.3%2C0.6c0%2C0%2C0%2C0%2C0%2C0.1c-0.4%2C1.1-0.7%2C2.2-0.7%2C3.4c0%2C1.5%2C0.4%2C2.9%2C1%2C4.2c0%2C0%2C0%2C0.1%2C0.1%2C0.1%20%20%20%20%20c0.1%2C0.1%2C0.1%2C0.2%2C0.2%2C0.3c0.4%2C0.7%2C0.9%2C1.3%2C1.4%2C1.8c0.4%2C0.4%2C0.7%2C0.7%2C1.2%2C1c0.1%2C0.1%2C0.1%2C0.1%2C0.2%2C0.2c0%2C0%2C0.1%2C0%2C0.1%2C0.1%20%20%20%20%20c1.4%2C0.9%2C3.1%2C1.5%2C5%2C1.5h124.4l-36%2C36c-3.6%2C3.6-3.6%2C9.3%2C0%2C12.9c1.8%2C1.8%2C4.1%2C2.7%2C6.5%2C2.7c2.3%2C0%2C4.7-0.9%2C6.5-2.7l51.5-51.5%20%20%20%20%20c1.9-1.9%2C2.8-4.4%2C2.7-6.9C324.8%2C375.7%2C324%2C373.2%2C322.1%2C371.3z%22%20id%3D%22XMLID_808_%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E\");\n}\n.x6-widget-handle-surround .x6-widget-handle-animate .x6-widget-handle {\n  transition: background-size 80ms, width 80ms, height 80ms, top 150ms, left 150ms, bottom 150ms, right 150ms;\n}\n.x6-widget-handle-surround .x6-widget-handle-pos-se {\n  right: -25px;\n  bottom: -25px;\n}\n.x6-widget-handle-surround .x6-widget-handle-pos-nw {\n  top: -21px;\n  left: -25px;\n}\n.x6-widget-handle-surround .x6-widget-handle-pos-n {\n  top: -22px;\n  left: 50%;\n  margin-left: -10px;\n}\n.x6-widget-handle-surround .x6-widget-handle-pos-e {\n  top: -webkit-calc(40%);\n  top: calc(50% - 10px);\n  right: -25px;\n}\n.x6-widget-handle-surround .x6-widget-handle-pos-ne {\n  top: -21px;\n  right: -25px;\n}\n.x6-widget-handle-surround .x6-widget-handle-pos-w {\n  top: 50%;\n  left: -25px;\n  margin-top: -10px;\n}\n.x6-widget-handle-surround .x6-widget-handle-pos-sw {\n  bottom: -25px;\n  left: -25px;\n}\n.x6-widget-handle-surround .x6-widget-handle-pos-s {\n  bottom: -24px;\n  left: 50%;\n  margin-left: -10px;\n}\n.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle {\n  width: 15px;\n  height: 15px;\n  font-size: 15px;\n  background-size: 15px 15px;\n}\n.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-se {\n  right: -19px;\n  bottom: -19px;\n}\n.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-nw {\n  top: -19px;\n  left: -19px;\n}\n.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-n {\n  top: -19px;\n  margin-left: -7.5px;\n}\n.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-e {\n  top: -webkit-calc(42%);\n  top: calc(50% - 8px);\n  right: -19px;\n}\n.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-ne {\n  top: -19px;\n  right: -19px;\n}\n.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-w {\n  left: -19px;\n  margin-top: -8px;\n}\n.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-sw {\n  bottom: -19px;\n  left: -19px;\n}\n.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-s {\n  bottom: -19px;\n  margin-left: -7.5px;\n}\n.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle {\n  width: 10px;\n  height: 10px;\n  font-size: 10px;\n  background-size: 10px 10px;\n}\n.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-se {\n  right: -15px;\n  bottom: -13px;\n}\n.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-nw {\n  top: -13px;\n  left: -15px;\n}\n.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-n {\n  top: -13px;\n  margin-left: -5px;\n}\n.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-e {\n  top: -webkit-calc(45%);\n  top: calc(50% - 5px);\n  right: -15px;\n}\n.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-ne {\n  top: -13px;\n  right: -15px;\n}\n.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-w {\n  left: -15px;\n  margin-top: -5px;\n}\n.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-sw {\n  bottom: -13px;\n  left: -15px;\n}\n.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-s {\n  bottom: -13px;\n  margin-left: -5px;\n}\n.x6-widget-handle-toolbar {\n  position: absolute;\n  top: -50px;\n  display: table-row;\n  padding: 7px 5px;\n}\n.x6-widget-handle-toolbar::after {\n  position: absolute;\n  top: 100%;\n  left: 10px;\n  width: 0;\n  height: 0;\n  margin-top: 4px;\n  border-right: 10px solid transparent;\n  border-left: 10px solid transparent;\n  content: '';\n}\n.x6-widget-handle-toolbar .x6-widget-handle {\n  position: relative;\n  display: table-cell;\n  min-width: 20px;\n  margin: 0 2px;\n  background-position: 3px 3px;\n  background-size: 16px 16px;\n}\n.x6-widget-handle-toolbar .x6-widget-handle::after {\n  position: absolute;\n  bottom: -11px;\n  width: 100%;\n  content: '';\n}\n.x6-widget-handle-pie {\n  position: absolute;\n  top: -webkit-calc(0%);\n  top: calc(50% - 50px);\n  right: -50px;\n  z-index: 1;\n  display: none;\n  width: 100px;\n  height: 100px;\n  margin: -2px -2px 0 0;\n  border-radius: 50%;\n  cursor: default;\n  pointer-events: visiblePainted;\n}\n.x6-widget-handle-pie .x6-widget-handle {\n  width: 1px;\n  height: auto;\n  pointer-events: visiblePainted;\n}\n.x6-widget-handle-pie-slice-svg {\n  width: 100%;\n  height: 100%;\n  overflow: visible !important;\n}\n.x6-widget-handle-pie-slice-img,\n.x6-widget-handle-pie-slice-txt {\n  display: none;\n  pointer-events: none;\n}\n.x6-widget-handle-pie[data-pie-toggle-position='e'] {\n  top: calc(50% - 50px);\n  right: -50px;\n  left: auto;\n}\n.x6-widget-handle-pie[data-pie-toggle-position='w'] {\n  top: calc(50% - 50px);\n  right: auto;\n  left: -52px;\n}\n.x6-widget-handle-pie[data-pie-toggle-position='n'] {\n  top: -50px;\n  right: auto;\n  bottom: auto;\n  left: calc(50% - 52px);\n}\n.x6-widget-handle-pie[data-pie-toggle-position='s'] {\n  top: auto;\n  right: auto;\n  bottom: -52px;\n  left: calc(50% - 52px);\n}\n.x6-widget-handle-pie-opened {\n  display: block;\n  animation: halo-pie-visibility 0.1s, halo-pie-opening 0.1s;\n  animation-timing-function: step-end, ease;\n  animation-delay: 0s, 0.1s;\n}\n.x6-widget-handle-pie-toggle {\n  position: absolute;\n  top: -webkit-calc(35%);\n  top: calc(50% - 15px);\n  right: -15px;\n  z-index: 2;\n  display: block;\n  box-sizing: border-box;\n  width: 30px;\n  height: 30px;\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: 20px 20px;\n  border-radius: 50%;\n  cursor: pointer;\n  user-select: none;\n  pointer-events: visiblePainted;\n  -webkit-user-drag: none;\n  user-drag: none;\n  /* stylelint-disable-line */\n}\n.x6-widget-handle-pie-toggle-pos-e {\n  top: -webkit-calc(35%);\n  top: calc(50% - 15px);\n  right: -15px;\n  bottom: auto;\n  left: auto;\n}\n.x6-widget-handle-pie-toggle-pos-w {\n  top: -webkit-calc(35%);\n  top: calc(50% - 15px);\n  right: auto;\n  bottom: auto;\n  left: -15px;\n}\n.x6-widget-handle-pie-toggle-pos-n {\n  top: -15px;\n  right: auto;\n  bottom: auto;\n  left: -webkit-calc(35%);\n  left: calc(50% - 15px);\n}\n.x6-widget-handle-pie-toggle-pos-s {\n  top: auto;\n  right: auto;\n  bottom: -15px;\n  left: -webkit-calc(35%);\n  left: calc(50% - 15px);\n}\n.x6-widget-handle-pie-toggle-opened {\n  transition: 0.1s background-image;\n}\n.x6-widget-handle-toolbar {\n  position: static;\n  display: inline-block;\n  margin-top: -50px;\n  margin-left: 45px;\n  white-space: nowrap;\n  vertical-align: top;\n  background-color: #f5f5f5;\n  border-bottom: 3px solid #333;\n  border-radius: 5px;\n  box-shadow: 0 1px 2px #222;\n}\n.x6-widget-handle-toolbar::after {\n  top: -12px;\n  left: 55px;\n  margin-top: 0;\n  border-top: 6px solid #333;\n  border-right: 10px solid transparent;\n  border-left: 10px solid transparent;\n}\n.x6-widget-handle-toolbar .x6-widget-handle {\n  display: inline-block;\n  vertical-align: top;\n}\n.x6-widget-handle-toolbar .x6-widget-handle:hover::after {\n  border-bottom: 4px solid #fc6cb8;\n}\n.x6-widget-handle-toolbar .x6-widget-handle-rotate {\n  position: absolute;\n  top: 100%;\n  right: 100%;\n  margin-top: 3px;\n  margin-right: 6px;\n}\n.x6-widget-handle-toolbar .x6-widget-handle-remove:hover::after,\n.x6-widget-handle-toolbar .x6-widget-handle-rotate:hover::after {\n  border-bottom: none;\n}\n.x6-widget-handle-toolbar .x6-widget-handle + .x6-widget-handle {\n  margin-left: 4px;\n}\n.x6-widget-handle-pie {\n  box-sizing: content-box;\n  background-color: #f5f5f5;\n  border: 2px solid #404040;\n}\n.x6-widget-handle-pie-slice {\n  fill: transparent;\n  stroke: #e9e9e9;\n  stroke-width: 1;\n}\n.x6-widget-handle-pie-slice:hover {\n  fill: #fff;\n}\n.x6-widget-handle-pie-slice-img {\n  display: block;\n}\n.x6-widget-handle-selected .x6-widget-handle-pie-slice {\n  fill: #fff;\n}\n.x6-widget-handle-pie-toggle {\n  background-color: #f6f6f6;\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20height%3D%2216px%22%20id%3D%22Layer_1%22%20style%3D%22enable-background%3Anew%200%200%2016%2016%3B%22%20version%3D%221.1%22%20viewBox%3D%220%200%2016%2016%22%20width%3D%2216px%22%20xml%3Aspace%3D%22preserve%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M15%2C6h-5V1c0-0.55-0.45-1-1-1H7C6.45%2C0%2C6%2C0.45%2C6%2C1v5H1C0.45%2C6%2C0%2C6.45%2C0%2C7v2c0%2C0.55%2C0.45%2C1%2C1%2C1h5v5c0%2C0.55%2C0.45%2C1%2C1%2C1h2%20c0.55%2C0%2C1-0.45%2C1-1v-5h5c0.55%2C0%2C1-0.45%2C1-1V7C16%2C6.45%2C15.55%2C6%2C15%2C6z%22%2F%3E%3C%2Fsvg%3E');\n  background-size: 16px 16px;\n  border: 2px solid #3b425f;\n}\n.x6-widget-handle-pie-toggle:hover {\n  background-color: #fff;\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20height%3D%2216px%22%20id%3D%22Layer_1%22%20style%3D%22enable-background%3Anew%200%200%2016%2016%3B%22%20version%3D%221.1%22%20viewBox%3D%220%200%2016%2016%22%20width%3D%2216px%22%20xml%3Aspace%3D%22preserve%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Cpath%20fill%3D%22%23FD6EB6%22%20d%3D%22M15%2C6h-5V1c0-0.55-0.45-1-1-1H7C6.45%2C0%2C6%2C0.45%2C6%2C1v5H1C0.45%2C6%2C0%2C6.45%2C0%2C7v2c0%2C0.55%2C0.45%2C1%2C1%2C1h5v5c0%2C0.55%2C0.45%2C1%2C1%2C1h2%20c0.55%2C0%2C1-0.45%2C1-1v-5h5c0.55%2C0%2C1-0.45%2C1-1V7C16%2C6.45%2C15.55%2C6%2C15%2C6z%22%2F%3E%3C%2Fsvg%3E');\n  border-color: #fd6eb6;\n}\n.x6-widget-handle-pie-toggle-opened {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%20standalone%3D%22no%22%3F%3E%3Csvg%20xmlns%3Adc%3D%22http%3A%2F%2Fpurl.org%2Fdc%2Felements%2F1.1%2F%22%20xmlns%3Acc%3D%22http%3A%2F%2Fcreativecommons.org%2Fns%23%22%20xmlns%3Ardf%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2F02%2F22-rdf-syntax-ns%23%22%20xmlns%3Asvg%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20version%3D%221.1%22%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20id%3D%22Layer_1%22%20xml%3Aspace%3D%22preserve%22%3E%3Cmetadata%20id%3D%22metadata9%22%3E%3Crdf%3ARDF%3E%3Ccc%3AWork%20rdf%3Aabout%3D%22%22%3E%3Cdc%3Aformat%3Eimage%2Fsvg%2Bxml%3C%2Fdc%3Aformat%3E%3Cdc%3Atype%20rdf%3Aresource%3D%22http%3A%2F%2Fpurl.org%2Fdc%2Fdcmitype%2FStillImage%22%20%2F%3E%3Cdc%3Atitle%3E%3C%2Fdc%3Atitle%3E%3C%2Fcc%3AWork%3E%3C%2Frdf%3ARDF%3E%3C%2Fmetadata%3E%3Cdefs%20id%3D%22defs7%22%20%2F%3E%3Cpath%20d%3D%22M%2015%2C6%2010%2C6%20C%201.0301983%2C6.00505%2015.002631%2C6.011353%206%2C6%20L%201%2C6%20C%200.45%2C6%200%2C6.45%200%2C7%20l%200%2C2%20c%200%2C0.55%200.45%2C1%201%2C1%20l%205%2C0%20c%208.988585%2C-0.019732%20-5.02893401%2C-0.018728%204%2C0%20l%205%2C0%20c%200.55%2C0%201%2C-0.45%201%2C-1%20L%2016%2C7%20C%2016%2C6.45%2015.55%2C6%2015%2C6%20z%22%20id%3D%22path3%22%20style%3D%22fill%3A%236a6c8a%22%20%2F%3E%3C%2Fsvg%3E');\n}\n.x6-widget-handle-pie-toggle-opened:hover {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%20standalone%3D%22no%22%3F%3E%3Csvg%20xmlns%3Adc%3D%22http%3A%2F%2Fpurl.org%2Fdc%2Felements%2F1.1%2F%22%20xmlns%3Acc%3D%22http%3A%2F%2Fcreativecommons.org%2Fns%23%22%20xmlns%3Ardf%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2F02%2F22-rdf-syntax-ns%23%22%20xmlns%3Asvg%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20version%3D%221.1%22%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20id%3D%22Layer_1%22%20xml%3Aspace%3D%22preserve%22%3E%3Cmetadata%20id%3D%22metadata9%22%3E%3Crdf%3ARDF%3E%3Ccc%3AWork%20rdf%3Aabout%3D%22%22%3E%3Cdc%3Aformat%3Eimage%2Fsvg%2Bxml%3C%2Fdc%3Aformat%3E%3Cdc%3Atype%20rdf%3Aresource%3D%22http%3A%2F%2Fpurl.org%2Fdc%2Fdcmitype%2FStillImage%22%20%2F%3E%3Cdc%3Atitle%3E%3C%2Fdc%3Atitle%3E%3C%2Fcc%3AWork%3E%3C%2Frdf%3ARDF%3E%3C%2Fmetadata%3E%3Cdefs%20id%3D%22defs7%22%20%2F%3E%3Cpath%20d%3D%22M%2015%2C6%2010%2C6%20C%201.0301983%2C6.00505%2015.002631%2C6.011353%206%2C6%20L%201%2C6%20C%200.45%2C6%200%2C6.45%200%2C7%20l%200%2C2%20c%200%2C0.55%200.45%2C1%201%2C1%20l%205%2C0%20c%208.988585%2C-0.019732%20-5.02893401%2C-0.018728%204%2C0%20l%205%2C0%20c%200.55%2C0%201%2C-0.45%201%2C-1%20L%2016%2C7%20C%2016%2C6.45%2015.55%2C6%2015%2C6%20z%22%20id%3D%22path3%22%20style%3D%22fill%3A%23FD6EB6%22%20%2F%3E%3C%2Fsvg%3E');\n}\n.x6-widget-dnd {\n  position: absolute;\n  top: -10000px;\n  left: -10000px;\n  z-index: 100;\n  display: none;\n  cursor: move;\n  opacity: 0.7;\n  pointer-events: 'cursor';\n}\n.x6-widget-dnd.dragging {\n  display: inline-block;\n}\n.x6-widget-dnd.dragging * {\n  pointer-events: none !important;\n}\n.x6-widget-dnd .x6-graph {\n  background: transparent;\n  box-shadow: none;\n}\n.x6-widget-halo {\n  position: absolute;\n  pointer-events: none;\n}\n.x6-widget-halo-content {\n  position: absolute;\n  top: 100%;\n  padding: 6px;\n  font-size: 10px;\n  line-height: 14px;\n  text-align: center;\n  border-radius: 6px;\n}\n.x6-widget-halo-handles + .x6-widget-halo-content {\n  right: -20px;\n  left: -20px;\n  margin-top: 30px;\n}\n.x6-widget-halo-handles.x6-widget-handle-small + .x6-widget-halo-content {\n  margin-top: 25px;\n}\n.x6-widget-halo-handles.x6-widget-handle-small + .x6-widget-halo-content {\n  margin-top: 20px;\n}\n.x6-widget-halo-handles.x6-widget-handle-pie + .x6-widget-halo-content {\n  right: 0;\n  left: 0;\n  margin-top: 10px;\n}\n.x6-widget-halo-content {\n  color: #fff;\n  background-color: #6a6b8a;\n}\n.x6-widget-halo.type-node .x6-widget-handle-toolbar .x6-widget-handle-remove {\n  position: absolute;\n  right: 100%;\n  bottom: 100%;\n  margin-right: 6px;\n  margin-bottom: 3px;\n}\n.x6-widget-halo.type-edge .x6-widget-handle-surround .x6-widget-handle-remove {\n  background-color: #fff;\n  border-radius: 50%;\n}\n.x6-widget-halo.type-edge .x6-widget-handle-toolbar {\n  margin-top: -60px;\n  margin-left: -18px;\n}\n.x6-widget-halo.type-edge .x6-widget-handle-toolbar::after {\n  top: -22px;\n  left: -9px;\n}\n.x6-widget-minimap {\n  position: relative;\n  display: table-cell;\n  box-sizing: border-box;\n  overflow: hidden;\n  text-align: center;\n  vertical-align: middle;\n  background-color: #fff;\n  user-select: none;\n}\n.x6-widget-minimap .x6-graph {\n  display: inline-block;\n  box-shadow: 0 0 4px 0 #eee;\n  cursor: pointer;\n}\n.x6-widget-minimap .x6-graph > svg {\n  pointer-events: none;\n  shape-rendering: optimizeSpeed;\n}\n.x6-widget-minimap .x6-graph .x6-node * {\n  /* stylelint-disable-next-line */\n  vector-effect: initial;\n}\n.x6-widget-minimap-viewport {\n  position: absolute;\n  box-sizing: content-box;\n  margin: -2px 0 0 -2px;\n  border: 2px solid #31d0c6;\n  cursor: move;\n}\n.x6-widget-minimap-viewport-zoom {\n  position: absolute;\n  right: 0;\n  bottom: 0;\n  box-sizing: border-box;\n  width: 12px;\n  height: 12px;\n  margin: 0 -6px -6px 0;\n  background-color: #fff;\n  border: 2px solid #31d0c6;\n  border-radius: 50%;\n  cursor: nwse-resize;\n}\n.x6-path-drawer {\n  cursor: crosshair;\n}\n.x6-path-drawer .start-point {\n  fill: #fff;\n  stroke: #000;\n  stroke-width: 2px;\n}\n.x6-path-drawer .start-point:hover {\n  fill: #000;\n}\n.x6-path-drawer .control-path {\n  pointer-events: none;\n  fill: none;\n  stroke: #000;\n  stroke-width: 1px;\n  stroke-linecap: round;\n}\n.x6-graph-scroller {\n  position: relative;\n  box-sizing: border-box;\n  overflow: scroll;\n  outline: none;\n}\n.x6-graph-scroller-content {\n  position: relative;\n}\n.x6-graph-scroller-background {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.x6-graph-scroller .x6-graph {\n  position: absolute;\n  display: inline-block;\n  margin: 0;\n  box-shadow: none;\n}\n.x6-graph-scroller .x6-graph > svg {\n  display: block;\n}\n.x6-graph-scroller.x6-graph-scroller-paged .x6-graph {\n  box-shadow: 0 0 4px 0 #eee;\n}\n.x6-graph-scroller-panning {\n  user-select: none;\n}\n.x6-graph-pagebreak {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.x6-graph-pagebreak-vertical {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  box-sizing: border-box;\n  width: 1px;\n  border-left: 1px dashed #bdbdbd;\n}\n.x6-graph-pagebreak-horizontal {\n  position: absolute;\n  right: 0;\n  left: 0;\n  box-sizing: border-box;\n  height: 1px;\n  border-top: 1px dashed #bdbdbd;\n}\n.x6-widget-selection {\n  position: absolute;\n  display: none;\n  width: 0;\n  height: 0;\n  touch-action: none;\n}\n.x6-widget-selection-rubberband {\n  display: block;\n  overflow: visible;\n  opacity: 0.3;\n}\n.x6-widget-selection-selected {\n  display: block;\n}\n.x6-widget-selection-box {\n  cursor: move;\n}\n.x6-widget-selection-inner[data-selection-length='0'],\n.x6-widget-selection-inner[data-selection-length='1'] {\n  display: none;\n}\n.x6-widget-selection-content {\n  position: absolute;\n  top: 100%;\n  right: -20px;\n  left: -20px;\n  margin-top: 30px;\n  padding: 6px;\n  line-height: 14px;\n  text-align: center;\n  border-radius: 6px;\n}\n.x6-widget-selection-content:empty {\n  display: none;\n}\n.x6-widget-selection-rubberband {\n  background-color: #3498db;\n  border: 2px solid #2980b9;\n}\n.x6-widget-selection-box {\n  box-sizing: content-box;\n  margin-top: -4px;\n  margin-left: -4px;\n  padding-right: 4px;\n  padding-bottom: 4px;\n  border: 2px dashed #feb663;\n  box-shadow: 2px 2px 5px #d3d3d3;\n}\n.x6-widget-selection-inner {\n  box-sizing: content-box;\n  margin-top: -8px;\n  margin-left: -8px;\n  padding-right: 12px;\n  padding-bottom: 12px;\n  border: 2px solid #feb663;\n  box-shadow: 2px 2px 5px #d3d3d3;\n}\n.x6-widget-selection-content {\n  color: #fff;\n  font-size: 10px;\n  background-color: #6a6b8a;\n}\n.x6-widget-snapline {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  pointer-events: none;\n}\n.x6-widget-snapline-vertical,\n.x6-widget-snapline-horizontal {\n  position: absolute;\n  opacity: 1;\n  pointer-events: none;\n}\n.x6-widget-snapline-horizontal {\n  border-bottom: 1px solid #2ecc71;\n}\n.x6-widget-snapline-vertical {\n  border-right: 1px solid #2ecc71;\n}\n.x6-widget-stencil {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.x6-widget-stencil::after {\n  position: absolute;\n  top: 0;\n  display: block;\n  width: 100%;\n  height: 20px;\n  padding: 8px 0;\n  line-height: 20px;\n  text-align: center;\n  opacity: 0;\n  transition: top 0.1s linear, opacity 0.1s linear;\n  content: ' ';\n  pointer-events: none;\n}\n.x6-widget-stencil-content {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  height: auto;\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n.x6-widget-stencil .x6-node [magnet]:not([magnet='passive']) {\n  pointer-events: none;\n}\n.x6-widget-stencil-group {\n  padding: 0;\n  padding-bottom: 8px;\n  overflow: hidden;\n  user-select: none;\n}\n.x6-widget-stencil-group.collapsed {\n  height: auto;\n  padding-bottom: 0;\n}\n.x6-widget-stencil-group-title {\n  position: relative;\n  margin-top: 0;\n  margin-bottom: 0;\n  padding: 4px;\n  cursor: pointer;\n}\n.x6-widget-stencil-title,\n.x6-widget-stencil-group > .x6-widget-stencil-group-title {\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  user-select: none;\n}\n.x6-widget-stencil .unmatched {\n  opacity: 0.3;\n}\n.x6-widget-stencil .x6-node.unmatched {\n  display: none;\n}\n.x6-widget-stencil-group.unmatched {\n  display: none;\n}\n.x6-widget-stencil-search-text {\n  position: relative;\n  z-index: 1;\n  box-sizing: border-box;\n  width: 100%;\n  height: 30px;\n  max-height: 30px;\n  line-height: 30px;\n  outline: 0;\n}\n.x6-widget-stencil.not-found::after {\n  opacity: 1;\n  content: 'No matches found';\n}\n.x6-widget-stencil.not-found.searchable::after {\n  top: 30px;\n}\n.x6-widget-stencil.not-found.searchable.collapsable::after {\n  top: 50px;\n}\n.x6-widget-stencil {\n  color: #333;\n  background: #f5f5f5;\n}\n.x6-widget-stencil-content {\n  position: absolute;\n}\n.x6-widget-stencil.collapsable > .x6-widget-stencil-content {\n  top: 32px;\n}\n.x6-widget-stencil.searchable > .x6-widget-stencil-content {\n  top: 80px;\n}\n.x6-widget-stencil.not-found::after {\n  position: absolute;\n}\n.x6-widget-stencil.not-found.searchable.collapsable::after {\n  top: 80px;\n}\n.x6-widget-stencil.not-found.searchable::after {\n  top: 60px;\n}\n.x6-widget-stencil-group {\n  height: auto;\n  margin-bottom: 1px;\n  padding: 0;\n  transition: none;\n}\n.x6-widget-stencil-group .x6-graph {\n  background: transparent;\n  box-shadow: none;\n}\n.x6-widget-stencil-group.collapsed {\n  height: auto;\n  max-height: 31px;\n}\n.x6-widget-stencil-title,\n.x6-widget-stencil-group > .x6-widget-stencil-group-title {\n  position: relative;\n  left: 0;\n  box-sizing: border-box;\n  width: 100%;\n  height: 32px;\n  padding: 0 5px 0 8px;\n  color: #666;\n  font-weight: 700;\n  font-size: 12px;\n  line-height: 32px;\n  cursor: default;\n  transition: all 0.3;\n}\n.x6-widget-stencil-title:hover,\n.x6-widget-stencil-group > .x6-widget-stencil-group-title:hover {\n  color: #444;\n}\n.x6-widget-stencil-title {\n  background: #e9e9e9;\n}\n.x6-widget-stencil-group > .x6-widget-stencil-group-title {\n  background: #ededed;\n}\n.x6-widget-stencil.collapsable > .x6-widget-stencil-title,\n.x6-widget-stencil-group.collapsable > .x6-widget-stencil-group-title {\n  padding-left: 32px;\n  cursor: pointer;\n}\n.x6-widget-stencil.collapsable > .x6-widget-stencil-title::before,\n.x6-widget-stencil-group.collapsable > .x6-widget-stencil-group-title::before {\n  position: absolute;\n  top: 6px;\n  left: 8px;\n  display: block;\n  width: 18px;\n  height: 18px;\n  margin: 0;\n  padding: 0;\n  background-color: transparent;\n  background-repeat: no-repeat;\n  background-position: 0 0;\n  border: none;\n  content: ' ';\n}\n.x6-widget-stencil.collapsable > .x6-widget-stencil-title::before,\n.x6-widget-stencil-group.collapsable > .x6-widget-stencil-group-title::before {\n  background-image: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgiIGhlaWdodD0iMTgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJub256ZXJvIj48cGF0aCBkPSJNOS4zNzUuNUM0LjY4Ny41Ljg3NSA0LjMxMy44NzUgOWMwIDQuNjg4IDMuODEyIDguNSA4LjUgOC41IDQuNjg3IDAgOC41LTMuODEyIDguNS04LjUgMC00LjY4Ny0zLjgxMy04LjUtOC41LTguNXptMCAxNS44ODZDNS4zMDMgMTYuMzg2IDEuOTkgMTMuMDcyIDEuOTkgOXMzLjMxMi03LjM4NSA3LjM4NS03LjM4NVMxNi43NiA0LjkyOCAxNi43NiA5YzAgNC4wNzItMy4zMTMgNy4zODYtNy4zODUgNy4zODZ6Ii8+PHBhdGggZD0iTTEyLjc1MyA4LjQ0M0g1Ljk5N2EuNTU4LjU1OCAwIDAwMCAxLjExNmg2Ljc1NmEuNTU4LjU1OCAwIDAwMC0xLjExNnoiLz48L2c+PC9zdmc+');\n  opacity: 0.4;\n  transition: all 0.3s;\n}\n.x6-widget-stencil.collapsable > .x6-widget-stencil-title:hover::before,\n.x6-widget-stencil-group.collapsable > .x6-widget-stencil-group-title:hover::before {\n  opacity: 0.6;\n}\n.x6-widget-stencil.collapsable.collapsed > .x6-widget-stencil-title::before,\n.x6-widget-stencil-group.collapsable.collapsed > .x6-widget-stencil-group-title::before {\n  background-image: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgiIGhlaWdodD0iMTgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJub256ZXJvIj48cGF0aCBkPSJNOS4zNzUuNUM0LjY4Ny41Ljg3NSA0LjMxMy44NzUgOWMwIDQuNjg4IDMuODEyIDguNSA4LjUgOC41IDQuNjg3IDAgOC41LTMuODEyIDguNS04LjUgMC00LjY4Ny0zLjgxMy04LjUtOC41LTguNXptMCAxNS44ODZDNS4zMDMgMTYuMzg2IDEuOTkgMTMuMDcyIDEuOTkgOXMzLjMxMi03LjM4NSA3LjM4NS03LjM4NVMxNi43NiA0LjkyOCAxNi43NiA5YzAgNC4wNzItMy4zMTMgNy4zODYtNy4zODUgNy4zODZ6Ii8+PHBhdGggZD0iTTEyLjc1MyA4LjQ0M0g1Ljk5N2EuNTU4LjU1OCAwIDAwMCAxLjExNmg2Ljc1NmEuNTU4LjU1OCAwIDAwMC0xLjExNnoiLz48cGF0aCBkPSJNOC44MTcgNS42MjN2Ni43NTZhLjU1OC41NTggMCAwMDEuMTE2IDBWNS42MjNhLjU1OC41NTggMCAxMC0xLjExNiAweiIvPjwvZz48L3N2Zz4=');\n  opacity: 0.4;\n}\n.x6-widget-stencil.collapsable.collapsed > .x6-widget-stencil-title:hover::before,\n.x6-widget-stencil-group.collapsable.collapsed > .x6-widget-stencil-group-title:hover::before {\n  opacity: 0.6;\n}\n.x6-widget-stencil input[type='search'] {\n  -webkit-appearance: textfield;\n}\n.x6-widget-stencil input[type='search']::-webkit-search-cancel-button,\n.x6-widget-stencil input[type='search']::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n.x6-widget-stencil-search-text {\n  display: block;\n  width: 90%;\n  margin: 8px 5%;\n  padding-left: 8px;\n  color: #333;\n  background: #fff;\n  border: 1px solid #e9e9e9;\n  border-radius: 12px;\n  outline: 0;\n}\n.x6-widget-stencil-search-text:focus {\n  outline: 0;\n}\n.x6-widget-stencil::after {\n  color: #808080;\n  font-weight: 600;\n  font-size: 12px;\n  background: 0 0;\n}\n.x6-widget-transform {\n  position: absolute;\n  box-sizing: content-box;\n  margin: -5px 0 0 -5px;\n  padding: 4px;\n  border: 1px dashed #000;\n  border-radius: 5px;\n  user-select: none;\n  pointer-events: none;\n}\n.x6-widget-transform > div {\n  position: absolute;\n  box-sizing: border-box;\n  background-color: #fff;\n  border: 1px solid #000;\n  transition: background-color 0.2s;\n  pointer-events: auto;\n  -webkit-user-drag: none;\n  user-drag: none;\n  /* stylelint-disable-line */\n}\n.x6-widget-transform > div:hover {\n  background-color: #d3d3d3;\n}\n.x6-widget-transform-cursor-n {\n  cursor: n-resize;\n}\n.x6-widget-transform-cursor-s {\n  cursor: s-resize;\n}\n.x6-widget-transform-cursor-e {\n  cursor: e-resize;\n}\n.x6-widget-transform-cursor-w {\n  cursor: w-resize;\n}\n.x6-widget-transform-cursor-ne {\n  cursor: ne-resize;\n}\n.x6-widget-transform-cursor-nw {\n  cursor: nw-resize;\n}\n.x6-widget-transform-cursor-se {\n  cursor: se-resize;\n}\n.x6-widget-transform-cursor-sw {\n  cursor: sw-resize;\n}\n.x6-widget-transform-resize {\n  width: 10px;\n  height: 10px;\n  border-radius: 6px;\n}\n.x6-widget-transform-resize[data-position='top-left'] {\n  top: -5px;\n  left: -5px;\n}\n.x6-widget-transform-resize[data-position='top-right'] {\n  top: -5px;\n  right: -5px;\n}\n.x6-widget-transform-resize[data-position='bottom-left'] {\n  bottom: -5px;\n  left: -5px;\n}\n.x6-widget-transform-resize[data-position='bottom-right'] {\n  right: -5px;\n  bottom: -5px;\n}\n.x6-widget-transform-resize[data-position='top'] {\n  top: -5px;\n  left: 50%;\n  margin-left: -5px;\n}\n.x6-widget-transform-resize[data-position='bottom'] {\n  bottom: -5px;\n  left: 50%;\n  margin-left: -5px;\n}\n.x6-widget-transform-resize[data-position='left'] {\n  top: 50%;\n  left: -5px;\n  margin-top: -5px;\n}\n.x6-widget-transform-resize[data-position='right'] {\n  top: 50%;\n  right: -5px;\n  margin-top: -5px;\n}\n.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='top'],\n.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='bottom'],\n.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='left'],\n.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='right'] {\n  display: none;\n}\n.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='bottom'],\n.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='left'],\n.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='right'],\n.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='top'] {\n  display: none;\n}\n.x6-widget-transform.no-resize .x6-widget-transform-resize {\n  display: none;\n}\n.x6-widget-transform-rotate {\n  top: -20px;\n  left: -20px;\n  width: 12px;\n  height: 12px;\n  border-radius: 6px;\n  cursor: crosshair;\n}\n.x6-widget-transform.no-rotate .x6-widget-transform-rotate {\n  display: none;\n}\n.x6-widget-transform-active {\n  pointer-events: all;\n}\n.x6-widget-transform-active > div {\n  display: none;\n}\n.x6-widget-transform-active > .x6-widget-transform-active-handle {\n  display: block;\n  background-color: #808080;\n}\n.x6-graph-print {\n  position: relative;\n}\n.x6-graph-print .x6-graph-print-ready {\n  display: none;\n}\n.x6-graph-print .x6-graph-print-preview {\n  overflow: hidden !important;\n  background: #fff !important;\n}\n@media print {\n  html,\n  html > body.x6-graph-printing {\n    position: relative !important;\n    width: 100% !important;\n    height: 100% !important;\n    margin: 0 !important;\n    padding: 0 !important;\n  }\n  html > body.x6-graph-printing > * {\n    display: none !important;\n  }\n  html > body.x6-graph-printing > .x6-graph-print {\n    display: block !important;\n  }\n  .x6-graph-print {\n    top: 0 !important;\n    left: 0 !important;\n    margin: 0 !important;\n    padding: 0 !important;\n    overflow: hidden !important;\n    page-break-after: always;\n    background: #fff !important;\n  }\n  .x6-graph-print .x6-graph-print-ready {\n    display: none;\n  }\n}\n";
    class Nk extends Dk {
      init() {
        Jx.autoInsertCSS && Nk.ensure()
      }
    }
    var Fk, $k, Bk;
    ! function(t) {
      let e;
      (Nk || (Nk = {})).ensure = function() {
        if (null == e && !D.a.isApplyingHMR()) {
          (e = document.createElement("style")).setAttribute("type", "text/css"), e.textContent = Lk;
          const t = document.querySelector("head");
          t && t.insertBefore(e, t.firstChild)
        }
      }
    }(),
    function(t) {
      t.root = "widget-minimap", t.viewport = `${t.root}-viewport`, t.zoom = `${t.viewport}-zoom`
    }(Fk || (Fk = {}));
    class Ik extends ZE {
      constructor(t) {
        super(), this.options = Object.assign(Object.assign({}, $k.defaultOptions), t), this.updateViewport = l
          .debounce(this.updateViewport.bind(this), 0), this.container = document.createElement("div"), this.$container =
          this.$(this.container).addClass(this.prefixClassName(Fk.root));
        const e = document.createElement("div");
        this.container.appendChild(e), this.$viewport = this.$("<div>").addClass(this.prefixClassName(Fk.viewport)),
          this.options.scalable && (this.zoomHandle = this.$("<div>").addClass(this.prefixClassName(Fk.zoom)).appendTo(
            this.$viewport).get(0)), this.$container.append(this.$viewport).css({
            width: this.options.width,
            height: this.options.height,
            padding: this.options.padding
          }), this.options.container && this.options.container.appendChild(this.container), this.sourceGraph =
          this.scroller.graph;
        const n = Object.assign(Object.assign({}, this.options.graphOptions), {
          container: e,
          model: this.sourceGraph.model,
          frozen: !0,
          interacting: !1,
          grid: !1,
          background: !1,
          rotating: !1,
          resizing: !1,
          embedding: !1,
          selecting: !1,
          snapline: !1,
          clipboard: !1,
          history: !1,
          scroller: !1
        });
        this.targetGraph = this.options.createGraph ? this.options.createGraph(n) : new JO(n), this.targetGraph
          .renderer.unfreeze(), this.updatePaper(this.sourceGraph.options.width, this.sourceGraph.options.height),
          this.startListening()
      }
      get scroller() {
        return this.options.scroller
      }
      startListening() {
        this.scroller.$container.on(`scroll${this.getEventNamespace()}`, this.updateViewport), this.sourceGraph
          .on("resize", this.updatePaper, this), this.delegateEvents({
            mousedown: "startAction",
            touchstart: "startAction",
            [`mousedown .${this.prefixClassName("graph")}`]: "scrollTo",
            [`touchstart .${this.prefixClassName("graph")}`]: "scrollTo"
          })
      }
      stopListening() {
        this.scroller.$container.off(this.getEventNamespace()), this.sourceGraph.off("resize", this.updatePaper,
          this), this.undelegateEvents()
      }
      onRemove() {
        this.targetGraph.view.remove(), this.stopListening()
      }
      updatePaper(t, e) {
        let n, r;
        "object" == typeof t ? (n = t.width, r = t.height) : (n = t, r = e);
        const i = this.sourceGraph.options,
          o = this.sourceGraph.scale(),
          s = this.options.width - 2 * this.options.padding,
          a = this.options.height - 2 * this.options.padding;
        n /= o.sx, r /= o.sy, this.ratio = Math.min(s / n, a / r);
        const l = this.ratio,
          c = i.x * l / o.sx,
          h = i.y * l / o.sy;
        return n *= l, r *= l, this.targetGraph.resizeGraph(n, r), this.targetGraph.translate(c, h), this.targetGraph
          .scale(l, l), this.updateViewport(), this
      }
      updateViewport() {
        const t = this.ratio,
          e = this.sourceGraph.scale(),
          n = this.scroller,
          r = n.clientToLocalPoint(0, 0),
          i = this.$(this.targetGraph.container).position(),
          o = this.targetGraph.translate();
        o.ty = o.ty || 0, this.geometry = {
          top: i.top + r.y * t + o.ty,
          left: i.left + r.x * t + o.tx,
          width: n.$container.innerWidth() * t / e.sx,
          height: n.$container.innerHeight() * t / e.sy
        }, this.$viewport.css(this.geometry)
      }
      startAction(t) {
        const e = this.normalizeEvent(t),
          n = {
            action: e.target === this.zoomHandle ? "zooming" : "panning",
            clientX: e.clientX,
            clientY: e.clientY,
            scrollLeft: this.scroller.container.scrollLeft,
            scrollTop: this.scroller.container.scrollTop,
            zoom: this.scroller.zoom(),
            scale: this.sourceGraph.scale(),
            geometry: this.geometry
          };
        this.delegateDocumentEvents($k.documentEvents, n)
      }
      doAction(t) {
        const e = this.normalizeEvent(t),
          n = e.clientX,
          r = e.clientY,
          i = e.data;
        switch (i.action) {
          case "panning":
            {
              const t = this.sourceGraph.scale(),
                e = (n - i.clientX) * t.sx,
                o = (r - i.clientY) * t.sy;this.scroller.container.scrollLeft = i.scrollLeft + e / this.ratio,
              this.scroller.container.scrollTop = i.scrollTop + o / this.ratio;
              break
            }
          case "zooming":
            {
              const t = i.scale,
                e = i.geometry,
                r = 1 + (i.clientX - n) / e.width / t.sx;i.frameId && cancelAnimationFrame(i.frameId),
              i.frameId = requestAnimationFrame(() => {
                this.scroller.zoom(r * i.zoom, {
                  absolute: !0,
                  minScale: this.options.minScale,
                  maxScale: this.options.maxScale
                })
              });
              break
            }
        }
      }
      stopAction() {
        this.undelegateDocumentEvents()
      }
      scrollTo(t) {
        const e = this.normalizeEvent(t);
        let n, r;
        const i = this.targetGraph.translate();
        if (i.ty = i.ty || 0, null == e.offsetX) {
          const t = this.$(this.targetGraph.container).offset();
          n = e.pageX - t.left, r = e.pageY - t.top
        } else n = e.offsetX, r = e.offsetY;
        const o = (n - i.tx) / this.ratio,
          s = (r - i.ty) / this.ratio;
        this.scroller.centerPoint(o, s)
      }
    }(Bk = $k || ($k = {})).defaultOptions = {
      width: 300,
      height: 200,
      padding: 10,
      scalable: !0,
      minScale: .01,
      maxScale: 16,
      graphOptions: {},
      createGraph: t => new JO(t)
    }, Bk.documentEvents = {
      mousemove: "doAction",
      touchmove: "doAction",
      mouseup: "stopAction",
      touchend: "stopAction"
    };
    var zk = this && this.__decorate || function(t, e, n, r) {
        var i, o = arguments.length,
          s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r);
        else
          for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) ||
            s);
        return o > 3 && s && Object.defineProperty(e, n, s), s
      },
      Rk = this && this.__rest || function(t, e) {
        var n = {};
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
        if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
          var i = 0;
          for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
            .call(t, r[i]) && (n[r[i]] = t[r[i]])
        }
        return n
      };
    class Vk extends ZE {
      constructor(t) {
        super();
        const {
          graph: e
        } = t, n = Rk(t, ["graph"]);
        this.graph = e, this.options = Object.assign({
          tolerance: 10
        }, n), this.render(), this.parseFilter(), this.disabled || this.startListening()
      }
      get model() {
        return this.graph.model
      }
      get containerClassName() {
        return this.prefixClassName("widget-snapline")
      }
      get verticalClassName() {
        return `${this.containerClassName}-vertical`
      }
      get horizontalClassName() {
        return `${this.containerClassName}-horizontal`
      }
      get disabled() {
        return !0 !== this.options.enabled || !0 !== this.graph.options.snapline.enabled
      }
      enable() {
        this.disabled && (this.options.enabled = !0, this.graph.options.snapline.enabled = !0, this.startListening())
      }
      disable() {
        this.disabled || (this.options.enabled = !1, this.graph.options.snapline.enabled = !1, this.stopListening())
      }
      setFilter(t) {
        this.options.filter = t, this.parseFilter()
      }
      render() {
        this.container = document.createElement("div"), this.$container = this.$(this.container), this.$horizontal =
          this.$(document.createElement("div")).addClass(this.horizontalClassName), this.$vertical = this.$(
            document.createElement("div")).addClass(this.verticalClassName), this.$container.hide().addClass(
            this.containerClassName).append([this.$horizontal, this.$vertical]), this.options.className && this
          .$container.addClass(this.options.className)
      }
      startListening() {
        this.stopListening(), this.graph.on("node:mousedown", this.captureCursorOffset, this), this.graph.on(
            "node:mousemove", this.snapOnMoving, this), this.model.on("batch:stop", this.onBatchStop, this),
          this.delegateDocumentEvents({
            mouseup: "hide",
            touchend: "hide"
          })
      }
      stopListening() {
        this.graph.off("node:mousedown", this.captureCursorOffset, this), this.graph.off("node:mousemove", this
          .snapOnMoving, this), this.model.off("batch:stop", this.onBatchStop, this), this.undelegateDocumentEvents()
      }
      parseFilter() {
        this.filterShapes = {}, this.filterCells = {}, this.filterFunction = null;
        const t = this.options.filter;
        Array.isArray(t) ? t.forEach(t => {
          "string" == typeof t ? this.filterShapes[t] = !0 : this.filterCells[t.id] = !0
        }) : "function" == typeof t && (this.filterFunction = t)
      }
      onBatchStop({
        name: t,
        data: e
      }) {
        "resize" === t && this.snapOnResizing(e.cell, e)
      }
      captureCursorOffset({
        view: t,
        x: e,
        y: n
      }) {
        const r = t.getDelegatedView();
        if (r && this.isNodeMovable(r)) {
          const r = t.cell.getPosition();
          this.offset = {
            x: e - r.x,
            y: n - r.y
          }
        }
      }
      isNodeMovable(t) {
        return t && t.cell.isNode() && t.can("nodeMovable")
      }
      snapOnResizing(t, e) {
        if (this.options.resizing && !e.snapped && e.ui && e.direction && e.trueDirection) {
          const n = this.graph.renderer.findViewByCell(t);
          if (n && n.cell.isNode()) {
            const r = t.getBBox(),
              o = r.bbox(t.getAngle()),
              s = o.getTopLeft(),
              a = o.getBottomRight(),
              l = nC.normalize(t.getAngle()),
              c = this.options.tolerance || 0;
            let h, u, d, p, f, g;
            const m = {
                vertical: 0,
                horizontal: 0
              },
              v = e.direction,
              y = e.trueDirection,
              b = e.relativeDirection; - 1 !== y.indexOf("right") ? m.vertical = a.x : m.vertical = s.x, -1 !==
              y.indexOf("bottom") ? m.horizontal = a.y : m.horizontal = s.y, this.model.getNodes().some(e => {
                if (this.isIgnored(t, e)) return !1;
                const n = e.getBBox().bbox(e.getAngle()),
                  r = n.getTopLeft(),
                  s = n.getBottomRight(),
                  l = {
                    vertical: [r.x, s.x],
                    horizontal: [r.y, s.y]
                  },
                  v = {};
                return Object.keys(l).forEach(t => {
                  const e = t,
                    n = l[e].map(t => ({
                      position: t,
                      distance: Math.abs(t - m[e])
                    })).filter(t => t.distance <= c);
                  v[e] = i.sortBy(n, t => t.distance)
                }), null == h && v.vertical.length > 0 && (h = v.vertical[0].position, u = Math.min(o.y, n.y),
                  d = Math.max(a.y, s.y) - u), null == p && v.horizontal.length > 0 && (p = v.horizontal[0]
                  .position, f = Math.min(o.x, n.x), g = Math.max(a.x, s.x) - f), null != h && null != p
              }), this.hide();
            let C = 0,
              x = 0;
            null == p && null == h || (null != h && (C = -1 !== y.indexOf("right") ? h - a.x : s.x - h), null !=
              p && (x = -1 !== y.indexOf("bottom") ? p - a.y : s.y - p));
            let w = 0,
              A = 0;
            if (l % 90 == 0) 90 === l || 270 === l ? (w = x, A = C) : (w = C, A = x);
            else {
              const t = 0 <= l && l < 90 ? 1 : 90 <= l && l < 180 ? 4 : 180 <= l && l < 270 ? 3 : 2;
              null != p && null != h && (C < x ? (x = 0, p = void 0) : (C = 0, h = void 0));
              const e = nC.toRad(l % 90);
              C && (w = 3 === t ? C / Math.cos(e) : C / Math.sin(e)), x && (A = 3 === t ? x / Math.cos(e) : x /
                Math.sin(e));
              const n = 1 === t || 3 === t;
              switch (b) {
                case "top":
                case "bottom":
                  A = x ? x / (n ? Math.cos(e) : Math.sin(e)) : C / (n ? Math.sin(e) : Math.cos(e));
                  break;
                case "left":
                case "right":
                  w = C ? C / (n ? Math.cos(e) : Math.sin(e)) : x / (n ? Math.sin(e) : Math.cos(e))
              }
            }
            switch (b) {
              case "top":
              case "bottom":
                w = 0;
                break;
              case "left":
              case "right":
                A = 0
            }
            const E = this.graph.getGridSize();
            let S = Math.max(r.width + w, E),
              M = Math.max(r.height + A, E);
            e.minWidth && e.minWidth > E && (S = Math.max(S, e.minWidth)), e.minHeight && e.minHeight > E && (M =
              Math.max(M, e.minHeight)), e.maxWidth && (S = Math.min(S, e.maxWidth)), e.maxHeight && (M =
              Math.min(M, e.maxHeight)), e.preserveAspectRatio && (A < w ? M = S * (r.height / r.width) : S =
              M * (r.width / r.height)), S === r.width && M === r.height || (t.resize(S, M, {
              direction: v,
              relativeDirection: b,
              trueDirection: y,
              snapped: !0,
              snaplines: this.cid,
              restrict: this.graph.hook.getRestrictArea(n)
            }), d && (d += M - r.height), g && (g += S - r.width));
            const k = t.getBBox().bbox(l);
            h && Math.abs(k.x - h) > 1 && Math.abs(k.width + k.x - h) > 1 && (h = void 0), p && Math.abs(k.y -
              p) > 1 && Math.abs(k.height + k.y - p) > 1 && (p = void 0), this.update({
              verticalLeft: h,
              verticalTop: u,
              verticalHeight: d,
              horizontalTop: p,
              horizontalLeft: f,
              horizontalWidth: g
            })
          }
        }
      }
      snapOnMoving({
        view: t,
        e: e,
        x: n,
        y: r
      }) {
        const i = t.getEventData(e).delegatedView || t;
        if (!this.isNodeMovable(i)) return;
        const o = i.cell,
          s = o.getSize(),
          a = o.getPosition(),
          l = new uC(n - this.offset.x, r - this.offset.y, s.width, s.height),
          c = o.getAngle(),
          h = l.getCenter(),
          u = l.bbox(c),
          d = u.getTopLeft(),
          p = u.getBottomRight(),
          f = this.options.tolerance || 0;
        let g, m, v, y, b, C, x = 0,
          w = 0;
        if (this.model.getNodes().some(t => {
            if (this.isIgnored(o, t)) return !1;
            const e = t.getBBox().bbox(t.getAngle()),
              n = e.getCenter(),
              r = e.getTopLeft(),
              i = e.getBottomRight();
            return null == g && (Math.abs(n.x - h.x) < f ? (g = n.x, x = .5) : Math.abs(r.x - d.x) < f ? (g =
              r.x, x = 0) : Math.abs(r.x - p.x) < f ? (g = r.x, x = 1) : Math.abs(i.x - p.x) < f ? (g = i
              .x, x = 1) : Math.abs(i.x - d.x) < f && (g = i.x), null != g && (m = Math.min(u.y, e.y), v =
              Math.max(p.y, i.y) - m)), null == y && (Math.abs(n.y - h.y) < f ? (y = n.y, w = .5) : Math.abs(
                r.y - d.y) < f ? y = r.y : Math.abs(r.y - p.y) < f ? (y = r.y, w = 1) : Math.abs(i.y - p.y) <
              f ? (y = i.y, w = 1) : Math.abs(i.y - d.y) < f && (y = i.y), null != y && (b = Math.min(u.x,
                e.x), C = Math.max(p.x, i.x) - b)), null != g && null != y
          }), this.hide(), null != y || null != g) {
          null != y && (u.y = y - w * u.height), null != g && (u.x = g - x * u.width);
          const t = u.getCenter(),
            e = t.x - l.width / 2,
            n = t.y - l.height / 2,
            r = e - a.x,
            s = n - a.y;
          0 === r && 0 === s || (o.translate(r, s, {
            snapped: !0,
            restrict: this.graph.hook.getRestrictArea(i)
          }), C && (C += r), v && (v += s)), this.update({
            verticalLeft: g,
            verticalTop: m,
            verticalHeight: v,
            horizontalTop: y,
            horizontalLeft: b,
            horizontalWidth: C
          })
        }
      }
      isIgnored(t, e) {
        return e.id === t.id || e.isDescendantOf(t) || this.filterShapes[e.shape] || this.filterCells[e.id] ||
          this.filterFunction && l.call(this.filterFunction, this.graph, e)
      }
      update(t) {
        const e = this.graph.matrix(),
          n = e.a,
          r = e.d,
          i = e.e,
          o = e.f,
          s = this.options.sharp,
          a = null != this.graph.scroller.widget;
        t.horizontalTop ? this.$horizontal.css({
          top: t.horizontalTop * r + o,
          left: s ? t.horizontalLeft * n + i : a ? "-300%" : 0,
          width: s ? t.horizontalWidth * n : a ? "700%" : "100%"
        }).show() : this.$horizontal.hide(), t.verticalLeft ? this.$vertical.css({
          left: t.verticalLeft * n + i,
          top: s ? t.verticalTop * r + o : a ? "-300%" : 0,
          height: s ? t.verticalHeight * r : a ? "700%" : "100%"
        }).show() : this.$vertical.hide(), this.show()
      }
      resetTimer() {
        this.timer && (clearTimeout(this.timer), this.timer = null)
      }
      show() {
        return this.$container.show(), this.resetTimer(), null == this.container.parentNode && this.graph.container
          .appendChild(this.container), this
      }
      hide() {
        this.$container.hide(), this.resetTimer();
        const t = this.options.clean,
          e = "number" == typeof t ? t : !1 !== t ? 3e3 : 0;
        return e > 0 && (this.timer = window.setTimeout(() => {
          this.unmount()
        }, e)), this
      }
      onRemove() {
        this.stopListening(), this.hide()
      }
      dispose() {
        this.remove()
      }
    }
    zk([ZE.dispose()], Vk.prototype, "dispose", null);
    var Hk = this && this.__decorate || function(t, e, n, r) {
      var i, o = arguments.length,
        s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r);
      else
        for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) ||
          s);
      return o > 3 && s && Object.defineProperty(e, n, s), s
    };
    class Gk extends Dk {
      get container() {
        return this.view.container
      }
      get elem() {
        return this.view.background
      }
      init() {
        this.graph.on("scale", this.update, this), this.graph.on("translate", this.update, this), this.options.background &&
          this.draw(this.options.background)
      }
      updateBackgroundImage(t = {}) {
        let e = t.size || "auto auto",
          n = t.position || "center";
        const r = this.graph.scale(),
          i = this.graph.translate();
        if ("object" == typeof n) {
          n = `${i.tx+r.sx*(n.x||0)}px ${i.ty+r.sy*(n.y||0)}px`
        }
        "object" == typeof e && (e = `${(e=uC.fromSize(e).scale(r.sx,r.sy)).width}px ${e.height}px`), this.view.$(
          this.elem).css({
          backgroundSize: e,
          backgroundPosition: n
        })
      }
      drawBackgroundImage(t, e = {}) {
        if (!(t instanceof HTMLImageElement)) return void(this.elem.style.backgroundImage = "");
        let n;
        const r = e.opacity || 1,
          i = e.size;
        let o = e.repeat || "no-repeat";
        const s = rE.registry.get(o);
        if ("function" == typeof s) {
          const r = e.quality || 1;
          t.width *= r, t.height *= r;
          const a = s(t, e);
          if (!(a instanceof HTMLCanvasElement)) throw new Error(
            "Background pattern must return an HTML Canvas instance");
          n = a.toDataURL("image/png"), o = e.repeat && o !== e.repeat ? e.repeat : "repeat", "object" == typeof i ?
            (i.width *= a.width / t.width, i.height *= a.height / t.height) : void 0 === i && (e.size = {
              width: a.width / r,
              height: a.height / r
            })
        } else n = t.src, void 0 === i && (e.size = {
          width: t.width,
          height: t.height
        });
        this.view.$(this.elem).css({
          opacity: r,
          backgroundRepeat: o,
          backgroundImage: `url(${n})`
        }), this.updateBackgroundImage(e)
      }
      updateBackgroundColor(t) {
        this.container.style.backgroundColor = t || ""
      }
      update() {
        this.optionCache && this.updateBackgroundImage(this.optionCache)
      }
      draw(t = {}) {
        if (this.updateBackgroundColor(t.color), t.image) {
          const e = document.createElement("img");
          e.onload = (() => this.drawBackgroundImage(e, t)), e.setAttribute("crossorigin", "anonymous"), e.src =
            t.image, this.optionCache = o.clone(t)
        } else this.drawBackgroundImage(null), this.optionCache = null
      }
      clear() {
        this.draw()
      }
      dispose() {
        this.graph.off("scale", this.update, this), this.graph.off("translate", this.update, this), this.clear()
      }
    }
    Hk([Dk.dispose()], Gk.prototype, "dispose", null);
    var Uk, qk = this && this.__decorate || function(t, e, n, r) {
        var i, o = arguments.length,
          s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r);
        else
          for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) ||
            s);
        return o > 3 && s && Object.defineProperty(e, n, s), s
      },
      Wk = this && this.__rest || function(t, e) {
        var n = {};
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
        if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
          var i = 0;
          for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
            .call(t, r[i]) && (n[r[i]] = t[r[i]])
        }
        return n
      };
    class Xk extends ZE {
      constructor(t) {
        super(), this.padding = {
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        }, this.options = Uk.getOptions(t);
        const e = this.graph.scale();
        this.sx = e.sx, this.sy = e.sy;
        const n = this.options.width || this.graph.options.width,
          r = this.options.height || this.graph.options.height;
        this.container = document.createElement("div"), this.$container = this.$(this.container).addClass(this.prefixClassName(
            Uk.containerClass)).css({
            width: n,
            height: r
          }), this.options.pageVisible && this.$container.addClass(this.prefixClassName(Uk.pagedClass)), this.options
          .className && this.$container.addClass(this.options.className);
        const i = this.graph,
          o = i.container;
        o.parentNode && this.$container.insertBefore(o), this.content = document.createElement("div"), this.$content =
          this.$(this.content).addClass(this.prefixClassName(Uk.contentClass)).css({
            width: i.options.width,
            height: i.options.height
          }), this.options.background && (this.background = document.createElement("div"), this.$background =
            this.$(this.background).addClass(this.prefixClassName(Uk.backgroundClass)), this.$content.append(
              this.background)), this.options.pageVisible || (this.$content.append(this.graph.view.background),
            this.$content.append(this.graph.view.grid)), this.$content.append(o), this.$content.appendTo(this.container),
          this.startListening(), this.setCursor(this.options.cursor), this.options.pageVisible || (this.graph.grid
            .update(), this.graph.background.update()), this.backgroundManager = new Xk.Background(this)
      }
      get graph() {
        return this.options.graph
      }
      get model() {
        return this.graph.model
      }
      startListening() {
        const t = this.graph,
          e = this.model;
        t.on("scale", this.onScale, this), t.on("resize", this.onResize, this), t.on("before:print", this.storeScrollPosition,
          this), t.on("before:export", this.storeScrollPosition, this), t.on("after:print", this.restoreScrollPosition,
          this), t.on("after:export", this.restoreScrollPosition, this), this.options.autoResize && (t.renderer
          .isAsync() ? t.on("render:done", this.onRenderDone, this) : (t.on("unfreeze", this.update, this), e
            .on("reseted", this.update, this), e.on("cell:added", this.update, this), e.on("cell:removed",
              this.update, this), e.on("cell:changed", this.update, this))), this.delegateBackgroundEvents()
      }
      stopListening() {
        const t = this.graph,
          e = this.model;
        t.off("scale", this.onScale, this), t.off("resize", this.onResize, this), t.off("beforeprint", this.storeScrollPosition,
          this), t.off("beforeexport", this.storeScrollPosition, this), t.off("afterprint", this.restoreScrollPosition,
          this), t.off("afterexport", this.restoreScrollPosition, this), t.off("render:done", this.onRenderDone,
          this), t.off("unfreeze", this.update, this), e.off("reseted", this.update, this), e.off(
          "cell:added", this.update, this), e.off("cell:removed", this.update, this), e.off("cell:changed",
          this.update, this), this.undelegateBackgroundEvents()
      }
      delegateBackgroundEvents(t) {
        const e = t || jk.events;
        this.delegatedHandlers = Object.keys(e).reduce((t, n) => {
            const r = e[n];
            if (-1 === n.indexOf(" "))
              if ("function" == typeof r) t[n] = r;
              else {
                let e = this.graph.view[r];
                "function" == typeof e && (e = e.bind(this.graph.view), t[n] = e)
              } return t
          }, {}), this.onBackgroundEvent = this.onBackgroundEvent.bind(this), Object.keys(this.delegatedHandlers)
          .forEach(t => {
            this.delegateEvent(t, {
              guarded: !1
            }, this.onBackgroundEvent)
          })
      }
      undelegateBackgroundEvents() {
        Object.keys(this.delegatedHandlers).forEach(t => {
          this.undelegateEvent(t, this.onBackgroundEvent)
        })
      }
      onBackgroundEvent(t) {
        let e = !1;
        const n = t.target;
        if (e = this.options.pageVisible ? this.options.background ? this.background === n : this.content ===
          n : this.graph.view.background === n || this.graph.view.grid === n) {
          const e = this.delegatedHandlers[t.type];
          "function" == typeof e && e.apply(this.graph, arguments)
        }
      }
      onRenderDone({
        stats: t
      }) {
        t.priority < 2 && this.update()
      }
      onResize() {
        this.cachedCenterPoint && (this.centerPoint(this.cachedCenterPoint.x, this.cachedCenterPoint.y), this.updatePageBreak())
      }
      onScale({
        sx: t,
        sy: e,
        ox: n,
        oy: r
      }) {
        this.updateScale(t, e), this.sx = t, this.sy = e, (n || r) && (this.centerPoint(n, r), this.updatePageBreak()),
          "function" == typeof this.options.fitTocontentOptions && this.update()
      }
      storeScrollPosition() {
        this.cachedScrollLeft = this.container.scrollLeft, this.cachedScrollTop = this.container.scrollTop
      }
      restoreScrollPosition() {
        this.container.scrollLeft = this.cachedScrollLeft, this.container.scrollTop = this.cachedScrollTop,
          this.cachedScrollLeft = null, this.cachedScrollTop = null
      }
      beforeManipulation() {
        (D.a.IS_IE || D.a.IS_EDGE) && this.$container.css("visibility", "hidden")
      }
      afterManipulation() {
        (D.a.IS_IE || D.a.IS_EDGE) && this.$container.css("visibility", "visible")
      }
      updatePageBreak() {
        this.pageBreak && this.pageBreak.parentNode && this.pageBreak.parentNode.removeChild(this.pageBreak);
        const t = this.options;
        if (t.pageVisible && t.pageBreak) {
          const e = this.graph.options.width,
            n = this.graph.options.height,
            r = t.pageWidth || e,
            i = t.pageHeight || n;
          if (e > r || n > i) {
            this.pageBreak = document.createElement("div"), h.addClass(this.pageBreak, this.prefixClassName(
              "graph-pagebreak")), this.$(this.graph.view.grid).after(this.pageBreak);
            for (let t = 1, n = Math.floor(e / r); t < n; t += 1) this.$("<div/>").addClass(this.prefixClassName(
              "graph-pagebreak-vertical")).css({
              left: t * r
            }).appendTo(this.pageBreak);
            for (let t = 1, e = Math.floor(n / i); t < e; t += 1) this.$("<div/>").addClass(this.prefixClassName(
              "graph-pagebreak-horizontal")).css({
              top: t * i
            }).appendTo(this.pageBreak)
          }
        }
      }
      update() {
        const t = this.getClientSize();
        this.cachedCenterPoint = this.clientToLocalPoint(t.width / 2, t.height / 2);
        let e = this.options.fitTocontentOptions;
        "function" == typeof e && (e = l.call(e, this, this));
        const n = Object.assign({
          gridWidth: this.options.pageWidth,
          gridHeight: this.options.pageHeight,
          allowNewOrigin: "negative"
        }, e);
        this.graph.fitToContent(this.getFitToContentOptions(n))
      }
      getFitToContentOptions(t) {
        const e = this.sx,
          n = this.sy;
        return t.gridWidth && (t.gridWidth *= e), t.gridHeight && (t.gridHeight *= n), t.minWidth && (t.minWidth *=
          e), t.minHeight && (t.minHeight *= n), "object" == typeof t.padding ? t.padding = {
          left: (t.padding.left || 0) * e,
          right: (t.padding.right || 0) * e,
          top: (t.padding.top || 0) * n,
          bottom: (t.padding.bottom || 0) * n
        } : "number" == typeof t.padding && (t.padding = t.padding * e), t
      }
      updateScale(t, e) {
        const n = this.graph.options,
          r = t / this.sx,
          i = e / this.sy;
        this.graph.translate(n.x * r, n.y * i), this.graph.resizeGraph(n.width * r, n.height * i)
      }
      scrollbarPosition(t, e, n) {
        if (null == t && null == e) return {
          left: this.container.scrollLeft,
          top: this.container.scrollTop
        };
        const r = {};
        return "number" == typeof t && (r.scrollLeft = t), "number" == typeof e && (r.scrollTop = e), n && n.animation ?
          this.$container.animate(r, n.animation) : this.$container.prop(r), this
      }
      scrollToPoint(t, e, n) {
        const r = this.getClientSize(),
          i = this.graph.matrix(),
          o = {};
        return "number" == typeof t && (o.scrollLeft = t - r.width / 2 + i.e + (this.padding.left || 0)),
          "number" == typeof e && (o.scrollTop = e - r.height / 2 + i.f + (this.padding.top || 0)), n && n.animation ?
          this.$container.animate(o, n.animation) : this.$container.prop(o), this
      }
      scrollToContent(t) {
        const e = this.sx,
          n = this.sy,
          r = this.graph.getContentArea().getCenter();
        return this.scrollToPoint(r.x * e, r.y * n, t)
      }
      scrollToCell(t, e) {
        const n = this.sx,
          r = this.sy,
          i = t.getBBox().getCenter();
        return this.scrollToPoint(i.x * n, i.y * r, e)
      }
      center(t) {
        return this.centerPoint(t)
      }
      centerPoint(t, e, n) {
        const r = this.graph.matrix(),
          i = r.a,
          o = r.d,
          s = -r.e,
          a = -r.f,
          l = s + this.graph.options.width,
          c = a + this.graph.options.height;
        let h;
        if ("number" == typeof t || "number" == typeof e) {
          h = n;
          const r = this.getVisibleArea().getCenter();
          "number" == typeof t ? t *= i : t = r.x, "number" == typeof e ? e *= o : e = r.y
        } else h = t, t = (s + l) / 2, e = (a + c) / 2;
        if (h && h.padding) return this.positionPoint({
          x: t,
          y: e
        }, "50%", "50%", h);
        const u = this.getPadding(),
          d = this.getClientSize(),
          p = d.width / 2,
          f = d.height / 2,
          g = p - u.left - t + s,
          m = p - u.right + t - l,
          v = f - u.top - e + a,
          y = f - u.bottom + e - c;
        return this.addPadding(Math.max(g, 0), Math.max(m, 0), Math.max(v, 0), Math.max(y, 0)), this.scrollToPoint(
          t, e, h || void 0)
      }
      centerContent(t) {
        return this.positionContent("center", t)
      }
      centerCell(t, e) {
        return this.positionCell(t, "center", e)
      }
      positionContent(t, e) {
        const n = this.graph.getContentArea(e);
        return this.positionRect(n, t, e)
      }
      positionCell(t, e, n) {
        const r = t.getBBox();
        return this.positionRect(r, e, n)
      }
      positionRect(t, e, n) {
        const r = uC.create(t);
        switch (e) {
          case "center":
            return this.positionPoint(r.getCenter(), "50%", "50%", n);
          case "top":
            return this.positionPoint(r.getTopCenter(), "50%", 0, n);
          case "top-right":
            return this.positionPoint(r.getTopRight(), "100%", 0, n);
          case "right":
            return this.positionPoint(r.getRightMiddle(), "100%", "50%", n);
          case "bottom-right":
            return this.positionPoint(r.getBottomRight(), "100%", "100%", n);
          case "bottom":
            return this.positionPoint(r.getBottomCenter(), "50%", "100%", n);
          case "bottom-left":
            return this.positionPoint(r.getBottomLeft(), 0, "100%", n);
          case "left":
            return this.positionPoint(r.getLeftMiddle(), 0, "50%", n);
          case "top-left":
            return this.positionPoint(r.getTopLeft(), 0, 0, n);
          default:
            return this
        }
      }
      positionPoint(t, e, n, r = {}) {
        const {
          padding: i
        } = r, o = Wk(r, ["padding"]), s = a.normalizeSides(i), l = uC.fromSize(this.getClientSize()), c = l.clone()
          .moveAndExpand({
            x: s.left,
            y: s.top,
            width: -s.right - s.left,
            height: -s.top - s.bottom
          });
        (e = a.normalizePercentage(e, Math.max(0, c.width))) < 0 && (e = c.width + e), (n = a.normalizePercentage(
          n, Math.max(0, c.height))) < 0 && (n = c.height + n);
        const h = c.getTopLeft().translate(e, n),
          u = l.getCenter().diff(h),
          d = this.zoom(),
          p = u.scale(1 / d, 1 / d),
          f = hC.create(t).translate(p);
        return this.centerPoint(f.x, f.y, o)
      }
      zoom(t, e) {
        if (null == t) return this.sx;
        let n, r;
        e = e || {};
        const i = this.getClientSize(),
          o = this.clientToLocalPoint(i.width / 2, i.height / 2);
        let s = t,
          a = t;
        if (e.absolute || (s += this.sx, a += this.sy), e.scaleGrid && (s = Math.round(s / e.scaleGrid) * e.scaleGrid,
            a = Math.round(a / e.scaleGrid) * e.scaleGrid), e.maxScale && (s = Math.min(e.maxScale, s), a =
            Math.min(e.maxScale, a)), e.minScale && (s = Math.max(e.minScale, s), a = Math.max(e.minScale, a)),
          s = this.graph.transform.clampScale(s), a = this.graph.transform.clampScale(a), e.center) {
          const t = s / this.sx,
            i = a / this.sy;
          n = e.center.x - (e.center.x - o.x) / t, r = e.center.y - (e.center.y - o.y) / i
        } else n = o.x, r = o.y;
        return this.beforeManipulation(), this.graph.transform.scale(s, a), this.centerPoint(n, r), this.afterManipulation(),
          this
      }
      zoomToRect(t, e = {}) {
        const n = uC.create(t),
          r = this.graph,
          i = {
            x: r.options.x,
            y: r.options.y
          };
        e.contentArea = n, null == e.viewportArea && (e.viewportArea = Object.assign(Object.assign({}, i), {
          width: this.$container.width(),
          height: this.$container.height()
        })), this.beforeManipulation(), r.scaleContentToFit(e);
        const o = n.getCenter();
        return this.centerPoint(o.x, o.y), this.afterManipulation(), this
      }
      zoomToFit(t = {}) {
        return this.zoomToRect(this.graph.getContentArea(t), t)
      }
      transitionToPoint(t, e, n) {
        let r, i;
        "object" == typeof t ? (n = e, e = t.y, t = t.x) : e = e, null == n && (n = {});
        const o = this.sx,
          s = Math.max(n.scale || o, 1e-6),
          a = this.getClientSize(),
          c = new hC(t, e),
          h = this.clientToLocalPoint(a.width / 2, a.height / 2);
        if (o === s) {
          const t = h.diff(c).scale(o, o).round();
          r = `translate(${t.x}px,${t.y}px)`
        } else {
          const t = s / (o - s) * c.distance(h),
            e = h.clone().move(c, t),
            n = this.localToBackgroundPoint(e).round();
          r = `scale(${s/o})`, i = `${n.x}px ${n.y}px`
        }
        const u = n.onTransitionEnd;
        return this.$container.addClass(Uk.transitionClassName), this.$content.off(Uk.transitionEventName).on(
          Uk.transitionEventName, n => {
            this.syncTransition(s, {
              x: t,
              y: e
            }), "function" == typeof u && l.call(u, this, n.originalEvent)
          }).css({
          transform: r,
          transformOrigin: i,
          transition: "transform",
          transitionDuration: n.duration || "1s",
          transitionDelay: n.delay,
          transitionTimingFunction: n.timing
        }), this
      }
      syncTransition(t, e) {
        return this.beforeManipulation(), this.graph.scale(t), this.removeTransition(), this.centerPoint(e.x, e
          .y), this.afterManipulation(), this
      }
      removeTransition() {
        return this.$container.removeClass(Uk.transitionClassName), this.$content.off(Uk.transitionEventName).css({
          transform: "",
          transformOrigin: "",
          transition: "",
          transitionDuration: "",
          transitionDelay: "",
          transitionTimingFunction: ""
        }), this
      }
      transitionToRect(t, e = {}) {
        const n = uC.create(t),
          r = e.maxScale || 1 / 0,
          i = e.minScale || Number.MIN_VALUE,
          o = e.scaleGrid || null,
          s = e.visibility || 1,
          a = e.center ? hC.create(e.center) : n.getCenter(),
          l = this.getClientSize(),
          c = l.width * s,
          h = l.height * s;
        let u = new uC(a.x - c / 2, a.y - h / 2, c, h).maxRectUniformScaleToFit(n, a);
        return u = Math.min(u, r), o && (u = Math.floor(u / o) * o), u = Math.max(i, u), this.transitionToPoint(
          a, Object.assign({
            scale: u
          }, e))
      }
      startPanning(t) {
        const e = this.normalizeEvent(t);
        this.clientX = e.clientX, this.clientY = e.clientY, this.$container.addClass(this.prefixClassName(Uk.panningClass)),
          this.trigger("pan:start", {
            e: e
          }), this.$(document.body).on({
            "mousemove.panning touchmove.panning": this.pan.bind(this),
            "mouseup.panning touchend.panning": this.stopPanning.bind(this)
          }), this.$(window).on("mouseup.panning", this.stopPanning.bind(this))
      }
      pan(t) {
        const e = this.normalizeEvent(t),
          n = e.clientX - this.clientX,
          r = e.clientY - this.clientY;
        this.container.scrollTop -= r, this.container.scrollLeft -= n, this.clientX = e.clientX, this.clientY =
          e.clientY
      }
      stopPanning(t) {
        this.$(document.body).off(".panning"), this.$(window).off(".panning"), this.$container.removeClass(this
          .prefixClassName(Uk.panningClass)), this.trigger("pan:stop", {
          e: t
        })
      }
      clientToLocalPoint(t, e) {
        let n = "object" == typeof t ? t.x : t,
          r = "object" == typeof t ? t.y : e;
        const i = this.graph.matrix();
        return n += this.container.scrollLeft - this.padding.left - i.e, r += this.container.scrollTop - this.padding
          .top - i.f, new hC(n / i.a, r / i.d)
      }
      localToBackgroundPoint(t, e) {
        const n = "object" == typeof t ? hC.create(t) : new hC(t, e),
          r = this.graph.matrix(),
          i = this.padding;
        return h.transformPoint(n, r).translate(i.left, i.top)
      }
      resize(t, e) {
        let n = null != t ? t : this.container.clientWidth,
          r = null != e ? e : this.container.clientHeight;
        "number" == typeof n && (n = Math.round(n)), "number" == typeof r && (r = Math.round(r)), this.options.width =
          n, this.options.height = r, this.$container.css({
            width: n,
            height: r
          }), this.update()
      }
      getClientSize() {
        return {
          width: this.container.clientWidth,
          height: this.container.clientHeight
        }
      }
      addPadding(t, e, n, r) {
        let i = this.getPadding();
        this.padding = {
          left: Math.round(i.left + (t || 0)),
          top: Math.round(i.top + (n || 0)),
          bottom: Math.round(i.bottom + (r || 0)),
          right: Math.round(i.right + (e || 0))
        }, i = this.padding, this.$content.css({
          width: i.left + this.graph.options.width + i.right,
          height: i.top + this.graph.options.height + i.bottom
        });
        const o = this.graph.container;
        return o.style.left = `${this.padding.left}px`, o.style.top = `${this.padding.top}px`, this
      }
      getPadding() {
        const t = this.options.padding;
        return "function" == typeof t ? a.normalizeSides(l.call(t, this)) : a.normalizeSides(t)
      }
      getVisibleArea() {
        const t = this.graph.matrix(),
          e = this.getClientSize(),
          n = {
            x: this.container.scrollLeft || 0,
            y: this.container.scrollTop || 0,
            width: e.width,
            height: e.height
          },
          r = h.transformRectangle(n, t.inverse());
        return r.x -= (this.padding.left || 0) / this.sx, r.y -= (this.padding.top || 0) / this.sy, r
      }
      isCellVisible(t, e = {}) {
        const n = t.getBBox(),
          r = this.getVisibleArea();
        return e.strict ? r.containsRect(n) : r.isIntersectWith(n)
      }
      isPointVisible(t) {
        return this.getVisibleArea().containsPoint(t)
      }
      lock() {
        return this.$container.css("overflow", "hidden"), this
      }
      unlock() {
        return this.$container.css("overflow", "scroll"), this
      }
      setCursor(t, e = {}) {
        this.$container.css("cursor", t || ""), !0 !== e.silent && (this.options.cursor = t)
      }
      onRemove() {
        this.stopListening()
      }
      dispose() {
        this.$(this.graph.container).insertBefore(this.$container), this.remove()
      }
    }

    function Yk(t, e, n) {
      if (n) {
        const r = n.graph,
          i = r.view.normalizeEvent(e),
          o = r.snapToGrid(i.clientX, i.clientY);
        n.notify(t, {
          e: i,
          view: n,
          x: o.x,
          y: o.y,
          node: n.cell,
          cell: n.cell
        })
      }
    }
    qk([ZE.dispose()], Xk.prototype, "dispose", null),
      function(t) {
        (Xk || (Xk = {})).Background = class extends Gk {
          constructor(t) {
            super(t.graph), this.scroller = t, t.options.background && this.draw(t.options.background)
          }
          get elem() {
            return this.scroller.background
          }
          get container() {
            return this.scroller.content
          }
          init() {
            this.graph.on("scale", this.update, this), this.graph.on("translate", this.update, this)
          }
        }
      }(),
      function(t) {
        t.containerClass = "graph-scroller", t.panningClass = `${t.containerClass}-panning`, t.pagedClass =
          `${t.containerClass}-paged`, t.contentClass = `${t.containerClass}-content`, t.backgroundClass =
          `${t.containerClass}-background`, t.transitionClassName = "transition-in-progress", t.transitionEventName =
          "transitionend.graph-scroller-transition", t.defaultOptions = {
            padding() {
              const t = this.getClientSize(),
                e = Math.max(this.options.minVisibleWidth || 0, 1) || 1,
                n = Math.max(this.options.minVisibleHeight || 0, 1) || 1,
                r = Math.max(t.width - e, 0),
                i = Math.max(t.height - n, 0);
              return {
                left: r,
                top: i,
                right: r,
                bottom: i
              }
            },
            minVisibleWidth: 50,
            minVisibleHeight: 50,
            pageVisible: !1,
            pageBreak: !1,
            autoResize: !0
          }, t.getOptions = function(e) {
            const n = o.merge({}, t.defaultOptions, e),
              r = e.graph;
            return null == n.pageWidth && (n.pageWidth = r.options.width), null == n.pageHeight && (n.pageHeight =
              r.options.height), n
          }
      }(Uk || (Uk = {}));
    var Jk, Zk, Kk = this && this.__rest || function(t, e) {
      var n = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
          .call(t, r[i]) && (n[r[i]] = t[r[i]])
      }
      return n
    };
    class Qk {
      get handleClassName() {
        return Jk.handle
      }
      get pie() {
        return Object.assign(Object.assign({}, Qk.defaultPieOptions), this.handleOptions.pie)
      }
      initHandles() {
        if (this.handles = [], this.handleOptions.handles && this.handleOptions.handles.forEach(t => this.addHandle(
            t)), "pie" === this.handleOptions.type) {
          if (this.pie.toggles) {
            const t = Jk.pieToggle;
            this.$pieToggles = {}, this.pie.toggles.forEach(e => {
              const n = this.$("<div/>");
              this.applyAttrs(n, e.attrs), n.addClass(t).addClass(`${t}-pos-${e.position||"e"}`).attr(
                "data-name", e.name).appendTo(this.container), this.$pieToggles[e.name] = n
            })
          }
          this.setPieIcons()
        }
        if (this.$handleContainer) {
          const t = this.handleOptions.type || "surround";
          this.$handleContainer.addClass(Jk.wrap).addClass(Jk.animate).addClass(`${Jk.handle}-${t}`)
        }
        this.delegateEvents({
          [`mousedown .${Jk.handle}`]: "onHandleMouseDown",
          [`touchstart .${Jk.handle}`]: "onHandleMouseDown",
          [`mousedown .${Jk.pieToggle}`]: "onPieToggleMouseDown",
          [`touchstart .${Jk.pieToggle}`]: "onPieToggleMouseDown"
        })
      }
      onHandleMouseDown(t) {
        const e = this.$(t.currentTarget).closest(`.${Jk.handle}`).attr("data-action");
        e && (t.preventDefault(), t.stopPropagation(), this.setEventData(t, {
          action: e,
          clientX: t.clientX,
          clientY: t.clientY,
          startX: t.clientX,
          startY: t.clientY
        }), "mousedown" === t.type && 2 === t.button ? this.triggerHandleAction(e, "contextmenu", t) : (
          this.triggerHandleAction(e, "mousedown", t), this.delegateDocumentEvents({
            mousemove: "onHandleMouseMove",
            touchmove: "onHandleMouseMove",
            mouseup: "onHandleMouseUp",
            touchend: "onHandleMouseUp",
            touchcancel: "onHandleMouseUp"
          }, t.data)))
      }
      onHandleMouseMove(t) {
        const e = this.getEventData(t).action;
        e && this.triggerHandleAction(e, "mousemove", t)
      }
      onHandleMouseUp(t) {
        const e = this.getEventData(t).action;
        e && (this.triggerHandleAction(e, "mouseup", t), this.undelegateDocumentEvents())
      }
      triggerHandleAction(t, e, n, r) {
        n.preventDefault(), n.stopPropagation();
        const i = this.normalizeEvent(n),
          o = this.getEventData(i),
          s = this.graph.snapToGrid(i.clientX, i.clientY),
          a = this.graph.snapToGrid(o.clientX, o.clientY),
          l = s.x - a.x,
          c = s.y - a.y;
        this.trigger(`action:${t}:${e}`, Object.assign({
          e: i,
          dx: l,
          dy: c,
          x: s.x,
          y: s.y,
          offsetX: n.clientX - o.startX,
          offsetY: n.clientY - o.startY
        }, r)), o.clientX = n.clientX, o.clientY = n.clientY
      }
      onPieToggleMouseDown(t) {
        t.stopPropagation();
        const e = this.$(t.target).closest(`.${Jk.pieToggle}`).attr("data-name");
        this.isOpen(e) || this.isOpen() && this.toggleState(), this.toggleState(e)
      }
      setPieIcons() {
        "pie" === this.handleOptions.type && this.$handleContainer.find(`.${Jk.handle}`).each((t, e) => {
          const n = this.$(e),
            r = n.attr("data-action"),
            i = Jk.pieSlice,
            o = this.getHandle(r);
          if (!o || !o.icon) {
            const t = window.getComputedStyle(e, ":before").getPropertyValue("content");
            if (t && "none" !== t) {
              const e = n.find(`.${i}-txt`);
              e.length && h.createVector(e[0]).text(t.replace(/['"]/g, ""))
            }
            const r = n.css("background-image");
            if (r) {
              const t = r.match(/url\(['"]?([^'"]+)['"]?\)/);
              if (t) {
                const e = t[1],
                  r = n.find(`.${i}-img`);
                r.length > 0 && h.createVector(r[0]).attr("xlink:href", e)
              }
            }
          }
        })
      }
      getHandleIdx(t) {
        return this.handles.findIndex(e => e.name === t)
      }
      hasHandle(t) {
        return this.getHandleIdx(t) >= 0
      }
      getHandle(t) {
        return this.handles.find(e => e.name === t)
      }
      renderHandle(t) {
        const e = this.$("<div/>").addClass(`${Jk.handle} ${Jk.handle}-${t.name}`).attr("data-action", t.name).prop(
          "draggable", !1);
        if ("pie" === this.handleOptions.type) {
          const n = this.getHandleIdx(t.name),
            r = this.pie,
            i = r.outerRadius,
            o = r.innerRadius,
            s = (i + o) / 2,
            a = new hC(i, i),
            l = nC.toRad(r.sliceAngle),
            c = n * l + nC.toRad(r.startAngle),
            u = c + l,
            d = h.createSlicePathData(o, i, c, u),
            p = h.createVector("svg").addClass(`${Jk.pieSlice}-svg`),
            f = h.createVector("path").addClass(Jk.pieSlice).attr("d", d).translate(i, i),
            g = hC.fromPolar(s, -c - l / 2, a).toJSON(),
            m = r.iconSize,
            v = h.createVector("image").attr(g).addClass(`${Jk.pieSlice}-img`);
          g.y = g.y + m - 2;
          const y = h.createVector("text", {
            "font-size": m
          }).attr(g).addClass(`${Jk.pieSlice}-txt`);
          v.attr({
            width: m,
            height: m
          }), v.translate(-m / 2, -m / 2), y.translate(-m / 2, -m / 2), p.append([f, v, y]), e.append(p.node)
        } else e.addClass(`${Jk.handle}-pos-${t.position}`), t.content && ("string" == typeof t.content ? e.html(
          t.content) : e.append(t.content));
        return this.updateHandleIcon(e, t.icon), this.applyAttrs(e, t.attrs), e
      }
      addHandle(t) {
        if (!this.hasHandle(t.name)) {
          this.handles.push(t);
          const e = t.events;
          e && Object.keys(e).forEach(n => {
            const r = e[n],
              i = `action:${t.name}:${n}`;
            "string" == typeof r ? this.on(i, this[r], this) : this.on(i, r)
          }), this.$handleContainer && this.$handleContainer.append(this.renderHandle(t))
        }
        return this
      }
      addHandles(t) {
        return t.forEach(t => this.addHandle(t)), this
      }
      removeHandles() {
        for (; this.handles.length;) this.removeHandle(this.handles[0].name);
        return this
      }
      removeHandle(t) {
        const e = this.getHandleIdx(t),
          n = this.handles[e];
        return n && (n.events && Object.keys(n.events).forEach(e => {
          this.off(`action:${t}:${e}`)
        }), this.getHandleElem(t).remove(), this.handles.splice(e, 1)), this
      }
      changeHandle(t, e) {
        const n = this.getHandle(t);
        return n && (this.removeHandle(t), this.addHandle(Object.assign(Object.assign({}, n), e))), this
      }
      toggleHandle(t, e) {
        const n = this.getHandle(t);
        if (n) {
          const r = this.getHandleElem(t),
            i = `${Jk.handle}-selected`;
          void 0 === e && (e = !r.hasClass(i)), r.toggleClass(i, e);
          const o = e ? n.iconSelected : n.icon;
          o && this.updateHandleIcon(r, o)
        }
        return this
      }
      selectHandle(t) {
        return this.toggleHandle(t, !0)
      }
      deselectHandle(t) {
        return this.toggleHandle(t, !1)
      }
      deselectAllHandles() {
        return this.handles.forEach(t => this.deselectHandle(t.name)), this
      }
      getHandleElem(t) {
        return this.$handleContainer.find(`.${Jk.handle}-${t}`)
      }
      updateHandleIcon(t, e) {
        if ("pie" === this.handleOptions.type) {
          const n = t.find(`.${Jk.pieSliceImg}`);
          this.$(n[0]).attr("xlink:href", e || "")
        } else t.css("background-image", e ? `url(${e})` : "")
      }
      isRendered() {
        return null != this.$handleContainer
      }
      isOpen(t) {
        return !!this.isRendered() && (t ? this.$pieToggles[t].hasClass(Jk.pieToggleOpened) : this.$handleContainer
          .hasClass(`${Jk.pieOpended}`))
      }
      toggleState(t) {
        if (this.isRendered()) {
          const e = this.$handleContainer;
          if (Object.keys(this.$pieToggles).forEach(t => {
              this.$pieToggles[t].removeClass(Jk.pieToggleOpened)
            }), this.isOpen()) this.trigger("pie:close", {
            name: t
          }), e.removeClass(Jk.pieOpended);
          else {
            if (this.trigger("pie:open", {
                name: t
              }), t) {
              const n = this.pie.toggles,
                r = n && n.find(e => e.name === t);
              r && e.attr({
                "data-pie-toggle-name": r.name,
                "data-pie-toggle-position": r.position
              }), this.$pieToggles[t].addClass(Jk.pieToggleOpened)
            }
            e.addClass(Jk.pieOpended)
          }
        }
      }
      applyAttrs(t, e) {
        if (e) {
          const n = ZE.$(t);
          Object.keys(e).forEach(t => {
            const r = n.find(t).addBack().filter(t),
              i = e[t],
              {
                class: o
              } = i,
              s = Kk(i, ["class"]);
            o && r.addClass(o), r.attr(s)
          })
        }
      }
    }(Qk || (Qk = {})).defaultPieOptions = {
        innerRadius: 20,
        outerRadius: 50,
        sliceAngle: 45,
        startAngle: 0,
        iconSize: 14,
        toggles: [{
          name: "default",
          position: "e"
        }]
      }, (Zk = Jk || (Jk = {})).handle = ZE.prototype.prefixClassName("widget-handle"), Zk.wrap =
      `${Zk.handle}-wrap`, Zk.animate = `${Zk.handle}-animate`, Zk.pieOpended = `${Zk.handle}-pie-opened`, Zk.pieToggle =
      `${Zk.handle}-pie-toggle`, Zk.pieToggleOpened = `${Zk.handle}-pie-toggle-opened`, Zk.pieSlice =
      `${Zk.handle}-pie-slice`, Zk.pieSliceImg = `${Zk.handle}-pie-slice-img`;
    var tO, eO, nO, rO, iO = this && this.__decorate || function(t, e, n, r) {
        var i, o = arguments.length,
          s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r);
        else
          for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) ||
            s);
        return o > 3 && s && Object.defineProperty(e, n, s), s
      },
      oO = this && this.__rest || function(t, e) {
        var n = {};
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
        if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
          var i = 0;
          for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
            .call(t, r[i]) && (n[r[i]] = t[r[i]])
        }
        return n
      };
    class sO extends ZE {
      constructor(t) {
        super();
        const e = t,
          {
            view: n,
            cell: r,
            node: i,
            edge: o,
            graph: s
          } = e,
          a = oO(e, ["view", "cell", "node", "edge", "graph"]);
        n ? (this.view = n, this.cell = n.cell, this.graph = n.graph, this.model = this.graph.model) : (r || o ||
          i) && s && (this.cell = i || o || r, this.view = s.renderer.findViewByCell(this.cell), this.graph =
          s, this.model = this.graph.model);
        const l = this.constructor;
        !1 !== t.clearAll && l.removeInstances(this.graph), l.register(this), this.init(a)
      }
      static ensureCache() {
        return this.instanceCache.has(this) || this.instanceCache.set(this, {}), this.instanceCache.get(this)
      }
      static register(t, e) {
        null == e && (e = t.graph);
        const n = this.ensureCache();
        let r = n[e.view.cid];
        null == r && (r = n[e.view.cid] = {}), r[t.cid] = t
      }
      static unregister(t, e) {
        null == e && (e = t.graph);
        const n = this.ensureCache();
        n[e.view.cid] && delete n[e.view.cid][t.cid]
      }
      static removeInstances(t) {
        const e = this.ensureCache()[t.view.cid];
        e && Object.keys(e).forEach(t => {
          const n = e[t];
          n && n.remove()
        })
      }
      static getInstances(t) {
        return this.ensureCache()[t.view.cid] || {}
      }
      init(t) {}
      render() {
        return this
      }
      startListening() {
        !1 !== this.options.clearOnBlankMouseDown && this.graph.on("blank:mousedown", this.remove, this)
      }
      stopListening() {
        !1 !== this.options.clearOnBlankMouseDown && this.graph.off("blank:mousedown", this.remove, this)
      }
      remove() {
        return this.stopListening(), this.constructor.unregister(this), super.remove()
      }
      dispose() {
        this.remove()
      }
    }
    sO.instanceCache = new WeakMap, iO([ZE.dispose()], sO.prototype, "dispose", null);
    class aO extends ZE {
      constructor(t) {
        super(), this.options = o.merge({}, tO.defaultOptions, t), this.options.model && (this.options.collection =
            this.options.model.collection), this.options.collection ? this.collection = this.options.collection :
          (this.collection = new wk([], {
            comparator: tO.depthComparator
          }), this.options.collection = this.collection), this.boxCount = 0, this.createContainer(), this.initHandles(),
          this.startListening()
      }
      get graph() {
        return this.options.graph
      }
      get boxClassName() {
        return this.prefixClassName(tO.classNames.box)
      }
      get $boxes() {
        return this.$container.children(`.${this.boxClassName}`)
      }
      get handleOptions() {
        return this.options
      }
      startListening() {
        const t = this.graph,
          e = this.collection;
        this.delegateEvents({
            [`mousedown .${this.boxClassName}`]: "onSelectionBoxMouseDown",
            [`touchstart .${this.boxClassName}`]: "onSelectionBoxMouseDown"
          }, !0), t.on("scale", this.onTransformed, this), t.on("translate", this.onTransformed, this), t.model
          .on("updated", this.onModelUpdated, this), e.on("added", this.onCellAdded, this), e.on("removed",
            this.onCellRemoved, this), e.on("reseted", this.onReseted, this), e.on("updated", this.onCollectionUpdated,
            this), e.on("node:change:position", this.onNodePositionChanged, this), e.on("cell:change:*", this.onCellChanged,
            this)
      }
      stopListening() {
        const t = this.graph,
          e = this.collection;
        this.undelegateEvents(), t.off("scale", this.onTransformed, this), t.off("translate", this.onTransformed,
            this), t.model.off("updated", this.onModelUpdated, this), e.off("added", this.onCellAdded, this), e
          .off("removed", this.onCellRemoved, this), e.off("reseted", this.onReseted, this), e.off("updated",
            this.onCollectionUpdated, this), e.off("node:change:position", this.onNodePositionChanged, this), e
          .off("cell:change:*", this.onCellChanged, this)
      }
      onRemove() {
        this.stopListening()
      }
      onTransformed() {
        this.updateSelectionBoxes({
          async: !1
        })
      }
      onCellChanged() {
        this.updateSelectionBoxes()
      }
      onNodePositionChanged({
        node: t,
        options: e
      }) {
        if (!0 !== this.options.showNodeSelectionBox && !this.translating) {
          this.translating = !0;
          const n = t.position(),
            r = t.previous("position"),
            i = n.x - r.x,
            o = n.y - r.y;
          0 === i && 0 === o || this.translateSelectedNodes(i, o, t, e), this.translating = !1
        }
      }
      onModelUpdated({
        removed: t
      }) {
        t && t.length && this.unselect(t)
      }
      isEmpty() {
        return this.length <= 0
      }
      isSelected(t) {
        return this.collection.has(t)
      }
      get length() {
        return this.collection.length
      }
      get cells() {
        return this.collection.toArray()
      }
      select(t, e = {}) {
        return e.dryrun = !0, this.collection.add(t, e), this
      }
      unselect(t, e = {}) {
        return e.dryrun = !0, this.collection.remove(Array.isArray(t) ? t : [t], e), this
      }
      reset(t, e = {}) {
        return t ? (this.collection.reset(Array.isArray(t) ? t : [t], Object.assign(Object.assign({}, e), {
          ui: !0
        })), this) : this.clean(e)
      }
      clean(t = {}) {
        return this.length && this.collection.reset([], Object.assign(Object.assign({}, t), {
          ui: !0
        })), this
      }
      setFilter(t) {
        this.options.filter = t
      }
      setContent(t) {
        this.options.content = t
      }
      startSelecting(t) {
        let e, n;
        t = this.normalizeEvent(t), this.clean();
        const r = this.graph.container;
        if (null != t.offsetX && null != t.offsetY && r.contains(t.target)) e = t.offsetX, n = t.offsetY;
        else {
          const i = this.$(r).offset(),
            o = r.scrollLeft,
            s = r.scrollTop;
          e = t.clientX - i.left + window.pageXOffset + o, n = t.clientY - i.top + window.pageYOffset + s
        }
        this.$container.css({
          top: n,
          left: e,
          width: 1,
          height: 1
        }), this.setEventData(t, {
          action: "selecting",
          clientX: t.clientX,
          clientY: t.clientY,
          offsetX: e,
          offsetY: n
        }), this.delegateDocumentEvents(tO.documentEvents, t.data)
      }
      stopSelecting(t) {
        const e = this.graph,
          n = this.getEventData(t).action;
        switch (n) {
          case "selecting":
            {
              let t = this.$container.width(),
                n = this.$container.height();
              const r = this.$container.offset(),
                i = e.pageToLocal(r.left, r.top),
                o = e.scale();t /= o.sx,
              n /= o.sy;
              const s = new uC(i.x, i.y, t, n);
              let a = this.getNodesInArea(s);
              const c = this.options.filter;Array.isArray(c) ? a = a.filter(t => !c.includes(t.cell) && !c.includes(
                t.cell.shape)) : "function" == typeof c && (a = a.filter(t => !l.call(c, this.graph, t.cell)));
              const h = a.map(t => t.cell);this.collection.reset(h, {
                ui: !0
              });
              break
            }
          case "translating":
            {
              this.graph.model.stopBatch("move-selection");
              const n = e.snapToGrid(t.clientX, t.clientY);this.notifyBoxEvent("box:mouseup", t, n.x, n.y);
              break
            }
          default:
            n || this.clean()
        }
      }
      onMouseUp(t) {
        this.getEventData(t).action && (this.stopSelecting(t), this.undelegateDocumentEvents())
      }
      onSelectionBoxMouseDown(t) {
        t.stopPropagation();
        const e = this.normalizeEvent(t);
        this.options.movable && this.startTranslating(e);
        const n = this.getCellViewFromElem(e.target);
        this.setEventData(e, {
          activeView: n
        });
        const r = this.graph.snapToGrid(e.clientX, e.clientY);
        this.notifyBoxEvent("box:mousedown", e, r.x, r.y), this.delegateDocumentEvents(tO.documentEvents, e.data)
      }
      startTranslating(t) {
        this.graph.model.startBatch("move-selection");
        const e = this.graph.snapToGrid(t.clientX, t.clientY);
        this.setEventData(t, {
          action: "translating",
          clientX: e.x,
          clientY: e.y
        })
      }
      adjustSelection(t) {
        const e = this.normalizeEvent(t),
          n = this.getEventData(e);
        switch (n.action) {
          case "selecting":
            {
              const t = n;!0 !== t.moving && (this.$container.appendTo(this.graph.container), this.showRubberband(),
                t.moving = !0);
              const r = e.clientX - t.clientX,
                i = e.clientY - t.clientY,
                o = parseInt(this.$container.css("left"), 10),
                s = parseInt(this.$container.css("top"), 10);this.$container.css({
                left: r < 0 ? t.offsetX + r : o,
                top: i < 0 ? t.offsetY + i : s,
                width: Math.abs(r),
                height: Math.abs(i)
              });
              break
            }
          case "translating":
            {
              const r = n,
                i = this.graph.snapToGrid(e.clientX, e.clientY);
              let o = i.x - r.clientX,
                s = i.y - r.clientY;
              const a = this.graph.hook.getRestrictArea();
              if (a) {
                const t = this.collection.toArray(),
                  e = fk.getCellsBBox(t),
                  n = a.x - e.x,
                  r = a.y - e.y,
                  i = a.x + a.width - (e.x + e.width),
                  l = a.y + a.height - (e.y + e.height);
                o < n && (o = n), s < r && (s = r), i < o && (o = i), l < s && (s = l)
              }
              if (o || s) {
                if (this.translateSelectedNodes(o, s), this.boxesUpdated) this.collection.length > 1 && this.updateSelectionBoxes();
                else {
                  const t = this.graph.scale();
                  this.$boxes.add(this.$selectionContainer).css({
                    left: `+=${o*t.sx}`,
                    top: `+=${s*t.sy}`
                  })
                }
                r.clientX = i.x, r.clientY = i.y
              }
              this.notifyBoxEvent("box:mousemove", t, i.x, i.y);
              break
            }
        }
        this.boxesUpdated = !1
      }
      translateSelectedNodes(t, e, n, r) {
        const i = {};
        this.collection.toArray().forEach(o => {
          if (!i[o.id] && o !== n) {
            const n = Object.assign(Object.assign({}, r), {
              selection: this.cid
            });
            o.translate(t, e, n), o.getDescendants({
              deep: !0
            }).forEach(t => {
              i[t.id] = !0
            }), this.graph.model.getConnectedEdges(o).forEach(r => {
              i[r.id] || (r.translate(t, e, n), i[r.id] = !0)
            })
          }
        })
      }
      getNodesInArea(t) {
        const e = this.graph,
          n = {
            strict: this.options.strict
          };
        return this.options.useCellGeometry ? e.model.getNodesInArea(t, n).map(t => e.renderer.findViewByCell(t))
          .filter(t => null != t) : e.renderer.findViewsInArea(t, n)
      }
      notifyBoxEvent(t, e, n, r) {
        const i = this.getEventData(e).activeView;
        this.trigger(t, {
          e: e,
          view: i,
          x: n,
          y: r,
          cell: i.cell
        })
      }
      getSelectedClassName(t) {
        return this.prefixClassName(`${t.isNode()?"node":"edge"}-selected`)
      }
      addCellSelectedClassName(t) {
        const e = this.graph.renderer.findViewByCell(t);
        e && e.addClass(this.getSelectedClassName(t))
      }
      removeCellUnSelectedClassName(t) {
        const e = this.graph.renderer.findViewByCell(t);
        e && e.removeClass(this.getSelectedClassName(t))
      }
      destroySelectionBox(t) {
        this.removeCellUnSelectedClassName(t), this.canShowSelectionBox(t) && (this.$container.find(
          `[data-cell="${t.id}"]`).remove(), 0 === this.$boxes.length && this.hide(), this.boxCount = Math.max(
          0, this.boxCount - 1))
      }
      destroyAllSelectionBoxes(t) {
        t.forEach(t => this.removeCellUnSelectedClassName(t)), this.hide(), this.$boxes.remove(), this.boxCount =
          0
      }
      hide() {
        this.$container.removeClass(this.prefixClassName(tO.classNames.rubberband)).removeClass(this.prefixClassName(
          tO.classNames.selected))
      }
      showRubberband() {
        this.$container.addClass(this.prefixClassName(tO.classNames.rubberband))
      }
      showSelected() {
        this.$container.removeAttr("style").addClass(this.prefixClassName(tO.classNames.selected))
      }
      createContainer() {
        this.container = document.createElement("div"), this.$container = this.$(this.container), this.$container
          .addClass(this.prefixClassName(tO.classNames.root)), this.options.className && this.$container.addClass(
            this.options.className), this.$selectionContainer = this.$("<div/>").addClass(this.prefixClassName(
            tO.classNames.inner)), this.$selectionContent = this.$("<div/>").addClass(this.prefixClassName(tO.classNames
            .content)), this.$selectionContainer.append(this.$selectionContent), this.$selectionContainer.attr(
            "data-selection-length", this.collection.length), this.$container.prepend(this.$selectionContainer),
          this.$handleContainer = this.$selectionContainer
      }
      updateContainer() {
        const t = {
            x: 1 / 0,
            y: 1 / 0
          },
          e = {
            x: 0,
            y: 0
          };
        this.collection.toArray().filter(t => this.canShowSelectionBox(t)).forEach(n => {
          const r = this.graph.renderer.findViewByCell(n);
          if (r) {
            const n = r.getBBox({
              useCellGeometry: this.options.useCellGeometry
            });
            t.x = Math.min(t.x, n.x), t.y = Math.min(t.y, n.y), e.x = Math.max(e.x, n.x + n.width), e.y =
              Math.max(e.y, n.y + n.height)
          }
        }), this.$selectionContainer.css({
          position: "absolute",
          pointerEvents: "none",
          left: t.x,
          top: t.y,
          width: e.x - t.x,
          height: e.y - t.y
        }).attr("data-selection-length", this.collection.length);
        const n = this.options.content;
        if (n)
          if ("function" == typeof n) {
            const t = l.call(n, this.graph, this, this.$selectionContent[0]);
            t && this.$selectionContent.html(t)
          } else this.$selectionContent.html(n);
        this.collection.length > 0 && !this.container.parentNode ? this.$container.appendTo(this.graph.container) :
          this.collection.length <= 0 && this.container.parentNode && this.container.parentNode.removeChild(
            this.container)
      }
      canShowSelectionBox(t) {
        return t.isNode() && !0 === this.options.showNodeSelectionBox || t.isEdge() && !0 === this.options.showEdgeSelectionBox
      }
      createSelectionBox(t) {
        if (this.addCellSelectedClassName(t), this.canShowSelectionBox(t)) {
          const e = this.graph.renderer.findViewByCell(t);
          if (e) {
            const n = e.getBBox({
                useCellGeometry: this.options.useCellGeometry
              }),
              r = this.boxClassName;
            this.$("<div/>").addClass(r).addClass(`${r}-${t.isNode()?"node":"edge"}`).attr("data-cell", t.id).css({
              position: "absolute",
              left: n.x,
              top: n.y,
              width: n.width,
              height: n.height
            }).appendTo(this.container), this.showSelected(), this.boxCount += 1
          }
        }
      }
      updateSelectionBoxes(t = {}) {
        this.collection.length > 0 && (this.boxesUpdated = !0, this.graph.renderer.requestViewUpdate(this, 1, 2,
          t))
      }
      confirmUpdate() {
        return this.boxCount && (this.hide(), this.$boxes.each((t, e) => {
          const n = this.$(e).remove().attr("data-cell"),
            r = this.collection.get(n);
          r && this.createSelectionBox(r)
        }), this.updateContainer()), 0
      }
      getCellViewFromElem(t) {
        const e = t.getAttribute("data-cell");
        if (e) {
          const t = this.collection.get(e);
          if (t) return this.graph.renderer.findViewByCell(t)
        }
        return null
      }
      onCellRemoved({
        cell: t
      }) {
        this.destroySelectionBox(t), this.updateContainer()
      }
      onReseted({
        previous: t,
        current: e
      }) {
        this.destroyAllSelectionBoxes(t), e.forEach(t => {
          this.listenCellRemoveEvent(t), this.createSelectionBox(t)
        }), this.updateContainer()
      }
      onCellAdded({
        cell: t
      }) {
        this.listenCellRemoveEvent(t), this.createSelectionBox(t), this.updateContainer()
      }
      listenCellRemoveEvent(t) {
        t.off("removed", this.onCellRemoved, this), t.on("removed", this.onCellRemoved, this)
      }
      onCollectionUpdated({
        added: t,
        removed: e,
        options: n
      }) {
        t.forEach(t => {
          this.trigger("cell:selected", {
            cell: t,
            options: n
          }), this.graph.trigger("cell:selected", {
            cell: t,
            options: n
          }), t.isNode() ? (this.trigger("node:selected", {
            cell: t,
            options: n,
            node: t
          }), this.graph.trigger("node:selected", {
            cell: t,
            options: n,
            node: t
          })) : t.isEdge() && (this.trigger("edge:selected", {
            cell: t,
            options: n,
            edge: t
          }), this.graph.trigger("edge:selected", {
            cell: t,
            options: n,
            edge: t
          }))
        }), e.forEach(t => {
          this.trigger("cell:unselected", {
            cell: t,
            options: n
          }), this.graph.trigger("cell:unselected", {
            cell: t,
            options: n
          }), t.isNode() ? (this.trigger("node:unselected", {
            cell: t,
            options: n,
            node: t
          }), this.graph.trigger("node:unselected", {
            cell: t,
            options: n,
            node: t
          })) : t.isEdge() && (this.trigger("edge:unselected", {
            cell: t,
            options: n,
            edge: t
          }), this.graph.trigger("edge:unselected", {
            cell: t,
            options: n,
            edge: t
          }))
        });
        const r = {
          added: t,
          removed: e,
          options: n,
          selected: this.cells
        };
        this.trigger("selection:changed", r), this.graph.trigger("selection:changed", r)
      }
      deleteSelectedCells() {
        const t = this.collection.toArray();
        this.clean(), this.graph.model.removeCells(t, {
          selection: this.cid
        })
      }
      startRotate({
        e: t
      }) {
        const e = this.collection.toArray(),
          n = fk.getCellsBBox(e).getCenter(),
          r = this.graph.snapToGrid(t.clientX, t.clientY),
          i = e.reduce((t, e) => (t[e.id] = nC.normalize(e.getAngle()), t), {});
        this.setEventData(t, {
          center: n,
          angles: i,
          start: r.theta(n)
        })
      }
      doRotate({
        e: t
      }) {
        const e = this.getEventData(t),
          n = this.graph.options.rotating.grid,
          r = "function" == typeof n ? l.call(n, this.graph, null) : n,
          i = this.graph.snapToGrid(t.clientX, t.clientY),
          o = e.start - i.theta(e.center);
        e.rotated || (e.rotated = !0), Math.abs(o) > .001 && (this.collection.toArray().forEach(t => {
          const n = oE.snapToGrid(e.angles[t.id] + o, r || 15);
          t.rotate(n, {
            absolute: !0,
            center: e.center,
            selection: this.cid
          })
        }), this.updateSelectionBoxes())
      }
      stopRotate({
        e: t
      }) {
        const e = this.getEventData(t);
        e.rotated && (e.rotated = !1, this.collection.toArray().forEach(e => {
          Yk("node:rotated", t, this.graph.findViewByCell(e))
        }))
      }
      startResize({
        e: t
      }) {
        const e = this.graph.getGridSize(),
          n = this.collection.toArray(),
          r = fk.getCellsBBox(n),
          i = n.map(t => t.getBBox()),
          o = i.reduce((t, e) => e.width < t ? e.width : t, 1 / 0),
          s = i.reduce((t, e) => e.height < t ? e.height : t, 1 / 0);
        this.setEventData(t, {
          bbox: r,
          cells: this.graph.model.getSubGraph(n),
          minWidth: e * r.width / o,
          minHeight: e * r.height / s
        })
      }
      doResize({
        e: t,
        dx: e,
        dy: n
      }) {
        const r = this.eventData(t),
          i = r.bbox,
          o = i.width,
          s = i.height,
          a = Math.max(o + e, r.minWidth),
          l = Math.max(s + n, r.minHeight);
        r.resized || (r.resized = !0), (.001 < Math.abs(o - a) || .001 < Math.abs(s - l)) && (this.graph.model.resizeCells(
          a, l, r.cells, {
            selection: this.cid
          }), i.width = a, i.height = l, this.updateSelectionBoxes())
      }
      stopResize({
        e: t
      }) {
        const e = this.eventData(t);
        e.resized && (e.resized = !1, this.collection.toArray().forEach(e => {
          Yk("node:resized", t, this.graph.findViewByCell(e))
        }))
      }
    }
    o.applyMixins(aO, Qk),
      function(t) {
        const e = "widget-selection";
        t.classNames = {
          root: e,
          inner: `${e}-inner`,
          box: `${e}-box`,
          content: `${e}-content`,
          rubberband: `${e}-rubberband`,
          selected: `${e}-selected`
        }, t.documentEvents = {
          mousemove: "adjustSelection",
          touchmove: "adjustSelection",
          mouseup: "onMouseUp",
          touchend: "onMouseUp",
          touchcancel: "onMouseUp"
        }, t.defaultOptions = {
          movable: !0,
          strict: !1,
          useCellGeometry: !1,
          content: t => s.template('<%= length %> node<%= length > 1 ? "s":"" %> selected.')({
            length: t.length
          }),
          handles: [{
            name: "remove",
            position: "nw",
            events: {
              mousedown: "deleteSelectedCells"
            }
          }, {
            name: "rotate",
            position: "sw",
            events: {
              mousedown: "startRotate",
              mousemove: "doRotate",
              mouseup: "stopRotate"
            }
          }, {
            name: "resize",
            position: "se",
            events: {
              mousedown: "startResize",
              mousemove: "doResize",
              mouseup: "stopResize"
            }
          }]
        }, t.depthComparator = function(t) {
          return t.getAncestors().length
        }
      }(tO || (tO = {}));
    class lO {
      constructor() {
        this.cells = []
      }
      copy(t, e, n = {}) {
        this.options = Object.assign({}, n);
        const r = (e instanceof Ak ? e : e.model).cloneSubGraph(t, n);
        this.cells = i.sortBy(Object.keys(r).map(t => r[t]), t => t.isEdge() ? 2 : 1), this.serialize(n)
      }
      cut(t, e, n = {}) {
        this.copy(t, e, n), (e instanceof JO ? e.model : e).batchUpdate("cut", () => {
          t.forEach(t => t.remove())
        })
      }
      paste(t, e = {}) {
        const n = Object.assign(Object.assign({}, e), this.options),
          {
            offset: r,
            edgeProps: i,
            nodeProps: o
          } = n;
        let s = 20,
          a = 20;
        r && (s = "number" == typeof r ? r : r.dx, a = "number" == typeof r ? r : r.dy), this.deserialize(n);
        const l = this.cells;
        l.map(t => {
          t.model = null, t.removeProp("zIndex"), (s || a) && t.translate(s, a), o && t.isNode() && t.prop(
            o), i && t.isEdge() && t.prop(i)
        });
        const c = t instanceof JO ? t.model : t;
        return c.batchUpdate("paste", () => {
          c.addCells(this.cells)
        }), this.copy(l, t, e), l
      }
      serialize(t) {
        !1 !== t.useLocalStorage && eO.save(this.cells)
      }
      deserialize(t) {
        if (t.useLocalStorage) {
          const t = eO.fetch();
          t && (this.cells = t)
        }
      }
      isEmpty() {
        return this.cells.length <= 0
      }
      clean() {
        this.options = {}, this.cells = [], eO.clean()
      }
    }! function(t) {
      const e = `${Jx.prefixCls}.clipboard.cells`;
      t.save = function(t) {
        if (window.localStorage) {
          const n = t.map(t => t.toJSON());
          localStorage.setItem(e, JSON.stringify(n))
        }
      }, t.fetch = function() {
        if (window.localStorage) {
          const t = localStorage.getItem(e),
            n = t ? JSON.parse(t) : [];
          if (n) return Ak.fromJSON(n)
        }
      }, t.clean = function() {
        window.localStorage && localStorage.removeItem(e)
      }
    }(eO || (eO = {}));
    class cO extends sO {
      get node() {
        return this.cell
      }
      get containerClassName() {
        return this.prefixClassName("widget-transform")
      }
      get resizeClassName() {
        return `${this.containerClassName}-resize`
      }
      get rotateClassName() {
        return `${this.containerClassName}-rotate`
      }
      init(t) {
        this.options = Object.assign(Object.assign({}, nO.defaultOptions), t), this.render(), this.startListening()
      }
      startListening() {
        this.delegateEvents({
          [`mousedown .${this.resizeClassName}`]: "startResizing",
          [`touchstart .${this.resizeClassName}`]: "startResizing",
          [`mousedown .${this.rotateClassName}`]: "startRotating",
          [`touchstart .${this.rotateClassName}`]: "startRotating"
        }), this.model.on("*", this.update, this), this.model.on("reseted", this.remove, this), this.node.on(
          "removed", this.remove, this), this.graph.on("scale", this.update, this), this.graph.on("translate",
          this.update, this), super.startListening()
      }
      stopListening() {
        this.undelegateEvents(), this.model.off("*", this.update, this), this.model.off("reseted", this.remove,
            this), this.node.off("removed", this.remove, this), this.graph.off("scale", this.update, this), this.graph
          .off("translate", this.update, this), super.stopListening()
      }
      onRemove() {
        this.stopListening()
      }
      renderHandles() {
        this.container = document.createElement("div"), this.$container = this.$(this.container);
        const t = this.$("<div/>").prop("draggable", !1),
          e = t.clone().addClass(this.rotateClassName),
          n = nO.POSITIONS.map(e => t.clone().addClass(this.resizeClassName).attr("data-position", e));
        this.empty(), this.$container.append(n, e)
      }
      render() {
        return this.renderHandles(), this.$container.addClass(this.containerClassName).toggleClass(
            "no-orth-resize", this.options.preserveAspectRatio || !this.options.orthogonalResizing).toggleClass(
            "no-resize", !this.options.resizable).toggleClass("no-rotate", !this.options.rotatable), this.options
          .className && this.$container.addClass(this.options.className), this.graph.container.appendChild(this.container),
          this.update()
      }
      update() {
        const t = this.graph.matrix(),
          e = this.node.getBBox();
        e.x *= t.a, e.x += t.e, e.y *= t.d, e.y += t.f, e.width *= t.a, e.height *= t.d;
        const n = nC.normalize(this.node.getAngle()),
          r = 0 !== n ? `rotate(${n}deg)` : "";
        return this.$container.css({
          transform: r,
          width: e.width,
          height: e.height,
          left: e.x,
          top: e.y
        }), this.updateResizerDirections(), this
      }
      updateResizerDirections() {
        const t = nC.normalize(this.node.getAngle()),
          e = Math.floor(t * (nO.DIRECTIONS.length / 360));
        if (e !== this.prevShift) {
          const t = nO.DIRECTIONS.slice(e).concat(nO.DIRECTIONS.slice(0, e)),
            n = t => `${this.containerClassName}-cursor-${t}`;
          this.$container.find(`.${this.resizeClassName}`).removeClass(nO.DIRECTIONS.map(t => n(t)).join(" ")).each(
            (e, r) => {
              this.$(r).addClass(n(t[e]))
            }), this.prevShift = e
        }
      }
      getTrueDirection(t) {
        const e = nC.normalize(this.node.getAngle());
        let n = nO.POSITIONS.indexOf(t);
        return n += Math.floor(e * (nO.POSITIONS.length / 360)), n %= nO.POSITIONS.length, nO.POSITIONS[n]
      }
      toValidResizeDirection(t) {
        return {
          top: "top-left",
          bottom: "bottom-right",
          left: "bottom-left",
          right: "top-right"
        } [t] || t
      }
      startResizing(t) {
        t.stopPropagation(), this.model.startBatch("resize", {
          cid: this.cid
        });
        const e = this.$(t.target).attr("data-position");
        this.prepareResizing(t, e), this.startAction(t)
      }
      prepareResizing(t, e) {
        const n = this.getTrueDirection(e);
        let r = 0,
          i = 0;
        e.split("-").forEach(t => {
          r = {
            left: -1,
            right: 1
          } [t] || r, i = {
            top: -1,
            bottom: 1
          } [t] || i
        });
        const o = this.toValidResizeDirection(e),
          s = {
            "top-right": "bottomLeft",
            "top-left": "bottomRight",
            "bottom-left": "topRight",
            "bottom-right": "topLeft"
          } [o];
        this.setEventData(t, {
          selector: s,
          direction: o,
          trueDirection: n,
          relativeDirection: e,
          resizeX: r,
          resizeY: i,
          angle: nC.normalize(this.node.getAngle()),
          action: "resizing"
        })
      }
      startRotating(t) {
        t.stopPropagation(), this.model.startBatch("rotate", {
          cid: this.cid
        });
        const e = this.node.getBBox().getCenter(),
          n = this.graph.snapToGrid(t.clientX, t.clientY);
        this.setEventData(t, {
          center: e,
          action: "rotating",
          angle: nC.normalize(this.node.getAngle()),
          start: hC.create(n).theta(e)
        }), this.startAction(t)
      }
      onMouseMove(t) {
        let e = this.getEventData(t);
        if (e.action) {
          const n = this.normalizeEvent(t),
            r = this.graph.snapToGrid(n.clientX, n.clientY),
            i = this.graph.getGridSize(),
            o = this.node,
            s = this.options;
          if ("resizing" === e.action) {
            (e = e).resized || (e.resized = !0);
            const n = o.getBBox(),
              a = hC.create(r).rotate(e.angle, n.getCenter()).diff(n[e.selector]);
            let l = e.resizeX ? a.x * e.resizeX : n.width,
              c = e.resizeY ? a.y * e.resizeY : n.height;
            const h = l,
              u = c;
            if (l = oE.snapToGrid(l, i), c = oE.snapToGrid(c, i), l = Math.max(l, s.minWidth || i), c = Math.max(
                c, s.minHeight || i), l = Math.min(l, s.maxWidth || 1 / 0), c = Math.min(c, s.maxHeight || 1 / 0),
              s.preserveAspectRatio) {
              const t = n.width * c / n.height,
                e = n.height * l / n.width;
              l < t ? c = e : l = t
            }
            const d = e.relativeDirection;
            if (h <= -l || u <= -c) {
              let e;
              "left" === d ? h <= -l && (e = "right") : "right" === d ? h <= -l && (e = "left") : "top" === d ? u <=
                -c && (e = "bottom") : "bottom" === d ? u <= -c && (e = "top") : "top-left" === d ? h <= -l && u <=
                -c ? e = "bottom-right" : h <= -l ? e = "top-right" : u <= -c && (e = "bottom-left") :
                "top-right" === d ? h <= -l && u <= -c ? e = "bottom-left" : h <= -l ? e = "top-left" : u <= -c &&
                (e = "bottom-right") : "bottom-left" === d ? h <= -l && u <= -c ? e = "top-right" : h <= -l ? e =
                "bottom-right" : u <= -c && (e = "top-left") : "bottom-right" === d && (h <= -l && u <= -c ? e =
                  "top-left" : h <= -l ? e = "bottom-left" : u <= -c && (e = "top-right"));
              const n = e;
              this.stopHandle();
              const r = this.$container.find(`.${this.resizeClassName}[data-position="${n}"]`);
              this.startHandle(r[0]), this.prepareResizing(t, n), this.onMouseMove(t)
            }
            if (n.width !== l || n.height !== c) {
              const t = {
                ui: !0,
                direction: e.direction,
                relativeDirection: e.relativeDirection,
                trueDirection: e.trueDirection,
                minWidth: s.minWidth,
                minHeight: s.minHeight,
                maxWidth: s.maxWidth,
                maxHeight: s.maxHeight,
                preserveAspectRatio: !0 === s.preserveAspectRatio
              };
              o.resize(l, c, t)
            }
          } else if ("rotating" === e.action) {
            (e = e).rotated || (e.rotated = !0);
            const t = e.start - hC.create(r).theta(e.center);
            let n = e.angle + t;
            s.rotateGrid && (n = oE.snapToGrid(n, s.rotateGrid)), o.rotate(n, {
              absolute: !0
            })
          }
        }
      }
      onMouseUp(t) {
        let e = this.getEventData(t);
        e.action && (this.stopAction(t), this.model.stopBatch("resizing" === e.action ? "resize" : "rotate", {
          cid: this.cid
        }), "resizing" === e.action ? (e = e).resized && Yk("node:resized", t, this.graph.findViewByCell(this
          .cell)) : (e = e).rotated && Yk("node:rotated", t, this.graph.findViewByCell(this.cell)))
      }
      startHandle(t) {
        this.handle = t, this.$(t).addClass(`${this.containerClassName}-active-handle`), this.$container.addClass(
          `${this.containerClassName}-active`);
        const e = t.getAttribute("data-position");
        if (e) {
          const t = nO.DIRECTIONS[nO.POSITIONS.indexOf(e)];
          this.$container.addClass(`${this.containerClassName}-cursor-${t}`)
        }
      }
      stopHandle() {
        if (this.handle) {
          this.$(this.handle).removeClass(`${this.containerClassName}-active-handle`), this.$container.removeClass(
            `${this.containerClassName}-active`);
          const t = this.handle.getAttribute("data-position");
          if (t) {
            const e = nO.DIRECTIONS[nO.POSITIONS.indexOf(t)];
            this.$container.removeClass(`${this.containerClassName}-cursor-${e}`)
          }
          this.handle = null
        }
      }
      startAction(t) {
        const e = t.target;
        this.startHandle(e), this.graph.view.undelegateEvents(), this.delegateDocumentEvents(nO.documentEvents, t
          .data)
      }
      stopAction(t) {
        this.stopHandle(), this.undelegateDocumentEvents(), this.graph.view.delegateEvents()
      }
    }(rO = nO || (nO = {})).DIRECTIONS = ["nw", "n", "ne", "e", "se", "s", "sw", "w"], rO.POSITIONS = ["top-left",
      "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left"
    ], rO.documentEvents = {
      mousemove: "onMouseMove",
      touchmove: "onMouseMove",
      mouseup: "onMouseUp",
      touchend: "onMouseUp"
    }, rO.defaultOptions = {
      minWidth: 0,
      minHeight: 0,
      maxWidth: 1 / 0,
      maxHeight: 1 / 0,
      rotateGrid: 15,
      rotatable: !0,
      preserveAspectRatio: !1,
      orthogonalResizing: !0
    };
    const hO = xk.define({
      shape: "edge",
      markup: [{
        tagName: "path",
        selector: "wrap",
        attrs: {
          fill: "none",
          cursor: "pointer",
          stroke: "transparent",
          strokeLinecap: "round"
        }
      }, {
        tagName: "path",
        selector: "line",
        attrs: {
          fill: "none",
          pointerEvents: "none"
        }
      }],
      attrs: {
        wrap: {
          connection: !0,
          strokeWidth: 10,
          strokeLinejoin: "round"
        },
        line: {
          connection: !0,
          stroke: "#333333",
          strokeWidth: 2,
          strokeLinejoin: "round",
          targetMarker: "classic"
        }
      }
    });
    var uO, dO = this && this.__rest || function(t, e) {
      var n = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
          .call(t, r[i]) && (n[r[i]] = t[r[i]])
      }
      return n
    };
    ! function(t) {
      (uO || (uO = {})).parseOptionGroup = function(t, e, n) {
        const r = {};
        return Object.keys(n || {}).forEach(i => {
          const o = n[i];
          r[i] = "function" == typeof o ? o.call(t, e) : o
        }), r
      }
    }(),
    function(t) {
      t.get = function(e) {
        const {
          grid: n,
          selecting: r,
          embedding: i,
          snapline: s,
          resizing: a,
          rotating: l,
          clipboard: c,
          history: h,
          scroller: u,
          minimap: d,
          keyboard: p,
          mousewheel: f
        } = e, g = dO(e, ["grid", "selecting", "embedding", "snapline", "resizing", "rotating", "clipboard",
          "history", "scroller", "minimap", "keyboard", "mousewheel"
        ]), m = e.container;
        if (null == m) throw new Error("Ensure the container of the graph is specified and vliad");
        null == g.width && (g.width = m.clientWidth), null == g.height && (g.height = m.clientHeight);
        const v = o.merge({}, t.defaults, g),
          y = {
            size: 10,
            visible: !1
          };
        return v.grid = "number" == typeof n ? {
          size: n,
          visible: !1
        } : "boolean" == typeof n ? Object.assign(Object.assign({}, y), {
          visible: n
        }) : Object.assign(Object.assign({}, y), n), ["selecting", "embedding", "snapline", "resizing",
          "rotating", "clipboard", "history", "scroller", "minimap", "keyboard", "mousewheel"
        ].forEach(t => {
          const n = e[t];
          "boolean" == typeof n ? v[t].enabled = n : v[t] = Object.assign(Object.assign({}, v[t]), n)
        }), v.background && v.scroller.enabled && null == v.scroller.background && (v.scroller.background = v
          .background, delete v.background), v
      }
    }(uO || (uO = {})), (uO || (uO = {})).defaults = {
      x: 0,
      y: 0,
      grid: {
        size: 10,
        visible: !1
      },
      scaling: {
        min: .01,
        max: 16
      },
      background: !1,
      highlighting: {
        default: {
          name: "stroke",
          args: {
            padding: 3
          }
        },
        nodeAvailable: {
          name: "className",
          args: {
            className: oE.prefix("available-node")
          }
        },
        magnetAvailable: {
          name: "className",
          args: {
            className: oE.prefix("available-magnet")
          }
        }
      },
      connecting: {
        snap: !1,
        multi: !0,
        dangling: !0,
        highlight: !1,
        anchor: "center",
        edgeAnchor: "ratio",
        connectionPoint: "boundary",
        strategy: null,
        router: "normal",
        connector: "normal",
        validateConnection: ({
          type: t,
          sourceView: e,
          targetView: n
        }) => ("target" === t ? n : e) instanceof Sk,
        createEdge: () => new hO
      },
      transforming: {
        clearAll: !0,
        clearOnBlankMouseDown: !0
      },
      resizing: {
        enabled: !1,
        minWidth: 0,
        minHeight: 0,
        maxWidth: Number.MAX_SAFE_INTEGER,
        maxHeight: Number.MAX_SAFE_INTEGER,
        orthogonal: !0,
        preserveAspectRatio: !1
      },
      rotating: {
        enabled: !1,
        grid: 15
      },
      translating: {
        restrict: !1
      },
      embedding: {
        enabled: !1,
        findParent: "bbox",
        frontOnly: !0,
        validate: () => !0
      },
      selecting: {
        enabled: !1,
        rubberband: !1,
        multiple: !0,
        movable: !0,
        strict: !1,
        useCellGeometry: !1,
        selectCellOnMoved: !1,
        selectNodeOnMoved: !1,
        selectEdgeOnMoved: !1,
        content: null,
        handles: null
      },
      snapline: {
        enabled: !1
      },
      clipboard: {
        enabled: !1
      },
      history: {
        enabled: !1
      },
      scroller: {
        enabled: !1
      },
      keyboard: {
        enabled: !1
      },
      mousewheel: {
        enabled: !1,
        factor: 1.2,
        zoomAtMousePosition: !0
      },
      async: !1,
      frozen: !1,
      sorting: "exact",
      moveThreshold: 0,
      clickThreshold: 0,
      magnetThreshold: 0,
      preventDefaultContextMenu: !0,
      preventDefaultBlankAction: !0,
      interacting: {
        edgeLabelMovable: !1
      },
      guard: () => !1
    };
    var pO, fO = this && this.__decorate || function(t, e, n, r) {
      var i, o = arguments.length,
        s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r);
      else
        for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) ||
          s);
      return o > 3 && s && Object.defineProperty(e, n, s), s
    };
    class gO extends Dk {
      init() {
        this.resetUpdates(), this.setup(), this.resetViews(this.model.getCells()), !this.isFrozen() && this.isAsync() &&
          this.updateViewsAsync()
      }
      setup() {
        const t = this.model;
        t.on("sorted", () => this.onSortModel()), t.on("reseted", ({
          options: t
        }) => this.onModelReseted(t)), t.on("batch:stop", ({
          name: t,
          data: e
        }) => this.onBatchStop(t, e)), t.on("cell:added", ({
          cell: t,
          options: e
        }) => this.onCellAdded(t, e)), t.on("cell:removed", ({
          cell: t,
          options: e
        }) => this.onCellRemoved(t, e)), t.on("cell:change:zIndex", ({
          cell: t,
          options: e
        }) => this.onCellZIndexChanged(t, e)), t.on("cell:change:visible", ({
          cell: t,
          current: e,
          options: n
        }) => {
          this.onCellVisibleChanged(t, !1 !== e, n)
        })
      }
      resetUpdates() {
        this.updates = {
          priorities: [{}, {}, {}],
          mounted: {},
          mountedCids: [],
          unmounted: {},
          unmountedCids: [],
          count: 0,
          sort: !1,
          frozen: !1,
          freezeKey: null,
          animationId: null
        }
      }
      onSortModel() {
        this.model.hasActiveBatch(gO.SORT_DELAYING_BATCHES) || this.sortViews()
      }
      onModelReseted(t) {
        this.removeZPivots(), this.resetViews(this.model.getCells(), t)
      }
      onCellAdded(t, e) {
        const n = e.position;
        this.isAsync() || "number" != typeof n ? this.renderView(t, e) : (e.maxPosition === n && this.freeze({
          key: "addCells"
        }), this.renderView(t, e), 0 === n && this.unfreeze({
          key: "addCells"
        }))
      }
      onCellRemoved(t, e) {
        const n = this.findViewByCell(t);
        n && this.requestViewUpdate(n, gO.FLAG_REMOVE, n.priority, e)
      }
      onCellZIndexChanged(t, e) {
        if ("approx" === this.options.sorting) {
          const n = this.findViewByCell(t);
          n && this.requestViewUpdate(n, gO.FLAG_INSERT, n.priority, e)
        }
      }
      onCellVisibleChanged(t, e, n) {
        e || this.processEdgeOnTerminalVisibleChanged(t, !1);
        const r = this.findViewByCell(t);
        !e && r ? this.removeView(t) : e && null == r && this.renderView(t, n), e && this.processEdgeOnTerminalVisibleChanged(
          t, !0)
      }
      processEdgeOnTerminalVisibleChanged(t, e) {
        var n, r;
        this.model.getConnectedEdges(t).forEach(n => {
          const i = (r = t, (n = n).getSourceCellId() !== r.id ? n.getSourceCell() : n.getTargetCellId() !==
            r.id ? n.getTargetCell() : null);
          (null == i || i.isVisible()) && (e ? n.show() : n.hide())
        })
      }
      onBatchStop(t, e) {
        if (this.isFrozen()) return;
        const n = this.model;
        if (!this.isAsync()) {
          const r = gO.UPDATE_DELAYING_BATCHES;
          r.includes(t) && !n.hasActiveBatch(r) && this.updateViews(e)
        }
        const r = gO.SORT_DELAYING_BATCHES;
        r.includes(t) && !n.hasActiveBatch(r) && this.sortViews()
      }
      requestConnectedEdgesUpdate(t, e = {}) {
        if (t instanceof dS) {
          const n = t.cell,
            r = this.model.getConnectedEdges(n);
          for (let t = 0, i = r.length; t < i; t += 1) {
            const i = r[t],
              o = this.findViewByCell(i);
            if (!o) continue;
            const s = ["update"];
            i.getTargetCell() === n && s.push("target"), i.getSourceCell() === n && s.push("source"), this.scheduleViewUpdate(
              o, o.getFlag(s), o.priority, e)
          }
        }
      }
      forcePostponedViewUpdate(t, e) {
        if (!(t && t instanceof dS)) return !1;
        const n = t.cell;
        if (n.isNode()) return !1;
        const r = t;
        if (n.isEdge() && 0 == (e & t.getFlag(["source", "target"]))) {
          let t = 0;
          const e = this.findViewByCell(n.getSourceCell());
          e && !this.isViewMounted(e) && (t = this.dumpView(e), r.updateTerminalMagnet("source"));
          let i = 0;
          const o = this.findViewByCell(n.getTargetCell());
          if (o && !this.isViewMounted(o) && (i = this.dumpView(o), r.updateTerminalMagnet("target")), 0 === t &&
            0 === i) return !this.dumpView(r)
        }
        return !1
      }
      scheduleViewUpdate(t, e, n, r = {}) {
        const i = t.cid,
          o = this.updates;
        let s = o.priorities[n];
        s || (s = o.priorities[n] = {});
        const a = s[i] || 0;
        (a & e) !== e && (a || (o.count += 1), e & gO.FLAG_REMOVE && a & gO.FLAG_INSERT ? s[i] ^= gO.FLAG_INSERT :
          e & gO.FLAG_INSERT && a & gO.FLAG_REMOVE && (s[i] ^= gO.FLAG_REMOVE), s[i] |= e, this.graph.hook.onViewUpdated(
            t, e, r))
      }
      requestViewUpdate(t, e, n, r = {}) {
        this.scheduleViewUpdate(t, e, n, r);
        const i = this.isAsync();
        if (this.isFrozen() || i && !1 !== r.async || this.model.hasActiveBatch(gO.UPDATE_DELAYING_BATCHES))
          return;
        const o = this.updateViews(r);
        i && this.graph.trigger("render:done", {
          stats: o,
          options: r
        })
      }
      dumpView(t, e = {}) {
        if (null == t) return 0;
        const n = t.cid,
          r = this.updates.priorities[t.priority],
          i = this.registerMountedView(t) | r[n];
        return delete r[n], i ? this.updateView(t, i, e) : 0
      }
      dumpViews(t = {}) {
        this.checkView(t), this.updateViews(t)
      }
      requireView(t, e = {}) {
        const n = this.findViewByCell(t);
        return null == n ? null : (this.dumpView(n, e), n)
      }
      updateView(t, e, n = {}) {
        if (null == t) return 0;
        if (t instanceof dS) {
          if (e & gO.FLAG_REMOVE) return this.removeView(t.cell), 0;
          e & gO.FLAG_INSERT && (this.insertView(t), e ^= gO.FLAG_INSERT)
        }
        return e ? t.confirmUpdate(e, n) : 0
      }
      updateViews(t = {}) {
        let e, n = 0,
          r = 0,
          i = gO.MIN_PRIORITY;
        do {
          n += 1, r += (e = this.updateViewsBatch(t)).updatedCount, i = Math.min(e.priority, i)
        } while (!e.empty);
        return {
          priority: i,
          batchCount: n,
          updatedCount: r
        }
      }
      updateViewsBatch(t = {}) {
        const e = this.updates,
          n = e.priorities,
          r = t.batchSize || gO.UPDATE_BATCH_SIZE;
        let i = !0,
          o = gO.MIN_PRIORITY,
          s = 0,
          a = 0,
          c = 0,
          h = 0,
          u = t.checkView || this.options.checkView;
        "function" != typeof u && (u = null);
        t: for (let d = 0, p = n.length; d < p; d += 1) {
          const p = n[d];
          for (const n in p) {
            if (c >= r) {
              i = !1;
              break t
            }
            const f = ZE.views[n];
            if (!f) {
              delete p[n];
              continue
            }
            let g = p[n];
            if (0 == (g & gO.FLAG_REMOVE)) {
              const t = n in e.unmounted;
              if (u && !l.call(u, this.graph, {
                  view: f,
                  unmounted: t
                })) {
                t || (this.registerUnmountedView(f), f.unmount()), e.unmounted[n] |= g, delete p[n], a += 1;
                continue
              }
              t && (g |= gO.FLAG_INSERT, s += 1), g |= this.registerMountedView(f)
            }
            const m = this.updateView(f, g, t);
            m > 0 && (p[n] = m, !this.graph.hook.onViewPostponed(f, m, t) || p[n]) ? (h += 1, i = !1) : (o >
              d && (o = d), c += 1, delete p[n])
          }
        }
        return {
          empty: i,
          priority: o,
          mountedCount: s,
          unmountedCount: a,
          updatedCount: c,
          postponedCount: h
        }
      }
      updateViewsAsync(t = {}, e = {
        processed: 0,
        priority: gO.MIN_PRIORITY
      }) {
        const n = this.updates,
          r = n.animationId;
        if (r) {
          if (h.cancelAnimationFrame(r), 0 === e.processed) {
            const e = t.before;
            "function" == typeof e && l.call(e, this.graph, this.graph)
          }
          const i = this.updateViewsBatch(t),
            o = this.checkViewImpl({
              checkView: t.checkView,
              mountedBatchSize: gO.MOUNT_BATCH_SIZE - i.mountedCount,
              unmountedBatchSize: gO.MOUNT_BATCH_SIZE - i.unmountedCount
            });
          let s = e.processed;
          const a = n.count,
            c = o.mountedCount,
            u = o.unmountedCount;
          i.updatedCount > 0 && (s += i.updatedCount + i.unmountedCount, e.priority = Math.min(i.priority, e.priority),
            i.empty && 0 === c ? (i.priority = e.priority, i.mountedCount += c, i.unmountedCount += u, this.graph
              .trigger("render:done", {
                stats: i,
                options: t
              }), e.processed = 0, n.count = 0) : e.processed = s);
          const d = t.progress;
          if (a && "function" == typeof d && l.call(d, this.graph, {
              total: a,
              done: i.empty,
              current: s
            }), n.animationId !== r) return
        }
        n.animationId = h.requestAnimationFrame(() => {
          this.updateViewsAsync(t, e)
        })
      }
      registerMountedView(t) {
        const e = t.cid,
          n = this.updates;
        if (e in n.mounted) return 0;
        n.mounted[e] = !0, n.mountedCids.push(e);
        const r = n.unmounted[e] || 0;
        return delete n.unmounted[e], r
      }
      registerUnmountedView(t) {
        const e = t.cid,
          n = this.updates;
        if (e in n.unmounted) return 0;
        n.unmounted[e] |= gO.FLAG_INSERT;
        const r = n.unmounted[e];
        return n.unmountedCids.push(e), delete n.mounted[e], r
      }
      isViewMounted(t) {
        if (null == t) return !1;
        return t.cid in this.updates.mounted
      }
      getMountedViews() {
        return Object.keys(this.updates.mounted).map(t => dS.views[t])
      }
      getUnmountedViews() {
        return Object.keys(this.updates.unmounted).map(t => dS.views[t])
      }
      checkMountedViews(t, e) {
        let n = 0;
        if ("function" != typeof t) return n;
        const r = this.updates,
          i = r.mounted,
          o = r.mountedCids,
          s = null == e ? o.length : Math.min(o.length, e);
        for (let e = 0; e < s; e += 1) {
          const r = o[e];
          if (!(r in i)) continue;
          const s = dS.views[r];
          null != s && (l.call(t, this.graph, {
            view: s,
            unmounted: !0
          }) ? o.push(r) : (n += 1, this.registerUnmountedView(s) && s.unmount()))
        }
        return o.splice(0, s), n
      }
      checkUnmountedViews(t, e) {
        let n = 0;
        "function" != typeof t && (t = null);
        const r = this.updates,
          i = r.unmounted,
          o = r.unmountedCids,
          s = null == e ? o.length : Math.min(o.length, e);
        for (let e = 0; e < s; e += 1) {
          const r = o[e];
          if (!(r in i)) continue;
          const s = dS.views[r];
          if (null == s) continue;
          if (t && !l.call(t, this.graph, {
              view: s,
              unmounted: !1
            })) {
            o.push(r);
            continue
          }
          n += 1;
          const a = this.registerMountedView(s);
          a && this.scheduleViewUpdate(s, a, s.priority, {
            mounting: !0
          })
        }
        return o.splice(0, s), n
      }
      checkViewImpl(t = {
        mountedBatchSize: Number.MAX_SAFE_INTEGER,
        unmountedBatchSize: Number.MAX_SAFE_INTEGER
      }) {
        const e = t.checkView || this.options.checkView,
          n = this.checkMountedViews(e, t.unmountedBatchSize);
        return {
          mountedCount: this.checkUnmountedViews(e, n > 0 ? Math.min(this.updates.unmountedCids.length - n, t.mountedBatchSize) :
            t.mountedBatchSize),
          unmountedCount: n
        }
      }
      checkView(t = {}) {
        return this.checkViewImpl(t)
      }
      isFrozen() {
        return !!this.options.frozen
      }
      freeze(t = {}) {
        const e = t.key,
          n = this.updates,
          r = this.options.frozen,
          i = n.freezeKey;
        if (e && e !== i) {
          if (r && i) return;
          n.frozen = r, n.freezeKey = e
        }
        this.options.frozen = !0;
        const o = n.animationId;
        n.animationId = null, this.isAsync() && null != o && h.cancelAnimationFrame(o), this.graph.trigger(
          "freeze", {
            key: e
          })
      }
      unfreeze(t = {}) {
        const e = t.key,
          n = this.updates,
          r = n.freezeKey;
        if (e && r && e !== r) return;
        if (n.freezeKey = null, e && e === r && n.frozen) return;
        const i = () => {
          this.options.frozen = n.frozen = !1, n.sort && (this.sortViews(), n.sort = !1);
          const r = t.after;
          r && l.call(r, this.graph, this.graph), this.graph.trigger("unfreeze", {
            key: e
          })
        };
        if (this.isAsync()) {
          this.freeze();
          const e = t.progress;
          this.updateViewsAsync(Object.assign(Object.assign({}, t), {
            progress: ({
              done: t,
              current: n,
              total: r
            }) => {
              e && l.call(e, this.graph, {
                done: t,
                current: n,
                total: r
              }), t && i()
            }
          }))
        } else this.updateViews(t), i()
      }
      isAsync() {
        return !!this.options.async
      }
      setAsync(t) {
        this.options.async = t
      }
      onRemove() {
        this.freeze(), this.removeViews()
      }
      resetViews(t = [], e = {}) {
        this.resetUpdates(), this.removeViews(), this.freeze({
          key: "reset"
        });
        for (let n = 0, r = t.length; n < r; n += 1) this.renderView(t[n], e);
        this.unfreeze({
          key: "reset"
        }), this.sortViews()
      }
      removeView(t) {
        const e = this.views[t.id];
        if (e) {
          const n = e.cid,
            r = this.updates,
            i = r.mounted,
            o = r.unmounted;
          e.remove(), delete this.views[t.id], delete i[n], delete o[n]
        }
        return e
      }
      removeViews() {
        this.views && Object.keys(this.views).forEach(t => {
          const e = this.views[t];
          e && this.removeView(e.cell)
        }), this.views = {}
      }
      renderView(t, e = {}) {
        const n = t.id,
          r = this.views;
        let i = 0,
          o = r[n];
        if (o) i = gO.FLAG_INSERT;
        else {
          const e = this.graph.hook.createCellView(t);
          e && ((o = r[t.id] = e).graph = this.graph, i = this.registerUnmountedView(o) | o.getBootstrapFlag())
        }
        return o && this.requestViewUpdate(o, i, o.priority, e), o
      }
      isExactSorting() {
        return "exact" === this.options.sorting
      }
      sortViews() {
        this.isExactSorting() && (this.isFrozen() ? this.updates.sort = !0 : this.sortViewsExact())
      }
      sortElements(t, e) {
        const n = t.map(t => {
          const e = t.parentNode,
            n = e.insertBefore(document.createTextNode(""), t.nextSibling);
          return t => {
            if (e === t) throw new Error("You can't sort elements if any one is a descendant of another.");
            e.insertBefore(t, n), e.removeChild(n)
          }
        });
        t.sort(e).forEach((t, e) => n[e](t))
      }
      sortViewsExact() {
        const t = this.view.$(this.view.stage).children("[data-cell-id]").toArray(),
          e = this.model;
        this.sortElements(t, (t, n) => {
          const r = e.getCell(t.getAttribute("data-cell-id") || ""),
            i = e.getCell(n.getAttribute("data-cell-id") || ""),
            o = r.getZIndex() || 0,
            s = i.getZIndex() || 0;
          return o === s ? 0 : o < s ? -1 : 1
        })
      }
      addZPivot(t = 0) {
        null == this.zPivots && (this.zPivots = {});
        const e = this.zPivots;
        let n = e[t];
        if (n) return n;
        n = e[t] = document.createComment(`z-index:${t+1}`);
        let r = -1 / 0;
        for (const n in e) {
          const e = +n;
          e < t && e > r && (r = e)
        }
        const i = this.view.stage;
        if (r !== -1 / 0) {
          const t = e[r];
          i.insertBefore(n, t.nextSibling)
        } else i.insertBefore(n, i.firstChild);
        return n
      }
      removeZPivots() {
        this.zPivots && Object.keys(this.zPivots).forEach(t => {
          const e = this.zPivots[t];
          e && e.parentNode && e.parentNode.removeChild(e)
        }), this.zPivots = {}
      }
      insertView(t) {
        const e = this.view.stage;
        switch (this.options.sorting) {
          case "approx":
            const n = t.cell.getZIndex(),
              r = this.addZPivot(n);
            e.insertBefore(t.container, r);
            break;
          case "exact":
          default:
            e.appendChild(t.container)
        }
      }
      findViewByCell(t) {
        if (null == t) return null;
        const e = t instanceof fk ? t.id : t;
        return this.views[e]
      }
      findViewByElem(t) {
        if (null == t) return null;
        const e = "string" == typeof t ? this.view.stage.querySelector(t) : t instanceof Element ? t : t[0];
        if (e) {
          const t = this.view.findAttr("data-cell-id", e);
          if (t) return this.views[t]
        }
        return null
      }
      findViewsFromPoint(t) {
        const e = {
          x: t.x,
          y: t.y
        };
        return this.model.getCells().map(t => this.findViewByCell(t)).filter(t => {
          if (null != t) return h.getBBox(t.container, {
            target: this.view.stage
          }).containsPoint(e)
        })
      }
      findViewsInArea(t, e = {}) {
        const n = uC.create(t);
        return this.model.getNodes().map(t => this.findViewByCell(t)).filter(t => {
          if (t) {
            const r = h.getBBox(t.container, {
              target: this.view.stage
            });
            return e.strict ? n.containsRect(r) : n.isIntersectWith(r)
          }
        })
      }
      dispose() {}
    }
    fO([Dk.dispose()], gO.prototype, "dispose", null), (pO = gO || (gO = {})).FLAG_INSERT = 1 << 30, pO.FLAG_REMOVE =
      1 << 29, pO.MOUNT_BATCH_SIZE = 1e3, pO.UPDATE_BATCH_SIZE = 1e3, pO.MIN_PRIORITY = 2, pO.SORT_DELAYING_BATCHES = [
        "add", "to-front", "to-back"
      ], pO.UPDATE_DELAYING_BATCHES = ["translate"];
    var mO = this && this.__rest || function(t, e) {
      var n = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
          .call(t, r[i]) && (n[r[i]] = t[r[i]])
      }
      return n
    };
    class vO extends Dk {
      get cid() {
        return this.graph.view.cid
      }
      get svg() {
        return this.view.svg
      }
      get elem() {
        return this.view.defs
      }
      isDefined(t) {
        return null != this.svg.getElementById(t)
      }
      filter(t) {
        let e = t.id;
        const n = t.name;
        if (e || (e = `filter-${n}-${this.cid}-${s.hashcode(JSON.stringify(t))}`), !this.isDefined(e)) {
          const r = BA.registry.get(n);
          if (null == r) return BA.registry.onNotFound(n);
          const i = r(t.args || {}),
            o = Object.assign(Object.assign({
              x: -1,
              y: -1,
              width: 3,
              height: 3,
              filterUnits: "objectBoundingBox"
            }, t.attrs), {
              id: e
            });
          h.createVector(oS.sanitize(i), o).appendTo(this.elem)
        }
        return e
      }
      gradient(t) {
        let e = t.id;
        const n = t.type;
        if (e || (e = `gradient-${n}-${this.cid}-${s.hashcode(JSON.stringify(t))}`), !this.isDefined(e)) {
          const r =
            `<${n}>${t.stops.map(t=>{const e=null!=t.opacity&&Number.isFinite(t.opacity)?t.opacity:1;return`<stop offset="${t.offset}" stop-color="${t.color}" stop-opacity="${e}"/>`}).join("")}</${n}>`,
            i = Object.assign({
              id: e
            }, t.attrs);
          h.createVector(r, i).appendTo(this.elem)
        }
        return e
      }
      marker(t) {
        const {
          id: e,
          tagName: n,
          markerUnits: r,
          children: i
        } = t, o = mO(t, ["id", "tagName", "markerUnits", "children"]);
        let a = e;
        if (a || (a = `marker-${this.cid}-${s.hashcode(JSON.stringify(t))}`), !this.isDefined(a)) {
          "path" !== n && delete o.d;
          const t = h.createVector("marker", {
            id: a,
            orient: "auto",
            overflow: "visible",
            markerUnits: r || "userSpaceOnUse"
          }, i ? i.map(t => {
            var {
              tagName: e
            } = t, n = mO(t, ["tagName"]);
            return h.createVector(`${e}` || "path", this.normalizeAttrs(Object.assign(Object.assign({}, o),
              n)))
          }) : [h.createVector(n || "path", this.normalizeAttrs(o))]);
          this.elem.appendChild(t.node)
        }
        return a
      }
      normalizeAttrs(t) {
        const e = {};
        return Object.keys(t).forEach(n => {
          n.indexOf(":") > 0 ? e[n] = t[n] : e[s.kebabCase(n)] = t[n]
        }), e
      }
    }
    var yO, bO = this && this.__decorate || function(t, e, n, r) {
        var i, o = arguments.length,
          s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r);
        else
          for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) ||
            s);
        return o > 3 && s && Object.defineProperty(e, n, s), s
      },
      CO = this && this.__rest || function(t, e) {
        var n = {};
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
        if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
          var i = 0;
          for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
            .call(t, r[i]) && (n[r[i]] = t[r[i]])
        }
        return n
      };
    class xO extends Dk {
      get elem() {
        return this.view.grid
      }
      get grid() {
        return this.options.grid
      }
      init() {
        this.graph.on("scale", this.update, this), this.graph.on("translate", this.update, this), this.draw(this.grid)
      }
      setVisible(t) {
        this.grid.visible !== t && (this.grid.visible = t, this.update())
      }
      getGridSize() {
        return this.grid.size
      }
      setGridSize(t) {
        this.grid.size = Math.max(t, 1), this.update()
      }
      show() {
        this.setVisible(!0), this.update()
      }
      hide() {
        this.setVisible(!1), this.update()
      }
      clear() {
        this.elem.style.backgroundImage = ""
      }
      draw(t) {
        this.clear(), this.instance = null, Object.assign(this.grid, t), this.patterns = this.resolveGrid(t),
          this.update()
      }
      update(t = {}) {
        const e = this.grid.size;
        if (e <= 1 || !this.grid.visible) return this.clear();
        const n = this.graph.matrix(),
          r = this.getInstance(),
          i = Array.isArray(t) ? t : [t];
        this.patterns.forEach((t, o) => {
          const s = `pattern_${o}`,
            a = n.a || 1,
            l = n.d || 1,
            {
              update: c,
              markup: u
            } = t,
            d = CO(t, ["update", "markup"]),
            p = Object.assign(Object.assign(Object.assign({}, d), i[o]), {
              sx: a,
              sy: l,
              ox: n.e || 0,
              oy: n.f || 0,
              width: e * a,
              height: e * l
            });
          r.has(s) || r.add(s, h.createVector("pattern", {
            id: s,
            patternUnits: "userSpaceOnUse"
          }, h.createVectors(u)).node);
          const f = r.get(s);
          "function" == typeof c && c(f.childNodes[0], p);
          let g = p.ox % p.width;
          g < 0 && (g += p.width);
          let m = p.oy % p.height;
          m < 0 && (m += p.height), h.attr(f, {
            x: g,
            y: m,
            width: p.width,
            height: p.height
          })
        });
        const o = (new XMLSerializer).serializeToString(r.root),
          s = `url(data:image/svg+xml;base64,${btoa(o)})`;
        this.elem.style.backgroundImage = s
      }
      getInstance() {
        return this.instance || (this.instance = new FA), this.instance
      }
      resolveGrid(t) {
        if (!t) return [];
        const e = t.type;
        if (null == e) return [Object.assign(Object.assign({}, FA.presets.dot), t.args)];
        const n = FA.registry.get(e);
        if (n) {
          let e = t.args || [];
          return Array.isArray(e) || (e = [e]), Array.isArray(n) ? n.map((t, n) => Object.assign(Object.assign({},
            t), e[n])) : [Object.assign(Object.assign({}, n), e[0])]
        }
        return FA.registry.onNotFound(e)
      }
      dispose() {
        this.graph.off("scale", this.update, this), this.graph.off("translate", this.update, this)
      }
    }
    bO([Dk.dispose()], xO.prototype, "dispose", null);
    class wO extends Dk {
      getClientMatrix() {
        return h.createSVGMatrix(this.view.stage.getScreenCTM())
      }
      getClientOffset() {
        const t = this.view.svg.getBoundingClientRect();
        return new hC(t.left, t.top)
      }
      getPageOffset() {
        return this.getClientOffset().translate(window.scrollX, window.scrollY)
      }
      snapToGrid(t, e) {
        return ("number" == typeof t ? this.clientToLocalPoint(t, e) : this.clientToLocalPoint(t.x, t.y)).snapToGrid(
          this.graph.getGridSize())
      }
      localToGraphPoint(t, e) {
        const n = hC.create(t, e);
        return h.transformPoint(n, this.graph.matrix())
      }
      localToClientPoint(t, e) {
        const n = hC.create(t, e);
        return h.transformPoint(n, this.getClientMatrix())
      }
      localToPagePoint(t, e) {
        return ("number" == typeof t ? this.localToGraphPoint(t, e) : this.localToGraphPoint(t)).translate(this
          .getPageOffset())
      }
      localToGraphRect(t, e, n, r) {
        const i = uC.create(t, e, n, r);
        return h.transformRectangle(i, this.graph.matrix())
      }
      localToClientRect(t, e, n, r) {
        const i = uC.create(t, e, n, r);
        return h.transformRectangle(i, this.getClientMatrix())
      }
      localToPageRect(t, e, n, r) {
        return ("number" == typeof t ? this.localToGraphRect(t, e, n, r) : this.localToGraphRect(t)).translate(
          this.getPageOffset())
      }
      graphToLocalPoint(t, e) {
        const n = hC.create(t, e);
        return h.transformPoint(n, this.graph.matrix().inverse())
      }
      clientToLocalPoint(t, e) {
        const n = hC.create(t, e);
        return h.transformPoint(n, this.getClientMatrix().inverse())
      }
      pageToLocalPoint(t, e) {
        const n = hC.create(t, e).diff(this.getPageOffset());
        return this.graphToLocalPoint(n)
      }
      graphToLocalRect(t, e, n, r) {
        const i = uC.create(t, e, n, r);
        return h.transformRectangle(i, this.graph.matrix().inverse())
      }
      clientToLocalRect(t, e, n, r) {
        const i = uC.create(t, e, n, r);
        return h.transformRectangle(i, this.getClientMatrix().inverse())
      }
      pageToLocalRect(t, e, n, r) {
        const i = uC.create(t, e, n, r),
          o = this.getPageOffset();
        return i.x -= o.x, i.y -= o.y, this.graphToLocalRect(i)
      }
    }
    class AO extends Dk {
      constructor() {
        super(...arguments), this.widget = this.graph.hook.createSnapline()
      }
    }! function(t) {
      function e(t) {
        const e = [],
          n = [];
        return Array.isArray(t) ? e.push(...t) : t.split("|").forEach(t => {
          -1 === t.indexOf("&") ? e.push(t) : n.push(...t.split("&"))
        }), {
          or: e,
          and: n
        }
      }
      t.parse = e, t.equals = function(t, n) {
        if (null != t && null != n) {
          const r = e(t),
            i = e(n),
            o = r.or.sort(),
            s = i.or.sort(),
            a = r.and.sort(),
            l = i.and.sort(),
            c = (t, e) => t.length === e.length && (0 === t.length || t.every((t, n) => t === e[n]));
          return c(o, s) && c(a, l)
        }
        return null == t && null == n
      }, t.test = function(t, n) {
        if (null == n) return !0;
        const {
          or: r,
          and: i
        } = e(n);
        return r.some(e => t[`${e.toLowerCase()}Key`]) && i.every(e => t[`${e.toLowerCase()}Key`])
      }
    }(yO || (yO = {}));
    class EO extends Dk {
      get widgetOptions() {
        return this.options.scroller
      }
      get pannable() {
        return this.widgetOptions && !0 === this.widgetOptions.pannable
      }
      init() {
        this.widget = this.graph.hook.createScroller(), this.autoSetCursor(), this.graph.on("blank:mousedown",
            this.preparePanning, this), this.graph.on("node:unhandled:mousedown", this.preparePanning, this),
          this.graph.on("edge:unhandled:mousedown", this.preparePanning, this), this.widget && this.widget.center()
      }
      preparePanning({
        e: t
      }) {
        this.widget && this.pannable && yO.test(t, this.widgetOptions.modifiers) && this.graph.hook.allowPanning(
          t) && this.widget.startPanning(t)
      }
      autoSetCursor() {
        var t;
        const e = this.widgetOptions;
        if (null == e.cursor) {
          const n = e.pannable ? "grab" : "";
          null === (t = this.widget) || void 0 === t || t.setCursor(n, {
            silent: !0
          })
        }
      }
      enablePanning() {
        this.pannable || (this.widgetOptions.pannable = !0, yO.equals(this.graph.options.scroller.modifiers, this
          .graph.options.selecting.modifiers) && this.graph.selection.disableRubberband()), this.autoSetCursor()
      }
      disablePanning() {
        this.pannable && (this.widgetOptions.pannable = !1), this.autoSetCursor()
      }
      lock() {
        this.widget && this.widget.lock()
      }
      unlock() {
        this.widget && this.widget.unlock()
      }
      update() {
        this.widget && this.widget.update()
      }
      setCursor(t) {
        this.widget && this.widget.setCursor(t)
      }
      resize(t, e) {
        this.widget && this.widget.resize(t, e)
      }
    }
    var SO = this && this.__decorate || function(t, e, n, r) {
        var i, o = arguments.length,
          s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r);
        else
          for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) ||
            s);
        return o > 3 && s && Object.defineProperty(e, n, s), s
      },
      MO = this && this.__rest || function(t, e) {
        var n = {};
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
        if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
          var i = 0;
          for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
            .call(t, r[i]) && (n[r[i]] = t[r[i]])
        }
        return n
      };
    class kO extends Dk {
      get commonOptions() {
        const t = this.instanceOptions,
          {
            enabled: e
          } = t;
        return MO(t, ["enabled"])
      }
      get instanceOptions() {
        return this.options.clipboard
      }
      get cells() {
        return this.widget.cells
      }
      get disabled() {
        return !0 !== this.instanceOptions.enabled
      }
      init() {
        this.widget = this.graph.hook.createClipboard(), this.widget.deserialize(this.instanceOptions)
      }
      enable() {
        this.disabled && (this.instanceOptions.enabled = !0)
      }
      disable() {
        this.disabled || (this.instanceOptions.enabled = !1)
      }
      copy(t, e = {}) {
        this.disabled || this.widget.copy(t, this.graph, Object.assign(Object.assign({}, this.commonOptions), e))
      }
      cut(t, e = {}) {
        this.disabled || this.widget.cut(t, this.graph, Object.assign(Object.assign({}, this.commonOptions), e))
      }
      paste(t = {}, e = this.graph) {
        return this.disabled ? [] : this.widget.paste(e, Object.assign(Object.assign({}, this.commonOptions), t))
      }
      clean() {
        this.disabled || this.widget.clean()
      }
      isEmpty() {
        return this.widget.isEmpty()
      }
      dispose() {
        this.clean()
      }
    }
    SO([Dk.dispose()], kO.prototype, "dispose", null);
    class OO extends Dk {
      constructor() {
        super(...arguments), this.highlights = {}
      }
      init() {
        this.graph.on("cell:highlight", ({
          view: t,
          magnet: e,
          options: n
        }) => this.onCellHighlight(t, e, n)), this.graph.on("cell:unhighlight", ({
          view: t,
          magnet: e,
          options: n
        }) => this.onCellUnhighlight(t, e, n))
      }
      onCellHighlight(t, e, n = {}) {
        const r = this.resolveHighlighter(n);
        if (!r) return;
        const i = this.getHighlighterId(e, r);
        if (!this.highlights[i]) {
          const n = r.highlighter;
          n.highlight(t, e, Object.assign({}, r.args)), this.highlights[i] = {
            cellView: t,
            magnet: e,
            highlighter: n,
            args: r.args
          }
        }
      }
      onCellUnhighlight(t, e, n = {}) {
        const r = this.resolveHighlighter(n);
        if (!r) return;
        const i = this.getHighlighterId(e, r),
          o = this.highlights[i];
        o && (o.highlighter.unhighlight(o.cellView, o.magnet, o.args), delete this.highlights[i])
      }
      resolveHighlighter(t) {
        const e = this.options;
        let n = t.highlighter;
        if (null == n) {
          const r = t.type;
          n = r && e.highlighting[r] || e.highlighting.default
        }
        if (null == n) return null;
        const r = "string" == typeof n ? {
            name: n
          } : n,
          i = r.name,
          o = fE.registry.get(i);
        return null == o ? fE.registry.onNotFound(i) : (fE.check(i, o), {
          name: i,
          highlighter: o,
          args: r.args || {}
        })
      }
      getHighlighterId(t, e) {
        return h.ensureId(t), e.name + t.id + JSON.stringify(e.args)
      }
    }
    class PO extends Dk {
      constructor() {
        super(...arguments), this.widgets = new WeakMap
      }
      get container() {
        return this.graph.view.container
      }
      get viewport() {
        return this.graph.view.viewport
      }
      get isSelectionEnabled() {
        return !0 === this.options.selecting.enabled
      }
      init() {
        this.setup(), this.resize()
      }
      setup() {
        this.graph.on("node:mouseup", ({
          node: t
        }) => {
          if (!this.isSelectionEnabled) {
            const e = this.graph.hook.createTransform(t, {
              clearAll: !0
            });
            e && this.widgets.set(t, e)
          }
        }), this.graph.on("node:selected", ({
          node: t
        }) => {
          if (this.isSelectionEnabled) {
            const e = this.graph.hook.createTransform(t, {
              clearAll: !1
            });
            e && this.widgets.set(t, e)
          }
        }), this.graph.on("node:unselected", ({
          node: t
        }) => {
          if (this.isSelectionEnabled) {
            const e = this.widgets.get(t);
            e && e.dispose(), this.widgets.delete(t)
          }
        })
      }
      getMatrix() {
        const t = this.viewport.getAttribute("transform");
        return t !== this.viewportTransformString && (this.viewportMatrix = this.viewport.getCTM(), this.viewportTransformString =
          t), h.createSVGMatrix(this.viewportMatrix)
      }
      setMatrix(t) {
        const e = h.createSVGMatrix(t),
          n = h.matrixToTransformString(e);
        this.viewport.setAttribute("transform", n), this.viewportMatrix = e, this.viewportTransformString = n
      }
      resize(t, e) {
        const n = this.options;
        let r = void 0 === t ? n.width : t,
          i = void 0 === e ? n.height : e;
        n.width = r, n.height = i, "number" == typeof r && (r = Math.round(r)), "number" == typeof i && (i =
            Math.round(i)), this.container.style.width = null == r ? "" : `${r}px`, this.container.style.height =
          null == i ? "" : `${i}px`;
        const o = this.getComputedSize();
        return this.graph.trigger("resize", Object.assign({}, o)), this
      }
      getComputedSize() {
        const t = this.options;
        let e = t.width,
          n = t.height;
        return a.isNumber(e) || (e = this.container.clientWidth), a.isNumber(n) || (n = this.container.clientHeight), {
          width: e,
          height: n
        }
      }
      getScale() {
        return h.matrixToScale(this.getMatrix())
      }
      scale(t, e = t, n = 0, r = 0) {
        if (t = this.clampScale(t), e = this.clampScale(e), n || r) {
          const i = this.getTranslation(),
            o = i.tx - n * (t - 1),
            s = i.ty - r * (e - 1);
          o === i.tx && s === i.ty || this.translate(o, s)
        }
        const i = this.getMatrix();
        return i.a = t, i.d = e, this.setMatrix(i), this.graph.trigger("scale", {
          sx: t,
          sy: e,
          ox: n,
          oy: r
        }), this
      }
      clampScale(t) {
        const e = this.graph.options.scaling;
        return a.clamp(t, e.min || .01, e.max || 16)
      }
      getRotation() {
        return h.matrixToRotation(this.getMatrix())
      }
      rotate(t, e, n) {
        if (null == e || null == n) {
          const t = h.getBBox(this.graph.view.stage);
          e = t.width / 2, n = t.height / 2
        }
        const r = this.getMatrix().translate(e, n).rotate(t).translate(-e, -n);
        return this.setMatrix(r), this
      }
      getTranslation() {
        return h.matrixToTranslation(this.getMatrix())
      }
      translate(t, e) {
        const n = this.getMatrix();
        n.e = t || 0, n.f = e || 0, this.setMatrix(n);
        const r = this.getTranslation(),
          i = this.options;
        return i.x = r.tx, i.y = r.ty, this.graph.trigger("translate", Object.assign({}, r)), this
      }
      setOrigin(t, e) {
        return this.translate(t || 0, e || 0)
      }
      fitToContent(t, e, n, r) {
        if ("object" == typeof t) {
          const i = t;
          t = i.gridWidth || 1, e = i.gridHeight || 1, n = i.padding || 0, r = i
        } else t = t || 1, e = e || 1, n = n || 0, null == r && (r = {});
        const i = a.normalizeSides(n),
          o = r.contentArea ? uC.create(r.contentArea) : this.getContentArea(r),
          s = this.getScale(),
          l = this.getTranslation(),
          c = s.sx,
          h = s.sy;
        o.x *= c, o.y *= h, o.width *= c, o.height *= h;
        let u = Math.max(Math.ceil((o.width + o.x) / t), 1) * t,
          d = Math.max(Math.ceil((o.height + o.y) / e), 1) * e,
          p = 0,
          f = 0;
        ("negative" === r.allowNewOrigin && o.x < 0 || "positive" === r.allowNewOrigin && o.x >= 0 || "any" ===
          r.allowNewOrigin) && (p = Math.ceil(-o.x / t) * t, u += p += i.left), ("negative" === r.allowNewOrigin &&
          o.y < 0 || "positive" === r.allowNewOrigin && o.y >= 0 || "any" === r.allowNewOrigin) && (f = Math.ceil(
          -o.y / e) * e, d += f += i.top), u += i.right, d += i.bottom, u = Math.max(u, r.minWidth || 0), d =
          Math.max(d, r.minHeight || 0), u = Math.min(u, r.maxWidth || Number.MAX_SAFE_INTEGER), d = Math.min(d,
            r.maxHeight || Number.MAX_SAFE_INTEGER);
        const g = this.getComputedSize(),
          m = u !== g.width || d !== g.height;
        return (p !== l.tx || f !== l.ty) && this.translate(p, f), m && this.resize(u, d), new uC(-p / c, -f /
          h, u / c, d / h)
      }
      scaleContentToFit(t = {}) {
        let e;
        if (t.contentArea) {
          const n = t.contentArea;
          e = this.graph.localToGraph(n)
        } else e = this.getContentBBox(t);
        if (!e.width || !e.height) return;
        const n = t.padding || 0,
          r = t.minScale || 0,
          i = t.maxScale || Number.MAX_SAFE_INTEGER,
          o = t.minScaleX || r,
          s = t.maxScaleX || i,
          a = t.minScaleY || r,
          l = t.maxScaleY || i;
        let c;
        if (t.viewportArea) c = t.viewportArea;
        else {
          const t = this.getComputedSize(),
            e = this.getTranslation();
          c = {
            x: e.tx,
            y: e.ty,
            width: t.width,
            height: t.height
          }
        }
        c = uC.create(c).inflate(-n);
        const h = this.getScale();
        let u = c.width / e.width * h.sx,
          d = c.height / e.height * h.sy;
        !1 !== t.preserveAspectRatio && (u = d = Math.min(u, d));
        const p = t.scaleGrid;
        p && (u = p * Math.floor(u / p), d = p * Math.floor(d / p)), u = Math.min(s, Math.max(o, u)), d = Math.min(
          l, Math.max(a, d)), this.scale(u, d)
      }
      getContentArea(t = {}) {
        return t.useCellGeometry ? this.model.getAllCellsBBox() || new uC : h.getBBox(this.graph.view.stage)
      }
      getContentBBox(t = {}) {
        return this.graph.localToGraph(this.getContentArea(t))
      }
      getGraphArea() {
        const t = uC.fromSize(this.getComputedSize());
        return this.graph.graphToLocal(t)
      }
    }
    class DO extends Dk {
      get widgetOptions() {
        return this.options.selecting
      }
      get rubberbandDisabled() {
        return !0 !== this.widgetOptions.enabled || !0 !== this.widgetOptions.rubberband
      }
      get disabled() {
        return !0 !== this.widgetOptions.enabled
      }
      get length() {
        return this.widget.length
      }
      get cells() {
        return this.widget.cells
      }
      init() {
        this.widget = this.graph.hook.createSelection(), this.graph.on("blank:mousedown", ({
          e: t
        }) => {
          !this.rubberbandDisabled && yO.test(t, this.widgetOptions.modifiers) && this.graph.hook.allowRubberband(
            t) ? this.startRubberband(t) : this.clean()
        });
        const t = new Xx;
        this.graph.on("cell:mousemove", ({
          cell: e
        }) => {
          t.set(e, !0)
        }), this.graph.on("cell:mouseup", ({
          e: e,
          cell: n
        }) => {
          const r = this.widgetOptions;
          let i = this.disabled;
          !i && t.has(n) && ((i = !1 === r.selectCellOnMoved) || (i = !1 === r.selectNodeOnMoved && n.isNode()),
            i || (i = !1 === r.selectEdgeOnMoved && n.isEdge())), i || (!1 !== r.multiple && (e.ctrlKey ||
            e.metaKey) || this.clean(), this.select(n)), t.delete(n)
        }), this.widget.on("box:mousedown", ({
          cell: t,
          e: e
        }) => {
          this.disabled || !1 !== this.widgetOptions.multiple && (e.ctrlKey || e.metaKey) && this.unselect(t)
        })
      }
      isEmpty() {
        return this.length <= 0
      }
      isSelected(t) {
        return this.widget.isSelected(t)
      }
      getCells(t) {
        return (Array.isArray(t) ? t : [t]).map(t => "string" == typeof t ? this.graph.getCellById(t) : t).filter(
          t => null != t)
      }
      select(t, e = {}) {
        let n = this.getCells(t);
        return !this.isMultiple() && n.length > 0 && (this.clean(), n.length > 1 && (n = n.slice(0, 1))), this.widget
          .select(n, e), this
      }
      unselect(t, e = {}) {
        return this.widget.unselect(this.getCells(t), e), this
      }
      reset(t) {
        return this.widget.reset(t ? this.getCells(t) : []), this
      }
      clean() {
        return this.widget.clean(), this
      }
      enable() {
        return this.disabled && (this.widgetOptions.enabled = !0), this
      }
      disable() {
        return this.disabled || (this.widgetOptions.enabled = !1), this
      }
      startRubberband(t) {
        return this.rubberbandDisabled || this.widget.startSelecting(t), this
      }
      enableRubberband() {
        return this.rubberbandDisabled && (this.widgetOptions.rubberband = !0, yO.equals(this.graph.options.scroller
          .modifiers, this.graph.options.selecting.modifiers) && this.graph.scroller.disablePanning()), this
      }
      disableRubberband() {
        return this.rubberbandDisabled || (this.widgetOptions.rubberband = !1), this
      }
      isMultiple() {
        return !1 !== this.widgetOptions.multiple
      }
      enableMultiple() {
        return this.widgetOptions.multiple = !0, this
      }
      disableMultiple() {
        return this.widgetOptions.multiple = !1, this
      }
      setModifiers(t) {
        return this.widgetOptions.modifiers = t, this
      }
      setContent(t) {
        return this.widget.setContent(t), this
      }
      setFilter(t) {
        return this.widget.setFilter(t), this
      }
    }
    var TO, _O = this && this.__decorate || function(t, e, n, r) {
        var i, o = arguments.length,
          s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r);
        else
          for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) ||
            s);
        return o > 3 && s && Object.defineProperty(e, n, s), s
      },
      jO = this && this.__rest || function(t, e) {
        var n = {};
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
        if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
          var i = 0;
          for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
            .call(t, r[i]) && (n[r[i]] = t[r[i]])
        }
        return n
      };
    class LO extends Vx {
      constructor(t) {
        super(), this.batchCommands = null, this.batchLevel = 0, this.lastBatchIndex = -1, this.freezed = !1,
          this.handlers = [], this.model = t.graph.model, this.options = TO.getOptions(t), this.validator = new LO
          .Validator({
            history: this,
            cancelInvalid: this.options.cancelInvalid
          }), this.clean(), this.startListening()
      }
      get disabled() {
        return !0 !== this.options.enabled
      }
      enable() {
        this.disabled && (this.options.enabled = !0)
      }
      disable() {
        this.disabled || (this.options.enabled = !1)
      }
      undo(t = {}) {
        if (!this.disabled) {
          const e = this.undoStack.pop();
          e && (this.revertCommand(e, t), this.redoStack.push(e), this.notify("undo", e, t))
        }
        return this
      }
      redo(t = {}) {
        if (!this.disabled) {
          const e = this.redoStack.pop();
          e && (this.applyCommand(e, t), this.undoStack.push(e), this.notify("redo", e, t))
        }
        return this
      }
      cancel(t = {}) {
        if (!this.disabled) {
          const e = this.undoStack.pop();
          e && (this.revertCommand(e, t), this.redoStack = [], this.notify("cancel", e, t))
        }
        return this
      }
      clean(t = {}) {
        return this.undoStack = [], this.redoStack = [], this.notify("clean", null, t), this
      }
      canUndo() {
        return !this.disabled && this.undoStack.length > 0
      }
      canRedo() {
        return !this.disabled && this.redoStack.length > 0
      }
      validate(t, ...e) {
        return this.validator.validate(t, ...e), this
      }
      dispose() {
        this.validator.dispose(), this.clean(), this.stopListening()
      }
      startListening() {
        this.model.on("batch:start", this.initBatchCommand, this), this.model.on("batch:stop", this.storeBatchCommand,
          this), this.options.eventNames && this.options.eventNames.forEach((t, e) => {
          this.handlers[e] = this.addCommand.bind(this, t), this.model.on(t, this.handlers[e])
        }), this.validator.on("invalid", t => this.trigger("invalid", t))
      }
      stopListening() {
        this.model.off("batch:start", this.initBatchCommand, this), this.model.off("batch:stop", this.storeBatchCommand,
          this), this.options.eventNames && (this.options.eventNames.forEach((t, e) => {
          this.model.off(t, this.handlers[e])
        }), this.handlers.length = 0), this.validator.off("invalid")
      }
      createCommand(t) {
        return {
          batch: !!t && t.batch,
          data: {}
        }
      }
      revertCommand(t, e) {
        this.freezed = !0;
        const n = Array.isArray(t) ? TO.sortBatchCommands(t) : [t];
        for (let t = n.length - 1; t >= 0; t -= 1) {
          const r = n[t],
            i = Object.assign(Object.assign({}, e), o.pick(r.options, this.options.revertOptionsList || []));
          this.executeCommand(r, !0, i)
        }
        this.freezed = !1
      }
      applyCommand(t, e) {
        this.freezed = !0;
        const n = Array.isArray(t) ? TO.sortBatchCommands(t) : [t];
        for (let t = 0; t < n.length; t += 1) {
          const r = n[t],
            i = Object.assign(Object.assign({}, e), o.pick(r.options, this.options.applyOptionsList || []));
          this.executeCommand(r, !1, i)
        }
        this.freezed = !1
      }
      executeCommand(t, e, n) {
        const r = this.model,
          i = r.getCell(t.data.id),
          o = t.event;
        if (TO.isAddEvent(o) && e || TO.isRemoveEvent(o) && !e) i.remove(n);
        else if (TO.isAddEvent(o) && !e || TO.isRemoveEvent(o) && e) {
          const e = t.data;
          e.node ? r.addNode(e.props, n) : e.edge && r.addEdge(e.props, n)
        } else if (TO.isChangeEvent(o)) {
          const r = t.data,
            o = r.key;
          if (o) {
            const t = e ? r.prev[o] : r.next[o];
            i.prop(o, t, n)
          }
        } else {
          const r = this.options.executeCommand;
          r && l.call(r, this, t, e, n)
        }
      }
      addCommand(t, e) {
        if (this.freezed || this.disabled) return;
        const n = e,
          r = n.options || {};
        if (r.dryrun) return;
        if (TO.isAddEvent(t) && this.options.ignoreAdd || TO.isRemoveEvent(t) && this.options.ignoreRemove ||
          TO.isChangeEvent(t) && this.options.ignoreChange) return;
        const i = this.options.beforeAddCommand;
        if (null != i && !1 === l.call(i, this, t, e)) return;
        "cell:change:*" === t && (t = `cell:change:${n.key}`);
        const s = n.cell,
          a = s instanceof Ak;
        let c;
        if (this.batchCommands) {
          c = this.batchCommands[Math.max(this.lastBatchIndex, 0)];
          const e = a && !c.modelChange || c.data.id !== s.id,
            n = c.event !== t;
          if (this.lastBatchIndex >= 0 && (e || n)) {
            const e = this.batchCommands.findIndex(e => (a && e.modelChange || e.data.id === s.id) && e.event ===
              t);
            e < 0 || TO.isAddEvent(t) || TO.isRemoveEvent(t) ? c = this.createCommand({
                batch: !0
              }) : (c = this.batchCommands[e], this.batchCommands.splice(e, 1)), this.batchCommands.push(c),
              this.lastBatchIndex = this.batchCommands.length - 1
          }
        } else c = this.createCommand({
          batch: !1
        });
        if (TO.isAddEvent(t) || TO.isRemoveEvent(t)) {
          const e = c.data;
          return c.event = t, c.options = r, e.id = s.id, e.props = o.cloneDeep(s.toJSON()), s.isEdge() ? e.edge = !
            0 : s.isNode() && (e.node = !0), this.push(c, r)
        }
        if (TO.isChangeEvent(t)) {
          const n = e.key,
            i = c.data;
          return c.batch && c.event || (c.event = t, c.options = r, i.key = n, null == i.prev && (i.prev = {}),
              i.prev[n] = o.clone(s.previous(n)), a ? c.modelChange = !0 : i.id = s.id), null == i.next && (i.next = {}),
            i.next[n] = o.clone(s.prop(n)), this.push(c, r)
        }
        const h = this.options.afterAddCommand;
        h && l.call(h, this, t, e, c), this.push(c, r)
      }
      initBatchCommand(t) {
        this.batchCommands ? this.batchLevel += 1 : (this.batchCommands = [this.createCommand({
          batch: !0
        })], this.batchLevel = 0, this.lastBatchIndex = -1)
      }
      storeBatchCommand(t) {
        if (this.batchCommands && this.batchLevel <= 0) {
          const e = this.filterBatchCommand(this.batchCommands);
          0 < e.length && (this.redoStack = [], this.undoStack.push(e), this.notify("add", e, t)), this.batchCommands =
            null, this.lastBatchIndex = -1, this.batchLevel = 0
        } else this.batchCommands && this.batchLevel > 0 && (this.batchLevel -= 1)
      }
      filterBatchCommand(t) {
        let e = t.slice();
        const n = [];
        for (; 0 < e.length;) {
          const t = e.shift(),
            r = t.event,
            i = t.data.id;
          if (null != r && (null != i || t.modelChange)) {
            if (TO.isAddEvent(r)) {
              const t = e.findIndex(t => TO.isRemoveEvent(t.event) && t.data.id === i);
              if (t >= 0) {
                e = e.filter((e, n) => t < n || e.data.id !== i);
                continue
              }
            } else if (TO.isRemoveEvent(r)) {
              const t = e.findIndex(t => TO.isAddEvent(t.event) && t.data.id === i);
              if (t >= 0) {
                e.splice(t, 1);
                continue
              }
            } else if (TO.isChangeEvent(r)) {
              const e = t.data;
              if (o.isEqual(e.prev, e.next)) continue
            }
            n.push(t)
          }
        }
        return n
      }
      notify(t, e, n) {
        const r = null == e ? null : Array.isArray(e) ? e : [e];
        this.emit(t, {
          cmds: r,
          options: n
        }), this.emit("change", {
          cmds: r,
          options: n
        })
      }
      push(t, e) {
        this.redoStack = [], t.batch ? (this.lastBatchIndex = Math.max(this.lastBatchIndex, 0), this.emit(
          "batch", {
            cmd: t,
            options: e
          })) : (this.undoStack.push(t), this.notify("add", t, e))
      }
    }
    _O([Vx.dispose()], LO.prototype, "dispose", null),
      function(t) {
        class e extends Vx {
          constructor(t) {
            super(), this.map = {}, this.command = t.history, this.cancelInvalid = !1 !== t.cancelInvalid, this
              .command.on("add", this.onCommandAdded, this)
          }
          onCommandAdded({
            cmds: t
          }) {
            return Array.isArray(t) ? t.every(t => this.isValidCommand(t)) : this.isValidCommand(t)
          }
          isValidCommand(t) {
            if (t.options && !1 === t.options.validation) return !0;
            let e = null;
            return (t.event && this.map[t.event] || []).forEach(n => {
              let r = 0;
              const i = o => {
                const s = n[r];
                r += 1;
                try {
                  if (!s) return void(e = o);
                  s(o, t, i)
                } catch (o) {
                  i(o)
                }
              };
              i(e)
            }), !e || (this.cancelInvalid && this.command.cancel(), this.emit("invalid", {
              err: e
            }), !1)
          }
          validate(t, ...e) {
            const n = Array.isArray(t) ? t : t.split(/\s+/);
            return e.forEach(t => {
              if ("function" != typeof t) throw new Error(`${n.join(" ")} requires callback functions.`)
            }), n.forEach(t => {
              null == this.map[t] && (this.map[t] = []), this.map[t].push(e)
            }), this
          }
          dispose() {
            this.command.off("add", this.onCommandAdded, this)
          }
        }
        _O([Vx.dispose()], e.prototype, "dispose", null), t.Validator = e
      }(LO || (LO = {})),
      function(t) {
        t.isAddEvent = function(t) {
          return "cell:added" === t
        }, t.isRemoveEvent = function(t) {
          return "cell:removed" === t
        }, t.isChangeEvent = function(t) {
          return null != t && t.startsWith("cell:change:")
        }, t.getOptions = function(e) {
          const {
            graph: n
          } = e, r = jO(e, ["graph"]), i = ["cell:added", "cell:removed", "cell:change:*"], o = ["batch:start",
            "batch:stop"
          ], s = e.eventNames ? e.eventNames.filter(e => !(t.isChangeEvent(e) || i.includes(e) || o.includes(
            e))) : i;
          return Object.assign(Object.assign({}, r), {
            eventNames: s,
            applyOptionsList: e.applyOptionsList || ["propertyPath"],
            revertOptionsList: e.revertOptionsList || ["propertyPath"]
          })
        }, t.sortBatchCommands = function(e) {
          const n = [];
          for (let r = 0, i = e.length; r < i; r += 1) {
            const i = e[r];
            let o = null;
            if (t.isAddEvent(i.event)) {
              const t = i.data.id;
              for (let n = 0; n < r; n += 1)
                if (e[n].data.id === t) {
                  o = n;
                  break
                }
            }
            null !== o ? n.splice(o, 0, i) : n.push(i)
          }
          return n
        }
      }(TO || (TO = {}));
    class NO extends Dk {
      get widgetOptions() {
        return this.options.minimap
      }
      init() {
        this.widget = this.graph.hook.createMiniMap()
      }
    }
    var FO = n("knr3"),
      $O = n.n(FO),
      BO = this && this.__decorate || function(t, e, n, r) {
        var i, o = arguments.length,
          s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r);
        else
          for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) ||
            s);
        return o > 3 && s && Object.defineProperty(e, n, s), s
      };
    class IO extends Ix {
      constructor(t) {
        super(), this.options = t;
        const e = this.graph.scroller.widget;
        this.container = e ? e.container : this.graph.container, t.global ? this.target = document : (this.target =
            this.container, this.disabled || this.target.setAttribute("tabindex", "-1"), this.graph.on(
              "cell:mousedown", this.focus, this), this.graph.on("blank:mousedown", this.focus, this)), this.mousetrap =
          IO.createMousetrap(this)
      }
      get graph() {
        return this.options.graph
      }
      get disabled() {
        return !0 !== this.options.enabled
      }
      enable() {
        this.disabled && (this.options.enabled = !0, this.graph.options.keyboard.enabled = !0, this.target instanceof HTMLElement &&
          this.target.setAttribute("tabindex", "-1"))
      }
      disable() {
        this.disabled || (this.options.enabled = !1, this.graph.options.keyboard.enabled = !1, this.target instanceof HTMLElement &&
          this.target.removeAttribute("tabindex"))
      }
      on(t, e, n) {
        this.mousetrap.bind(this.getKeys(t), e, n)
      }
      off(t, e) {
        this.mousetrap.unbind(this.getKeys(t), e)
      }
      focus() {
        this.target.focus()
      }
      getKeys(t) {
        return (Array.isArray(t) ? t : [t]).map(t => this.formatkey(t))
      }
      formatkey(t) {
        const e = t.toLowerCase().replace(/\s/g, "").replace("delete", "del").replace("cmd", "command"),
          n = this.options.format;
        return n ? l.call(n, this.graph, e) : e
      }
      isGraphEvent(t) {
        const e = t.srcElement || t.target;
        return !!e && (e === this.target || e.parentElement === this.target || h.contains(this.container, e))
      }
      isEnabledForEvent(t) {
        const e = !this.disabled && this.isGraphEvent(t);
        return e && this.options.guard ? l.call(this.options.guard, this.graph, t) : e
      }
      dispose() {
        this.mousetrap.reset()
      }
    }
    BO([Ix.dispose()], IO.prototype, "dispose", null),
      function(t) {
        (IO || (IO = {})).createMousetrap = function(t) {
          const e = new $O.a(t.target),
            n = e.stopCallback;
          return e.stopCallback = ((r, i, o) => !(!t.isEnabledForEvent(r) || !n) && n.call(e, r, i, o)), e
        }
      }();
    var zO = this && this.__decorate || function(t, e, n, r) {
      var i, o = arguments.length,
        s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r);
      else
        for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) ||
          s);
      return o > 3 && s && Object.defineProperty(e, n, s), s
    };
    class RO extends Ix {
      constructor(t) {
        super(), this.options = t, this.cumulatedFactor = 1;
        const e = this.graph.scroller.widget;
        this.container = e ? e.container : this.graph.container, this.target = this.options.global ? document :
          this.container, this.wheelEvent = D.a.isEventSupported("wheel") ? "wheel" : "mousewheel", this.handler =
          this.onMouseWheel.bind(this), this.options.enabled && this.enable(!0)
      }
      get graph() {
        return this.options.graph
      }
      get disabled() {
        return !0 !== this.options.enabled
      }
      enable(t) {
        (this.disabled || t) && (this.options.enabled = !0, this.graph.options.mousewheel.enabled = !0, D.a.SUPPORT_PASSIVE ?
          this.target.addEventListener(this.wheelEvent, this.handler, {
            passive: !1
          }) : P()(this.target).on("mousewheel", this.handler))
      }
      disable() {
        this.disabled || (this.options.enabled = !1, this.graph.options.mousewheel.enabled = !1, D.a.SUPPORT_PASSIVE ?
          this.target.removeEventListener(this.wheelEvent, this.handler) : P()(this.target).off("mousewheel")
        )
      }
      onMouseWheel(t) {
        const e = t.originalEvent || t;
        if (yO.test(e, this.options.modifiers)) {
          t.preventDefault(), t.stopPropagation(), this.frameId && (h.cancelAnimationFrame(this.frameId), this.frameId =
            null);
          const e = this.options.factor || 1.2;
          null == this.currentScale && (this.startPos = {
                x: t.clientX,
                y: t.clientY
              }, this.currentScale = this.graph.scroller.widget ? this.graph.scroller.widget.zoom() : this.graph
              .scale().sx), t.deltaY < 0 ? this.currentScale * this.cumulatedFactor < .15 ? this.cumulatedFactor =
            (this.currentScale + .01) / this.currentScale : this.cumulatedFactor *= e : this.currentScale *
            this.cumulatedFactor <= .15 ? this.cumulatedFactor = (this.currentScale - .01) / this.currentScale :
            this.cumulatedFactor /= e, this.cumulatedFactor = Math.round(this.currentScale * this.cumulatedFactor *
              20) / 20 / this.currentScale, this.cumulatedFactor = Math.max(.01, Math.min(this.currentScale *
              this.cumulatedFactor, 160) / this.currentScale), this.frameId = h.requestAnimationFrame(() => {
              const t = this.graph.scroller.widget,
                e = this.currentScale,
                n = this.graph.transform.clampScale(e * this.cumulatedFactor);
              if (n !== e)
                if (t)
                  if (this.options.zoomAtMousePosition) {
                    const e = this.graph.coord.clientToLocalPoint(this.startPos);
                    t.zoom(n, {
                      absolute: !0,
                      center: e.clone()
                    })
                  } else t.zoom(n, {
                    absolute: !0
                  });
              else if (this.graph.scale(n, n), this.options.zoomAtMousePosition) {
                const t = this.graph.coord.clientToLocalPoint(this.startPos);
                this.graph.translate(t.x * (1 - n), t.y * (1 - n))
              }
              this.frameId = null, this.currentScale = null, this.cumulatedFactor = 1
            })
        }
      }
      dispose() {
        this.disable()
      }
    }
    zO([Ix.dispose()], RO.prototype, "dispose", null);
    class VO extends Dk {
      show(t = {}) {
        const e = Object.assign(Object.assign({}, VO.defaultOptions), t),
          n = this.createPrintPages(e);
        e.ready(n, t => this.showPrintWindow(t, e), {
          sheetSize: this.getSheetSize(e)
        })
      }
      get className() {
        return this.view.prefixClassName("graph-print")
      }
      showPrintWindow(t, e) {
        if (t) {
          const n = P()(document.body),
            r = P()(this.view.container),
            i = this.view.prefixClassName("graph-printing");
          n.addClass(i);
          const o = r.children().detach();
          t.forEach(t => {
            t.removeClass(`${this.className}-preview`).addClass(`${this.className}-ready`).appendTo(n)
          });
          let s = !1;
          const a = () => {
            s || (s = !0, n.removeClass(i), t.forEach(t => t.remove()), r.append(o), P()(
              `#${this.styleSheetId}`).remove(), this.graph.trigger("after:print", e), P()(window).off(
              "afterprint", a))
          };
          P()(window).one("afterprint", a), setTimeout(a, 200), window.print()
        }
      }
      createPrintPage(t, e) {
        this.graph.trigger("before:print", e);
        const n = P()("<div/>").addClass(this.className),
          r = P()("<div/>").addClass(this.view.prefixClassName("graph-print-inner")).css("position", "relative");
        e.size && n.addClass(`${this.className}-size-${e.size}`);
        const i = h.createVector(this.view.svg).clone(),
          o = i.findOne(`.${this.view.prefixClassName("graph-svg-stage")}`);
        r.append(i.node);
        const s = this.getSheetSize(e),
          a = this.graph.transform.getGraphArea(),
          l = this.graph.scale(),
          c = this.graph.translate(),
          u = h.createSVGMatrix().translate(c.tx / l.sx, c.ty / l.sy),
          d = this.getPageInfo(a, t, s),
          p = d.scale,
          f = d.bbox;
        return r.css({
          left: 0,
          top: 0
        }), i.attr({
          width: f.width * p,
          height: f.height * p,
          style: "position:relative",
          viewBox: [f.x, f.y, f.width, f.height].join(" ")
        }), o.attr("transform", h.matrixToTransformString(u)), n.append(r), n.addClass(
          `${this.className}-preview`), {
          $page: n,
          sheetSize: s
        }
      }
      createPrintPages(t) {
        let e;
        const n = this.getPrintArea(t),
          r = [];
        if (t.page) {
          const i = this.getPageSize(n, t.page);
          this.getPageAreas(n, i).forEach(n => {
            e = this.createPrintPage(n, t), r.push(e.$page)
          })
        } else e = this.createPrintPage(n, t), r.push(e.$page);
        if (e) {
          const n = {
            width: e.sheetSize.cssWidth,
            height: e.sheetSize.cssHeight
          };
          this.updatePrintStyle(n, t)
        }
        return r
      }
      get styleSheetId() {
        return this.view.prefixClassName("graph-print-style")
      }
      updatePrintStyle(t, e) {
        const n = Object.keys(t).reduce((e, n) => `${e} ${n}:${t[n]};`, ""),
          r = a.normalizeSides(e.margin),
          i = e.marginUnit || "",
          o = e.sheetUnit || "",
          s =
          `\n      @media print {\n        .${this.className}.${this.className}-ready {\n          ${n}\n        }\n\n        @page {\n          margin:\n          ${[r.top+i,r.right+i,r.bottom+i,r.left+i].join(" ")};\n          size: ${e.sheet.width+o} ${e.sheet.height+o};\n\n        .${this.className}.${this.className}-preview {\n          ${n}\n        }\n      }`,
          l = this.styleSheetId,
          c = P()(`#${l}`);
        c.length ? c.html(s) : P()("head").append(`'<style type="text/css" id="${l}">${s}</style>'`)
      }
      getPrintArea(t) {
        let e = t.area;
        if (!e) {
          const n = a.normalizeSides(t.padding);
          e = this.graph.getContentArea().moveAndExpand({
            x: -n.left,
            y: -n.top,
            width: n.left + n.right,
            height: n.top + n.bottom
          })
        }
        return e
      }
      getPageSize(t, e) {
        if ("object" == typeof e) {
          const n = e,
            r = {
              width: n.width,
              height: n.height
            };
          return null == r.width && (r.width = Math.ceil(t.width / (n.columns || 1))), null == r.height && (r.height =
            Math.ceil(t.height / (n.rows || 1))), r
        }
        return {
          width: t.width,
          height: t.height
        }
      }
      getPageAreas(t, e) {
        const n = [],
          r = e.width,
          i = e.height;
        for (let e = 0, o = 0; e < t.height && o < 200; e += i, o += 1)
          for (let o = 0, s = 0; o < t.width && s < 200; o += r, s += 1) n.push(new uC(t.x + o, t.y + e, r, i));
        return n
      }
      getSheetSize(t) {
        const e = t.sheet,
          n = a.normalizeSides(t.margin),
          r = t.marginUnit || "",
          i = t.sheetUnit || "",
          o = "calc(" + e.width + i + " - " + (n.left + n.right) + r + ")",
          s = "calc(" + e.height + i + " - " + (n.top + n.bottom) + r + ")",
          l = Fx.measure(o, s);
        return {
          cssWidth: o,
          cssHeight: s,
          width: l.width,
          height: l.height
        }
      }
      getPageInfo(t, e, n) {
        const r = new uC(e.x - t.x, e.y - t.y, e.width, e.height),
          i = r.width / r.height,
          o = n.width / n.height;
        return {
          bbox: r,
          scale: o < i ? n.width / r.width : n.height / r.height,
          fitHorizontal: o < i
        }
      }
    }(VO || (VO = {})).defaultOptions = {
      page: !1,
      sheet: {
        width: 210,
        height: 297
      },
      sheetUnit: "mm",
      margin: .4,
      marginUnit: "in",
      padding: 5,
      ready: (t, e) => e(t)
    };
    class HO extends Dk {
      toSVG(t, e = {}) {
        this.graph.trigger("before:export", e);
        const n = this.view.svg,
          r = h.createVector(n).clone();
        let i = r.node;
        const o = r.findOne(`.${this.view.prefixClassName("graph-svg-stage")}`),
          s = e.viewBox || this.graph.graphToLocal(this.graph.getContentBBox()),
          a = e.preserveDimensions;
        if (a) {
          const t = "boolean" == typeof a ? s : a;
          r.attr({
            width: t.width,
            height: t.height
          })
        }
        if (r.removeAttribute("style").attr("viewBox", [s.x, s.y, s.width, s.height].join(" ")), o.removeAttribute(
            "transform"), !1 !== e.copyStyles) {
          const t = n.ownerDocument,
            e = Array.from(n.querySelectorAll("*")),
            r = Array.from(i.querySelectorAll("*")),
            o = t.styleSheets.length,
            s = [];
          for (let e = o - 1; 0 <= e; e -= 1) s[e] = t.styleSheets[e], t.styleSheets[e].disabled = !0;
          const a = {};
          e.forEach((t, e) => {
            const n = window.getComputedStyle(t, null),
              r = {};
            Object.keys(n).forEach(t => {
              r[t] = n.getPropertyValue(t)
            }), a[e] = r
          }), o !== t.styleSheets.length && s.forEach((e, n) => {
            t.styleSheets[n] = e
          });
          for (let e = 0; e < o; e += 1) t.styleSheets[e].disabled = !1;
          const l = {};
          e.forEach((t, e) => {
            const n = window.getComputedStyle(t, null),
              r = a[e],
              i = {};
            Object.keys(n).forEach(t => {
              n.getPropertyValue(t) !== r[t] && (i[t] = n.getPropertyValue(t))
            }), l[e] = i
          }), r.forEach((t, e) => {
            P()(t).css(l[e])
          })
        }
        const c = e.stylesheet;
        if ("string" == typeof c) {
          const t = n.ownerDocument.implementation.createDocument(null, "xml", null).createCDATASection(c);
          r.prepend(h.createVector("style", {
            type: "text/css"
          }, [t]))
        }
        const u = () => {
          const n = e.beforeSerialize;
          if ("function" == typeof n) {
            const t = l.call(n, this.graph, i);
            t instanceof SVGSVGElement && (i = t)
          }
          const r = (new XMLSerializer).serializeToString(i).replace(/&nbsp;/g, " ");
          this.graph.trigger("after:export", e), t(r)
        };
        if (e.serializeImages) {
          const t = r.find("image").map(t => new Promise(e => {
            const n = t.attr("xlink:href") || t.attr("href");
            Hb.imageToDataUri(n, (n, r) => {
              !n && r && t.attr("xlink:href", r), e()
            })
          }));
          Promise.all(t).then(u)
        } else u()
      }
      toDataURL(t, e) {
        let n = e.viewBox || this.graph.graphToLocal(this.graph.getContentBBox());
        const r = a.normalizeSides(e.padding);
        e.width && e.height && (r.left + r.right >= e.width && (r.left = r.right = 0), r.top + r.bottom >= e.height &&
          (r.top = r.bottom = 0));
        const i = new uC(-r.left, -r.top, r.left + r.right, r.top + r.bottom);
        if (e.width && e.height) {
          const t = n.width + r.left + r.right,
            o = n.height + r.top + r.bottom;
          i.scale(t / e.width, o / e.height)
        }
        n = uC.create(n).moveAndExpand(i);
        const o = "number" == typeof e.width && "number" == typeof e.height ? {
          width: e.width,
          height: e.height
        } : n;
        let s = e.ratio ? parseFloat(e.ratio) : 1;
        isFinite(s) && 0 !== s || (s = 1);
        const l = {
          width: Math.max(Math.round(o.width * s), 1),
          height: Math.max(Math.round(o.height * s), 1)
        }; {
          const t = document.createElement("canvas"),
            e = t.getContext("2d");
          t.width = l.width, t.height = l.height;
          const n = l.width - 1,
            r = l.height - 1;
          e.fillStyle = "rgb(1,1,1)", e.fillRect(n, r, 1, 1);
          const i = e.getImageData(n, r, 1, 1).data;
          if (1 !== i[0] || 1 !== i[1] || 1 !== i[2]) throw new Error("size exceeded")
        }
        const c = new Image;
        c.onload = (() => {
          const n = document.createElement("canvas");
          n.width = l.width, n.height = l.height;
          const r = n.getContext("2d");
          r.fillStyle = e.backgroundColor || "white", r.fillRect(0, 0, l.width, l.height);
          try {
            r.drawImage(c, 0, 0, l.width, l.height);
            const i = n.toDataURL(e.type, e.quality);
            t(i)
          } catch (t) {}
        }), this.toSVG(t => {
          c.src = `data:image/svg+xml,${encodeURIComponent(t)}`
        }, Object.assign(Object.assign({}, e), {
          viewBox: n,
          serializeImages: !0,
          preserveDimensions: Object.assign({}, l)
        }))
      }
      toPNG(t, e = {}) {
        this.toDataURL(t, Object.assign(Object.assign({}, e), {
          type: "image/png"
        }))
      }
      toJPEG(t, e = {}) {
        this.toDataURL(t, Object.assign(Object.assign({}, e), {
          type: "image/jpeg"
        }))
      }
    }
    var GO, UO = this && this.__decorate || function(t, e, n, r) {
        var i, o = arguments.length,
          s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r);
        else
          for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) ||
            s);
        return o > 3 && s && Object.defineProperty(e, n, s), s
      },
      qO = this && this.__rest || function(t, e) {
        var n = {};
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
        if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
          var i = 0;
          for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
            .call(t, r[i]) && (n[r[i]] = t[r[i]])
        }
        return n
      };
    ! function(t) {
      t.hook = function(t, e) {
        return (n, r, i) => {
          const o = i.value,
            s = e || r;
          i.value = function(...e) {
            const n = this.options[s];
            if (null != n) {
              this.getNativeValue = o.bind(this, ...e);
              const r = l.call(n, this.graph, ...e);
              if (this.getNativeValue = null, null != r || !0 === t && null === r) return r
            }
            return o.call(this, ...e)
          }
        }
      }, t.after = function(t) {
        return (e, n, r) => {
          const i = r.value,
            o = t || n;
          r.value = function(...t) {
            let e = i.call(this, ...t);
            const n = this.options[o];
            return null != n && (e = l.call(n, this.graph, ...t) && e), e
          }
        }
      }
    }(GO || (GO = {}));
    class WO extends Dk {
      createModel() {
        if (this.options.model) return this.options.model;
        const t = new Ak;
        return t.graph = this.graph, t
      }
      createView() {
        return new jk(this.graph)
      }
      createRenderer() {
        return new gO(this.graph)
      }
      createDefsManager() {
        return new vO(this.graph)
      }
      createGridManager() {
        return new xO(this.graph)
      }
      createCoordManager() {
        return new wO(this.graph)
      }
      createTransform(t, e) {
        const n = this.getTransformOptions(t);
        return n.resizable || n.rotatable ? new cO(Object.assign(Object.assign({
          node: t,
          graph: this.graph
        }, n), e)) : null
      }
      getTransformOptions(t) {
        const e = uO.parseOptionGroup(this.graph, t, this.options.resizing),
          n = uO.parseOptionGroup(this.graph, t, this.options.rotating),
          r = uO.parseOptionGroup(this.graph, t, this.options.transforming);
        return Object.assign(Object.assign({}, r), {
          resizable: e.enabled,
          minWidth: e.minWidth,
          maxWidth: e.maxWidth,
          minHeight: e.minHeight,
          maxHeight: e.maxHeight,
          orthogonalResizing: e.orthogonal,
          preserveAspectRatio: e.preserveAspectRatio,
          rotatable: n.enabled,
          rotateGrid: n.grid
        })
      }
      createTransformManager() {
        return new PO(this.graph)
      }
      createHighlightManager() {
        return new OO(this.graph)
      }
      createBackgroundManager() {
        return new Gk(this.graph)
      }
      createClipboard() {
        return new lO
      }
      createClipboardManager() {
        return new kO(this.graph)
      }
      createSnapline() {
        return new Vk(Object.assign({
          graph: this.graph
        }, this.options.snapline))
      }
      createSnaplineManager() {
        return new AO(this.graph)
      }
      createSelection() {
        return new aO(Object.assign({
          graph: this.graph
        }, this.options.selecting))
      }
      createSelectionManager() {
        return new DO(this.graph)
      }
      allowRubberband(t) {
        return !0
      }
      createHistoryManager() {
        return new LO(Object.assign({
          graph: this.graph
        }, this.options.history))
      }
      createScroller() {
        return this.options.scroller.enabled ? new Xk(Object.assign({
          graph: this.graph
        }, this.options.scroller)) : null
      }
      createScrollerManager() {
        return new EO(this.graph)
      }
      allowPanning(t) {
        return !0
      }
      createMiniMap() {
        const t = this.options.minimap,
          {
            enabled: e
          } = t,
          n = qO(t, ["enabled"]);
        if (e) {
          const t = this.graph.scroller.widget;
          if (null == t) throw new Error("Minimap requires scroller be enabled.");
          return new Ik(Object.assign({
            scroller: t
          }, n))
        }
        return null
      }
      createMiniMapManager() {
        return new NO(this.graph)
      }
      createKeyboard() {
        return new IO(Object.assign({
          graph: this.graph
        }, this.options.keyboard))
      }
      createMouseWheel() {
        return new RO(Object.assign({
          graph: this.graph
        }, this.options.mousewheel))
      }
      createPrintManager() {
        return new VO(this.graph)
      }
      createFormatManager() {
        return new HO(this.graph)
      }
      allowMultiEdges(t) {
        const e = this.options.connecting.multi;
        return "function" != typeof e ? !!e : l.call(e, this.graph, {
          edge: t,
          sourceCell: t.getSourceCell(),
          targetCell: t.getTargetCell(),
          sourcePort: t.getSourcePortId(),
          targetPort: t.getTargetPortId()
        })
      }
      allowDanglingEdge(t) {
        const e = this.options.connecting.dangling;
        return "function" != typeof e ? !!e : l.call(e, this.graph, {
          edge: t,
          sourceCell: t.getSourceCell(),
          targetCell: t.getTargetCell(),
          sourcePort: t.getSourcePortId(),
          targetPort: t.getTargetPortId()
        })
      }
      validateEdge(t, e, n) {
        if (!this.allowMultiEdges(t)) {
          const e = t.getSource(),
            n = t.getTarget();
          if (e.cell && n.cell) {
            const r = t.getSourceCell();
            if (r) {
              if (this.model.getConnectedEdges(r, {
                  outgoing: !0
                }).filter(t => {
                  const r = t.getSource(),
                    i = t.getTarget();
                  return r && r.cell === e.cell && (!r.port || r.port === e.port) && i && i.cell === n.cell &&
                    (!i.port || i.port === n.port)
                }).length > 1) return !1
            }
          }
        }
        if (!this.allowDanglingEdge(t)) {
          const e = t.getSourceCellId(),
            n = t.getTargetCellId();
          if (!e || !n) return !1
        }
        const r = this.options.connecting.validateEdge;
        return !r || l.call(r, this.graph, {
          edge: t,
          type: e,
          previous: n
        })
      }
      validateMagnet(t, e, n) {
        if ("passive" !== e.getAttribute("magnet")) {
          const r = this.options.connecting.validateMagnet;
          return !r || l.call(r, this.graph, {
            e: n,
            magnet: e,
            view: t,
            cell: t.cell
          })
        }
        return !1
      }
      getDefaultEdge(t, e) {
        let n;
        const r = this.options.connecting.createEdge;
        return r && (n = l.call(r, this.graph, {
          sourceMagnet: e,
          sourceView: t,
          sourceCell: t.cell
        })), null == n && (n = new hO), n
      }
      validateConnection(t, e, n, r, i, o) {
        const s = this.options.connecting.validateConnection;
        return !s || l.call(s, this.graph, {
          edgeView: o,
          sourceView: t,
          sourceMagnet: e,
          targetView: n,
          targetMagnet: r,
          sourceCell: t ? t.cell : null,
          targetCell: n ? n.cell : null,
          edge: o ? o.cell : null,
          type: i
        })
      }
      getRestrictArea(t) {
        const e = this.options.translating.restrict;
        return "function" == typeof e ? l.call(e, this.graph, t) : !0 === e ? this.graph.transform.getGraphArea() :
          e || null
      }
      onViewUpdated(t, e, n) {
        e & gO.FLAG_INSERT || n.mounting || this.graph.renderer.requestConnectedEdgesUpdate(t, n)
      }
      onViewPostponed(t, e, n) {
        return this.graph.renderer.forcePostponedViewUpdate(t, e)
      }
      getCellView(t) {
        return null
      }
      createCellView(t) {
        const e = {
            interacting: this.options.interacting
          },
          n = this.getCellView(t);
        if (n) return new n(t, e);
        const r = t.view;
        if (null != r && "string" == typeof r) {
          const n = dS.registry.get(r);
          return n ? new n(t, e) : dS.registry.onNotFound(r)
        }
        return t.isNode() ? new Sk(t, e) : t.isEdge() ? new Ek(t, e) : null
      }
      getHTMLComponent(t) {
        let e = t.getHTML();
        return "string" == typeof e && (e = Pk.componentRegistry.get(e) || e), "function" == typeof e ? l.call(
          e, this.graph, t) : e
      }
      onEdgeLabelRendered(t) {}
      onPortRendered(t) {}
      onToolItemCreated(t) {}
    }
    UO([GO.hook()], WO.prototype, "createModel", null), UO([GO.hook()], WO.prototype, "createView", null), UO([GO
        .hook()
      ], WO.prototype, "createRenderer", null), UO([GO.hook()], WO.prototype, "createDefsManager", null), UO([GO.hook()],
        WO.prototype, "createGridManager", null), UO([GO.hook()], WO.prototype, "createCoordManager", null), UO([
        GO.hook()
      ], WO.prototype, "createTransform", null), UO([GO.hook()], WO.prototype, "createTransformManager", null),
      UO([GO.hook()], WO.prototype, "createHighlightManager", null), UO([GO.hook()], WO.prototype,
        "createBackgroundManager", null), UO([GO.hook()], WO.prototype, "createClipboard", null), UO([GO.hook()],
        WO.prototype, "createClipboardManager", null), UO([GO.hook()], WO.prototype, "createSnapline", null), UO(
        [GO.hook()], WO.prototype, "createSnaplineManager", null), UO([GO.hook()], WO.prototype,
        "createSelection", null), UO([GO.hook()], WO.prototype, "createSelectionManager", null), UO([GO.hook()],
        WO.prototype, "allowRubberband", null), UO([GO.hook()], WO.prototype, "createHistoryManager", null), UO([
        GO.hook()
      ], WO.prototype, "createScroller", null), UO([GO.hook()], WO.prototype, "createScrollerManager", null), UO(
        [GO.hook()], WO.prototype, "allowPanning", null), UO([GO.hook()], WO.prototype, "createMiniMap", null),
      UO([GO.hook()], WO.prototype, "createMiniMapManager", null), UO([GO.hook()], WO.prototype, "createKeyboard",
        null), UO([GO.hook()], WO.prototype, "createMouseWheel", null), UO([GO.hook()], WO.prototype,
        "createPrintManager", null), UO([GO.hook()], WO.prototype, "createFormatManager", null), UO([GO.after()],
        WO.prototype, "onViewUpdated", null), UO([GO.after()], WO.prototype, "onViewPostponed", null), UO([GO.hook()],
        WO.prototype, "getCellView", null), UO([GO.hook(!0)], WO.prototype, "createCellView", null), UO([GO.hook()],
        WO.prototype, "getHTMLComponent", null), UO([GO.hook()], WO.prototype, "onEdgeLabelRendered", null), UO([
        GO.hook()
      ], WO.prototype, "onPortRendered", null), UO([GO.hook()], WO.prototype, "onToolItemCreated", null);
    var XO, YO = this && this.__decorate || function(t, e, n, r) {
      var i, o = arguments.length,
        s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r);
      else
        for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) ||
          s);
      return o > 3 && s && Object.defineProperty(e, n, s), s
    };
    class JO extends Vx {
      constructor(t) {
        super(), this.options = uO.get(t), this.css = new Nk(this), this.hook = new WO(this), this.view = this.hook
          .createView(), this.defs = this.hook.createDefsManager(), this.coord = this.hook.createCoordManager(),
          this.transform = this.hook.createTransformManager(), this.highlight = this.hook.createHighlightManager(),
          this.grid = this.hook.createGridManager(), this.background = this.hook.createBackgroundManager(),
          this.model = this.hook.createModel(), this.renderer = this.hook.createRenderer(), this.clipboard =
          this.hook.createClipboardManager(), this.snapline = this.hook.createSnaplineManager(), this.selection =
          this.hook.createSelectionManager(), this.history = this.hook.createHistoryManager(), this.scroller =
          this.hook.createScrollerManager(), this.minimap = this.hook.createMiniMapManager(), this.keyboard =
          this.hook.createKeyboard(), this.mousewheel = this.hook.createMouseWheel(), this.print = this.hook.createPrintManager(),
          this.format = this.hook.createFormatManager(), this.setup()
      }
      get container() {
        return this.view.container
      }
      setup() {
        this.model.on("sorted", () => this.trigger("model:sorted")), this.model.on("reseted", t => this.trigger(
          "model:reseted", t)), this.model.on("updated", t => this.trigger("model:updated", t))
      }
      isNode(t) {
        return t.isNode()
      }
      isEdge(t) {
        return t.isEdge()
      }
      resetCells(t, e = {}) {
        return this.model.resetCells(t, e), this
      }
      clearCells(t = {}) {
        return this.model.clear(t), this
      }
      toJSON(t = {}) {
        return this.model.toJSON(t)
      }
      parseJSON(t) {
        return this.model.parseJSON(t)
      }
      fromJSON(t, e = {}) {
        return this.model.fromJSON(t, e), this
      }
      getCellById(t) {
        return this.model.getCell(t)
      }
      addNode(t, e = {}) {
        return this.model.addNode(t, e)
      }
      createNode(t) {
        return this.model.createNode(t)
      }
      removeNode(t, e = {}) {
        return this.model.removeCell(t)
      }
      addEdge(t, e = {}) {
        return this.model.addEdge(t, e)
      }
      removeEdge(t, e = {}) {
        return this.model.removeCell(t)
      }
      createEdge(t) {
        return this.model.createEdge(t)
      }
      addCell(t, e = {}) {
        return this.model.addCell(t, e), this
      }
      removeCell(t, e = {}) {
        return this.model.removeCell(t, e)
      }
      removeCells(t, e = {}) {
        return this.model.removeCells(t, e)
      }
      removeConnectedEdges(t, e = {}) {
        return this.model.removeConnectedEdges(t, e)
      }
      disconnectConnectedEdges(t, e = {}) {
        return this.model.disconnectConnectedEdges(t, e), this
      }
      hasCell(t) {
        return this.model.has(t)
      }
      getCell(t) {
        return this.model.getCell(t)
      }
      getCells() {
        return this.model.getCells()
      }
      getCellCount() {
        return this.model.total()
      }
      getNodes() {
        return this.model.getNodes()
      }
      getEdges() {
        return this.model.getEdges()
      }
      getOutgoingEdges(t) {
        return this.model.getOutgoingEdges(t)
      }
      getIncomingEdges(t) {
        return this.model.getIncomingEdges(t)
      }
      getConnectedEdges(t, e = {}) {
        return this.model.getConnectedEdges(t, e)
      }
      getRootNodes() {
        return this.model.getRoots()
      }
      getLeafNodes() {
        return this.model.getLeafs()
      }
      isRootNode(t) {
        return this.model.isRoot(t)
      }
      isLeafNode(t) {
        return this.model.isLeaf(t)
      }
      getNeighbors(t, e = {}) {
        return this.model.getNeighbors(t, e)
      }
      isNeighbor(t, e, n = {}) {
        return this.model.isNeighbor(t, e, n)
      }
      getSuccessors(t, e = {}) {
        return this.model.getSuccessors(t, e)
      }
      isSuccessor(t, e, n = {}) {
        return this.model.isSuccessor(t, e, n)
      }
      getPredecessors(t, e = {}) {
        return this.model.getPredecessors(t, e)
      }
      isPredecessor(t, e, n = {}) {
        return this.model.isPredecessor(t, e, n)
      }
      getCommonAncestor(...t) {
        return this.model.getCommonAncestor(...t)
      }
      getSubGraph(t, e = {}) {
        return this.model.getSubGraph(t, e)
      }
      cloneSubGraph(t, e = {}) {
        return this.model.cloneSubGraph(t, e)
      }
      cloneCells(t) {
        return this.model.cloneCells(t)
      }
      getNodesFromPoint(t, e) {
        return this.model.getNodesFromPoint(t, e)
      }
      getNodesInArea(t, e, n, r, i) {
        return this.model.getNodesInArea(t, e, n, r, i)
      }
      getNodesUnderNode(t, e = {}) {
        return this.model.getNodesUnderNode(t, e)
      }
      searchCell(t, e, n = {}) {
        return this.model.search(t, e, n), this
      }
      getShortestPath(t, e, n = {}) {
        return this.model.getShortestPath(t, e, n)
      }
      getAllCellsBBox() {
        return this.model.getAllCellsBBox()
      }
      getCellsBBox(t, e = {}) {
        return this.model.getCellsBBox(t, e)
      }
      startBatch(t, e = {}) {
        this.model.startBatch(t, e)
      }
      stopBatch(t, e = {}) {
        this.model.stopBatch(t, e)
      }
      batchUpdate(t, e, n) {
        this.startBatch(t, n);
        const r = e();
        return this.stopBatch(t, n), r
      }
      isFrozen() {
        return this.renderer.isFrozen()
      }
      freeze(t = {}) {
        return this.renderer.freeze(t), this
      }
      unfreeze(t = {}) {
        return this.renderer.unfreeze(t), this
      }
      isAsync() {
        return this.renderer.isAsync()
      }
      setAsync(t) {
        return this.renderer.setAsync(t), this
      }
      findView(t) {
        return t instanceof fk ? this.findViewByCell(t) : this.findViewByElem(t)
      }
      findViews(t) {
        return uC.isRectangleLike(t) ? this.findViewsInArea(t) : hC.isPointLike(t) ? this.findViewsFromPoint(t) :
          []
      }
      findViewByCell(t) {
        return this.renderer.findViewByCell(t)
      }
      findViewByElem(t) {
        return this.renderer.findViewByElem(t)
      }
      findViewsFromPoint(t, e) {
        const n = "number" == typeof t ? {
          x: t,
          y: e
        } : t;
        return this.renderer.findViewsFromPoint(n)
      }
      findViewsInArea(t, e, n, r, i) {
        const o = "number" == typeof t ? {
            x: t,
            y: e,
            width: n,
            height: r
          } : t,
          s = "number" == typeof t ? i : e;
        return this.renderer.findViewsInArea(o, s)
      }
      isViewMounted(t) {
        return this.renderer.isViewMounted(t)
      }
      getMountedViews() {
        return this.renderer.getMountedViews()
      }
      getUnmountedViews() {
        return this.renderer.getUnmountedViews()
      }
      matrix(t) {
        return void 0 === t ? this.transform.getMatrix() : (this.transform.setMatrix(t), this)
      }
      resize(t, e) {
        return this.scroller.widget ? this.scroller.resize(t, e) : this.transform.resize(t, e), this
      }
      resizeGraph(t, e) {
        return this.transform.resize(t, e), this
      }
      resizeScroller(t, e) {
        return this.scroller.resize(t, e), this
      }
      scale(t, e = t, n = 0, r = 0) {
        return void 0 === t ? this.transform.getScale() : (this.transform.scale(t, e, n, r), this)
      }
      rotate(t, e, n) {
        return void 0 === t ? this.transform.getRotation() : (this.transform.rotate(t, e, n), this)
      }
      translate(t, e) {
        return void 0 === t ? this.transform.getTranslation() : (this.transform.translate(t, e), this)
      }
      getArea() {
        return this.transform.getGraphArea()
      }
      getContentArea(t = {}) {
        return this.transform.getContentArea(t)
      }
      getContentBBox(t = {}) {
        return this.transform.getContentBBox(t)
      }
      fitToContent(t, e, n, r) {
        return this.transform.fitToContent(t, e, n, r)
      }
      scaleContentToFit(t = {}) {
        return this.transform.scaleContentToFit(t), this
      }
      getClientMatrix() {
        return this.coord.getClientMatrix()
      }
      getClientOffset() {
        return this.coord.getClientOffset()
      }
      getPageOffset() {
        return this.coord.getPageOffset()
      }
      snapToGrid(t, e) {
        return this.coord.snapToGrid(t, e)
      }
      pageToLocal(t, e, n, r) {
        return uC.isRectangleLike(t) ? this.coord.pageToLocalRect(t) : "number" == typeof t && "number" ==
          typeof e && "number" == typeof n && "number" == typeof r ? this.coord.pageToLocalRect(t, e, n, r) :
          this.coord.pageToLocalPoint(t, e)
      }
      localToPage(t, e, n, r) {
        return uC.isRectangleLike(t) ? this.coord.localToPageRect(t) : "number" == typeof t && "number" ==
          typeof e && "number" == typeof n && "number" == typeof r ? this.coord.localToPageRect(t, e, n, r) :
          this.coord.localToPagePoint(t, e)
      }
      clientToLocal(t, e, n, r) {
        return uC.isRectangleLike(t) ? this.coord.clientToLocalRect(t) : "number" == typeof t && "number" ==
          typeof e && "number" == typeof n && "number" == typeof r ? this.coord.clientToLocalRect(t, e, n, r) :
          this.coord.clientToLocalPoint(t, e)
      }
      localToClient(t, e, n, r) {
        return uC.isRectangleLike(t) ? this.coord.localToClientRect(t) : "number" == typeof t && "number" ==
          typeof e && "number" == typeof n && "number" == typeof r ? this.coord.localToClientRect(t, e, n, r) :
          this.coord.localToClientPoint(t, e)
      }
      localToGraph(t, e, n, r) {
        return uC.isRectangleLike(t) ? this.coord.localToGraphRect(t) : "number" == typeof t && "number" ==
          typeof e && "number" == typeof n && "number" == typeof r ? this.coord.localToGraphRect(t, e, n, r) :
          this.coord.localToGraphPoint(t, e)
      }
      graphToLocal(t, e, n, r) {
        return uC.isRectangleLike(t) ? this.coord.graphToLocalRect(t) : "number" == typeof t && "number" ==
          typeof e && "number" == typeof n && "number" == typeof r ? this.coord.graphToLocalRect(t, e, n, r) :
          this.coord.graphToLocalPoint(t, e)
      }
      defineFilter(t) {
        return this.defs.filter(t)
      }
      defineGradient(t) {
        return this.defs.gradient(t)
      }
      defineMarker(t) {
        return this.defs.marker(t)
      }
      getGridSize() {
        return this.grid.getGridSize()
      }
      setGridSize(t) {
        return this.grid.setGridSize(t), this
      }
      showGrid() {
        return this.grid.show(), this
      }
      hideGrid() {
        return this.grid.hide(), this
      }
      clearGrid() {
        return this.grid.clear(), this
      }
      drawGrid(t) {
        return this.grid.draw(t), this
      }
      updateBackground() {
        return this.background.update(), this
      }
      drawBackground(t) {
        return this.background.draw(t), this
      }
      clearBackground() {
        return this.background.clear(), this
      }
      isClipboardEnabled() {
        return !this.clipboard.disabled
      }
      enableClipboard() {
        return this.clipboard.enable(), this
      }
      disableClipboard() {
        return this.clipboard.disable(), this
      }
      toggleClipboard(t) {
        return null != t ? t !== this.isClipboardEnabled() && (t ? this.enableClipboard() : this.disableClipboard()) :
          this.isClipboardEnabled() ? this.disableClipboard() : this.enableClipboard(), this
      }
      isClipboardEmpty() {
        return this.clipboard.isEmpty()
      }
      getCellsInClipboard() {
        return this.clipboard.cells
      }
      cleanClipboard() {
        return this.clipboard.clean(), this
      }
      copy(t, e = {}) {
        return this.clipboard.copy(t, e), this
      }
      cut(t, e = {}) {
        return this.clipboard.cut(t, e), this
      }
      paste(t = {}, e = this) {
        return this.clipboard.paste(t, e)
      }
      isHistoryEnabled() {
        return !this.history.disabled
      }
      enableHistory() {
        return this.history.enable(), this
      }
      disableHistory() {
        return this.history.disable(), this
      }
      toggleHistory(t) {
        return null != t ? t !== this.isHistoryEnabled() && (t ? this.enableHistory() : this.disableHistory()) :
          this.isHistoryEnabled() ? this.disableHistory() : this.enableHistory(), this
      }
      undo(t = {}) {
        return this.history.undo(t), this
      }
      undoAndCancel(t = {}) {
        return this.history.cancel(t), this
      }
      redo(t = {}) {
        return this.history.redo(t), this
      }
      canUndo() {
        return this.history.canUndo()
      }
      canRedo() {
        return this.history.canRedo()
      }
      cleanHistory(t = {}) {
        this.history.clean(t)
      }
      isKeyboardEnabled() {
        return !this.keyboard.disabled
      }
      enableKeyboard() {
        return this.keyboard.enable(), this
      }
      disableKeyboard() {
        return this.keyboard.disable(), this
      }
      toggleKeyboard(t) {
        return null != t ? t !== this.isKeyboardEnabled() && (t ? this.enableKeyboard() : this.disableKeyboard()) :
          this.isKeyboardEnabled() ? this.disableKeyboard() : this.enableKeyboard(), this
      }
      bindKey(t, e, n) {
        return this.keyboard.on(t, e, n), this
      }
      unbindKey(t, e) {
        return this.keyboard.off(t, e), this
      }
      isMouseWheelEnabled() {
        return !this.mousewheel.disabled
      }
      enableMouseWheel() {
        return this.mousewheel.enable(), this
      }
      disableMouseWheel() {
        return this.mousewheel.disable(), this
      }
      toggleMouseWheel(t) {
        return null == t ? this.isMouseWheelEnabled() ? this.disableMouseWheel() : this.enableMouseWheel() : t ?
          this.enableMouseWheel() : this.disableMouseWheel(), this
      }
      lockScroller() {
        var t;
        null === (t = this.scroller.widget) || void 0 === t || t.lock()
      }
      unlockScroller() {
        var t;
        null === (t = this.scroller.widget) || void 0 === t || t.unlock()
      }
      updateScroller() {
        var t;
        null === (t = this.scroller.widget) || void 0 === t || t.update()
      }
      getScrollbarPosition() {
        return this.scroller.widget.scrollbarPosition()
      }
      setScrollbarPosition(t, e, n) {
        return this.scroller.widget.scrollbarPosition(t, e, n), this
      }
      scrollToPoint(t, e, n) {
        return this.scroller.widget.scrollToPoint(t, e, n), this
      }
      scrollToContent(t) {
        return this.scroller.widget.scrollToContent(t), this
      }
      scrollToCell(t, e) {
        return this.scroller.widget.scrollToCell(t, e), this
      }
      center(t) {
        return this.centerPoint(t)
      }
      centerPoint(t, e, n) {
        return this.scroller.widget.centerPoint(t, e, n), this
      }
      centerContent(t) {
        return this.scroller.widget.centerContent(t), this
      }
      centerCell(t, e) {
        return this.scroller.widget.centerCell(t, e), this
      }
      positionContent(t, e) {
        return this.scroller.widget.positionContent(t, e), this
      }
      positionCell(t, e, n) {
        return this.scroller.widget.positionCell(t, e, n), this
      }
      positionRect(t, e, n) {
        return this.scroller.widget.positionRect(t, e, n), this
      }
      positionPoint(t, e, n, r = {}) {
        return this.scroller.widget.positionPoint(t, e, n, r), this
      }
      zoom(t, e) {
        const n = this.scroller.widget;
        return null == t ? n.zoom() : (n.zoom(t, e), this)
      }
      zoomTo(t, e = {}) {
        this.scroller.widget.zoom(t, Object.assign(Object.assign({}, e), {
          absolute: !0
        }))
      }
      zoomToRect(t, e = {}) {
        return this.scroller.widget.zoomToRect(t, e), this
      }
      zoomToFit(t = {}) {
        return this.scroller.widget.zoomToFit(t), this
      }
      transitionToPoint(t, e, n) {
        return this.scroller.widget.transitionToPoint(t, e, n), this
      }
      transitionToRect(t, e = {}) {
        return this.scroller.widget.transitionToRect(t, e), this
      }
      isPannable() {
        return this.scroller.pannable
      }
      enablePanning() {
        return this.scroller.enablePanning(), this
      }
      disablePanning() {
        return this.scroller.disablePanning(), this
      }
      togglePanning(t) {
        return null == t ? this.isPannable() ? this.disablePanning() : this.enablePanning() : t !== this.isPannable() &&
          (t ? this.enablePanning() : this.disablePanning()), this
      }
      isSelectionEnabled() {
        return !this.selection.disabled
      }
      enableSelection() {
        return this.selection.enable(), this
      }
      disableSelection() {
        return this.selection.disable(), this
      }
      toggleSelection(t) {
        return null != t ? t !== this.isSelectionEnabled() && (t ? this.enableSelection() : this.disableSelection()) :
          this.isSelectionEnabled() ? this.disableSelection() : this.enableSelection(), this
      }
      isMultipleSelection() {
        return this.selection.isMultiple()
      }
      enableMultipleSelection() {
        return this.selection.enableMultiple(), this
      }
      disableMultipleSelection() {
        return this.selection.disableMultiple(), this
      }
      toggleMultipleSelection(t) {
        return null != t ? t !== this.isMultipleSelection() && (t ? this.enableMultipleSelection() : this.disableMultipleSelection()) :
          this.isMultipleSelection() ? this.disableMultipleSelection() : this.enableMultipleSelection(), this
      }
      isSelectionMovable() {
        return !1 !== this.selection.widget.options.movable
      }
      enableSelectionMovable() {
        return this.selection.widget.options.movable = !0, this
      }
      disableSelectionMovable() {
        return this.selection.widget.options.movable = !1, this
      }
      toggleSelectionMovable(t) {
        return null != t ? t !== this.isSelectionMovable() && (t ? this.enableSelectionMovable() : this.disableSelectionMovable()) :
          this.isSelectionMovable() ? this.disableSelectionMovable() : this.enableSelectionMovable(), this
      }
      isRubberbandEnabled() {
        return !this.selection.rubberbandDisabled
      }
      enableRubberband() {
        return this.selection.enableRubberband(), this
      }
      disableRubberband() {
        return this.selection.disableRubberband(), this
      }
      toggleRubberband(t) {
        return null != t ? t !== this.isRubberbandEnabled() && (t ? this.enableRubberband() : this.disableRubberband()) :
          this.isRubberbandEnabled() ? this.disableRubberband() : this.enableRubberband(), this
      }
      isStrictRubberband() {
        return !0 === this.selection.widget.options.strict
      }
      enableStrictRubberband() {
        return this.selection.widget.options.strict = !0, this
      }
      disableStrictRubberband() {
        return this.selection.widget.options.strict = !1, this
      }
      toggleStrictRubberband(t) {
        return null != t ? t !== this.isStrictRubberband() && (t ? this.enableStrictRubberband() : this.disableStrictRubberband()) :
          this.isStrictRubberband() ? this.disableStrictRubberband() : this.enableStrictRubberband(), this
      }
      setRubberbandModifiers(t) {
        this.selection.setModifiers(t)
      }
      setSelectionFilter(t) {
        return this.selection.setFilter(t), this
      }
      setSelectionDisplayContent(t) {
        return this.selection.setContent(t), this
      }
      isSelectionEmpty() {
        return this.selection.isEmpty()
      }
      cleanSelection() {
        return this.selection.clean(), this
      }
      resetSelection(t) {
        return this.selection.reset(t), this
      }
      getSelectedCells() {
        return this.selection.cells
      }
      getSelectedCellCount() {
        return this.selection.length
      }
      isSelected(t) {
        return this.selection.isSelected(t)
      }
      select(t, e = {}) {
        return this.selection.select(t, e), this
      }
      unselect(t, e = {}) {
        return this.selection.unselect(t, e), this
      }
      isSnaplineEnabled() {
        return !this.snapline.widget.disabled
      }
      enableSnapline() {
        return this.snapline.widget.enable(), this
      }
      disableSnapline() {
        return this.snapline.widget.disable(), this
      }
      toggleSnapline(t) {
        if (null == t) return this.isSnaplineEnabled() ? this.disableSnapline() : this.enableSnapline(), this;
        t !== this.isSnaplineEnabled() && (t ? this.enableSnapline() : this.disableSnapline())
      }
      hideSnapline() {
        return this.snapline.widget.hide(), this
      }
      setSnaplineFilter(t) {
        return this.snapline.widget.setFilter(t), this
      }
      isSnaplineOnResizingEnabled() {
        return !0 === this.snapline.widget.options.resizing
      }
      enableSnaplineOnResizing() {
        return this.snapline.widget.options.resizing = !0, this
      }
      disableSnaplineOnResizing() {
        return this.snapline.widget.options.resizing = !1, this
      }
      toggleSnaplineOnResizing(t) {
        return null != t ? t !== this.isSnaplineOnResizingEnabled() && (t ? this.enableSnaplineOnResizing() :
            this.disableSnaplineOnResizing()) : this.isSnaplineOnResizingEnabled() ? this.disableSnaplineOnResizing() :
          this.enableSnaplineOnResizing(), this
      }
      isSharpSnapline() {
        return !0 === this.snapline.widget.options.sharp
      }
      enableSharpSnapline() {
        return this.snapline.widget.options.sharp = !0, this
      }
      disableSharpSnapline() {
        return this.snapline.widget.options.sharp = !1, this
      }
      toggleSharpSnapline(t) {
        return null != t ? t !== this.isSharpSnapline() && (t ? this.enableSharpSnapline() : this.disableSharpSnapline()) :
          this.isSharpSnapline() ? this.disableSharpSnapline() : this.enableSharpSnapline(), this
      }
      getSnaplineTolerance() {
        return this.snapline.widget.options.tolerance
      }
      setSnaplineTolerance(t) {
        return this.snapline.widget.options.tolerance = t, this
      }
      removeTools() {
        return this.emit("tools:remove"), this
      }
      hideTools() {
        return this.emit("tools:hide"), this
      }
      showTools() {
        return this.emit("tools:show"), this
      }
      toSVG(t, e = {}) {
        this.format.toSVG(t, e)
      }
      toDataURL(t, e) {
        this.format.toDataURL(t, e)
      }
      toPNG(t, e = {}) {
        this.format.toPNG(t, e)
      }
      toJPEG(t, e = {}) {
        this.format.toJPEG(t, e)
      }
      printPreview(t) {
        this.print.show(t)
      }
      dispose() {
        this.view.dispose(), this.renderer.dispose()
      }
    }
    YO([Tk.checkScroller()], JO.prototype, "lockScroller", null), YO([Tk.checkScroller()], JO.prototype,
        "unlockScroller", null), YO([Tk.checkScroller()], JO.prototype, "updateScroller", null), YO([Tk.checkScroller()],
        JO.prototype, "getScrollbarPosition", null), YO([Tk.checkScroller()], JO.prototype,
        "setScrollbarPosition", null), YO([Tk.checkScroller()], JO.prototype, "scrollToPoint", null), YO([Tk.checkScroller()],
        JO.prototype, "scrollToContent", null), YO([Tk.checkScroller()], JO.prototype, "scrollToCell", null), YO(
        [Tk.checkScroller()], JO.prototype, "centerPoint", null), YO([Tk.checkScroller()], JO.prototype,
        "centerContent", null), YO([Tk.checkScroller()], JO.prototype, "centerCell", null), YO([Tk.checkScroller()],
        JO.prototype, "positionContent", null), YO([Tk.checkScroller()], JO.prototype, "positionCell", null), YO(
        [Tk.checkScroller()], JO.prototype, "positionRect", null), YO([Tk.checkScroller()], JO.prototype,
        "positionPoint", null), YO([Tk.checkScroller()], JO.prototype, "zoom", null), YO([Tk.checkScroller()], JO
        .prototype, "zoomTo", null), YO([Tk.checkScroller()], JO.prototype, "zoomToRect", null), YO([Tk.checkScroller()],
        JO.prototype, "zoomToFit", null), YO([Vx.dispose()], JO.prototype, "dispose", null), (XO = JO || (JO = {}))
      .View = jk, XO.Hook = WO, XO.Renderer = gO, XO.Keyboard = IO, XO.MouseWheel = RO, XO.BaseManager = Dk, XO.DefsManager =
      vO, XO.GridManager = xO, XO.CoordManager = wO, XO.PrintManager = VO, XO.FormatManager = HO, XO.MiniMapManager =
      NO, XO.HistoryManager = LO, XO.SnaplineManager = AO, XO.ScrollerManager = EO, XO.ClipboardManager = kO, XO.TransformManager =
      PO, XO.HighlightManager = OO, XO.BackgroundManager = Gk, XO.SelectionManager = DO,
      function(t) {
        t.render = function(e, n) {
          const r = e instanceof HTMLElement ? new t({
            container: e
          }) : new t(e);
          return null != n && r.fromJSON(n), r
        }
      }(JO || (JO = {})),
      function(t) {
        t.registerNode = yk.registry.register, t.registerEdge = xk.registry.register, t.registerView = dS.registry
          .register, t.registerAttr = DA.registry.register, t.registerGrid = FA.registry.register, t.registerFilter =
          BA.registry.register, t.registerNodeTool = PS.registry.register, t.registerEdgeTool = TS.registry.register,
          t.registerBackground = rE.registry.register, t.registerHighlighter = fE.registry.register, t.registerPortLayout =
          PE.registry.register, t.registerPortLabelLayout = XE.registry.register, t.registerMarker = pA.registry.register,
          t.registerRouter = GM.registry.register, t.registerConnector = ik.registry.register, t.registerAnchor =
          YS.registry.register, t.registerEdgeAnchor = nM.registry.register, t.registerConnectionPoint = hM.registry
          .register, t.registerConnectionStrategy = rS.registry.register, t.registerHTMLComponent = Pk.componentRegistry
          .register
      }(JO || (JO = {})),
      function(t) {
        t.unregisterNode = yk.registry.unregister, t.unregisterEdge = xk.registry.unregister, t.unregisterView =
          dS.registry.unregister, t.unregisterAttr = DA.registry.unregister, t.unregisterGrid = FA.registry.unregister,
          t.unregisterFilter = BA.registry.unregister, t.unregisterNodeTool = PS.registry.unregister, t.unregisterEdgeTool =
          TS.registry.unregister, t.unregisterBackground = rE.registry.unregister, t.unregisterHighlighter = fE.registry
          .unregister, t.unregisterPortLayout = PE.registry.unregister, t.unregisterPortLabelLayout = XE.registry
          .unregister, t.unregisterMarker = pA.registry.unregister, t.unregisterRouter = GM.registry.unregister,
          t.unregisterConnector = ik.registry.unregister, t.unregisterAnchor = YS.registry.unregister, t.unregisterEdgeAnchor =
          nM.registry.unregister, t.unregisterConnectionPoint = hM.registry.unregister, t.unregisterConnectionStrategy =
          rS.registry.unregister, t.unregisterHTMLComponent = Pk.componentRegistry.unregister
      }(JO || (JO = {}));
    var ZO = this && this.__rest || function(t, e) {
      var n = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
          .call(t, r[i]) && (n[r[i]] = t[r[i]])
      }
      return n
    };

    function KO(t) {
      return `basic.${t}`
    }

    function QO(t = "xlink:href") {
      return e => {
        const {
          imageUrl: n,
          imageWidth: r,
          imageHeight: i
        } = e, o = ZO(e, ["imageUrl", "imageWidth", "imageHeight"]);
        if (null != n || null != r || null != i) {
          const e = () => {
            if (o.attrs) {
              const e = o.attrs.image;
              null != n && (e[t] = n), null != r && (e.width = r), null != i && (e.height = i), o.attrs.image =
                e
            }
          };
          o.attrs ? (null == o.attrs.image && (o.attrs.image = {}), e()) : (o.attrs = {
            image: {}
          }, e())
        }
        return o
      }
    }

    function tP(t, e, n = {}) {
      const r = KO(t),
        i = {
          constructorName: r,
          attrs: {
            ".": {
              fill: "#ffffff",
              stroke: "none"
            },
            [t]: {
              fill: "#ffffff",
              stroke: "#000000"
            }
          }
        };
      return n.ignoreMarkup || (i.markup = function(t, e = !1) {
        return `<g class="rotatable"><g class="scalable"><${t}/></g>${e?"":"<text/>"}</g>`
      }(t, !0 === n.noText)), (n.parent || Ok).define(o.merge(i, e, {
        shape: r
      }))
    }
    tP("rect", {
      attrs: {
        rect: {
          width: 100,
          height: 60
        }
      }
    }), tP("circle", {
      width: 60,
      height: 60,
      attrs: {
        circle: {
          r: 30,
          cx: 30,
          cy: 30
        }
      }
    }), tP("ellipse", {
      width: 60,
      height: 40,
      attrs: {
        ellipse: {
          rx: 30,
          ry: 20,
          cx: 30,
          cy: 20
        }
      }
    }), tP("polygon", {
      width: 60,
      height: 40,
      attrs: {
        text: {
          refY: null,
          refDy: 16
        }
      }
    }), tP("polyline", {
      width: 60,
      height: 40,
      attrs: {
        text: {
          refY: null,
          refDy: 16
        }
      }
    }), tP("image", {
      attrs: {
        text: {
          refY: null,
          refDy: 16
        }
      },
      propHooks: QO()
    });
    var eP = this && this.__rest || function(t, e) {
      var n = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
          .call(t, r[i]) && (n[r[i]] = t[r[i]])
      }
      return n
    };
    const nP = tP("path", {
        width: 60,
        height: 60,
        attrs: {
          text: {
            ref: "path",
            refY: null,
            refDy: 16
          }
        },
        propHooks(t) {
          const {
            d: e
          } = t, n = eP(t, ["d"]);
          return null != e && o.setByPath(n, "attrs/path/d", e), n
        }
      }),
      rP = (tP("rhombus", {
        d: "M 30 0 L 60 30 30 60 0 30 z",
        attrs: {
          text: {
            refY: .5,
            refDy: null
          }
        }
      }, {
        parent: nP,
        ignoreMarkup: !0
      }), tP("cylinder", {
        width: 40,
        height: 40,
        attrs: {
          path: {
            fill: "#FFFFFF",
            stroke: "#cbd2d7",
            strokeWidth: 3,
            d: ["M 0 10 C 10 5, 30 5, 40 10 C 30 15, 10 15, 0 10", "L 0 20", "C 10 25, 30 25, 40 20",
              "L 40 10"
            ].join(" ")
          },
          text: {
            refY: .7,
            refDy: null,
            fill: "#435460"
          }
        }
      }, {
        parent: nP,
        ignoreMarkup: !0
      }), KO("text"));
    class iP extends(tP("text", {
      view: rP,
      attrs: {
        text: {
          fontSize: 18,
          fill: "#000000",
          stroke: null,
          refX: .5,
          refY: .5
        }
      }
    }, {
      noText: !0
    })) {}! function(t) {
      class e extends Sk {
        confirmUpdate(t, e = {}) {
          let n = super.confirmUpdate(t, e);
          return this.hasAction(n, "scale") && (this.resize(), n = this.removeAction(n, "scale")), n
        }
      }(iP || (iP = {})).View = e, e.config({
        actions: {
          attrs: ["scale"]
        }
      }), Sk.registry.register(rP, e)
    }();
    const oP = ".text-block-content",
      sP = KO("text-block");
    class aP extends yk {
      get content() {
        return this.getContent()
      }
      set content(t) {
        this.setContent(t)
      }
      getContent() {
        return this.store.get("content", "")
      }
      setContent(t, e = {}) {
        this.store.set("content", t, e)
      }
      setup() {
        super.setup(), this.store.on("change:*", t => {
          const e = t.key;
          "content" === e ? this.updateContent(this.getContent()) : "size" === e && this.updateSize(this.getSize())
        }), this.updateSize(this.getSize()), this.updateContent(this.getContent())
      }
      updateSize(t) {
        D.a.SUPPORT_FOREIGNOBJECT && this.setAttrs({
          foreignObject: Object.assign({}, t),
          [oP]: {
            style: Object.assign({}, t)
          }
        })
      }
      updateContent(t) {
        D.a.SUPPORT_FOREIGNOBJECT ? this.setAttrs({
          [oP]: {
            html: t ? s.sanitizeHTML(t) : ""
          }
        }) : this.setAttrs({
          [oP]: {
            text: t
          }
        })
      }
    }
    var lP;
    (lP = aP || (aP = {})).config({
        type: sP,
        view: sP,
        markup: ['<g class="rotatable">', '<g class="scalable"><rect/></g>', D.a.SUPPORT_FOREIGNOBJECT ? [
          "<foreignObject>", '<body xmlns="http://www.w3.org/1999/xhtml">',
          `<div class="${oP.substr(1)}" />`, "</body>", "</foreignObject>"
        ].join("") : `<text class="${oP.substr(1)}"/>`, "</g>"].join(""),
        attrs: {
          ".": {
            fill: "#ffffff",
            stroke: "none"
          },
          rect: {
            fill: "#ffffff",
            stroke: "#000000",
            width: 80,
            height: 100
          },
          text: {
            fill: "#000000",
            fontSize: 14,
            fontFamily: "Arial, helvetica, sans-serif"
          },
          body: {
            style: {
              background: "transparent",
              position: "static",
              margin: 0,
              padding: 0
            }
          },
          foreignObject: {
            style: {
              overflow: "hidden"
            }
          },
          [oP]: {
            refX: .5,
            refY: .5,
            yAlign: "middle",
            xAlign: "middle",
            style: {
              textAlign: "center",
              verticalAlign: "middle",
              display: "table-cell",
              padding: "0 5px",
              margin: 0
            }
          }
        }
      }), yk.registry.register(sP, lP),
      function(t) {
        const e = "content";
        class n extends Sk {
          confirmUpdate(t, n = {}) {
            let r = super.confirmUpdate(t, n);
            return this.hasAction(r, e) && (this.updateContent(), r = this.removeAction(r, e)), r
          }
          update(t) {
            if (D.a.SUPPORT_FOREIGNOBJECT) super.update(t);
            else {
              const e = this.cell,
                n = Object.assign({}, t || e.getAttrs());
              delete n[oP], super.update(n), t && !o.has(t, oP) || this.updateContent(t)
            }
          }
          updateContent(t) {
            if (D.a.SUPPORT_FOREIGNOBJECT) super.update(t);
            else {
              const e = this.cell,
                n = (t || e.getAttrs())[oP],
                r = h.breakText(e.getContent(), e.getSize(), n, {
                  svgDocument: this.graph.view.svg
                }),
                i = {
                  [oP]: o.merge({}, n, {
                    text: r
                  })
                };
              super.update(i)
            }
          }
        }
        t.View = n,
          function(t) {
            t.config({
              bootstrap: ["render", e],
              actions: D.a.SUPPORT_FOREIGNOBJECT ? {} : {
                size: e,
                content: e
              }
            }), Sk.registry.register(sP, t)
          }(n = t.View || (t.View = {}))
      }(aP || (aP = {}));
    const cP = {
        fill: "#ffffff",
        stroke: "#333333",
        strokeWidth: 2
      },
      hP = {
        fontSize: 14,
        fill: "#333333",
        refX: "50%",
        refY: "50%",
        textAnchor: "middle",
        textVerticalAnchor: "middle"
      };

    function uP(t, e, n = {}) {
      const r = {
        constructorName: t,
        markup: function(t, e = "body") {
          return [{
            tagName: t,
            selector: e
          }, {
            tagName: "text",
            selector: "label"
          }]
        }(t, n.selector),
        attrs: {
          [t]: {
            fill: "#ffffff",
            stroke: "#333333",
            strokeWidth: 2
          }
        }
      };
      return (n.parent || Ok).define(o.merge(r, e, {
        shape: t
      }))
    }
    const dP = uP("rect", {
        attrs: {
          body: {
            refWidth: "100%",
            refHeight: "100%"
          }
        }
      }),
      pP = yk.define({
        shape: "rect-headered",
        markup: [{
          tagName: "rect",
          selector: "body"
        }, {
          tagName: "rect",
          selector: "header"
        }, {
          tagName: "text",
          selector: "headerText"
        }, {
          tagName: "text",
          selector: "bodyText"
        }],
        attrs: {
          body: Object.assign(Object.assign({}, cP), {
            refWidth: "100%",
            refHeight: "100%"
          }),
          header: Object.assign(Object.assign({}, cP), {
            refWidth: "100%",
            height: 30,
            stroke: "#000000"
          }),
          headerText: Object.assign(Object.assign({}, hP), {
            refX: "50%",
            refY: 15,
            fontSize: 16
          }),
          bodyText: Object.assign(Object.assign({}, hP), {
            refY2: 15
          })
        }
      }),
      fP = uP("circle", {
        attrs: {
          body: {
            refCx: "50%",
            refCy: "50%",
            refR: "50%"
          }
        }
      }),
      gP = Ok.define({
        shape: "cylinder",
        markup: [{
          tagName: "path",
          selector: "body"
        }, {
          tagName: "ellipse",
          selector: "top"
        }, {
          tagName: "text",
          selector: "label"
        }],
        attrs: {
          body: Object.assign(Object.assign({}, cP), {
            lateralArea: 10
          }),
          top: Object.assign(Object.assign({}, cP), {
            refCx: "50%",
            refRx: "50%",
            cy: 10,
            ry: 10
          })
        },
        attrHooks: {
          lateralArea: {
            set(t, {
              refBBox: e
            }) {
              const n = a.isPercentage(t);
              n && (t = parseFloat(t) / 100);
              const r = e.x,
                i = e.y,
                o = e.width,
                s = e.height,
                l = n ? s * t : t,
                c = .551784 * (o / 2),
                h = .551784 * l,
                u = r + o / 2,
                d = r + o,
                p = i + l,
                f = p - l,
                g = i + s - l,
                m = i + s;
              return {
                d: ["M", r, p, "L", r, g, "C", r, g + h, u - c, m, u, m, "C", u + c, m, d, g + h, d, g, "L",
                  d, p, "C", d, p - h, u + c, f, u, f, "C", u - c, f, r, p - h, r, p, "Z"
                ].join(" ")
              }
            }
          }
        }
      }),
      mP = uP("ellipse", {
        attrs: {
          body: {
            refCx: "50%",
            refCy: "50%",
            refRx: "50%",
            refRy: "50%"
          }
        }
      });
    var vP = this && this.__rest || function(t, e) {
      var n = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
          .call(t, r[i]) && (n[r[i]] = t[r[i]])
      }
      return n
    };
    class yP extends Ok {
      get points() {
        return this.getPoints()
      }
      set points(t) {
        this.setPoints(t)
      }
      getPoints() {
        return this.getAttrByPath("body/refPoints")
      }
      setPoints(t, e) {
        return null == t ? this.removePoints() : this.setAttrByPath("body/refPoints", yP.pointsToString(t), e),
          this
      }
      removePoints() {
        return this.removeAttrByPath("body/refPoints"), this
      }
    }! function(t) {
      function e(t) {
        return "string" == typeof t ? t : t.map(t => Array.isArray(t) ? t.join(",") : hC.isPointLike(t) ?
          `${t.x}, ${t.y}` : "").join(" ")
      }
      t.pointsToString = e, t.config({
        propHooks(t) {
          const {
            points: n
          } = t, r = vP(t, ["points"]);
          if (n) {
            const t = e(n);
            t && o.setByPath(r, "attrs/body/refPoints", t)
          }
          return r
        }
      })
    }(yP || (yP = {}));
    const bP = uP("polygon", {
        attrs: {
          body: {
            refPoints: "0 0 10 0 10 10 0 10"
          }
        },
        parent: yP
      }),
      CP = uP("polyline", {
        attrs: {
          body: {
            refPoints: "0 0 10 0 10 10 0 10 0 0"
          }
        },
        parent: yP
      });
    var xP = this && this.__rest || function(t, e) {
      var n = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable
          .call(t, r[i]) && (n[r[i]] = t[r[i]])
      }
      return n
    };
    const wP = uP("path", {
      attrs: {
        body: {
          refD: "M 0 0 L 10 0 10 10 0 10 Z"
        }
      }
    });
    wP.config({
      propHooks(t) {
        const {
          path: e
        } = t, n = xP(t, ["path"]);
        return e && o.setByPath(n, "attrs/body/refD", e), n
      }
    });
    const AP = Ok.define({
        shape: "text-block",
        markup: [{
          tagName: "rect",
          selector: "body"
        }, D.a.SUPPORT_FOREIGNOBJECT ? {
          tagName: "foreignObject",
          selector: "foreignObject",
          children: [{
            tagName: "div",
            ns: h.ns.xhtml,
            selector: "label",
            style: {
              width: "100%",
              height: "100%",
              position: "static",
              backgroundColor: "transparent",
              textAlign: "center",
              margin: 0,
              padding: "0px 5px",
              boxSizing: "border-box",
              display: "flex",
              alignItems: "center",
              justifyContent: "center"
            }
          }]
        } : {
          tagName: "text",
          selector: "label",
          attrs: {
            textAnchor: "middle"
          }
        }],
        attrs: {
          body: Object.assign(Object.assign({}, cP), {
            refWidth: "100%",
            refHeight: "100%"
          }),
          foreignObject: {
            refWidth: "100%",
            refHeight: "100%"
          },
          label: {
            style: {
              fontSize: 14
            }
          }
        },
        attrHooks: {
          text: {
            set(t, {
              cell: e,
              view: n,
              refBBox: r,
              elem: i,
              attrs: o
            }) {
              if (!(i instanceof HTMLElement)) {
                const s = o.style || {},
                  a = {
                    text: t,
                    width: -5,
                    height: "100%"
                  },
                  c = Object.assign({
                    textVerticalAnchor: "middle"
                  }, s),
                  h = DA.presets.textWrap;
                return l.call(h.set, this, a, {
                  cell: e,
                  view: n,
                  elem: i,
                  refBBox: r,
                  attrs: c
                }), {
                  fill: s.color || null
                }
              }
              i.textContent = t
            },
            position(t, {
              refBBox: e,
              elem: n
            }) {
              if (n instanceof SVGElement) return e.getCenter()
            }
          }
        }
      }),
      EP = uP("image", {
        attrs: {
          body: {
            refWidth: "100%",
            refHeight: "100%"
          }
        },
        propHooks: QO()
      }, {
        selector: "image"
      }),
      SP = uP("image-bordered", {
        markup: [{
          tagName: "rect",
          selector: "background",
          attrs: {
            stroke: "none"
          }
        }, {
          tagName: "image",
          selector: "image"
        }, {
          tagName: "rect",
          selector: "border",
          attrs: {
            fill: "none"
          }
        }, {
          tagName: "text",
          selector: "label"
        }],
        attrs: {
          background: {
            refWidth: -1,
            refHeight: -1,
            x: .5,
            y: .5,
            fill: "#ffffff"
          },
          border: {
            refWidth: "100%",
            refHeight: "100%",
            stroke: "#333333",
            strokeWidth: 2
          },
          image: {
            refWidth: -1,
            refHeight: -1,
            x: .5,
            y: .5
          }
        },
        propHooks: QO()
      }),
      MP = uP("image-embedded", {
        markup: [{
          tagName: "rect",
          selector: "body"
        }, {
          tagName: "image",
          selector: "image"
        }, {
          tagName: "text",
          selector: "label"
        }],
        attrs: {
          body: {
            refWidth: "100%",
            refHeight: "100%",
            stroke: "#333333",
            fill: "#FFFFFF",
            strokeWidth: 2
          },
          image: {
            refWidth: "30%",
            refHeight: -20,
            x: 10,
            y: 10,
            preserveAspectRatio: "xMidYMin"
          }
        },
        propHooks: QO()
      }),
      kP = uP("image-inscribed", {
        propHooks: QO(),
        markup: [{
          tagName: "ellipse",
          selector: "background"
        }, {
          tagName: "image",
          selector: "image"
        }, {
          tagName: "ellipse",
          selector: "border",
          attrs: {
            fill: "none"
          }
        }, {
          tagName: "text",
          selector: "label"
        }],
        attrs: {
          border: {
            refRx: "50%",
            refRy: "50%",
            refCx: "50%",
            refCy: "50%",
            stroke: "#333333",
            strokeWidth: 2
          },
          background: {
            refRx: "50%",
            refRy: "50%",
            refCx: "50%",
            refCy: "50%",
            fill: "#ffffff"
          },
          image: {
            refWidth: "68%",
            refHeight: "68%",
            refX: "16%",
            refY: "16%",
            preserveAspectRatio: "xMidYMid"
          }
        }
      }),
      OP = xk.define({
        shape: "shadow-edge",
        markup: [{
          tagName: "path",
          selector: "shadow",
          attrs: {
            fill: "none"
          }
        }, {
          tagName: "path",
          selector: "line",
          attrs: {
            fill: "none"
          }
        }],
        attrs: {
          line: {
            connection: !0,
            stroke: "#FF0000",
            strokeWidth: 20,
            strokeLinejoin: "round",
            targetMarker: {
              tagName: "path",
              stroke: "none",
              d: "M 0 -10 -10 0 0 10 z"
            },
            sourceMarker: {
              tagName: "path",
              stroke: "none",
              d: "M -10 -10 0 0 -10 10 0 10 0 -10 z"
            }
          },
          shadow: {
            connection: !0,
            refX: 3,
            refY: 6,
            stroke: "#000000",
            strokeOpacity: .2,
            strokeWidth: 20,
            strokeLinejoin: "round",
            targetMarker: {
              tagName: "path",
              d: "M 0 -10 -10 0 0 10 z",
              stroke: "none"
            },
            sourceMarker: {
              tagName: "path",
              stroke: "none",
              d: "M -10 -10 0 0 -10 10 0 10 0 -10 z"
            }
          }
        }
      }),
      PP = xk.define({
        shape: "double-edge",
        markup: [{
          tagName: "path",
          selector: "outline",
          attrs: {
            fill: "none"
          }
        }, {
          tagName: "path",
          selector: "line",
          attrs: {
            fill: "none"
          }
        }],
        attrs: {
          line: {
            connection: !0,
            stroke: "#dddddd",
            strokeWidth: 4,
            strokeLinejoin: "round",
            targetMarker: {
              tagName: "path",
              stroke: "#000000",
              d: "M 10 -3 10 -10 -2 0 10 10 10 3"
            }
          },
          outline: {
            connection: !0,
            stroke: "#000000",
            strokeWidth: 6,
            strokeLinejoin: "round"
          }
        }
      });
    var DP, TP, _P, jP, LP, NP = this && this.__decorate || function(t, e, n, r) {
      var i, o = arguments.length,
        s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r);
      else
        for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) ||
          s);
      return o > 3 && s && Object.defineProperty(e, n, s), s
    };
    class FP extends Hx {
      constructor(t) {
        super(), this.delay = 10, this.throttle = 2, this.threshold = 5, this.changeCount = 0, this.timestamp =
          0, this.options = Object.assign(Object.assign({}, FP.defaultOptions), t), this.graph.model.on(
            "cell:change:*", this.onModelChanged, this)
      }
      get graph() {
        return this.options.graph
      }
      onModelChanged() {
        if (this.disabled) return;
        const t = ((new Date).getTime() - this.timestamp) / 1e3;
        t > this.delay || this.changeCount >= this.threshold && t > this.throttle ? (this.save(), this.reset()) :
          this.changeCount += 1
      }
      save() {
        this.trigger("save")
      }
      reset() {
        this.changeCount = 0, this.timestamp = (new Date).getTime()
      }
      dispose() {
        this.graph.model.off("cell:change:*", this.onModelChanged, this)
      }
    }
    NP([Hx.dispose()], FP.prototype, "dispose", null),
      function(t) {
        t.defaultOptions = {
          delay: 10,
          throttle: 2,
          threshold: 5
        }
      }(FP || (FP = {}));
    class $P {
      constructor(t) {
        this.halo = t
      }
      get options() {
        return this.halo.options
      }
      get graph() {
        return this.halo.graph
      }
      get model() {
        return this.halo.model
      }
      get view() {
        return this.halo.view
      }
      get cell() {
        return this.halo.cell
      }
      get node() {
        return this.cell
      }
      getPresets() {
        return {
          className: "type-node",
          handles: [{
            name: "remove",
            position: "nw",
            events: {
              mousedown: this.removeCell.bind(this)
            },
            icon: null
          }, {
            name: "resize",
            position: "se",
            events: {
              mousedown: this.startResize.bind(this),
              mousemove: this.doResize.bind(this),
              mouseup: ({
                e: t
              }) => {
                if (this.halo.stopBatch(), this.resized) {
                  this.resized = !1, Yk("node:resized", t, this.view)
                }
              }
            },
            icon: null
          }, {
            name: "clone",
            position: "n",
            events: {
              mousedown: this.startClone.bind(this),
              mousemove: this.doClone.bind(this),
              mouseup: this.stopClone.bind(this)
            },
            icon: null
          }, {
            name: "link",
            position: "e",
            events: {
              mousedown: this.startLink.bind(this),
              mousemove: this.doLink.bind(this),
              mouseup: this.stopLink.bind(this)
            },
            icon: null
          }, {
            name: "fork",
            position: "ne",
            events: {
              mousedown: this.startFork.bind(this),
              mousemove: this.doFork.bind(this),
              mouseup: this.stopFork.bind(this)
            },
            icon: null
          }, {
            name: "unlink",
            position: "w",
            events: {
              mousedown: this.unlink.bind(this)
            },
            icon: null
          }, {
            name: "rotate",
            position: "sw",
            events: {
              mousedown: this.startRotate.bind(this),
              mousemove: this.doRotate.bind(this),
              mouseup: ({
                e: t
              }) => {
                if (this.halo.stopBatch(), this.rotated) {
                  this.rotated = !1, this.halo.getEventData(t).nodes.forEach(e => {
                    Yk("node:rotated", t, this.graph.findViewByCell(e))
                  })
                }
              }
            },
            icon: null
          }],
          bbox(t) {
            if (this.options.useCellGeometry) {
              return t.cell.getBBox()
            }
            return t.getBBox()
          },
          content(t) {
            const e = s.template(
                "x: <%= x %>, y: <%= y %>, width: <%= width %>, height: <%= height %>, angle: <%= angle %>"),
              n = t.cell,
              r = n.getBBox();
            return e({
              x: Math.floor(r.x),
              y: Math.floor(r.y),
              width: Math.floor(r.width),
              height: Math.floor(r.height),
              angle: Math.floor(n.getAngle())
            })
          },
          magnet: t => t.container,
          tinyThreshold: 40,
          smallThreshold: 80,
          loopEdgePreferredSide: "top",
          loopEdgeWidth: 40,
          rotateGrid: 15,
          rotateEmbeds: !1
        }
      }
      removeCell() {
        this.model.removeConnectedEdges(this.cell), this.cell.remove()
      }
      startLink({
        x: t,
        y: e
      }) {
        this.halo.startBatch();
        const n = this.graph,
          r = this.createEdgeConnectedToSource();
        r.setTarget({
          x: t,
          y: e
        }), this.model.addEdge(r, {
          validation: !1,
          halo: this.halo.cid,
          async: !1
        }), n.view.undelegateEvents(), this.edgeView = n.renderer.findViewByCell(r), this.edgeView.prepareArrowheadDragging(
          "target", {
            fallbackAction: "remove"
          })
      }
      createEdgeConnectedToSource() {
        const t = this.getMagnet(this.view, "source"),
          e = this.getEdgeTerminal(this.view, t),
          n = this.graph.hook.getDefaultEdge(this.view, t);
        return n.setSource(e), n
      }
      getMagnet(t, e) {
        const n = this.options.magnet;
        if ("function" == typeof n) {
          const r = l.call(n, this.halo, t, e);
          if (r instanceof SVGElement) return r
        }
        throw new Error("`magnet()` has to return an SVGElement")
      }
      getEdgeTerminal(t, e) {
        const n = {
          cell: t.cell.id
        };
        if (e !== t.container) {
          const r = e.getAttribute("port");
          r ? n.port = r : n.selector = t.getSelector(e)
        }
        return n
      }
      doLink({
        e: t,
        x: e,
        y: n
      }) {
        this.edgeView && this.edgeView.onMouseMove(t, e, n)
      }
      stopLink({
        e: t,
        x: e,
        y: n
      }) {
        const r = this.edgeView;
        if (r) {
          r.onMouseUp(t, e, n);
          const i = r.cell;
          i.hasLoop() && this.makeLoopEdge(i), this.halo.stopBatch(), this.halo.trigger("action:edge:addde", {
            edge: i
          }), this.edgeView = null
        }
        this.graph.view.delegateEvents()
      }
      makeLoopEdge(t) {
        let e = null,
          n = null;
        const r = this.options.loopEdgeWidth,
          i = this.graph.options,
          o = new uC(0, 0, i.width, i.height),
          s = this.graph.graphToLocal(this.view.getBBox());
        [this.options.loopEdgePreferredSide, "top", "bottom", "left", "right"].some(t => {
          let i = null,
            a = 0,
            l = 0;
          switch (t) {
            case "top":
              i = new hC(s.x + s.width / 2, s.y - r), a = r / 2;
              break;
            case "bottom":
              i = new hC(s.x + s.width / 2, s.y + s.height + r), a = r / 2;
              break;
            case "left":
              i = new hC(s.x - r, s.y + s.height / 2), l = r / 2;
              break;
            case "right":
              i = new hC(s.x + s.width + r, s.y + s.height / 2), l = r / 2
          }
          if (i) return e = i.translate(-a, -l), n = i.translate(a, l), o.containsPoint(e) && o.containsPoint(
            n)
        }) && e && n && t.setVertices([e, n])
      }
      startResize() {
        this.halo.startBatch(), this.flip = [1, 0, 0, 1, 1, 0, 0, 1][Math.floor(nC.normalize(this.node.getAngle()) /
          45)]
      }
      doResize({
        dx: t,
        dy: e
      }) {
        const n = this.node.getSize(),
          r = Math.max(n.width + (this.flip ? t : e), 1),
          i = Math.max(n.height + (this.flip ? e : t), 1);
        this.resized = !0, this.node.resize(r, i, {
          absolute: !0
        })
      }
      startClone({
        e: t,
        x: e,
        y: n
      }) {
        this.halo.startBatch();
        const r = this.options.clone(this.cell, {
          clone: !0
        });
        if (!(r instanceof fk)) throw new Error("option 'clone()' has to return a cell");
        this.centerNodeAtCursor(r, e, n), this.model.addCell(r, {
          halo: this.halo.cid,
          async: !1
        });
        const i = this.graph.renderer.findViewByCell(r);
        i.onMouseDown(t, e, n), this.halo.setEventData(t, {
          cloneView: i
        })
      }
      centerNodeAtCursor(t, e, n) {
        const r = t.getBBox().getCenter(),
          i = e - r.x,
          o = n - r.y;
        t.translate(i, o)
      }
      doClone({
        e: t,
        x: e,
        y: n
      }) {
        const r = this.halo.getEventData(t).cloneView;
        r && r.onMouseMove(t, e, n)
      }
      stopClone({
        e: t,
        x: e,
        y: n
      }) {
        const r = this.halo.getEventData(t).cloneView;
        r && r.onMouseUp(t, e, n), this.halo.stopBatch()
      }
      startFork({
        e: t,
        x: e,
        y: n
      }) {
        this.halo.startBatch();
        const r = this.options.clone(this.cell, {
          fork: !0
        });
        if (!(r instanceof fk)) throw new Error("option 'clone()' has to return a cell");
        this.centerNodeAtCursor(r, e, n), this.model.addCell(r, {
          halo: this.halo.cid,
          async: !1
        });
        const i = this.createEdgeConnectedToSource(),
          o = this.graph.renderer.findViewByCell(r),
          s = this.getMagnet(o, "target"),
          a = this.getEdgeTerminal(o, s);
        i.setTarget(a), this.model.addEdge(i, {
          halo: this.halo.cid,
          async: !1
        }), o.onMouseDown(t, e, n), this.halo.setEventData(t, {
          cloneView: o
        })
      }
      doFork({
        e: t,
        x: e,
        y: n
      }) {
        const r = this.halo.getEventData(t).cloneView;
        r && r.onMouseMove(t, e, n)
      }
      stopFork({
        e: t,
        x: e,
        y: n
      }) {
        const r = this.halo.getEventData(t).cloneView;
        r && r.onMouseUp(t, e, n), this.halo.stopBatch()
      }
      startRotate({
        e: t,
        x: e,
        y: n
      }) {
        this.halo.startBatch();
        const r = this.node.getBBox().getCenter(),
          i = [this.node];
        this.options.rotateEmbeds && this.node.getDescendants({
          deep: !0
        }).reduce((t, e) => (e.isNode() && t.push(e), t), i), this.halo.setEventData(t, {
          center: r,
          nodes: i,
          rotateStartAngles: i.map(t => t.getAngle()),
          clientStartAngle: new hC(e, n).theta(r)
        })
      }
      doRotate({
        e: t,
        x: e,
        y: n
      }) {
        const r = this.halo.getEventData(t),
          i = r.clientStartAngle - new hC(e, n).theta(r.center);
        this.rotated = !0, r.nodes.forEach((t, e) => {
          const n = r.rotateStartAngles[e],
            o = oE.snapToGrid(n + i, this.options.rotateGrid);
          t.rotate(o, {
            absolute: !0,
            center: r.center,
            halo: this.halo.cid
          })
        })
      }
      unlink() {
        this.halo.startBatch(), this.model.removeConnectedEdges(this.cell), this.halo.stopBatch()
      }
    }
    class BP {
      constructor(t) {
        this.halo = t
      }
      get options() {
        return this.halo.options
      }
      get graph() {
        return this.halo.graph
      }
      get model() {
        return this.halo.model
      }
      get view() {
        return this.halo.view
      }
      get cell() {
        return this.halo.cell
      }
      get edge() {
        return this.cell
      }
      getPresets() {
        return {
          className: "type-edge",
          handles: [{
            name: "remove",
            position: "nw",
            icon: null,
            events: {
              mousedown: this.removeEdge.bind(this)
            }
          }, {
            name: "direction",
            position: "se",
            icon: null,
            events: {
              mousedown: this.directionSwap.bind(this)
            }
          }],
          content: !1,
          bbox: t => t.graph.localToGraph(t.getPointAtRatio(.5)),
          tinyThreshold: -1,
          smallThreshold: -1
        }
      }
      removeEdge() {
        this.cell.remove()
      }
      directionSwap() {
        const t = this.edge.getSource(),
          e = this.edge.getTarget();
        this.edge.prop({
          source: e,
          target: t
        })
      }
    }
    class IP extends sO {
      get type() {
        return this.options.type || "surround"
      }
      get handleOptions() {
        return this.options
      }
      init(t) {
        this.options = o.merge(IP.defaultOptions, this.cell.isNode() ? new $P(this).getPresets() : this.cell.isEdge() ?
          new BP(this).getPresets() : null, t), this.render(), this.initHandles(), this.update(), this.startListening()
      }
      startListening() {
        const t = this.model,
          e = this.graph;
        this.view.cell.on("removed", this.remove, this), t.on("reseted", this.remove, this), e.on("halo:destroy",
          this.remove, this), t.on("*", this.update, this), e.on("scale", this.update, this), e.on("translate",
          this.update, this), super.startListening()
      }
      stopListening() {
        const t = this.model,
          e = this.graph,
          n = this.view.cell;
        this.undelegateEvents(), n.off("removed", this.remove, this), t.off("reseted", this.remove, this), e.off(
            "halo:destroy", this.remove, this), t.off("*", this.update, this), e.off("scale", this.update, this),
          e.off("translate", this.update, this), super.stopListening()
      }
      render() {
        const t = this.options,
          e = this.prefixClassName("widget-halo");
        return this.container = document.createElement("div"), this.$container = this.$(this.container).addClass(
            e).attr("data-shape", this.view.cell.shape), t.className && this.$container.addClass(t.className),
          this.$handleContainer = this.$("<div/>").addClass(`${e}-handles`).appendTo(this.container), this.$content =
          this.$("<div/>").addClass(`${e}-content`).appendTo(this.container), this.$container.appendTo(this.graph
            .container), this
      }
      remove() {
        return this.stopBatch(), super.remove()
      }
      update() {
        if (this.isRendered()) {
          this.updateContent();
          const t = this.getBBox(),
            e = this.options.tinyThreshold || 0,
            n = this.options.smallThreshold || 0;
          this.$handleContainer.toggleClass(`${this.handleClassName}-tiny`, t.width < e && t.height < e);
          const r = `${this.handleClassName}-small`;
          this.$handleContainer.toggleClass(r, !this.$handleContainer.hasClass(r) && t.width < n && t.height < n),
            this.$container.css({
              width: t.width,
              height: t.height,
              left: t.x,
              top: t.y
            }), this.hasHandle("unlink") && this.toggleUnlink(), "surround" !== this.type && "toolbar" !== this.type ||
            this.hasHandle("fork") && this.toggleFork()
        }
      }
      updateContent() {
        const t = this.options.content;
        if ("function" == typeof t) {
          const e = l.call(t, this, this.view, this.$content[0]);
          e && this.$content.html(e)
        } else t ? this.$content.html(t) : this.$content.remove()
      }
      getBBox() {
        const t = this.view,
          e = this.options.bbox,
          n = "function" == typeof e ? l.call(e, this, t) : e;
        return uC.create(Object.assign({
          x: 0,
          y: 0,
          width: 1,
          height: 1
        }, n))
      }
      removeCell() {
        this.cell.remove()
      }
      toggleFork() {
        const t = this.view.cell.clone(),
          e = this.graph.hook.createCellView(t),
          n = this.graph.hook.validateConnection(this.view, null, e, null, "target");
        this.$handleContainer.children(".fork").toggleClass("hidden", !n), e.remove()
      }
      toggleUnlink() {
        const t = this.model.getConnectedEdges(this.view.cell).length > 0;
        this.$handleContainer.children(".unlink").toggleClass("hidden", !t)
      }
      startBatch() {
        this.model.startBatch("halo", {
          halo: this.cid
        })
      }
      stopBatch() {
        this.model.hasActiveBatch("halo") && this.model.stopBatch("halo", {
          halo: this.cid
        })
      }
    }(IP || (IP = {})).defaultOptions = {
      type: "surround",
      clearAll: !0,
      clearOnBlankMouseDown: !0,
      useCellGeometry: !1,
      clone: t => t.clone().removeZIndex()
    }, Object.getOwnPropertyNames(Qk.prototype).forEach(t => {
      "constructor" !== t && Object.defineProperty(IP.prototype, t, Object.getOwnPropertyDescriptor(Qk.prototype,
        t))
    });
    class zP extends ZE {
      constructor(t) {
        super(), this.MOVEMENT_DETECTION_THRESHOLD = 150, this.options = o.merge({}, zP.defaultOptions, t),
          this.action = "awaiting-input", this.render(), this.startListening()
      }
      get vel() {
        return h.createVector(this.container)
      }
      render() {
        const t = this.options;
        return this.container = h.createSvgElement("g"), h.addClass(this.container, this.prefixClassName(
            "path-drawer")), this.pathTemplate = h.createSvgElement("path"), h.attr(this.pathTemplate, t.pathAttributes),
          this.startPointElement = h.createVector(t.startPointMarkup).addClass("start-point").node, this.controlElement =
          h.createSvgElement("path"), h.addClass(this.controlElement, "control-path"), h.createVector("rect", {
            x: 0,
            y: 0,
            width: "100%",
            height: "100%",
            fill: "transparent",
            stroke: "none"
          }).appendTo(this.container), this.options.target.appendChild(this.container), this
      }
      onRemove() {
        this.remove(this.pathElement), this.clear(), this.stopListening()
      }
      startListening() {
        this.delegateEvents({
          mousedown: "onMouseDown",
          touchstart: "onMouseDown",
          dblclick: "onDoubleClick",
          contextmenu: "onContextMenu",
          "mousedown .start-point": "onStartPointMouseDown",
          "touchstart .start-point": "onStartPointMouseDown"
        })
      }
      stopListening() {
        this.undelegateEvents()
      }
      clear() {
        const t = this.pathElement;
        t && t.pathSegList.numberOfItems <= 1 && this.remove(t), this.startPointElement.remove(), this.controlElement
          .remove(), this.undelegateDocumentEvents(), this.action = "awaiting-input", this.emit("clear")
      }
      createPath(t, e) {
        this.pathElement = this.pathTemplate.cloneNode(!0), this.addMoveSegment(t, e), h.translate(this.startPointElement,
          t, e, {
            absolute: !0
          }), this.vel.before(this.pathElement), this.vel.append(this.startPointElement), this.emit(
          "path:create", {
            path: this.pathElement
          })
      }
      closePath() {
        const t = this.pathElement,
          e = this.getPathSeg(t, 0),
          n = this.getPathSeg(t, -1);
        n.pathSegType === SVGPathSeg.PATHSEG_LINETO_ABS ? t.pathSegList.replaceItem(t.createSVGPathSegClosePath(),
            t.pathSegList.numberOfItems - 1) : (n.x = e.x, n.y = e.y, t.pathSegList.appendItem(t.createSVGPathSegClosePath())),
          this.finishPath("path:close")
      }
      finishPath(t) {
        const e = this.pathElement;
        e && 0 < this.numberOfVisibleSegments() ? (this.emit("path:finish", {
          path: e
        }), this.trigger(t, {
          path: e
        })) : this.emit("path:abort", {
          path: e
        }), this.clear()
      }
      numberOfVisibleSegments() {
        const t = this.pathElement;
        let e = t.pathSegList.numberOfItems;
        return e -= 1, this.getPathSeg(t, -1).pathSegType === SVGPathSeg.PATHSEG_CLOSEPATH && (e -= 1), e
      }
      addMoveSegment(t, e) {
        const n = this.pathElement,
          r = n.createSVGPathSegMovetoAbs(t, e);
        n.pathSegList.appendItem(r), this.emit("path:segment:add", {
          path: n
        }), this.emit("path:move-segment:add", {
          path: n
        })
      }
      addLineSegment(t, e) {
        const n = this.pathElement,
          r = n.createSVGPathSegLinetoAbs(t, e);
        n.pathSegList.appendItem(r), this.emit("path:segment:add", {
          path: n
        }), this.emit("path:line-segment:add", {
          path: n
        })
      }
      addCurveSegment(t, e, n, r, i, o) {
        const s = this.pathElement,
          a = s.createSVGPathSegCurvetoCubicAbs(t, e, n, r, i || t, o || e);
        s.pathSegList.appendItem(a), this.emit("path:segment:add", {
          path: s
        }), this.emit("path:curve-segment:add", {
          path: s
        })
      }
      adjustLastSegment(t, e, n, r, i, o) {
        const s = this.pathElement,
          a = this.options.snapRadius;
        if (a && null != t && null != e) {
          const n = this.snapLastSegmentCoordinates(t, e, a);
          t = n.x, e = n.y
        }
        const l = this.getPathSeg(s, -1);
        null != t && (l.x = t), null != e && (l.y = e), null != n && (l.x1 = n), null != r && (l.y1 = r), null !=
          i && (l.x2 = i), null != o && (l.y2 = o), this.emit("path:edit", {
            path: s
          }), this.emit("path:last-segment:adjust", {
            path: s
          })
      }
      snapLastSegmentCoordinates(t, e, n) {
        const r = this.pathElement;
        let i = !1,
          o = !1,
          s = t,
          a = e;
        for (let l = r.pathSegList.numberOfItems - 2; 0 <= l && (!i || !o); l -= 1) {
          const c = this.getPathSeg(r, l);
          !i && Math.abs(c.x - t) < n && (s = c.x, i = !0), !o && Math.abs(c.y - e) < n && (a = c.y, o = !0)
        }
        return new hC(s, a)
      }
      removeLastSegment() {
        const t = this.pathElement;
        t.pathSegList.removeItem(t.pathSegList.numberOfItems - 1), this.emit("path:edit", {
          path: t
        }), this.emit("path:last-segment:remove", {
          path: t
        })
      }
      findControlPoint(t, e) {
        const n = this.pathElement,
          r = this.getPathSeg(n, -1);
        return new hC(t, e).reflection(r)
      }
      replaceLastSegmentWithCurve() {
        const t = this.pathElement,
          e = this.getPathSeg(t, -1),
          n = this.getPathSeg(t, -2),
          r = t.createSVGPathSegCurvetoCubicAbs(e.x, e.y, n.x, n.y, e.x, e.y);
        t.pathSegList.replaceItem(r, t.pathSegList.numberOfItems - 1), this.emit("path:edit", {
          path: t
        }), this.emit("path:last-segment:replace-with-curve", {
          path: t
        })
      }
      adjustControlPath(t, e, n, r) {
        const i = this.controlElement;
        i.pathSegList.initialize(i.createSVGPathSegMovetoAbs(t, e)), i.pathSegList.appendItem(i.createSVGPathSegLinetoAbs(
          n, r)), this.vel.append(i);
        const o = this.pathElement;
        this.emit("path:interact", {
          path: o
        }), this.emit("path:control:adjust", {
          path: o
        })
      }
      removeControlPath() {
        const t = this.pathElement,
          e = this.controlElement;
        e.pathSegList.clear(), this.vel.append(e), this.emit("path:interact", {
          path: t
        }), this.emit("path:control:remove", {
          path: t
        })
      }
      getPathSeg(t, e) {
        const n = e < 0 ? t.pathSegList.numberOfItems + e : e;
        return t.pathSegList.getItem(n)
      }
      onMouseDown(t) {
        const e = this.normalizeEvent(t);
        if (e.stopPropagation(), this.isLeftMouseDown(e) && this.isSamePositionEvent(e) && this.container.parentNode) {
          const t = this.vel.toLocalPoint(e.clientX, e.clientY);
          switch (this.action) {
            case "awaiting-input":
              this.createPath(t.x, t.y), this.action = "path-created", this.delegateDocumentEvents(zP.documentEvents);
              break;
            case "adjusting-line-end":
              this.action = "awaiting-line-end";
              break;
            case "adjusting-curve-end":
              this.action = "awaiting-curve-control-2"
          }
          this.timeStamp = e.timeStamp
        }
      }
      onMouseMove(t) {
        const e = this.normalizeEvent(t);
        if (e.stopPropagation(), "awaiting-input" !== this.action) {
          const t = this.vel.toLocalPoint(e.clientX, e.clientY),
            n = this.timeStamp;
          if (n)
            if (e.timeStamp - n < this.MOVEMENT_DETECTION_THRESHOLD) switch (this.action) {
              case "path-created":
                {
                  const e = h.translate(this.startPointElement);this.adjustControlPath(e.tx, e.ty, t.x, t.y);
                  break
                }
              case "awaiting-line-end":
              case "adjusting-curve-control-1":
                this.adjustLastSegment(t.x, t.y);
                break;
              case "awaiting-curve-control-2":
                this.adjustLastSegment(t.x, t.y, null, null, t.x, t.y)
            } else switch (this.action) {
              case "path-created":
                this.action = "adjusting-curve-control-1";
                break;
              case "awaiting-line-end":
                this.replaceLastSegmentWithCurve(), this.action = "adjusting-curve-control-2";
                break;
              case "awaiting-curve-control-2":
                this.action = "adjusting-curve-control-2";
                break;
              case "adjusting-curve-control-1":
                {
                  const e = h.translate(this.startPointElement);this.adjustControlPath(e.tx, e.ty, t.x, t.y);
                  break
                }
              case "adjusting-curve-control-2":
                {
                  const e = this.findControlPoint(t.x, t.y);this.adjustLastSegment(null, null, null, null,
                    e.x, e.y),
                  this.adjustControlPath(e.x, e.y, t.x, t.y)
                }
            } else switch (this.action) {
              case "adjusting-line-end":
                this.adjustLastSegment(t.x, t.y);
                break;
              case "adjusting-curve-end":
                this.adjustLastSegment(t.x, t.y, null, null, t.x, t.y)
            }
        }
      }
      onPointerUp(t) {
        this.timeStamp = null;
        const e = this.normalizeEvent(t);
        if (e.stopPropagation(), this.isLeftMouseDown(e) && this.isSamePositionEvent(e)) {
          const t = this.vel.toLocalPoint(e.clientX, e.clientY);
          switch (this.action) {
            case "path-created":
            case "awaiting-line-end":
              this.addLineSegment(t.x, t.y), this.action = "adjusting-line-end";
              break;
            case "awaiting-curve-control-2":
              this.removeControlPath(), this.addLineSegment(t.x, t.y), this.action = "adjusting-line-end";
              break;
            case "adjusting-curve-control-1":
            case "adjusting-curve-control-2":
              this.addCurveSegment(t.x, t.y, t.x, t.y), this.action = "adjusting-curve-end"
          }
        }
      }
      onStartPointMouseDown(t) {
        const e = this.normalizeEvent(t);
        e.stopPropagation(), this.isLeftMouseDown(e) && this.isSamePositionEvent(e) && this.closePath()
      }
      onDoubleClick(t) {
        const e = this.normalizeEvent(t);
        e.preventDefault(), e.stopPropagation(), this.isLeftMouseDown(e) && this.pathElement && 0 < this.numberOfVisibleSegments() &&
          (this.removeLastSegment(), this.finishPath("path:stop"))
      }
      onContextMenu(t) {
        const e = this.normalizeEvent(t);
        e.preventDefault(), e.stopPropagation(), this.isSamePositionEvent(e) && this.pathElement && 0 < this.numberOfVisibleSegments() &&
          (this.removeLastSegment(), this.finishPath("path:stop"))
      }
      isLeftMouseDown(t) {
        return (t.which || 0) <= 1
      }
      isSamePositionEvent(t) {
        const e = t.originalEvent;
        return null == e || e.detail <= 1
      }
    }(DP = zP || (zP = {})).defaultOptions = {
      pathAttributes: {
        class: null,
        fill: "#ffffff",
        stroke: "#000000",
        "stroke-width": 1,
        "pointer-events": "none"
      },
      startPointMarkup: '<circle r="5"/>',
      snapRadius: 0
    }, DP.documentEvents = {
      mousemove: "onMouseMove",
      touchmove: "onMouseMove",
      mouseup: "onMouseUp",
      touchend: "onMouseUp",
      touchcancel: "onMouseUp"
    };
    class RP extends ZE {
      constructor(t) {
        super(), this.options = Object.assign(Object.assign({}, RP.defaults), t), this.container = document.createElement(
            "div"), this.$container = this.$(this.container).addClass(this.prefixClassName("widget-dnd")), this
          .delegateGraph = new JO(Object.assign(Object.assign({}, this.options.delegateGraphOptions), {
            container: document.createElement("div"),
            width: 1,
            height: 1
          })), this.$container.append(this.delegateGraph.container)
      }
      get targetScroller() {
        const t = this.options.target;
        return t instanceof JO ? t.scroller.widget : t
      }
      get targetGraph() {
        const t = this.options.target;
        return t instanceof JO ? t : t.graph
      }
      get targetModel() {
        return this.targetGraph.model
      }
      get snapline() {
        return this.targetGraph.snapline.widget
      }
      start(t, e) {
        const n = e;
        n.preventDefault(), this.targetModel.startBatch("dnd"), this.$container.addClass("dragging").appendTo(
          document.body), this.prepareDragging(t, n.clientX, n.clientY);
        const r = this.updateNodePosition(n.clientX, n.clientY);
        this.isSnaplineEnabled() && (this.snapline.captureCursorOffset({
          e: n,
          node: t,
          cell: t,
          view: this.draggingView,
          x: r.x,
          y: r.y
        }), this.draggingNode.on("change:position", this.snap, this)), this.delegateDocumentEvents(RP.documentEvents,
          n.data)
      }
      isSnaplineEnabled() {
        return this.snapline && !this.snapline.disabled
      }
      prepareDragging(t, e, n) {
        const r = this.delegateGraph,
          i = r.model,
          o = this.options.getDragNode(t).position(0, 0);
        let s = 5;
        if (this.isSnaplineEnabled() && (s += this.snapline.options.tolerance || 0), this.isSnaplineEnabled() ||
          this.options.scaled) {
          const t = this.targetGraph.scale();
          r.scale(t.sx, t.sy), s *= Math.max(t.sx, t.sy)
        } else r.scale(1, 1);
        this.clearDragging(), this.options.animation && this.$container.stop(!0, !0), i.resetCells([o]);
        const a = r.findViewByCell(o);
        a.undelegateEvents(), a.cell.off("changed"), r.fitToContent({
          padding: s,
          allowNewOrigin: "any"
        });
        const l = a.getBBox();
        this.geometryBBox = a.getBBox({
            useCellGeometry: !0
          }), this.delta = this.geometryBBox.getTopLeft().diff(l.getTopLeft()), this.draggingNode = o, this.draggingView =
          a, this.delegateBBox = o.getBBox(), this.padding = s, this.originOffset = this.updateGraphPosition(e,
            n)
      }
      updateGraphPosition(t, e) {
        const n = document.body.scrollTop || document.documentElement.scrollTop,
          r = this.delta,
          i = this.geometryBBox,
          o = this.padding || 5,
          s = {
            left: t - r.x - i.width / 2 - o,
            top: e - r.y - i.height / 2 - o + n
          };
        return this.delegateGraph && this.$container.offset(s), s
      }
      updateNodePosition(t, e) {
        const n = this.targetGraph.clientToLocal(t, e),
          r = this.delegateBBox;
        return n.x -= r.width / 2, n.y -= r.height / 2, this.draggingNode.position(n.x, n.y), n
      }
      snap({
        cell: t,
        current: e,
        options: n
      }) {
        const r = t;
        if (n.snapped) {
          const t = this.delegateBBox;
          r.position(t.x + n.tx, t.y + n.ty, {
            silent: !0
          }), this.draggingView.translate(), r.position(e.x, e.y, {
            silent: !0
          }), this.snapOffset = {
            x: n.tx,
            y: n.ty
          }
        } else this.snapOffset = null
      }
      onDragging(t) {
        const e = this.draggingView;
        if (e) {
          t.preventDefault();
          const n = this.normalizeEvent(t),
            r = n.clientX,
            i = n.clientY;
          this.updateGraphPosition(r, i);
          const o = this.updateNodePosition(r, i),
            s = this.targetGraph.options.embedding.enabled,
            a = (s || this.isSnaplineEnabled()) && this.isInsideValidArea({
              x: r,
              y: i
            });
          if (s) {
            e.setEventData(n, {
              graph: this.targetGraph
            });
            const t = e.getEventData(n);
            a ? e.processEmbedding(t) : e.clearEmbedding(t)
          }
          this.isSnaplineEnabled() && (a ? this.snapline.snapOnMoving({
            e: n,
            view: e,
            x: o.x,
            y: o.y
          }) : this.snapline.hide())
        }
      }
      onDragEnd(t) {
        const e = this.draggingNode;
        if (e) {
          const n = this.normalizeEvent(t),
            r = this.draggingView,
            i = this.delegateBBox,
            o = this.snapOffset;
          let s = i.x,
            a = i.y;
          o && (s += o.x, a += o.y), e.position(s, a, {
            silent: !0
          });
          const l = this.options.getDropNode(e),
            c = this.drop(l, {
              x: n.clientX,
              y: n.clientY
            }),
            h = t => {
              t ? this.onDropped(e) : this.onDropInvalid(), this.targetGraph.options.embedding.enabled && r &&
                (r.setEventData(n, {
                  cell: l,
                  graph: this.targetGraph
                }), r.finalizeEmbedding(r.getEventData(n))), this.targetModel.stopBatch("dnd")
            };
          "boolean" == typeof c ? h(c) : c.then(h)
        }
      }
      clearDragging() {
        this.draggingNode && (this.draggingNode.remove(), this.draggingNode = null, this.draggingView = null,
          this.delta = null, this.padding = null, this.snapOffset = null, this.originOffset = null)
      }
      onDropped(t) {
        this.draggingNode === t && (this.clearDragging(), this.$container.removeClass("dragging").remove())
      }
      onDropInvalid() {
        const t = this.draggingNode;
        if (t) {
          const e = this.options.animation;
          if (e) {
            const n = "object" == typeof e && e.duration || 150,
              r = "object" == typeof e && e.easing || "swing";
            this.draggingView = null, this.$container.animate(this.originOffset, n, r, () => this.onDropped(t))
          } else this.onDropped(t)
        }
      }
      isInsideValidArea(t) {
        let e;
        const n = this.targetGraph,
          r = this.targetScroller;
        if (r)
          if (r.options.autoResize) e = this.getDropArea(r.container);
          else {
            const t = this.getDropArea(r.container);
            e = this.getDropArea(n.container).intersect(t)
          }
        else e = this.getDropArea(n.container);
        return e && e.containsPoint(t)
      }
      getDropArea(t) {
        const e = this.$(t),
          n = e.offset(),
          r = document.body.scrollTop || document.documentElement.scrollTop,
          i = document.body.scrollLeft || document.documentElement.scrollLeft;
        return uC.create({
          x: n.left + parseInt(e.css("border-left-width"), 10) - i,
          y: n.top + parseInt(e.css("border-top-width"), 10) - r,
          width: e.innerWidth(),
          height: e.innerHeight()
        })
      }
      drop(t, e) {
        const n = this.targetGraph,
          r = n.model;
        if (this.isInsideValidArea(e)) {
          const i = n.clientToLocal(e),
            o = t.getBBox();
          i.x += o.x - o.width / 2, i.y += o.y - o.height / 2;
          const s = this.snapOffset ? 1 : n.getGridSize();
          t.position(oE.snapToGrid(i.x, s), oE.snapToGrid(i.y, s)), t.removeZIndex();
          const a = this.options.validateNode,
            c = !a || l.call(a, n, t);
          return "boolean" == typeof c ? (c && r.addCell(t, {
            stencil: this.cid
          }), c) : l.toDeferredBoolean(c).then(e => (e && r.addCell(t, {
            stencil: this.cid
          }), e))
        }
        return !1
      }
      onRemove() {
        this.delegateGraph && this.delegateGraph.view.remove()
      }
    }(TP = RP || (RP = {})).defaults = {
        animation: !1,
        getDragNode: t => t.clone(),
        getDropNode: t => t.clone()
      }, TP.documentEvents = {
        mousemove: "onDragging",
        touchmove: "onDragging",
        mouseup: "onDragEnd",
        touchend: "onDragEnd",
        touchcancel: "onDragEnd"
      },
      function(t) {
        t.getMaxDim = function(t, e) {
          return t.reduce((t, n) => Math.max(n.getSize()[e], t), 0)
        }, t.getNodesInRow = function(t, e, n) {
          const r = [];
          for (let i = n * e, o = i + n; i < o; i += 1) r.push(t[i]);
          return r
        }, t.getNodesInColumn = function(t, e, n) {
          const r = [];
          for (let i = e, o = t.length; i < o; i += n) r.push(t[i]);
          return r
        }, t.accumulate = function(t, e) {
          return t.reduce((t, e, n) => (t.push(t[n] + e), t), [e || 0])
        }
      }(_P || (_P = {}));
      window.Dom = h;
       window.Shape = M;
        window.Addon = k;
        window.Util = oE;
         window.NodeView = Sk;
      window.Graph = JO;
    class VP extends ZE {
      constructor(t) {
        if (super(), this.graphs = {}, this.$groups = {}, this.options = Object.assign(Object.assign({}, VP.defaultOptions),
            t), this.dnd = new RP(this.options), this.onSearch = l.debounce(this.onSearch, 200), this.container =
          document.createElement("div"), this.$container = this.$(this.container).addClass(this.prefixClassName(
            jP.base)), this.options.collapsable = t.collapsable && t.groups && t.groups.some(t => !1 !== t.collapsable),
          this.options.collapsable) {
          this.$container.addClass("collapsable"), t.groups && t.groups.every(t => t.collapsed || !1 === t.collapsable) &&
            this.$container.addClass("collapsed")
        }
        this.$("<div/>").addClass(this.prefixClassName(jP.title)).html(this.options.title).appendTo(this.$container),
          t.search && this.$container.addClass("searchable").append(this.renderSearch()), this.$content = this.$(
            "<div/>").addClass(this.prefixClassName(jP.content)).appendTo(this.$container);
        const e = t.stencilGraphOptions || {};
        if (t.groups && t.groups.length) t.groups.forEach(n => {
          const r = this.$("<div/>").addClass(this.prefixClassName(jP.group)).attr("data-name", n.name);
          (null == n.collapsable && t.collapsable || !1 !== n.collapsable) && r.addClass("collapsable"), r.toggleClass(
            "collapsed", !0 === n.collapsed);
          const i = this.$("<h3/>").addClass(this.prefixClassName(jP.groupTitle)).html(n.title || n.name),
            o = this.$("<div/>").addClass(this.prefixClassName(jP.groupContent)),
            s = n.graphOptions,
            a = new JO(Object.assign(Object.assign(Object.assign({}, e), s), {
              container: document.createElement("div"),
              model: e.model || new Ak,
              width: n.graphWidth || t.stencilGraphWidth,
              height: n.graphHeight || t.stencilGraphHeight,
              interacting: !1,
              preventDefaultBlankAction: !1
            }));
          o.append(a.container), r.append(i, o).appendTo(this.$content), this.$groups[n.name] = r, this.graphs[
            n.name] = a
        });
        else {
          const n = new JO(Object.assign(Object.assign({}, e), {
            container: document.createElement("div"),
            model: e.model || new Ak,
            width: t.stencilGraphWidth,
            height: t.stencilGraphHeight,
            interacting: !1,
            preventDefaultBlankAction: !1
          }));
          this.$content.append(n.container), this.graphs[LP.defaultGroupName] = n
        }
        return this.startListening(), this
      }
      get targetScroller() {
        const t = this.options.target;
        return t instanceof JO ? t.scroller.widget : t
      }
      get targetGraph() {
        const t = this.options.target;
        return t instanceof JO ? t : t.graph
      }
      get targetModel() {
        return this.targetGraph.model
      }
      renderSearch() {
        return this.$("<div/>").addClass(this.prefixClassName(jP.search)).append(this.$("<input/>").attr({
          type: "search",
          placeholder: "Search"
        }).addClass(this.prefixClassName(jP.searchText)))
      }
      startListening() {
        const t = this.prefixClassName(jP.title),
          e = this.prefixClassName(jP.searchText),
          n = this.prefixClassName(jP.groupTitle);
        this.delegateEvents({
          [`click .${t}`]: "onTitleClick",
          [`touchstart .${t}`]: "onTitleClick",
          [`click .${n}`]: "onGroupTitleClick",
          [`touchstart .${n}`]: "onGroupTitleClick",
          [`input .${e}`]: "onSearch",
          [`focusin .${e}`]: "onSearchFocusIn",
          [`focusout .${e}`]: "onSearchFocusOut"
        }), Object.keys(this.graphs).forEach(t => {
          this.graphs[t].on("cell:mousedown", this.onDragStart, this)
        })
      }
      stopListening() {
        this.undelegateEvents(), Object.keys(this.graphs).forEach(t => {
          this.graphs[t].off("cell:mousedown", this.onDragStart, this)
        })
      }
      load(t, e) {
        return Array.isArray(t) ? this.loadGroup(t, e) : this.options.groups && Object.keys(this.options.groups)
          .forEach(e => {
            t[e] && this.loadGroup(t[e], e)
          }), this
      }
      loadGroup(t, e) {
        const n = this.getModel(e);
        if (n) {
          const e = t.map(t => t instanceof yk ? t : yk.create(t));
          n.resetCells(e)
        }
        const r = this.getGroup(e);
        let i = this.options.stencilGraphHeight;
        r && null != r.graphHeight && (i = r.graphHeight);
        const o = r && r.layout || this.options.layout;
        if (o && n && l.call(o, this, n, r), !i) {
          const t = this.getGraph(e);
          t.fitToContent({
            minWidth: t.options.width,
            gridHeight: 1,
            padding: r && r.graphPadding || this.options.stencilGraphPadding || 10
          })
        }
        return this
      }
      onDragStart(t) {
        const {
          e: e,
          node: n
        } = t;
        this.dnd.start(n, e)
      }
      filter(t, e) {
        const n = Object.keys(this.graphs).reduce((n, r) => {
          const i = this.graphs[r],
            o = r === LP.defaultGroupName ? null : r,
            s = i.model.getNodes().filter(n => {
              let r = !1;
              r = "function" == typeof e ? l.call(e, this, n, t, o, this) : "boolean" == typeof e ? e :
                this.isCellMatched(n, t, e, t.toLowerCase() !== t);
              const s = i.renderer.findViewByCell(n);
              return s && s.$(s.container).toggleClass("unmatched", !r), r
            }),
            a = s.length > 0,
            c = this.options,
            h = new Ak;
          return h.resetCells(s), c.layout && l.call(c.layout, this, h, this.getGroup(r)), this.$groups[r] &&
            this.$groups[r].toggleClass("unmatched", !a), i.fitToContent({
              gridWidth: 1,
              gridHeight: 1,
              padding: c.stencilGraphPadding || 10
            }), n || a
        }, !1);
        this.$container.toggleClass("not-found", !n)
      }
      isCellMatched(t, e, n, r) {
        return !e || !n || Object.keys(n).some(i => {
          if ("*" === i || t.shape === i) {
            const o = n[i];
            return "boolean" == typeof o ? o : (Array.isArray(o) ? o : [o]).some(n => {
              let i = t.getPropByPath(n);
              if (null != i) return i = `${i}`, r && (i = i.toLowerCase()), i.indexOf(e) >= 0
            })
          }
          return !1
        })
      }
      onSearch(t) {
        console.log(t.target.value), this.filter(t.target.value, this.options.search)
      }
      onSearchFocusIn() {
        this.$container.addClass("is-focused")
      }
      onSearchFocusOut() {
        this.$container.removeClass("is-focused")
      }
      onTitleClick() {
        this.options.collapsable && (this.$container.toggleClass("collapsed"), this.$container.hasClass(
          "collapsed") ? this.collapseGroups() : this.expandGroups())
      }
      onGroupTitleClick(t) {
        const e = this.$(t.target).closest(`.${this.prefixClassName(jP.group)}`);
        this.toggleGroup(e.attr("data-name") || "");
        const n = Object.keys(this.$groups).every(t => {
          const e = this.getGroup(t),
            n = this.$groups[t];
          return e && !1 === e.collapsable || n.hasClass("collapsed")
        });
        this.$container.toggleClass("collapsed", n)
      }
      getModel(t) {
        const e = this.getGraph(t);
        return e ? e.model : null
      }
      getGraph(t) {
        return this.graphs[t || LP.defaultGroupName]
      }
      getGroup(t) {
        const e = this.options.groups;
        return null != t && e && e.length ? e.find(e => e.name === t) : null
      }
      toggleGroup(t) {
        return this.isGroupCollapsed(t) ? this.expandGroup(t) : this.collapseGroup(t), this
      }
      collapseGroup(t) {
        if (this.isGroupCollapsable(t)) {
          const e = this.$groups[t];
          e && !this.isGroupCollapsed(t) && (this.trigger("group:collapse", {
            name: t
          }), e.addClass("collapsed"))
        }
        return this
      }
      expandGroup(t) {
        if (this.isGroupCollapsable(t)) {
          const e = this.$groups[t];
          e && this.isGroupCollapsed(t) && (this.trigger("group:expand", {
            name: t
          }), e.removeClass("collapsed"))
        }
        return this
      }
      isGroupCollapsable(t) {
        return this.$groups[t].hasClass("collapsable")
      }
      isGroupCollapsed(t) {
        const e = this.$groups[t];
        return e && e.hasClass("collapsed")
      }
      collapseGroups() {
        return Object.keys(this.$groups).forEach(t => this.collapseGroup(t)), this
      }
      expandGroups() {
        return Object.keys(this.$groups).forEach(t => this.expandGroup(t)), this
      }
      onRemove() {
        Object.keys(this.graphs).forEach(t => {
          this.graphs[t].view.remove(), delete this.graphs[t]
        }), this.dnd.remove(), this.stopListening(), this.undelegateDocumentEvents()
      }
    }(VP || (VP = {})).defaultOptions = Object.assign({
        stencilGraphWidth: 200,
        stencilGraphHeight: 800,
        title: "Stencil",
        collapsable: !1,
        layout(t, e) {
          const n = {
            columnWidth: this.options.stencilGraphWidth / 2 - 10,
            columns: 2,
            rowHeight: 80,
            resizeToFit: !1,
            dx: 10,
            dy: 10
          };
          ! function(t, e = {}) {
            const n = t instanceof Ak ? t : (new Ak).resetCells(t, {
                sort: !1,
                dryrun: !0
              }),
              r = n.getNodes(),
              i = e.columns || 1,
              o = Math.ceil(r.length / i),
              s = e.dx || 0,
              a = e.dy || 0,
              l = !1 !== e.center,
              c = !0 === e.resizeToFit,
              h = e.marginX || 0,
              u = e.marginY || 0,
              d = [];
            let p = e.columnWidth;
            if ("compact" === p)
              for (let t = 0; t < i; t += 1) {
                const e = _P.getNodesInColumn(r, t, i);
                d.push(_P.getMaxDim(e, "width") + s)
              } else {
                null != p && "auto" !== p || (p = _P.getMaxDim(r, "width") + s);
                for (let t = 0; t < i; t += 1) d.push(p)
              }
            const f = _P.accumulate(d, h),
              g = [];
            let m = e.rowHeight;
            if ("compact" === m)
              for (let t = 0; t < o; t += 1) {
                const e = _P.getNodesInRow(r, t, i);
                g.push(_P.getMaxDim(e, "height") + a)
              } else {
                null != m && "auto" !== m || (m = _P.getMaxDim(r, "height") + a);
                for (let t = 0; t < o; t += 1) g.push(m)
              }
            const v = _P.accumulate(g, u);
            n.startBatch("layout"), r.forEach((t, n) => {
              const r = n % i,
                o = Math.floor(n / i),
                h = d[r],
                u = g[o];
              let p = 0,
                m = 0,
                y = t.getSize();
              if (c) {
                let n = h - 2 * s,
                  r = u - 2 * a;
                const i = y.height * (y.width ? n / y.width : 1),
                  o = y.width * (y.height ? r / y.height : 1);
                u < i ? n = o : r = i, y = {
                  width: n,
                  height: r
                }, t.setSize(y, e)
              }
              l && (p = (h - y.width) / 2, m = (u - y.height) / 2), t.position(f[r] + s + p, v[o] + a + m,
                e)
            }), n.stopBatch("layout")
          }(t, Object.assign(Object.assign(Object.assign({}, n), this.options.layoutOptions), e ? e.layoutOptions :
            {}))
        }
      }, RP.defaults),
      function(t) {
        t.base = "widget-stencil", t.title = `${t.base}-title`, t.search = `${t.base}-search`, t.searchText =
          `${t.search}-text`, t.content = `${t.base}-content`, t.group = `${t.base}-group`, t.groupTitle =
          `${t.group}-title`, t.groupContent = `${t.group}-content`
      }(jP || (jP = {})), (LP || (LP = {})).defaultGroupName = "__default__", Jx.trackable && setTimeout(function() {
        if (Jx.trackable) {
          const t = "https://kcart.alipay.com/web/bi.do",
            e = new Image,
            n = Object.assign(Object.assign({}, Jx.trackInfo), {
              version: sE,
              pg: document.URL,
              r: (new Date).getTime(),
              x6: !0,
              page_type: "syslog"
            }),
            r = encodeURIComponent(JSON.stringify([n]));
          e.src = `${t}?BIProfile=merge&d=${r}`
        }
      }, 3e3), n.d(e, !1, function() {
        return P.a
      }), n.d(e, !1, function() {
        return r
      }), n.d(e, !1, function() {
        return i
      }), n.d(e, !1, function() {
        return o
      }), n.d(e, !1, function() {
        return s
      }), n.d(e, !1, function() {
        return a
      }), n.d(e, !1, function() {
        return l
      }), n.d(e, !1, function() {
        return D.a
      }), n.d(e, !1, function() {
        return c
      }), n.d(e, !1, function() {
        return Vb
      }), n.d(e, !1, function() {
        return Gb
      }), n.d(e, !1, function() {
        return Hb
      }), n.d(e, "b", function() {
        return h
      }), n.d(e, !1, function() {
        return Fx
      }), n.d(e, !1, function() {
        return DC
      }), n.d(e, !1, function() {
        return Bx
      }), n.d(e, !1, function() {
        return Vx
      }), n.d(e, !1, function() {
        return Ix
      }), n.d(e, !1, function() {
        return zx
      }), n.d(e, !1, function() {
        return Rx
      }), n.d(e, !1, function() {
        return Hx
      }), n.d(e, !1, function() {
        return Xx
      }), n.d(e, !1, function() {
        return Zx
      }), n.d(e, !1, function() {
        return Yx
      }), n.d(e, !1, function() {
        return Gx
      }), n.d(e, !1, function() {
        return Ux
      }), n.d(e, !1, function() {
        return qx
      }), n.d(e, !1, function() {
        return nC
      }), n.d(e, !1, function() {
        return hC
      }), n.d(e, !1, function() {
        return dC
      }), n.d(e, !1, function() {
        return pC
      }), n.d(e, !1, function() {
        return uC
      }), n.d(e, !1, function() {
        return gC
      }), n.d(e, !1, function() {
        return fC
      }), n.d(e, !1, function() {
        return PC
      }), n.d(e, !1, function() {
        return mC
      }), n.d(e, !1, function() {
        return fk
      }), n.d(e, !1, function() {
        return yk
      }), n.d(e, !1, function() {
        return xk
      }), n.d(e, !1, function() {
        return Ak
      }), n.d(e, !1, function() {
        return wk
      }), n.d(e, !1, function() {
        return oS
      }), n.d(e, !1, function() {
        return ZE
      }), n.d(e, !1, function() {
        return dS
      }), n.d(e, !1, function() {
        return Ek
      }), n.d(e, "d", function() {
        return Sk
      }), n.d(e, !1, function() {
        return pS
      }), n.d(e, "c", function() {
        return JO
      }), n.d(e, "e", function() {
        return M
      }), n.d(e, "a", function() {
        return k
      }), n.d(e, !1, function() {
        return S
      }), n.d(e, !1, function() {
        return Jx
      }), n.d(e, "f", function() {
        return oE
      }), n.d(e, !1, function() {
        return sE
      })
  },
  knr3: function(t, e, n) {
    var r;
    ! function(i, o, s) {
      if (i) {
        for (var a, l = {
            8: "backspace",
            9: "tab",
            13: "enter",
            16: "shift",
            17: "ctrl",
            18: "alt",
            20: "capslock",
            27: "esc",
            32: "space",
            33: "pageup",
            34: "pagedown",
            35: "end",
            36: "home",
            37: "left",
            38: "up",
            39: "right",
            40: "down",
            45: "ins",
            46: "del",
            91: "meta",
            93: "meta",
            224: "meta"
          }, c = {
            106: "*",
            107: "+",
            109: "-",
            110: ".",
            111: "/",
            186: ";",
            187: "=",
            188: ",",
            189: "-",
            190: ".",
            191: "/",
            192: "`",
            219: "[",
            220: "\\",
            221: "]",
            222: "'"
          }, h = {
            "~": "`",
            "!": "1",
            "@": "2",
            "#": "3",
            $: "4",
            "%": "5",
            "^": "6",
            "&": "7",
            "*": "8",
            "(": "9",
            ")": "0",
            _: "-",
            "+": "=",
            ":": ";",
            '"': "'",
            "<": ",",
            ">": ".",
            "?": "/",
            "|": "\\"
          }, u = {
            option: "alt",
            command: "meta",
            return: "enter",
            escape: "esc",
            plus: "+",
            mod: /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? "meta" : "ctrl"
          }, d = 1; d < 20; ++d) l[111 + d] = "f" + d;
        for (d = 0; d <= 9; ++d) l[d + 96] = d.toString();
        y.prototype.bind = function(t, e, n) {
          return t = t instanceof Array ? t : [t], this._bindMultiple.call(this, t, e, n), this
        }, y.prototype.unbind = function(t, e) {
          return this.bind.call(this, t, function() {}, e)
        }, y.prototype.trigger = function(t, e) {
          return this._directMap[t + ":" + e] && this._directMap[t + ":" + e]({}, t), this
        }, y.prototype.reset = function() {
          return this._callbacks = {}, this._directMap = {}, this
        }, y.prototype.stopCallback = function(t, e) {
          if ((" " + e.className + " ").indexOf(" mousetrap ") > -1) return !1;
          if (function t(e, n) {
              return null !== e && e !== o && (e === n || t(e.parentNode, n))
            }(e, this.target)) return !1;
          if ("composedPath" in t && "function" == typeof t.composedPath) {
            var n = t.composedPath()[0];
            n !== t.target && (e = n)
          }
          return "INPUT" == e.tagName || "SELECT" == e.tagName || "TEXTAREA" == e.tagName || e.isContentEditable
        }, y.prototype.handleKey = function() {
          return this._handleKey.apply(this, arguments)
        }, y.addKeycodes = function(t) {
          for (var e in t) t.hasOwnProperty(e) && (l[e] = t[e]);
          a = null
        }, y.init = function() {
          var t = y(o);
          for (var e in t) "_" !== e.charAt(0) && (y[e] = function(e) {
            return function() {
              return t[e].apply(t, arguments)
            }
          }(e))
        }, y.init(), i.Mousetrap = y, void 0 !== t && t.exports && (t.exports = y), void 0 === (r = function() {
          return y
        }.call(e, n, e, t)) || (t.exports = r)
      }

      function p(t, e, n) {
        t.addEventListener ? t.addEventListener(e, n, !1) : t.attachEvent("on" + e, n)
      }

      function f(t) {
        if ("keypress" == t.type) {
          var e = String.fromCharCode(t.which);
          return t.shiftKey || (e = e.toLowerCase()), e
        }
        return l[t.which] ? l[t.which] : c[t.which] ? c[t.which] : String.fromCharCode(t.which).toLowerCase()
      }

      function g(t) {
        return "shift" == t || "ctrl" == t || "alt" == t || "meta" == t
      }

      function m(t, e, n) {
        return n || (n = function() {
          if (!a)
            for (var t in a = {}, l) t > 95 && t < 112 || l.hasOwnProperty(t) && (a[l[t]] = t);
          return a
        }()[t] ? "keydown" : "keypress"), "keypress" == n && e.length && (n = "keydown"), n
      }

      function v(t, e) {
        var n, r, i, o = [];
        for (n = function(t) {
            return "+" === t ? ["+"] : (t = t.replace(/\+{2}/g, "+plus")).split("+")
          }(t), i = 0; i < n.length; ++i) r = n[i], u[r] && (r = u[r]), e && "keypress" != e && h[r] && (r = h[r],
          o.push("shift")), g(r) && o.push(r);
        return {
          key: r,
          modifiers: o,
          action: e = m(r, o, e)
        }
      }

      function y(t) {
        var e = this;
        if (t = t || o, !(e instanceof y)) return new y(t);
        e.target = t, e._callbacks = {}, e._directMap = {};
        var n, r = {},
          i = !1,
          s = !1,
          a = !1;

        function l(t) {
          t = t || {};
          var e, n = !1;
          for (e in r) t[e] ? n = !0 : r[e] = 0;
          n || (a = !1)
        }

        function c(t, n, i, o, s, a) {
          var l, c, h, u, d = [],
            p = i.type;
          if (!e._callbacks[t]) return [];
          for ("keyup" == p && g(t) && (n = [t]), l = 0; l < e._callbacks[t].length; ++l)
            if (c = e._callbacks[t][l], (o || !c.seq || r[c.seq] == c.level) && p == c.action && ("keypress" == p &&
                !i.metaKey && !i.ctrlKey || (h = n, u = c.modifiers, h.sort().join(",") === u.sort().join(",")))) {
              var f = !o && c.combo == s,
                m = o && c.seq == o && c.level == a;
              (f || m) && e._callbacks[t].splice(l, 1), d.push(c)
            } return d
        }

        function h(t, n, r, i) {
          e.stopCallback(n, n.target || n.srcElement, r, i) || !1 === t(n, r) && (function(t) {
            t.preventDefault ? t.preventDefault() : t.returnValue = !1
          }(n), function(t) {
            t.stopPropagation ? t.stopPropagation() : t.cancelBubble = !0
          }(n))
        }

        function u(t) {
          "number" != typeof t.which && (t.which = t.keyCode);
          var n = f(t);
          n && ("keyup" != t.type || i !== n ? e.handleKey(n, function(t) {
            var e = [];
            return t.shiftKey && e.push("shift"), t.altKey && e.push("alt"), t.ctrlKey && e.push("ctrl"), t
              .metaKey && e.push("meta"), e
          }(t), t) : i = !1)
        }

        function d(t, e, o, s) {
          function c(e) {
            return function() {
              a = e, ++r[t], clearTimeout(n), n = setTimeout(l, 1e3)
            }
          }

          function u(e) {
            h(o, e, t), "keyup" !== s && (i = f(e)), setTimeout(l, 10)
          }
          r[t] = 0;
          for (var d = 0; d < e.length; ++d) {
            var p = d + 1 === e.length ? u : c(s || v(e[d + 1]).action);
            m(e[d], p, s, t, d)
          }
        }

        function m(t, n, r, i, o) {
          e._directMap[t + ":" + r] = n;
          var s, a = (t = t.replace(/\s+/g, " ")).split(" ");
          a.length > 1 ? d(t, a, n, r) : (s = v(t, r), e._callbacks[s.key] = e._callbacks[s.key] || [], c(s.key,
            s.modifiers, {
              type: s.action
            }, i, t, o), e._callbacks[s.key][i ? "unshift" : "push"]({
            callback: n,
            modifiers: s.modifiers,
            action: s.action,
            seq: i,
            level: o,
            combo: t
          }))
        }
        e._handleKey = function(t, e, n) {
          var r, i = c(t, e, n),
            o = {},
            u = 0,
            d = !1;
          for (r = 0; r < i.length; ++r) i[r].seq && (u = Math.max(u, i[r].level));
          for (r = 0; r < i.length; ++r)
            if (i[r].seq) {
              if (i[r].level != u) continue;
              d = !0, o[i[r].seq] = 1, h(i[r].callback, n, i[r].combo, i[r].seq)
            } else d || h(i[r].callback, n, i[r].combo);
          var p = "keypress" == n.type && s;
          n.type != a || g(t) || p || l(o), s = d && "keydown" == n.type
        }, e._bindMultiple = function(t, e, n) {
          for (var r = 0; r < t.length; ++r) m(t[r], e, n)
        }, p(t, "keypress", u), p(t, "keydown", u), p(t, "keyup", u)
      }
    }("undefined" != typeof window ? window : null, "undefined" != typeof window ? document : null)
  },
  nSxQ: function(t, e, n) {
    "use strict";
    (function(t) {
      var n = "object" == typeof t && t && t.Object === Object && t;
      e.a = n
    }).call(e, n("DuR2"))
  }
});
//# sourceMappingURL=vendor.57e57b7e7bd7f21e3e0c.js.map
